{
  "version": 3,
  "sources": ["../../../../Scheduler/lib/Scheduler/preset/ViewPreset.js", "../../../../Scheduler/lib/Scheduler/localization/En.js", "../../../../Scheduler/lib/Scheduler/preset/PresetStore.js", "../../../../Scheduler/lib/Scheduler/preset/PresetManager.js", "../../../../Scheduler/lib/Scheduler/data/TimeAxis.js", "../../../../Scheduler/lib/Scheduler/view/model/TimeAxisViewModel.js", "../../../../Scheduler/lib/Scheduler/view/mixin/TimelineDateMapper.js", "../../../../Scheduler/lib/Scheduler/view/mixin/TimelineDomEvents.js", "../../../../Scheduler/lib/Scheduler/view/mixin/TimelineViewPresets.js", "../../../../Scheduler/lib/Scheduler/view/mixin/TimelineZoomable.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/RecurrenceConfirmationPopup.js", "../../../../Scheduler/lib/Scheduler/view/mixin/RecurringEvents.js", "../../../../Scheduler/lib/Scheduler/view/mixin/TimelineEventRendering.js", "../../../../Scheduler/lib/Scheduler/view/mixin/TimelineScroll.js", "../../../../Scheduler/lib/Scheduler/view/mixin/TimelineState.js", "../../../../Scheduler/lib/Scheduler/view/Header.js", "../../../../Scheduler/lib/Scheduler/view/TimeAxisSubGrid.js", "../../../../Scheduler/lib/Scheduler/view/TimelineBase.js", "../../../../Scheduler/lib/Scheduler/view/mixin/Describable.js", "../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerDom.js", "../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerDomEvents.js", "../../../../Scheduler/lib/Scheduler/eventlayout/HorizontalLayout.js", "../../../../Scheduler/lib/Scheduler/eventlayout/HorizontalLayoutStack.js", "../../../../Scheduler/lib/Scheduler/eventlayout/PackMixin.js", "../../../../Scheduler/lib/Scheduler/eventlayout/HorizontalLayoutPack.js", "../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerResourceRendering.js", "../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerEventRendering.js", "../../../../Scheduler/lib/Scheduler/data/mixin/ProjectConsumer.js", "../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerStores.js", "../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerScroll.js", "../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerRegions.js", "../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerState.js", "../../../../Scheduler/lib/Scheduler/view/mixin/EventSelection.js", "../../../../Scheduler/lib/Scheduler/view/mixin/EventNavigation.js", "../../../../Scheduler/lib/Scheduler/view/mixin/TransactionalFeatureMixin.js", "../../../../Scheduler/lib/Scheduler/data/mixin/AttachToProjectMixin.js", "../../../../Scheduler/lib/Scheduler/view/orientation/HorizontalRendering.js", "../../../../Scheduler/lib/Scheduler/eventlayout/VerticalLayout.js", "../../../../Scheduler/lib/Scheduler/view/orientation/VerticalRendering.js", "../../../../Scheduler/lib/Scheduler/view/TimeAxisBase.js", "../../../../Scheduler/lib/Scheduler/view/HorizontalTimeAxis.js", "../../../../Scheduler/lib/Scheduler/view/ResourceHeader.js", "../../../../Scheduler/lib/Scheduler/column/TimeAxisColumn.js", "../../../../Scheduler/lib/Scheduler/view/VerticalTimeAxis.js", "../../../../Scheduler/lib/Scheduler/column/VerticalTimeAxisColumn.js", "../../../../Scheduler/lib/Scheduler/view/mixin/CurrentConfig.js", "../../../../Scheduler/lib/Scheduler/view/SchedulerBase.js", "../../../../Scheduler/lib/Scheduler/widget/EventColorPicker.js", "../../../../Scheduler/lib/Scheduler/tooltip/ClockTemplate.js", "../../../../Scheduler/lib/Scheduler/feature/mixin/TaskEditStm.js", "../../../../Scheduler/lib/Scheduler/feature/base/TimeSpanMenuBase.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrenceFrequencyCombo.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrenceDaysCombo.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrenceDaysButtonGroup.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrenceMonthDaysButtonGroup.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrenceMonthsButtonGroup.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrenceStopConditionCombo.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrencePositionsCombo.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/RecurrenceEditorPanel.js", "../../../../Scheduler/lib/Scheduler/widget/EventColorField.js", "../../../../Scheduler/lib/Scheduler/feature/EventMenu.js", "../../../../Scheduler/lib/Scheduler/feature/ScheduleMenu.js"],
  "sourcesContent": ["import Model from '../../Core/data/Model.js';\nimport IdHelper from '../../Core/helper/IdHelper.js';\nimport DH from '../../Core/helper/DateHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\n/**\n * @module Scheduler/preset/ViewPreset\n */\n/**\n * An object containing a unit identifier and an increment variable, used to define the `timeResolution` of a\n * `ViewPreset`.\n * @typedef {Object} ViewPresetTimeResolution\n * @property {String} unit The unit of the resolution, e.g. 'minute'\n * @property {Number} increment The increment of the resolution, e.g. 15\n */\n/**\n * Defines a header level for a ViewPreset.\n *\n * A sample header configuration can look like below\n * ```javascript\n * headers    : {\n *     {\n *         unit        : \"month\",\n *         renderer : function(start, end, headerConfig, index) {\n *             var month = start.getMonth();\n *             // Simple alternating month in bold\n *             if (start.getMonth() % 2) {\n *                 return '<strong>' + month + '</strong>';\n *             }\n *             return month;\n *         },\n *         align       : 'start' // `start` or `end`, omit to center content (default)\n *     },\n *     {\n *         unit        : \"week\",\n *         increment   : 1,\n *         renderer    : function(start, end, headerConfig, index) {\n *             return 'foo';\n *         }\n *     },\n * }\n * ```\n *\n * @typedef {Object} ViewPresetHeaderRow\n * @property {'start'|'center'|'end'} align The text alignment for the cell. Valid values are `start` or `end`, omit\n * this to center text content (default). Can also be added programmatically in `the renderer`.\n * @property {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} unit The unit of time\n * represented by each cell in this header row. See also increment property. Valid values are \"millisecond\", \"second\",\n * \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\".\n * @property {String} headerCellCls A CSS class to add to the cells in the time axis header row. Can also be added\n * programmatically in the `renderer`.\n * @property {Number} increment The number of units each header cell will represent (e.g. 30 together with unit:\n * \"minute\" for 30 minute cells)\n * @property {String} dateFormat Defines how the cell date will be formatted\n * @property {Function} renderer A custom renderer function used to render the cell content. It should return text/HTML\n * to put in the header cell.\n *\n * ```javascript\n * function (startDate, endDate, headerConfig, i) {\n *   // applies special CSS class to align header left\n *   headerConfig.align = \"start\";\n *   // will be added as a CSS class of the header cell DOM element\n *   headerConfig.headerCellCls = \"myClass\";\n *\n *   return DateHelper.format(startDate, 'YYYY-MM-DD');\n * }\n * ```\n *\n * The render function is called with the following parameters:\n *\n * @property {Date} renderer.startDate The start date of the cell.\n * @property {Date} renderer.endDate The end date of the cell.\n * @property {Object} renderer.headerConfig An object containing the header config.\n * @property {'start'|'center'|'end'} [renderer.headerConfig.align] The text alignment for the cell. See `align` above.\n * @property {String} [renderer.headerConfig.headerCellCls] A CSS class to add to the cells in the time axis header row.\n * See `headerCellCls` above.\n * @property {Number} renderer.index The index of the cell in the row.\n * @property {Object} thisObj `this` reference for the renderer function\n * @property {Function} cellGenerator A function that should return an array of objects containing 'start', 'end' and\n * 'header' properties. Use this if you want full control over how the header rows are generated.\n *\n * **Note:** `cellGenerator` cannot be used for the bottom level of your headers.\n *\n * Example :\n * ```javascript\n * viewPreset : {\n *     displayDateFormat : 'H:mm',\n *     shiftIncrement    : 1,\n *     shiftUnit         : 'WEEK',\n *     timeResolution    : {\n *         unit      : 'MINUTE',\n *         increment : 10\n *     },\n *     headers           : [\n *         {\n *             unit          : 'year',\n *             // Simplified scenario, assuming view will always just show one US fiscal year\n *             cellGenerator : (viewStart, viewEnd) => [{\n *                 start  : viewStart,\n *                 end    : viewEnd,\n *                 header : `Fiscal Year ${viewStart.getFullYear() + 1}`\n *             }]\n *         },\n *         {\n *             unit : 'quarter',\n *             renderer(start, end, cfg) {\n *                 const\n *                     quarter       = Math.floor(start.getMonth() / 3) + 1,\n *                     fiscalQuarter = quarter === 4 ? 1 : (quarter + 1);\n *\n *                 return `FQ${fiscalQuarter} ${start.getFullYear() + (fiscalQuarter === 1 ? 1 : 0)}`;\n *             }\n *         },\n *         {\n *             unit       : 'month',\n *             dateFormat : 'MMM Y'\n *         }\n *     ]\n *  },\n * ```\n */\n/**\n * A ViewPreset is a record of {@link Scheduler.preset.PresetStore PresetStore} which describes the granularity\n * of the timeline view of a {@link Scheduler.view.Scheduler Scheduler} and the layout and subdivisions of the timeline header.\n *\n * You can create a new instance by specifying all fields:\n *\n * ```javascript\n * const myViewPreset = new ViewPreset({\n *     id   : 'myPreset',              // Unique id value provided to recognize your view preset. Not required, but having it you can simply set new view preset by id: scheduler.viewPreset = 'myPreset'\n *\n *     name : 'My view preset',        // A human-readable name provided to be used in GUI, e.i. preset picker, etc.\n *\n *     tickWidth  : 24,                // Time column width in horizontal mode\n *     tickHeight : 50,                // Time column height in vertical mode\n *     displayDateFormat : 'HH:mm',    // Controls how dates will be displayed in tooltips etc\n *\n *     shiftIncrement : 1,             // Controls how much time to skip when calling shiftNext and shiftPrevious.\n *     shiftUnit      : 'day',         // Valid values are 'millisecond', 'second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year'.\n *     defaultSpan    : 12,            // By default, if no end date is supplied to a view it will show 12 hours\n *\n *     timeResolution : {              // Dates will be snapped to this resolution\n *         unit      : 'minute',       // Valid values are 'millisecond', 'second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year'.\n *         increment : 15\n *     },\n *\n *     headers : [                     // This defines your header rows from top to bottom\n *         {                           // For each row you can define 'unit', 'increment', 'dateFormat', 'renderer', 'align', and 'thisObj'\n *             unit       : 'day',\n *             dateFormat : 'ddd DD/MM'\n *         },\n *         {\n *             unit       : 'hour',\n *             dateFormat : 'HH:mm'\n *         }\n *     ],\n *\n *     columnLinesFor : 1              // Defines header level column lines will be drawn for. Defaults to the last level.\n * });\n * ```\n *\n * Or you can extend one of view presets registered in {@link Scheduler.preset.PresetManager PresetManager}:\n *\n * ```javascript\n * const myViewPreset2 = new ViewPreset({\n *     id   : 'myPreset',                  // Unique id value provided to recognize your view preset. Not required, but having it you can simply set new view preset by id: scheduler.viewPreset = 'myPreset'\n *     name : 'My view preset',            // A human-readable name provided to be used in GUI, e.i. preset picker, etc.\n *     base : 'hourAndDay',                // Extends 'hourAndDay' view preset provided by PresetManager. You can pick out any of PresetManager's view presets: PresetManager.records\n *\n *     timeResolution : {                  // Override time resolution\n *         unit      : 'minute',\n *         increment : 15                  // Make it increment every 15 mins\n *     },\n *\n *     headers : [                         // Override headers\n *         {\n *             unit       : 'day',\n *             dateFormat : 'DD.MM.YYYY'   // Use different date format for top header 01.10.2020\n *         },\n *         {\n *             unit       : 'hour',\n *             dateFormat : 'LT'\n *         }\n *     ]\n * });\n * ```\n *\n * See {@link Scheduler.preset.PresetManager PresetManager} for the list of base presets. You may add your own\n * presets to this global list:\n *\n * ```javascript\n * PresetManager.add(myViewPreset);     // Adds new preset to the global scope. All newly created scheduler instances will have it too.\n *\n * const scheduler = new Scheduler({\n *     viewPreset : 'myPreset'\n *     // other configs...\n * });\n * ```\n *\n * Or add them on an individual basis to Scheduler instances:\n *\n * ```javascript\n * const scheduler = new Scheduler({...});\n *\n * scheduler.presets.add(myViewPreset); // Adds new preset to the scheduler instance only. All newly created scheduler instances will **not** have it.\n *\n * scheduler.viewPreset = 'myPreset';\n * ```\n *\n * ## Defining custom header rows\n *\n * You can have any number of header rows by specifying {@link #field-headers}, see {@link #typedef-ViewPresetHeaderRow}\n * for the config object format and {@link Core.helper.DateHelper} for the supported date formats, or use to render\n * custom contents into the row cells.\n *\n * ```javascript\n *  headers : [\n *      {\n *          unit       : 'month',\n *          dateFormat : 'MM.YYYY'\n *      },\n *      {\n *          unit       : 'week',\n *          renderer   : ({ startDate }) => `Week ${DateHelper.format(startDate, 'WW')}`\n *      }\n *  ]\n * ```\n *\n * {@inlineexample Scheduler/preset/CustomHeader.js}\n *\n * This live demo shows a custom ViewPreset with AM/PM time format:\n * {@inlineexample Scheduler/preset/amPmPreset.js}\n *\n * @extends Core/data/Model\n */\nexport default class ViewPreset extends Model {\n    static $name = 'ViewPreset';\n    static get fields() {\n        return [\n            /**\n             * The name of an existing view preset to extend\n             * @field {String} base\n             */\n            { name : 'base', type : 'string' },\n            /**\n             * The name of the view preset\n             * @field {String} name\n             */\n            { name : 'name', type : 'string' },\n            /**\n             * The height of the row in horizontal orientation\n             * @field {Number} rowHeight\n             * @default\n             */\n            {\n                name         : 'rowHeight',\n                defaultValue : 24\n            },\n            /**\n             * The width of the time tick column in horizontal orientation\n             * @field {Number} tickWidth\n             * @default\n             */\n            {\n                name         : 'tickWidth',\n                defaultValue : 50\n            },\n            /**\n             * The height of the time tick column in vertical orientation\n             * @field {Number} tickHeight\n             * @default\n             */\n            {\n                name         : 'tickHeight',\n                defaultValue : 50\n            },\n            /**\n             * Defines how dates will be formatted in tooltips etc\n             * @field {String} displayDateFormat\n             * @default\n             */\n            {\n                name         : 'displayDateFormat',\n                defaultValue : 'HH:mm'\n            },\n            /**\n             * The unit to shift when calling shiftNext/shiftPrevious to navigate in the chart.\n             * Valid values are \"millisecond\", \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\".\n             * @field {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} shiftUnit\n             * @default\n             */\n            {\n                name         : 'shiftUnit',\n                defaultValue : 'hour'\n            },\n            /**\n             * The amount to shift (in shiftUnits)\n             * @field {Number} shiftIncrement\n             * @default\n             */\n            {\n                name         : 'shiftIncrement',\n                defaultValue : 1\n            },\n            /**\n             * The amount of time to show by default in a view (in the unit defined by {@link #field-mainUnit})\n             * @field {Number} defaultSpan\n             * @default\n             */\n            {\n                name         : 'defaultSpan',\n                defaultValue : 12\n            },\n            /**\n             * Initially set to a unit. Defaults to the unit defined by the middle header.\n             * @field {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} mainUnit\n             */\n            {\n                name : 'mainUnit'\n            },\n            /**\n             * Note: Currently, this field only applies when changing viewPreset with the {@link Scheduler.widget.ViewPresetCombo}.\n             *\n             * Set to a number and that amount of {@link #field-mainUnit} will be added to the startDate. For example: A\n             * start value of `5` together with the mainUnit `hours` will add 5 hours to the startDate. This can achieve\n             * a \"day view\" that starts 5 AM.\n             *\n             * Set to a string unit (for example week, day, month) and the startDate will be the start of that unit\n             * calculated from current startDate. A start value of `week` will result in a startDate in the first day of\n             * the week.\n             *\n             * If set to a number or not set at all, the startDate will be calculated at the beginning of current\n             * mainUnit.\n             * @field {Number|String} start\n             */\n            {\n                name : 'start'\n            },\n            /**\n             * An object containing a unit identifier and an increment variable. This value means minimal task duration\n             * you can create using UI. For example when you drag create a task or drag & drop a task, if increment is 5\n             * and unit is 'minute' that means that you can create a 5-minute-long task, or move it 5 min\n             * forward/backward. This config maps to scheduler's\n             * {@link Scheduler.view.mixin.TimelineDateMapper#property-timeResolution} config.\n             *\n             * ```javascript\n             * timeResolution : {\n             *   unit      : 'minute',  //Valid values are \"millisecond\", \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\".\n             *   increment : 5\n             * }\n             * ```\n             *\n             * @field {ViewPresetTimeResolution} timeResolution\n             */\n            'timeResolution',\n            /**\n             * An array containing one or more {@link #typedef-ViewPresetHeaderRow} config objects, each of\n             * which defines a level of headers for the scheduler.\n             * The `main` unit will be the last header's unit, but this can be changed using the\n             * {@link #field-mainHeaderLevel} field.\n             * @field {ViewPresetHeaderRow[]} headers\n             */\n            'headers',\n            /**\n             * Index of the {@link #field-headers} array to define which header level is the `main` header.\n             * Defaults to the bottom header.\n             * @field {Number} mainHeaderLevel\n             */\n            'mainHeaderLevel',\n            /**\n             * Index of a header level in the {@link #field-headers} array for which column lines are drawn. See\n             * {@link Scheduler.feature.ColumnLines}.\n             * Defaults to the bottom header.\n             * @field {Number} columnLinesFor\n             */\n            'columnLinesFor'\n        ];\n    }\n    construct() {\n        super.construct(...arguments);\n        this.normalizeUnits();\n    }\n    generateId(owner) {\n        const\n            me    = this,\n            {\n                headers\n            }     = me,\n            parts = [];\n        // If we were subclassed from a base, use that id as the basis of our.\n        let result = Object.getPrototypeOf(me.data).id;\n        if (!result) {\n            for (let { length } = headers, i = length - 1; i >= 0; i--) {\n                const\n                    { unit, increment } = headers[i],\n                    multiple            = increment > 1;\n                parts.push(`${multiple ? increment : ''}${i ? unit : StringHelper.capitalize(unit)}${multiple ? 's' : ''}`);\n            }\n            // Use upwards header units so eg \"monthAndYear\"\n            result = parts.join('And');\n        }\n        // If duplicate, decorate the generated by adding details.\n        // For example make it \"hourAndDay-50by80\"\n        // Only interrogate the store if it is loaded. If consulted during\n        // a load, the idMap will be created empty\n        if (owner.count && owner.includes(result)) {\n            result += `-${me.tickWidth}by${me.tickHeight || me.tickWidth}`;\n            // If still duplicate use increment\n            if (owner.includes(result)) {\n                result += `-${me.bottomHeader.increment}`;\n                // And if STILL duplicate, make it unique with a suffix\n                if (owner.includes(result)) {\n                    result = IdHelper.generateId(`${result}-`);\n                }\n            }\n        }\n        return result;\n    }\n    normalizeUnits() {\n        const\n            me                                     = this,\n            { timeResolution, headers, shiftUnit } = me;\n        if (headers) {\n            // Make sure date \"unit\" constant specified in the preset are resolved\n            for (let i = 0, { length } = headers; i < length; i++) {\n                const header = headers[i];\n                header.unit = DH.normalizeUnit(header.unit);\n                if (header.splitUnit) {\n                    header.splitUnit = DH.normalizeUnit(header.splitUnit);\n                }\n                if (!('increment' in header)) {\n                    headers[i] = Object.assign({\n                        increment : 1\n                    }, header);\n                }\n            }\n        }\n        if (timeResolution) {\n            timeResolution.unit = DH.normalizeUnit(timeResolution.unit);\n        }\n        if (shiftUnit) {\n            me.shiftUnit = DH.normalizeUnit(shiftUnit);\n        }\n    }\n    // Process legacy columnLines config into a headers array.\n    static normalizeHeaderConfig(data) {\n        const\n            { headerConfig, columnLinesFor, mainHeaderLevel } = data,\n            headers                                           = data.headers = [];\n        if (headerConfig.top) {\n            if (columnLinesFor === 'top') {\n                data.columnLinesFor = 0;\n            }\n            if (mainHeaderLevel === 'top') {\n                data.mainHeaderLevel = 0;\n            }\n            headers[0] = headerConfig.top;\n        }\n        if (headerConfig.middle) {\n            if (columnLinesFor === 'middle') {\n                data.columnLinesFor = headers.length;\n            }\n            if (mainHeaderLevel === 'middle') {\n                data.mainHeaderLevel = headers.length;\n            }\n            headers.push(headerConfig.middle);\n        }\n        else {\n            throw new Error('ViewPreset.headerConfig must be configured with a middle');\n        }\n        if (headerConfig.bottom) {\n            // Main level is middle when using headerConfig object.\n            data.mainHeaderLevel = headers.length - 1;\n            // There *must* be a middle above this bottom header\n            // so that is the columnLines one by default.\n            if (columnLinesFor == null) {\n                data.columnLinesFor = headers.length - 1;\n            }\n            else if (columnLinesFor === 'bottom') {\n                data.columnLinesFor = headers.length;\n            }\n            // There *must* be a middle above this bottom header\n            // so that is the main one by default.\n            if (mainHeaderLevel == null) {\n                data.mainHeaderLevel = headers.length - 1;\n            }\n            if (mainHeaderLevel === 'bottom') {\n                data.mainHeaderLevel = headers.length;\n            }\n            headers.push(headerConfig.bottom);\n        }\n    }\n    // These are read-only once configured.\n    set() {}\n    inSet() {}\n    get columnLinesFor() {\n        return ('columnLinesFor' in this.data) ? this.data.columnLinesFor : this.headers.length - 1;\n    }\n    get tickSize() {\n        return this._tickSize || this.tickWidth;\n    }\n    get tickWidth() {\n        return ('tickWidth' in this.data) ? this.data.tickWidth : 50;\n    }\n    get tickHeight() {\n        return ('tickHeight' in this.data) ? this.data.tickHeight : 50;\n    }\n    get headerConfig() {\n        // Configured in the legacy manner, just return the configured value.\n        if (this.data.headerConfig) {\n            return this.data.headerConfig;\n        }\n        // Rebuild the object based upon the configured headers array.\n        const\n            result      = {},\n            { headers } = this,\n            { length }  = headers;\n        switch (length) {\n            case 1 :\n                result.middle = headers[0];\n                break;\n            case 2:\n                if (this.mainHeaderLevel === 0) {\n                    result.middle = headers[0];\n                    result.bottom = headers[1];\n                }\n                else {\n                    result.top    = headers[0];\n                    result.middle = headers[1];\n                }\n                break;\n            case 3:\n                result.top    = headers[0];\n                result.middle = headers[1];\n                result.bottom = headers[2];\n                break;\n            default:\n                throw new Error('headerConfig object not supported for >3 header levels');\n        }\n        return result;\n    }\n    set mainHeaderLevel(mainHeaderLevel) {\n        this.data.mainHeaderLevel = mainHeaderLevel;\n    }\n    get mainHeaderLevel() {\n        if ('mainHeaderLevel' in this.data) {\n            return this.data.mainHeaderLevel;\n        }\n        // 3 headers, then it's the middle\n        if (this.data.headers.length === 3) {\n            return 1;\n        }\n        // Assume it goes top, middle.\n        // If it's middle, top, use mainHeaderLevel : 0\n        return this.headers.length - 1;\n    }\n    get mainHeader() {\n        return this.headers[this.mainHeaderLevel];\n    }\n    get topHeader() {\n        return this.headers[0];\n    }\n    get topUnit() {\n        return this.topHeader.unit;\n    }\n    get topIncrement() {\n        return this.topHeader.increment;\n    }\n    get bottomHeader() {\n        return this.headers[this.headers.length - 1];\n    }\n    get leafUnit() {\n        return this.bottomHeader.unit;\n    }\n    get leafIncrement() {\n        return this.bottomHeader.increment;\n    }\n    get mainUnit() {\n        if ('mainUnit' in this.data) {\n            return this.data.mainUnit;\n        }\n        return this.mainHeader.unit;\n    }\n    get msPerPixel() {\n        const { bottomHeader } = this;\n        return Math.round(DH.asMilliseconds(bottomHeader.increment || 1, bottomHeader.unit) / this.tickWidth);\n    }\n    get isValid() {\n        const me = this;\n        let valid = true;\n        // Make sure all date \"unit\" constants are valid\n        for (const header of me.headers) {\n            valid = valid && Boolean(DH.normalizeUnit(header.unit));\n        }\n        if (me.timeResolution) {\n            valid = valid && DH.normalizeUnit(me.timeResolution.unit);\n        }\n        if (me.shiftUnit) {\n            valid = valid && DH.normalizeUnit(me.shiftUnit);\n        }\n        return valid;\n    }\n}\nViewPreset._$name = 'ViewPreset';", "import LocaleHelper from '../../Core/localization/LocaleHelper.js';\nimport '../../Grid/localization/En.js';\nconst locale = {\n    localeName : 'En',\n    localeDesc : 'English (US)',\n    localeCode : 'en-US',\n    Object : {\n        newEvent : 'New event'\n    },\n    ResourceInfoColumn : {\n        eventCountText : data => data + ' event' + (data !== 1 ? 's' : '')\n    },\n    Dependencies : {\n        from    : 'From',\n        to      : 'To',\n        valid   : 'Valid',\n        invalid : 'Invalid'\n    },\n    DependencyType : {\n        SS           : 'SS',\n        SF           : 'SF',\n        FS           : 'FS',\n        FF           : 'FF',\n        StartToStart : 'Start-to-Start',\n        StartToEnd   : 'Start-to-Finish',\n        EndToStart   : 'Finish-to-Start',\n        EndToEnd     : 'Finish-to-Finish',\n        short        : [\n            'SS',\n            'SF',\n            'FS',\n            'FF'\n        ],\n        long : [\n            'Start-to-Start',\n            'Start-to-Finish',\n            'Finish-to-Start',\n            'Finish-to-Finish'\n        ]\n    },\n    DependencyEdit : {\n        From              : 'From',\n        To                : 'To',\n        Type              : 'Type',\n        Lag               : 'Lag',\n        'Edit dependency' : 'Edit dependency',\n        Save              : 'Save',\n        Delete            : 'Delete',\n        Cancel            : 'Cancel',\n        StartToStart      : 'Start to Start',\n        StartToEnd        : 'Start to End',\n        EndToStart        : 'End to Start',\n        EndToEnd          : 'End to End'\n    },\n    EventEdit : {\n        Name         : 'Name',\n        Resource     : 'Resource',\n        Start        : 'Start',\n        End          : 'End',\n        Save         : 'Save',\n        Delete       : 'Delete',\n        Cancel       : 'Cancel',\n        'Edit event' : 'Edit event',\n        Repeat       : 'Repeat'\n    },\n    EventDrag : {\n        eventOverlapsExisting : 'Event overlaps existing event for this resource',\n        noDropOutsideTimeline : 'Event may not be dropped completely outside the timeline'\n    },\n    SchedulerBase : {\n        'Add event'      : 'Add event',\n        'Delete event'   : 'Delete event',\n        'Unassign event' : 'Unassign event',\n        color            : 'Color'\n    },\n    TimeAxisHeaderMenu : {\n        pickZoomLevel   : 'Zoom',\n        activeDateRange : 'Date range',\n        startText       : 'Start date',\n        endText         : 'End date',\n        todayText       : 'Today'\n    },\n    EventCopyPaste : {\n        copyEvent  : 'Copy event',\n        cutEvent   : 'Cut event',\n        pasteEvent : 'Paste event'\n    },\n    EventFilter : {\n        filterEvents : 'Filter tasks',\n        byName       : 'By name'\n    },\n    TimeRanges : {\n        showCurrentTimeLine : 'Show current timeline'\n    },\n    PresetManager : {\n        secondAndMinute : {\n            displayDateFormat : 'll LTS',\n            name              : 'Seconds'\n        },\n        minuteAndHour : {\n            topDateFormat     : 'ddd MM/DD, hA',\n            displayDateFormat : 'll LST'\n        },\n        hourAndDay : {\n            topDateFormat     : 'ddd MM/DD',\n            middleDateFormat  : 'LST',\n            displayDateFormat : 'll LST',\n            name              : 'Day'\n        },\n        day : {\n            name : 'Day/hours'\n        },\n        week : {\n            name : 'Week/hours'\n        },\n        dayAndWeek : {\n            displayDateFormat : 'll LST',\n            name              : 'Week/days'\n        },\n        dayAndMonth : {\n            name : 'Month'\n        },\n        weekAndDay : {\n            displayDateFormat : 'll LST',\n            name              : 'Week'\n        },\n        weekAndMonth : {\n            name : 'Weeks'\n        },\n        weekAndDayLetter : {\n            name : 'Weeks/weekdays'\n        },\n        weekDateAndMonth : {\n            name : 'Months/weeks'\n        },\n        monthAndYear : {\n            name : 'Months'\n        },\n        year : {\n            name : 'Years'\n        },\n        manyYears : {\n            name : 'Multiple years'\n        }\n    },\n    RecurrenceConfirmationPopup : {\n        'delete-title'              : 'You are deleting an event',\n        'delete-all-message'        : 'Do you want to delete all occurrences of this event?',\n        'delete-further-message'    : 'Do you want to delete this and all future occurrences of this event, or only the selected occurrence?',\n        'delete-further-btn-text'   : 'Delete All Future Events',\n        'delete-only-this-btn-text' : 'Delete Only This Event',\n        'update-title'              : 'You are changing a repeating event',\n        'update-all-message'        : 'Do you want to change all occurrences of this event?',\n        'update-further-message'    : 'Do you want to change only this occurrence of the event, or this and all future occurrences?',\n        'update-further-btn-text'   : 'All Future Events',\n        'update-only-this-btn-text' : 'Only This Event',\n        Yes                         : 'Yes',\n        Cancel                      : 'Cancel',\n        width                       : 600\n    },\n    RecurrenceLegend : {\n        ' and '                         : ' and ',\n        Daily                           : 'Daily',\n        'Weekly on {1}'                 : ({ days }) => `Weekly on ${days}`,\n        'Monthly on {1}'                : ({ days }) => `Monthly on ${days}`,\n        'Yearly on {1} of {2}'          : ({ days, months }) => `Yearly on ${days} of ${months}`,\n        'Every {0} days'                : ({ interval }) => `Every ${interval} days`,\n        'Every {0} weeks on {1}'        : ({ interval, days }) => `Every ${interval} weeks on ${days}`,\n        'Every {0} months on {1}'       : ({ interval, days }) => `Every ${interval} months on ${days}`,\n        'Every {0} years on {1} of {2}' : ({ interval, days, months }) => `Every ${interval} years on ${days} of ${months}`,\n        position1                       : 'the first',\n        position2                       : 'the second',\n        position3                       : 'the third',\n        position4                       : 'the fourth',\n        position5                       : 'the fifth',\n        'position-1'                    : 'the last',\n        day                             : 'day',\n        weekday                         : 'weekday',\n        'weekend day'                   : 'weekend day',\n        daysFormat                      : ({ position, days }) => `${position} ${days}`\n    },\n    RecurrenceEditor : {\n        'Repeat event'      : 'Repeat event',\n        Cancel              : 'Cancel',\n        Save                : 'Save',\n        Frequency           : 'Frequency',\n        Every               : 'Every',\n        DAILYintervalUnit   : 'day(s)',\n        WEEKLYintervalUnit  : 'week(s)',\n        MONTHLYintervalUnit : 'month(s)',\n        YEARLYintervalUnit  : 'year(s)',\n        Each                : 'Each',\n        'On the'            : 'On the',\n        'End repeat'        : 'End repeat',\n        'time(s)'           : 'time(s)'\n    },\n    RecurrenceDaysCombo : {\n        day           : 'day',\n        weekday       : 'weekday',\n        'weekend day' : 'weekend day'\n    },\n    RecurrencePositionsCombo : {\n        position1    : 'first',\n        position2    : 'second',\n        position3    : 'third',\n        position4    : 'fourth',\n        position5    : 'fifth',\n        'position-1' : 'last'\n    },\n    RecurrenceStopConditionCombo : {\n        Never     : 'Never',\n        After     : 'After',\n        'On date' : 'On date'\n    },\n    RecurrenceFrequencyCombo : {\n        None    : 'No repeat',\n        Daily   : 'Daily',\n        Weekly  : 'Weekly',\n        Monthly : 'Monthly',\n        Yearly  : 'Yearly'\n    },\n    RecurrenceCombo : {\n        None   : 'None',\n        Custom : 'Custom...'\n    },\n    Summary : {\n        'Summary for' : date => `Summary for ${date}`\n    },\n    ScheduleRangeCombo : {\n        completeview : 'Complete schedule',\n        currentview  : 'Visible schedule',\n        daterange    : 'Date range',\n        completedata : 'Complete schedule (for all events)'\n    },\n    SchedulerExportDialog : {\n        'Schedule range' : 'Schedule range',\n        'Export from'    : 'From',\n        'Export to'      : 'To'\n    },\n    ExcelExporter : {\n        'No resource assigned' : 'No resource assigned'\n    },\n    CrudManagerView : {\n        serverResponseLabel : 'Server response:'\n    },\n    DurationColumn : {\n        Duration : 'Duration'\n    }\n};\nexport default LocaleHelper.publishLocale(locale);\n", "import { unitMagnitudes } from '../../Core/helper/DateHelper.js';\nimport ViewPreset from './ViewPreset.js';\nimport Localizable from '../../Core/localization/Localizable.js';\nimport '../../Scheduler/localization/En.js';\nimport Store from '../../Core/data/Store.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\n/**\n * @module Scheduler/preset/PresetStore\n */\n/**\n * A special Store subclass which holds {@link Scheduler.preset.ViewPreset ViewPresets}.\n * Each ViewPreset in this store represents a zoom level. The store data is sorted in special\n * zoom order. That is zoomed out to zoomed in. The first Preset will produce the narrowest event bars\n * the last one will produce the widest event bars.\n *\n * To specify view presets (zoom levels) please provide set of view presets to the scheduler:\n *\n * ```javascript\n * const myScheduler = new Scheduler({\n *     presets : [\n *         {\n *             base : 'hourAndDay',\n *             id   : 'MyHourAndDay',\n *             // other preset configs....\n *         },\n *         {\n *             base : 'weekAndMonth',\n *             id   : 'MyWeekAndMonth',\n *             // other preset configs....\n *         }\n *     ],\n *     viewPreset : 'MyHourAndDay',\n *     // other scheduler configs....\n *     });\n * ```\n *\n * @extends Core/data/Store\n */\nexport default class PresetStore extends Localizable(Store) {\n    static get $name() {\n        return 'PresetStore';\n    }\n    static get defaultConfig() {\n        return {\n            useRawData : true,\n            modelClass : ViewPreset,\n            /**\n             * Specifies the sort order of the presets in the store.\n             * By default they are in zoomed out to zoomed in order. That is\n             * presets which will create widest event bars to presets\n             * which will produce narrowest event bars.\n             *\n             * Configure this as `-1` to reverse this order.\n             * @config {Number}\n             * @default\n             */\n            zoomOrder : 1\n        };\n    }\n    set storage(storage) {\n        super.storage = storage;\n        // Maintained in order automatically while adding.\n        this.storage.addSorter((lhs, rhs) => {\n            const\n                leftBottomHeader  = lhs.bottomHeader,\n                rightBottomHeader = rhs.bottomHeader;\n            // Sort order:\n            //  Milliseconds per pixel.\n            //  Tick size.\n            //  Unit magnitude.\n            //  Increment size.\n            const\n                order = rhs.msPerPixel - lhs.msPerPixel ||\n                unitMagnitudes[leftBottomHeader.unit] - unitMagnitudes[rightBottomHeader.unit] ||\n                leftBottomHeader.increment - rightBottomHeader.increment;\n            return order * this.zoomOrder;\n        });\n    }\n    get storage() {\n        return super.storage;\n    }\n    getById(id) {\n        // If we do not know about the id, inherit it from the PresetManager singleton\n        return super.getById(id) || !this.isPresetManager && globalThis.bryntum.PresetManager.getById(id);\n    }\n    createRecord(data, ...args) {\n        let result;\n        if (data.isViewPreset) {\n            return data;\n        }\n        if (typeof data === 'string') {\n            result = this.getById(data);\n        }\n        else if (typeof data === 'number') {\n            result = this.getAt(data);\n        }\n        // Its a ViewPreset data object\n        else {\n            // If it's extending an existing ViewPreset, inherit then override\n            // the data from the base.\n            if (data.base) {\n                data = this.copyBaseValues(data);\n            }\n            // Model constructor will call generateId if no id is provided\n            return super.createRecord(data, ...args);\n        }\n        if (!result) {\n            throw new Error(`ViewPreset ${data} does not exist`);\n        }\n        return result;\n    }\n    updateLocalization() {\n        super.updateLocalization();\n        const me = this;\n        // Collect presets from store...\n        let presets = me.allRecords;\n        // and basePresets if we are the PresetManager\n        if (me.isPresetManager) {\n            presets = new Set(presets.concat(Object.values(me.basePresets)));\n        }\n        presets.forEach(preset => {\n            let localePreset = me.optionalL(`L{PresetManager.${preset.id}}`, null, true);\n            // Default presets generated from base presets use localization of base if they have no own\n            if (typeof localePreset === 'string' && preset.baseId) {\n                localePreset = me.optionalL(`L{PresetManager.${preset.baseId}}`, null, true);\n            }\n            // Apply any custom format defined in locale, or the original format if none exists\n            if (localePreset && typeof localePreset === 'object') {\n                if (!preset.originalDisplayDateFormat) {\n                    preset.originalDisplayDateFormat = preset.displayDateFormat;\n                }\n                // it there is a topDateFormat but preset.mainHeaderLevel is 0, means the middle header is the top header actually,\n                // so convert property to middle (if middle doesn't exists) to localization understand (topDateFormat for weekAndDay for example)\n                // topDateFormat doesn't work when mainHeaderLevel is 0 because it doesn't have top config\n                // but has top header visually (Check on get headerConfig method in ViewPreset class)\n                if (preset.mainHeaderLevel === 0 && localePreset.topDateFormat) {\n                    localePreset.middleDateFormat = localePreset.middleDateFormat || localePreset.topDateFormat;\n                }\n                preset.setData('displayDateFormat', localePreset.displayDateFormat || preset.originalDisplayDateFormat);\n                ['top', 'middle', 'bottom'].forEach(level => {\n                    const\n                        levelConfig           = preset.headerConfig[level],\n                        localeLevelDateFormat = localePreset[level + 'DateFormat'];\n                    if (levelConfig) {\n                        if (!levelConfig.originalDateFormat) {\n                            levelConfig.originalDateFormat = levelConfig.dateFormat;\n                        }\n                        // if there was defined topDateFormat on locale file for example, use it instead of renderer from basePresets (https://github.com/bryntum/support/issues/1307)\n                        if (localeLevelDateFormat && levelConfig.renderer) {\n                            levelConfig.renderer = null;\n                        }\n                        levelConfig.dateFormat = localeLevelDateFormat || levelConfig.originalDateFormat;\n                    }\n                });\n                // The preset names are used in ViewPresetCombo and are localized by default\n                if (localePreset.name) {\n                    if (!preset.unlocalizedName) {\n                        preset.unlocalizedName = preset.name;\n                    }\n                    preset.setData('name', localePreset.name);\n                }\n                else if (preset.unlocalizedName && preset.unlocalizedName !== preset.name) {\n                    preset.name = preset.unlocalizedName;\n                    preset.unlocalizedName = null;\n                }\n            }\n        });\n    }\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    // Preset config on Scheduler/Gantt expects array of presets and not store config\n    getCurrentConfig(options) {\n        return super.getCurrentConfig(options).data;\n    }\n    copyBaseValues(presetData) {\n        let base = this.getById(presetData.base);\n        if (!base) {\n            throw new Error(`ViewPreset base '${presetData.base}' does not exist.`);\n        }\n        base = ObjectHelper.clone(base.data);\n        delete base.id;\n        if (presetData.name) {\n            delete base.name;\n        }\n        // Merge supplied data into a clone of the base ViewPreset's data\n        // so that the new one overrides the base.\n        return ObjectHelper.merge(base, presetData);\n    }\n    add(preset) {\n        preset = Array.isArray(preset) ? preset : [preset];\n        preset.forEach(preset => {\n            // If a ViewPreset instance that extends another preset was added\n            // Only in add we can apply the base data\n            if (preset.isViewPreset && preset.base) {\n                preset.data = this.copyBaseValues(preset.originalData);\n            }\n        });\n        return super.add(...arguments);\n    }\n}\nPresetStore._$name = 'PresetStore';", "import DateHelper from '../../Core/helper/DateHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport ViewPreset from './ViewPreset.js';\nimport PresetStore from './PresetStore.js';\n// No module tag here. That stops the singleton from being included by the docs.\n/**\n * ## Intro\n * This is a global Store of {@link Scheduler.preset.ViewPreset ViewPresets}, required to supply initial data to\n * Scheduler's {@link Scheduler.view.mixin.TimelineViewPresets#config-presets}.\n *\n * You can provide new view presets globally or for a specific scheduler.\n *\n * **NOTE:** You **cannot** modify existing records in the PresetManager store. You can either remove\n * preset records from the store or add new records to the store.\n * Also please keep in mind, all changes provided to the PresetManager store are not reflected to the\n * {@link Scheduler.view.mixin.TimelineViewPresets#config-presets} of schedulers that already exist!\n *\n * If you want to have just a few presets (also known as zoom levels) in your Scheduler, you can slice corresponding records\n * from the `PresetManager` and apply them to the Scheduler `presets` config.\n * ```javascript\n * const newPresets = PresetManager.records.slice(10, 12);\n *\n * const scheduler = new Scheduler({\n *     presets    : newPresets, // Only 2 zoom levels are available\n *     viewPreset : newPresets[0].id\n * });\n * ```\n *\n * If you want to adjust all default presets and assign to a specific scheduler you are going to create,\n * you can extend them and pass as an array to the Scheduler `presets` config.\n * Here is an example of how to set the same `timeResolution` to all `ViewPresets`.\n * ```javascript\n * const newPresets = PresetManager.map(preset => {\n *     return {\n *         id             : 'my_' + preset.id,\n *         base           : preset.id, // Based on an existing preset\n *         timeResolution : {\n *             unit      : 'day',\n *             increment : 1\n *         }\n *     };\n * });\n *\n * const scheduler = new Scheduler({\n *     presets     : newPresets,\n *     viewPreset : 'my_hourAndDay'\n * });\n * ```\n *\n * If you want to do the same for **all** schedulers which will be created next, you can register new presets in a loop.\n * ```javascript\n * PresetManager.records.forEach(preset => {\n *     // Pass the same ID, so when a new preset is added to the store,\n *     // it will replace the current one.\n *     PresetManager.registerPreset(preset.id, {\n *        id             : preset.id,\n *        base           : preset.id,\n *        timeResolution : {\n *            unit      : 'day',\n *            increment : 1\n *        }\n *    });\n * });\n * ```\n *\n * Here is an example of how to add a new `ViewPreset` to the global `PresetManager` store and to the already created\n * scheduler `presets`.\n * ```javascript\n * const scheduler = new Scheduler({...});\n *\n * const newGlobalPresets = PresetManager.add({\n *     id              : 'myNewPreset',\n *     base            : 'hourAndDay', // Based on an existing preset\n *     columnLinesFor  : 0,\n *     // Override headers\n *     headers : [\n *         {\n *             unit       : 'day',\n *             // Use different date format for top header 01.10.2020\n *             dateFormat : 'DD.MM.YYYY'\n *         },\n *         {\n *             unit       : 'hour',\n *             dateFormat : 'LT'\n *         }\n *     ]\n * });\n *\n * // Add new presets to the scheduler that has been created before changes\n * // to PresetManager are applied\n * scheduler.presets.add(newGlobalPresets);\n * ```\n *\n * ## Predefined presets\n *\n * Predefined presets are:\n *\n * - `secondAndMinute` - creates a 2 level header - minutes and seconds:\n * {@inlineexample Scheduler/preset/secondAndMinute.js}\n * - `minuteAndHour` - creates a 2 level header - hours and minutes:\n * {@inlineexample Scheduler/preset/minuteAndHour.js}\n * - `hourAndDay` - creates a 2 level header - days and hours:\n * {@inlineexample Scheduler/preset/hourAndDay.js}\n * - `dayAndWeek` - creates a 2 level header - weeks and days:\n * {@inlineexample Scheduler/preset/dayAndWeek.js}\n * - `dayAndMonth` - creates a 2 level header - months and days:\n * {@inlineexample Scheduler/preset/dayAndMonth.js}\n * - `weekAndDay` - just like `dayAndWeek` but with different formatting:\n * {@inlineexample Scheduler/preset/weekAndDay.js}\n * - `weekAndDayLetter` - creates a 2 level header - weeks and day letters:\n * {@inlineexample Scheduler/preset/weekAndDayLetter.js}\n * - `weekAndMonth` - creates a 2 level header - months and weeks:\n * {@inlineexample Scheduler/preset/weekAndMonth.js}\n * - `weekDateAndMonth` - creates a 2 level header - months and weeks (weeks shown by first day only):\n * {@inlineexample Scheduler/preset/weekDateAndMonth.js}\n * - `monthAndYear` - creates a 2 level header - years and months:\n * {@inlineexample Scheduler/preset/monthAndYear.js}\n * - `year` - creates a 2 level header - years and quarters:\n * {@inlineexample Scheduler/preset/year.js}\n * - `manyYears` - creates a 2 level header - 5-years and years:\n * {@inlineexample Scheduler/preset/manyYears.js}\n *\n * See the {@link Scheduler.preset.ViewPreset} and {@link Scheduler.preset.ViewPresetHeaderRow} classes for a\n * description of the view preset properties.\n *\n * ## Localizing View Presets\n * Bryntum Scheduler uses locales for translations including date formats for view presets.\n *\n * To translate date format for view presets just define the date format for the specified region\n * for your locale file, like this:\n * ```javascript\n * const locale = {\n *\n *     localeName : 'En',\n *\n *     // ... Other translations here ...\n *\n *     PresetManager : {\n *         // Translation for the \"weekAndDay\" ViewPreset\n *         weekAndDay : {\n *             // Change the date format for the top and middle levels\n *             topDateFormat    : 'MMM',\n *             middleDateFormat : 'D'\n *         },\n *         // Translation for the \"dayAndWeek\" ViewPreset\n *         dayAndWeek : {\n *             // Change the date format for the top level\n *             topDateFormat : 'MMMM YYYY'\n *         }\n *     }\n * }\n *\n * LocaleManager.applyLocale(locale);\n * ```\n *\n * Check the <a target=\"_blank\" href=\"../examples/localization/\">localization demo</a> and [this guide](#Scheduler/guides/customization/localization.md) for more details.\n *\n * @singleton\n * @extends Scheduler/preset/PresetStore\n */\nclass PresetManager extends PresetStore {\n    static get $name() {\n        return 'PresetManager';\n    }\n    static get defaultConfig() {\n        return {\n            // To not break CSP demo\n            preventSubClassingModel : true,\n            basePresets : {\n                secondAndMinute : {\n                    name              : 'Seconds',\n                    tickWidth         : 30,   // Time column width\n                    tickHeight        : 40,\n                    displayDateFormat : 'll LTS', // Controls how dates will be displayed in tooltips etc\n                    shiftIncrement    : 10,     // Controls how much time to skip when calling shiftNext and shiftPrevious.\n                    shiftUnit         : 'minute', // Valid values are \"millisecond\", \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\".\n                    defaultSpan       : 24,    // By default, if no end date is supplied to a view it will show 24 hours\n                    timeResolution    : {      // Dates will be snapped to this resolution\n                        unit      : 'second',  // Valid values are \"millisecond\", \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\".\n                        increment : 5\n                    },\n                    // This defines your header rows.\n                    // For each row you can define \"unit\", \"increment\", \"dateFormat\", \"renderer\", \"align\", and \"thisObj\"\n                    headers : [\n                        {\n                            unit       : 'minute',\n                            dateFormat : 'lll'\n                        },\n                        {\n                            unit       : 'second',\n                            increment  : 10,\n                            dateFormat : 'ss'\n                        }\n                    ]\n                },\n                minuteAndHour : {\n                    name              : 'Minutes',\n                    tickWidth         : 60,    // Time column width\n                    tickHeight        : 60,\n                    displayDateFormat : 'll LT', // Controls how dates will be displayed in tooltips etc\n                    shiftIncrement    : 1,     // Controls how much time to skip when calling shiftNext and shiftPrevious.\n                    shiftUnit         : 'hour', // Valid values are \"MILLI\", \"SECOND\", \"minute\", \"HOUR\", \"DAY\", \"WEEK\", \"MONTH\", \"QUARTER\", \"YEAR\".\n                    defaultSpan       : 24,    // By default, if no end date is supplied to a view it will show 24 hours\n                    timeResolution    : {      // Dates will be snapped to this resolution\n                        unit      : 'minute',  // Valid values are \"MILLI\", \"SECOND\", \"minute\", \"HOUR\", \"DAY\", \"WEEK\", \"MONTH\", \"QUARTER\", \"YEAR\".\n                        increment : 15\n                    },\n                    headers : [\n                        {\n                            unit       : 'hour',\n                            dateFormat : 'ddd MM/DD, hA'\n                        },\n                        {\n                            unit       : 'minute',\n                            increment  : 30,\n                            dateFormat : 'mm'\n                        }\n                    ]\n                },\n                hourAndDay : {\n                    name              : 'Day',\n                    tickWidth         : 70,\n                    tickHeight        : 40,\n                    displayDateFormat : 'll LT',\n                    shiftIncrement    : 1,\n                    shiftUnit         : 'day',\n                    defaultSpan       : 24,\n                    timeResolution    : {\n                        unit      : 'minute',\n                        increment : 30\n                    },\n                    headers : [\n                        {\n                            unit       : 'day',\n                            dateFormat : 'ddd DD/MM' //Mon 01/10\n                        },\n                        {\n                            unit       : 'hour',\n                            dateFormat : 'LT'\n                        }\n                    ]\n                },\n                day : {\n                    name              : 'Day/hours',\n                    displayDateFormat : 'LT',\n                    shiftIncrement    : 1,\n                    shiftUnit         : 'day',\n                    defaultSpan       : 1,\n                    timeResolution    : {\n                        unit      : 'minute',\n                        increment : 30\n                    },\n                    mainHeaderLevel : 0,\n                    headers         : [\n                        {\n                            unit       : 'day',\n                            dateFormat : 'ddd DD/MM', // Mon 01/02\n                            splitUnit  : 'day'\n                        },\n                        {\n                            unit : 'hour',\n                            renderer(value) {\n                                return `\n                                    <div class=\"b-sch-calendarcolumn-ct\"><span class=\"b-sch-calendarcolumn-hours\">${DateHelper.format(value, 'HH')}</span>\n                                    <span class=\"b-sch-calendarcolumn-minutes\">${DateHelper.format(value, 'mm')}</span></div>\n                                `;\n                            }\n                        }\n                    ]\n                },\n                week : {\n                    name              : 'Week/hours',\n                    displayDateFormat : 'LT',\n                    shiftIncrement    : 1,\n                    shiftUnit         : 'week',\n                    defaultSpan       : 24,\n                    timeResolution    : {\n                        unit      : 'minute',\n                        increment : 30\n                    },\n                    mainHeaderLevel : 0,\n                    headers         : [\n                        {\n                            unit       : 'week',\n                            dateFormat : 'D d',\n                            splitUnit  : 'day'\n                        },\n                        {\n                            unit       : 'hour',\n                            dateFormat : 'LT',    // will be overridden by renderer\n                            renderer(value) {\n                                return `\n                                    <div class=\"sch-calendarcolumn-ct\">\n                                    <span class=\"sch-calendarcolumn-hours\">${DateHelper.format(value, 'HH')}</span>\n                                    <span class=\"sch-calendarcolumn-minutes\">${DateHelper.format(value, 'mm')}</span>\n                                    </div>\n                                `;\n                            }\n                        }\n                    ]\n                },\n                dayAndWeek : {\n                    name              : 'Days & Weeks',\n                    tickWidth         : 100,\n                    tickHeight        : 80,\n                    displayDateFormat : 'll LT',\n                    shiftUnit         : 'day',\n                    shiftIncrement    : 1,\n                    defaultSpan       : 5,\n                    timeResolution    : {\n                        unit      : 'hour',\n                        increment : 1\n                    },\n                    headers : [\n                        {\n                            unit : 'week',\n                            renderer(start) {\n                                return DateHelper.getShortNameOfUnit('week') + '.' + DateHelper.format(start, 'WW MMM YYYY');\n                            }\n                        },\n                        {\n                            unit       : 'day',\n                            dateFormat : 'dd DD'\n                        }\n                    ]\n                },\n                // dayAndMonth : {\n                //     name              : 'Days & Months',\n                //     tickWidth         : 100,\n                //     tickHeight        : 80,\n                //     displayDateFormat : 'll LT',\n                //     shiftUnit         : 'day',\n                //     shiftIncrement    : 1,\n                //     defaultSpan       : 5,\n                //     timeResolution    : {\n                //         unit      : 'hour',\n                //         increment : 1\n                //     },\n                //     headers : [\n                //         {\n                //             unit       : 'month',\n                //             dateFormat : 'MMMM YYYY',\n                //             align      : 'start'\n                //         },\n                //         {\n                //             unit       : 'day',\n                //             dateFormat : 'dd DD'\n                //         }\n                //     ]\n                // },\n                dayAndMonth : {\n                    name              : 'Month',\n                    tickWidth         : 100,\n                    tickHeight        : 80,\n                    displayDateFormat : 'll LT',\n                    shiftUnit         : 'month',\n                    shiftIncrement    : 1,\n                    defaultSpan       : 1,\n                    mainUnit          : 'month',\n                    timeResolution    : {\n                        unit      : 'hour',\n                        increment : 1\n                    },\n                    headers : [\n                        {\n                            unit       : 'month',\n                            dateFormat : 'MMMM YYYY'\n                        },\n                        {\n                            unit       : 'day',\n                            dateFormat : 'DD'\n                        }\n                    ]\n                },\n                weekAndDay : {\n                    name              : 'Week',\n                    tickWidth         : 100,\n                    tickHeight        : 80,\n                    displayDateFormat : 'll hh:mm A',\n                    shiftUnit         : 'week',\n                    shiftIncrement    : 1,\n                    defaultSpan       : 1,\n                    timeResolution    : {\n                        unit      : 'day',\n                        increment : 1\n                    },\n                    mainHeaderLevel : 0,\n                    headers         : [\n                        {\n                            unit       : 'week',\n                            dateFormat : 'YYYY MMMM DD' // 2017 January 01\n                        },\n                        {\n                            unit       : 'day',\n                            increment  : 1,\n                            dateFormat : 'DD MMM'\n                        }\n                    ]\n                },\n                weekAndMonth : {\n                    name              : 'Weeks',\n                    tickWidth         : 100,\n                    tickHeight        : 105,\n                    displayDateFormat : 'll',\n                    shiftUnit         : 'week',\n                    shiftIncrement    : 5,\n                    defaultSpan       : 6,\n                    timeResolution    : {\n                        unit      : 'day',\n                        increment : 1\n                    },\n                    headers : [\n                        {\n                            unit       : 'month',\n                            dateFormat : 'MMM YYYY' //Jan 2017\n                        },\n                        {\n                            unit       : 'week',\n                            dateFormat : 'DD MMM'\n                        }\n                    ]\n                },\n                weekAndDayLetter : {\n                    name              : 'Weeks/weekdays',\n                    tickWidth         : 20,\n                    tickHeight        : 50,\n                    displayDateFormat : 'll',\n                    shiftUnit         : 'week',\n                    shiftIncrement    : 1,\n                    defaultSpan       : 10,\n                    timeResolution    : {\n                        unit      : 'day',\n                        increment : 1\n                    },\n                    mainHeaderLevel : 0,\n                    headers         : [\n                        {\n                            unit                : 'week',\n                            dateFormat          : 'ddd DD MMM YYYY',\n                            verticalColumnWidth : 115\n                        },\n                        {\n                            unit                : 'day',\n                            dateFormat          : 'd1',\n                            verticalColumnWidth : 25\n                        }\n                    ]\n                },\n                weekDateAndMonth : {\n                    name              : 'Months/weeks',\n                    tickWidth         : 30,\n                    tickHeight        : 40,\n                    displayDateFormat : 'll',\n                    shiftUnit         : 'week',\n                    shiftIncrement    : 1,\n                    defaultSpan       : 10,\n                    timeResolution    : {\n                        unit      : 'day',\n                        increment : 1\n                    },\n                    headers : [\n                        {\n                            unit       : 'month',\n                            dateFormat : 'YYYY MMMM'\n                        },\n                        {\n                            unit       : 'week',\n                            dateFormat : 'DD'\n                        }\n                    ]\n                },\n                monthAndYear : {\n                    name              : 'Months',\n                    tickWidth         : 110,\n                    tickHeight        : 110,\n                    displayDateFormat : 'll',\n                    shiftIncrement    : 3,\n                    shiftUnit         : 'month',\n                    defaultSpan       : 12,\n                    timeResolution    : {\n                        unit      : 'day',\n                        increment : 1\n                    },\n                    headers : [\n                        {\n                            unit       : 'year',\n                            dateFormat : 'YYYY' //2017\n                        },\n                        {\n                            unit       : 'month',\n                            dateFormat : 'MMM YYYY' //Jan 2017\n                        }\n                    ]\n                },\n                year : {\n                    name                : 'Years',\n                    tickWidth           : 100,\n                    tickHeight          : 100,\n                    resourceColumnWidth : 100,\n                    displayDateFormat   : 'll',\n                    shiftUnit           : 'year',\n                    shiftIncrement      : 1,\n                    defaultSpan         : 1,\n                    mainHeaderLevel     : 0,\n                    timeResolution      : {\n                        unit      : 'month',\n                        increment : 1\n                    },\n                    headers : [\n                        {\n                            unit       : 'year',\n                            dateFormat : 'YYYY'\n                        },\n                        {\n                            unit : 'quarter',\n                            renderer(start, end, cfg) {\n                                return DateHelper.getShortNameOfUnit('quarter').toUpperCase() + (Math.floor(start.getMonth() / 3) + 1);\n                            }\n                        }\n                    ]\n                },\n                manyYears : {\n                    name              : 'Multiple years',\n                    tickWidth         : 40,\n                    tickHeight        : 50,\n                    displayDateFormat : 'll',\n                    shiftUnit         : 'year',\n                    shiftIncrement    : 1,\n                    defaultSpan       : 10,\n                    timeResolution    : {\n                        unit      : 'year',\n                        increment : 1\n                    },\n                    mainHeaderLevel : 0,\n                    headers         : [\n                        {\n                            unit      : 'year',\n                            increment : 5,\n                            renderer  : (start, end) => start.getFullYear() + ' - ' + end.getFullYear()\n                        },\n                        {\n                            unit       : 'year',\n                            dateFormat : 'YY',\n                            increment  : 1\n                        }\n                    ]\n                }\n            },\n            // This is a list of bryntum-supplied preset adjustments used to create the Scheduler's\n            // default initial set of ViewPresets.\n            defaultPresets : [\n                // Years over years\n                'manyYears',\n                { width : 80, increment : 1, resolution : 1, base : 'manyYears', resolutionUnit : 'YEAR' },\n                // Years over quarters\n                'year',\n                { width : 30,  increment : 1, resolution : 1, base : 'year', resolutionUnit : 'MONTH' },\n                { width : 50,  increment : 1, resolution : 1, base : 'year', resolutionUnit : 'MONTH' },\n                { width : 200, increment : 1, resolution : 1, base : 'year', resolutionUnit : 'MONTH' },\n                // Years over months\n                'monthAndYear',\n                // Months over weeks\n                'weekDateAndMonth',\n                // Months over weeks\n                'weekAndMonth',\n                // Months over weeks\n                'weekAndDayLetter',\n                // Months over days\n                'dayAndMonth',\n                // Weeks over days\n                'weekAndDay',\n                { width : 54, increment : 1, resolution : 1, base : 'weekAndDay', resolutionUnit : 'HOUR' },\n                // Days over hours\n                'hourAndDay',\n                { width : 64,  increment : 6, resolution : 30, base : 'hourAndDay', resolutionUnit : 'MINUTE' },\n                { width : 100, increment : 6, resolution : 30, base : 'hourAndDay', resolutionUnit : 'MINUTE' },\n                { width : 64,  increment : 2, resolution : 30, base : 'hourAndDay', resolutionUnit : 'MINUTE' },\n                // Hours over minutes\n                'minuteAndHour',\n                { width : 60,  increment : 15, resolution : 5, base : 'minuteAndHour' },\n                { width : 130, increment : 15, resolution : 5, base : 'minuteAndHour' },\n                { width : 60,  increment : 5,  resolution : 5, base : 'minuteAndHour' },\n                { width : 100, increment : 5,  resolution : 5, base : 'minuteAndHour' },\n                // Minutes over seconds\n                'secondAndMinute',\n                { width : 60,  increment : 10, resolution : 5, base : 'secondAndMinute' },\n                { width : 130, increment : 5,  resolution : 5, base : 'secondAndMinute' }\n            ],\n            internalListeners : {\n                locale : 'updateLocalization'\n            }\n        };\n    }\n    set basePresets(basePresets) {\n        const presetCache = this._basePresets = {};\n        for (const id in basePresets) {\n            basePresets[id].id = id;\n            presetCache[id] = this.createRecord(basePresets[id]);\n        }\n    }\n    get basePresets() {\n        return this._basePresets;\n    }\n    set defaultPresets(defaultPresets) {\n        for (let i = 0, { length } = defaultPresets; i < length; i++) {\n            const\n                presetAdjustment   = defaultPresets[i],\n                isBase             = typeof presetAdjustment === 'string',\n                baseType           = isBase ? presetAdjustment : presetAdjustment.base;\n            let preset;\n            // The default was just a string, so it's an unmodified instance of a base type.\n            if (isBase) {\n                preset = this.basePresets[baseType];\n            }\n            // If it's an object, it's an adjustment to a base type\n            else {\n                const\n                    config             = Object.setPrototypeOf(ObjectHelper.clone(this.basePresets[baseType].data), { id : baseType }),\n                    { timeResolution } = config,\n                    bottomHeader       = config.headers[config.headers.length - 1];\n                config.id = undefined;\n                if ('width' in presetAdjustment) {\n                    config.tickWidth = presetAdjustment.width;\n                }\n                if ('height' in presetAdjustment) {\n                    config.tickHeight = presetAdjustment.height;\n                }\n                if ('increment' in presetAdjustment) {\n                    bottomHeader.increment = presetAdjustment.increment;\n                }\n                if ('resolution' in presetAdjustment) {\n                    timeResolution.increment = presetAdjustment.resolution;\n                }\n                if ('resolutionUnit' in presetAdjustment) {\n                    timeResolution.unit = DateHelper.getUnitByName(presetAdjustment.resolutionUnit);\n                }\n                preset = this.createRecord(config);\n                // Keep id of original preset around, used with localization in PresetStore\n                preset.baseId = baseType;\n            }\n            this.add(preset);\n        }\n    }\n    getById(id) {\n        // Look first in the default set, and if it's one of the base types that is not imported into the\n        // default set, then look at the bases.\n        return super.getById(id) || this.basePresets[id];\n    }\n    /**\n     * Registers a new view preset base to be used by any scheduler grid or tree on the page.\n     * @param {String} id The unique identifier for this preset\n     * @param {ViewPresetConfig} config The configuration properties of the view preset (see\n     * {@link Scheduler.preset.ViewPreset} for more information)\n     * @returns {Scheduler.preset.ViewPreset} A new ViewPreset based upon the passed configuration.\n     */\n    registerPreset(id, config) {\n        const\n            preset = this.createRecord(Object.assign({\n                id\n            }, config)),\n            existingDuplicate = this.find(p => p.equals(preset));\n        if (existingDuplicate) {\n            return existingDuplicate;\n        }\n        if (preset.isValid) {\n            this.add(preset);\n        }\n        else {\n            throw new Error('Invalid preset, please check your configuration');\n        }\n        return preset;\n    }\n    getPreset(preset) {\n        if (typeof preset === 'number') {\n            preset = this.getAt(preset);\n        }\n        if (typeof preset === 'string') {\n            preset = this.getById(preset);\n        }\n        else if (!(preset instanceof ViewPreset)) {\n            preset = this.createRecord(preset);\n        }\n        return preset;\n    }\n    /**\n     * Applies preset customizations or fetches a preset view preset using its name.\n     * @param {String|ViewPresetConfig} presetOrId Id of a predefined preset or a preset config object\n     * @returns {Scheduler.preset.ViewPreset} Resulting ViewPreset instance\n     */\n    normalizePreset(preset) {\n        const me = this;\n        if (!(preset instanceof ViewPreset)) {\n            if (typeof preset === 'string') {\n                preset = me.getPreset(preset);\n                if (!preset) {\n                    throw new Error('You must define a valid view preset. See PresetManager for reference');\n                }\n            }\n            else if (typeof preset === 'object') {\n                // Look up any existing ViewPreset that it is based upon.\n                if (preset.base) {\n                    const base = this.getById(preset.base);\n                    if (!base) {\n                        throw new Error(`ViewPreset base '${preset.base}' does not exist`);\n                    }\n                    // The config is based upon the base's data with the new config object merged in.\n                    preset = ObjectHelper.merge(ObjectHelper.clone(base.data), preset);\n                }\n                // Ensure the new ViewPreset has a legible, logical id which does not already\n                // exist in our store.\n                if (preset.id) {\n                    preset = me.createRecord(preset);\n                }\n                else {\n                    preset = me.createRecord(ObjectHelper.assign({}, preset));\n                    preset.id = preset.generateId(preset);\n                }\n            }\n        }\n        return preset;\n    }\n    /**\n     * Deletes a view preset\n     * @param {String} id The id of the preset, or the preset instance.\n     */\n    deletePreset(presetOrId) {\n        if (typeof presetOrId === 'string') {\n            presetOrId = this.getById(presetOrId);\n        }\n        else if (typeof presetOrId === 'number') {\n            presetOrId = this.getAt(presetOrId);\n        }\n        if (presetOrId) {\n            this.remove(presetOrId);\n            // ALso remove it from our base list\n            delete this.basePresets[presetOrId.id];\n        }\n    }\n}\nconst pm = new PresetManager();\nglobalThis.bryntum.PresetManager = pm;\nexport { pm as default };\n", "import Store from '../../Core/data/Store.js';\nimport DH from '../../Core/helper/DateHelper.js';\nimport TimeSpan from '../model/TimeSpan.js';\nimport PresetManager from '../preset/PresetManager.js';\n/**\n * @module Scheduler/data/TimeAxis\n */\n// Micro-optimized version of TimeSpan for faster reading. Hit a lot and since it is internal fields are guaranteed to\n// not be remapped and changes won't be batches, so we can always return raw value from data avoiding all additional\n// checks and logic\nclass Tick extends TimeSpan {\n    // Only getters on purpose, we do not support manipulating ticks\n    get startDate() {\n        return this.data.startDate;\n    }\n    get endDate() {\n        return this.data.endDate;\n    }\n}\n/**\n * A class representing the time axis of the scheduler. The scheduler timescale is based on the ticks generated by this\n * class. This is a pure \"data\" (model) representation of the time axis and has no UI elements.\n *\n * The time axis can be {@link #config-continuous} or not. In continuous mode, each timespan starts where the previous\n * ended, and in non-continuous mode there can be gaps between the ticks.\n * A non-continuous time axis can be used when want to filter out certain periods of time (like weekends) from the time\n * axis.\n *\n * To create a non-continuous time axis you have 2 options. First, you can create a time axis containing only the time\n * spans of interest. To do that, subclass this class and override the {@link #property-generateTicks} method.\n *\n * The other alternative is to call the {@link #function-filterBy} method, passing a function to it which should return\n * `false` if the time tick should be filtered out. Calling {@link Core.data.mixin.StoreFilter#function-clearFilters}\n * will return you to a full time axis.\n *\n * @extends Core/data/Store\n */\nexport default class TimeAxis extends Store {\n    //region Events\n    /**\n     * Fires before the timeaxis is about to be reconfigured (e.g. new start/end date or unit/increment). Return `false`\n     * to abort the operation.\n     * @event beforeReconfigure\n     * @param {Scheduler.data.TimeAxis} source The time axis instance\n     * @param {Date} startDate The new time axis start date\n     * @param {Date} endDate The new time axis end date\n     */\n    /**\n     * Event that is triggered when we end reconfiguring and everything UI-related should be done\n     * @event endReconfigure\n     * @private\n     */\n    /**\n     * Fires when the timeaxis has been reconfigured (e.g. new start/end date or unit/increment)\n     * @event reconfigure\n     * @param {Scheduler.data.TimeAxis} source The time axis instance\n     */\n    /**\n     * Fires if all the ticks in the timeaxis are filtered out. After firing the filter is temporarily disabled to\n     * return the time axis to a valid state. A disabled filter will be re-enabled the next time ticks are regenerated\n     * @event invalidFilter\n     * @param {Scheduler.data.TimeAxis} source The time axis instance\n     */\n    //endregion\n    //region Default config\n    static get defaultConfig() {\n        return {\n            modelClass : Tick,\n            /**\n             * Set to false if the timeline is not continuous, e.g. the next timespan does not start where the previous ended (for example skipping weekends etc).\n             * @config {Boolean}\n             * @default\n             */\n            continuous : true,\n            originalContinuous : null,\n            /**\n             * Include only certain hours or days in the time axis (makes it `continuous : false`). Accepts and object\n             * with `day` and `hour` properties:\n             * ```\n             * const scheduler = new Scheduler({\n             *     timeAxis : {\n             *         include : {\n             *              // Do not display hours after 17 or before 9 (only display 9 - 17). The `to\u00B4 value is not\n             *              // included in the time axis\n             *              hour : {\n             *                  from : 9,\n             *                  to   : 17\n             *              },\n             *              // Do not display sunday or saturday\n             *              day : [0, 6]\n             *         }\n             *     }\n             * }\n             * ```\n             * In most cases we recommend that you use Scheduler's workingTime config instead. It is easier to use and\n             * makes sure all parts of the Scheduler gets updated.\n             * @config {Object}\n             */\n            include : null,\n            /**\n             * Automatically adjust the timespan when generating ticks with {@link #property-generateTicks} according to\n             * the `viewPreset` configuration. Setting this to false may lead to shifting time/date of ticks.\n             * @config {Boolean}\n             * @default\n             */\n            autoAdjust : true,\n            //isConfigured : false,\n            // in case of `autoAdjust : false`, the 1st and last ticks can be truncated, containing only part of the normal tick\n            // these dates will contain adjusted start/end (like if the tick has not been truncated)\n            adjustedStart    : null,\n            adjustedEnd      : null,\n            // the visible position in the first tick, can actually be > 1 because the adjustment is done by the `mainUnit`\n            visibleTickStart : null,\n            // the visible position in the first tick, is always ticks count - 1 < value <= ticks count, in case of autoAdjust, always = ticks count\n            visibleTickEnd   : null,\n            tickCache : {},\n            viewPreset       : null,\n            maxTraverseTries : 100,\n            useRawData       : {\n                disableDuplicateIdCheck : true,\n                disableDefaultValue     : true,\n                disableTypeConversion   : true\n            }\n        };\n    }\n    static get configurable() {\n        return {\n            /**\n             * Method generating the ticks for this time axis. Should return a **non-empty** array of ticks. Each tick\n             * is an object of the following structure:\n             * ```\n             * {\n             *    startDate : ..., // start date\n             *    endDate   : ...  // end date\n             * }\n             * ```\n             * To see it in action please check out our [TimeAxis](https://bryntum.com/products/scheduler/examples/timeaxis/)\n             * example and navigate to \"Compressed non-working time\" tab.\n             *\n             * @param {Date} axisStartDate The start date of the interval\n             * @param {Date} axisEndDate The end date of the interval\n             * @param {String} unit The unit of the time axis\n             * @param {Number} increment The increment for the unit specified.\n             * @returns {TimeSpanConfig[]} ticks The ticks representing the time axis\n             * @config {Function}\n             */\n            generateTicks : null,\n            unit                : null,\n            increment           : null,\n            resolutionUnit      : null,\n            resolutionIncrement : null,\n            mainUnit            : null,\n            shiftUnit           : null,\n            shiftIncrement      : 1,\n            defaultSpan         : 1,\n            weekStartDay : null,\n            // Used to force resolution to match whole ticks, to snap accordingly when using fillTicks in the UI\n            forceFullTicks : null\n        };\n    }\n    //endregion\n    //region Init\n    // private\n    construct(config) {\n        const me = this;\n        super.construct(config);\n        me.originalContinuous = me.continuous;\n        me.ion({\n            change : ({ action }) => {\n                // If the change was due to filtering, there will be a refresh event\n                // arriving next, so do not reconfigure\n                if (action !== 'filter') {\n                    me.trigger('reconfigure', { supressRefresh : false });\n                }\n            },\n            refresh        : () => me.trigger('reconfigure', { supressRefresh : false }),\n            endreconfigure : event => me.trigger('reconfigure', event)\n        });\n        if (me.startDate) {\n            me.internalOnReconfigure();\n            me.trigger('reconfigure');\n        }\n        else if (me.viewPreset) {\n            const range  = me.getAdjustedDates(new Date());\n            me.startDate = range.startDate;\n            me.endDate   = range.endDate;\n        }\n    }\n    get isTimeAxis() {\n        return true;\n    }\n    //endregion\n    //region Configuration (reconfigure & consumePreset)\n    /**\n     * Reconfigures the time axis based on the config object supplied and generates the new 'ticks'.\n     * @param {Object} config\n     * @param {Boolean} [suppressRefresh]\n     * @private\n     */\n    reconfigure(config, suppressRefresh = false, preventThrow = false) {\n        const\n            me         = this,\n            normalized = me.getAdjustedDates(config.startDate, config.endDate),\n            oldConfig  = {};\n        if (me.trigger('beforeReconfigure', { startDate : normalized.startDate, endDate : normalized.endDate, config }) !== false) {\n            me.trigger('beginReconfigure');\n            me._configuredStartDate = config.startDate;\n            me._configuredEndDate   = config.endDate;\n            // Collect old values for end event\n            for (const propName in config) {\n                oldConfig[propName] = me[propName];\n            }\n            const viewPresetChanged = config.viewPreset && config.viewPreset !== me.viewPreset;\n            // If changing viewPreset, try to gracefully recover if an applied filter results in an empty view\n            if (viewPresetChanged) {\n                preventThrow = me.isFiltered;\n                me.filters.forEach(f => f.disabled = false);\n            }\n            Object.assign(me, config);\n            if (me.internalOnReconfigure(preventThrow, viewPresetChanged) === false) {\n                return false;\n            }\n            me.trigger('endReconfigure', { suppressRefresh, config, oldConfig });\n        }\n    }\n    internalOnReconfigure(preventThrow = false, viewPresetChanged) {\n        const me = this;\n        me.isConfigured = true;\n        const\n            adjusted   = me.getAdjustedDates(me.startDate, me.endDate, true),\n            normalized = me.getAdjustedDates(me.startDate, me.endDate),\n            start      = normalized.startDate,\n            end        = normalized.endDate;\n        if (start >= end) {\n            throw new Error(`Invalid start/end dates. Start date must be less than end date. Start date: ${start}. End date: ${end}.`);\n        }\n        const\n            { unit, increment = 1 } = me,\n            ticks                   = me.generateTicks(start, end, unit, increment) ||\n                                      // Offer a fallback in case user did not generate any ticks at all.\n                                      me.constructor.prototype.generateTicks.call(me, start, end, unit, increment);\n        // Suspending to be able to detect an invalid filter\n        me.suspendEvents();\n        me.maintainFilter = preventThrow;\n        me.data           = ticks;\n        me.maintainFilter = false;\n        const { count } = me;\n        if (count === 0) {\n            if (preventThrow) {\n                if (viewPresetChanged) {\n                    me.disableFilters();\n                }\n                me.resumeEvents();\n                return false;\n            }\n            throw new Error('Invalid time axis configuration or filter, please check your input data.');\n        }\n        // start date is cached, update it to fill after generated ticks\n        me.startDate = me.first.startDate;\n        me.endDate   = me.last.endDate;\n        me.resumeEvents();\n        if (me.isContinuous) {\n            me.adjustedStart = adjusted.startDate;\n            me.adjustedEnd   = DH.getNext(count > 1 ? ticks[count - 1].startDate : adjusted.startDate, unit, increment, me.weekStartDay);\n        }\n        else {\n            me.adjustedStart = me.startDate;\n            me.adjustedEnd   = me.endDate;\n        }\n        me.updateVisibleTickBoundaries();\n        me.updateTickCache(true);\n    }\n    updateVisibleTickBoundaries() {\n        const\n            me = this,\n            {\n                count,\n                unit,\n                startDate,\n                endDate,\n                weekStartDay,\n                increment = 1\n            }  = me;\n        // Denominator is amount of milliseconds in a full tick (unit * increment). Normally we use 30 days in a month\n        // and 365 days in a year. But if month is 31 day long or year is a leap one standard formula might calculate\n        // wrong value. e.g. if we're rendering 1 day from August, formula goes like (2021-08-31 - 2021-08-02) / 30 = 1\n        // and renders full tick which is incorrect. For such cases we need to adjust denominator to a correct one.\n        // Thankfully there are only a few of them - month, year and day with DST transition.\n        const\n            startDenominator = DH.getNormalizedUnitDuration(startDate, unit) * increment,\n            endDenominator   = DH.getNormalizedUnitDuration(endDate, unit) * increment;\n        // if visibleTickStart > 1 this means some tick is fully outside of the view - we are not interested in it and want to\n        // drop it and adjust \"adjustedStart\" accordingly\n        do {\n            me.visibleTickStart = (startDate - me.adjustedStart) / startDenominator;\n            if (me.autoAdjust) me.visibleTickStart = Math.floor(me.visibleTickStart);\n            if (me.visibleTickStart >= 1) me.adjustedStart = DH.getNext(me.adjustedStart, unit, increment, weekStartDay);\n        } while (me.visibleTickStart >= 1);\n        do {\n            me.visibleTickEnd = count - (me.adjustedEnd - endDate) / endDenominator;\n            if (count - me.visibleTickEnd >= 1) me.adjustedEnd = DH.getNext(me.adjustedEnd, unit, -1, weekStartDay);\n        } while (count - me.visibleTickEnd >= 1);\n        // This flag indicates that the time axis starts exactly on a tick boundary and finishes on a tick boundary\n        // This is used as an optimization flag by TimeAxisViewModel.createHeaderRow\n        me.fullTicks = !me.visibleTickStart && me.visibleTickEnd === count;\n    }\n    /**\n     * Get the currently used time unit for the ticks\n     * @readonly\n     * @member {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} unit\n     */\n    /**\n     * Get/set currently used preset\n     * @property {Scheduler.preset.ViewPreset}\n     */\n    get viewPreset() {\n        return this._viewPreset;\n    }\n    set viewPreset(preset) {\n        const me = this;\n        preset = PresetManager.getPreset(preset);\n        if (!preset.isViewPreset) {\n            throw new Error('TimeAxis must be configured with the ViewPreset instance that the Scheduler is using');\n        }\n        me._viewPreset = preset;\n        Object.assign(me, {\n            unit      : preset.bottomHeader.unit,\n            increment : preset.bottomHeader.increment || 1,\n            resolutionUnit      : preset.timeResolution.unit,\n            resolutionIncrement : preset.timeResolution.increment,\n            mainUnit       : preset.mainHeader.unit,\n            shiftUnit      : preset.shiftUnit || preset.mainHeader.unit,\n            shiftIncrement : preset.shiftIncrement || 1,\n            defaultSpan : preset.defaultSpan || 1,\n            presetName  : preset.id,\n            // Weekview columns are updated upon 'datachanged' event on this object.\n            // We have to pass headers in order to render them correctly (timeAxisViewModel is incorrect in required time)\n            headers : preset.headers\n        });\n    }\n    //endregion\n    //region Getters & setters\n    get weekStartDay() {\n        return this._weekStartDay ?? DH.weekStartDay;\n    }\n    // private\n    get resolution() {\n        return {\n            unit      : this.resolutionUnit,\n            increment : this.resolutionIncrement\n        };\n    }\n    // private\n    set resolution(resolution) {\n        this.resolutionUnit      = resolution.unit;\n        this.resolutionIncrement = resolution.increment;\n    }\n    get resolutionUnit() {\n        return this.forceFullTicks ? this.unit : this._resolutionUnit;\n    }\n    get resolutionIncrement() {\n        return this.forceFullTicks ? this.increment : this._resolutionIncrement;\n    }\n    //endregion\n    //region Timespan & resolution\n    /**\n     * Changes the time axis timespan to the supplied start and end dates.\n     *\n     * **Note** This does **not** preserve the temporal scroll position. You may use\n     * {@link Scheduler.view.Scheduler#function-setTimeSpan} to set the time axis and\n     * maintain temporal scroll position (if possible).\n     * @param {Date} newStartDate The new start date\n     * @param {Date} [newEndDate] The new end date\n     */\n    setTimeSpan(newStartDate, newEndDate, preventThrow = false) {\n        // If providing a 0 span range, add default range\n        if (newEndDate && newStartDate - newEndDate === 0) {\n            newEndDate = null;\n        }\n        const\n            me                     = this,\n            { startDate, endDate } = me.getAdjustedDates(newStartDate, newEndDate);\n        if (me.startDate - startDate !== 0 || me.endDate - endDate !== 0) {\n            return me.reconfigure({\n                startDate,\n                endDate\n            }, false, preventThrow);\n        }\n    }\n    /**\n     * Moves the time axis by the passed amount and unit.\n     *\n     * NOTE: When using a filtered TimeAxis the result of `shift()` cannot be guaranteed, it might shift into a\n     * filtered out span. It tries to be smart about it by shifting from unfiltered start and end dates.\n     * If that solution does not work for your filtering setup, please call {@link #function-setTimeSpan} directly\n     * instead.\n     *\n     * @param {Number} amount The number of units to jump\n     * @param {String} [unit] The unit (Day, Week etc)\n     */\n    shift(amount, unit = this.shiftUnit) {\n        const me = this;\n        let { startDate, endDate } = me;\n        // Use unfiltered start and end dates when shifting a filtered time axis, to lessen risk of messing it up.\n        // Still not guaranteed to work though\n        if (me.isFiltered) {\n            startDate = me.allRecords[0].startDate;\n            endDate   = me.allRecords[me.allCount - 1].endDate;\n        }\n        // Hack for filtered time axis, for example if weekend is filtered out and you shiftPrev() day from monday\n        let tries = 0;\n        do {\n            startDate = DH.add(startDate, amount, unit);\n            endDate   = DH.add(endDate, amount, unit);\n        } while (tries++ < me.maxTraverseTries && me.setTimeSpan(startDate, endDate, {\n            preventThrow : true\n        }) === false);\n    }\n    /**\n     * Moves the time axis forward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement`\n     * config of the current view preset.\n     *\n     * NOTE: When using a filtered TimeAxis the result of `shiftNext()` cannot be guaranteed, it might shift into a\n     * filtered out span. It tries to be smart about it by shifting from unfiltered start and end dates.\n     * If that solution does not work for your filtering setup, please call {@link #function-setTimeSpan} directly\n     * instead.\n     *\n     * @param {Number} [amount] The number of units to jump forward\n     */\n    shiftNext(amount = this.shiftIncrement) {\n        this.shift(amount);\n    }\n    /**\n     * Moves the time axis backward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement` config of the current view preset.\n     *\n     * NOTE: When using a filtered TimeAxis the result of `shiftPrev()` cannot be guaranteed, it might shift into a\n     * filtered out span. It tries to be smart about it by shifting from unfiltered start and end dates.\n     * If that solution does not work for your filtering setup, please call {@link #function-setTimeSpan} directly\n     * instead.\n     *\n     * @param {Number} [amount] The number of units to jump backward\n     */\n    shiftPrevious(amount = this.shiftIncrement) {\n        this.shift(-amount);\n    }\n    //endregion\n    //region Filter & continuous\n    /**\n     * Filter the time axis by a function (and clears any existing filters first). The passed function will be called with each tick in time axis.\n     * If the function returns `true`, the 'tick' is included otherwise it is filtered. If all ticks are filtered out\n     * the time axis is considered invalid, triggering `invalidFilter` and then removing the filter.\n     * @param {Function} fn The function to be called, it will receive an object with `startDate`/`endDate` properties, and `index` of the tick.\n     * @param {Object} [thisObj] `this` reference for the function\n     * @typings {Promise<any|null>}\n     */\n    filterBy(fn, thisObj = this) {\n        const me = this;\n        me.filters.clear();\n        super.filterBy((tick, index) => fn.call(thisObj, tick.data, index));\n    }\n    filter() {\n        const\n            me     = this,\n            retVal = super.filter(...arguments);\n        if (!me.maintainFilter && me.count === 0) {\n            me.resumeEvents();\n            me.trigger('invalidFilter');\n            me.disableFilters();\n        }\n        return retVal;\n    }\n    disableFilters() {\n        this.filters.forEach(f => f.disabled = true);\n        this.filter();\n    }\n    triggerFilterEvent(event) {\n        const me = this;\n        if (!event.filters.count) {\n            me.continuous = me.originalContinuous;\n        }\n        else {\n            me.continuous = false;\n        }\n        // Filters has been applied (or cleared) but listeners are not informed yet, update tick cache to have start and\n        // end dates correct when later redrawing events & header\n        me.updateTickCache();\n        super.triggerFilterEvent(event);\n    }\n    /**\n     * Returns `true` if the time axis is continuous (will return `false` when filtered)\n     * @property {Boolean}\n     */\n    get isContinuous() {\n        return this.continuous !== false && !this.isFiltered;\n    }\n    //endregion\n    //region Dates\n    getAdjustedDates(startDate, endDate, forceAdjust = false) {\n        const me = this;\n        // If providing a 0 span range, add default range\n        if (endDate && startDate - endDate === 0) {\n            endDate = null;\n        }\n        startDate = startDate || me.startDate;\n        endDate   = endDate || DH.add(startDate, me.defaultSpan, me.mainUnit);\n        return me.autoAdjust || forceAdjust ? {\n            startDate : me.floorDate(startDate, false, me.autoAdjust ? me.mainUnit : me.unit, 1),\n            endDate   : me.ceilDate(endDate, false, me.autoAdjust ? me.mainUnit : me.unit, 1)\n        } : {\n            startDate,\n            endDate\n        };\n    }\n    /**\n     * Method to get the current start date of the time axis.\n     * @property {Date}\n     */\n    get startDate() {\n        return this._start || (this.first ? new Date(this.first.startDate) : null);\n    }\n    set startDate(start) {\n        this._start = DH.parse(start);\n    }\n    /**\n     * Method to get a the current end date of the time axis\n     * @property {Date}\n     */\n    get endDate() {\n        return this._end || (this.last ? new Date(this.last.endDate) : null);\n    }\n    set endDate(end) {\n        if (end) this._end = DH.parse(end);\n    }\n    // used in performance critical code for comparisons\n    get startMS() {\n        return this._startMS;\n    }\n    // used in performance critical code for comparisons\n    get endMS() {\n        return this._endMS;\n    }\n    // Floors a date and optionally snaps it to one of the following resolutions:\n    // 1. 'resolutionUnit'. If param 'resolutionUnit' is passed, the date will simply be floored to this unit.\n    // 2. If resolutionUnit is not passed: If date should be snapped relative to the timeaxis start date,\n    // the resolutionUnit of the timeAxis will be used, or the timeAxis 'mainUnit' will be used to snap the date\n    //\n    // returns a copy of the original date\n    // private\n    floorDate(date, relativeToStart, resolutionUnit, incr) {\n        relativeToStart = relativeToStart !== false;\n        const\n            me         = this,\n            relativeTo = relativeToStart ? DH.clone(me.startDate) : null,\n            increment  = incr || me.resolutionIncrement,\n            unit       = resolutionUnit || (relativeToStart ? me.resolutionUnit : me.mainUnit),\n            snap       = (value, increment) => Math.floor(value / increment) * increment;\n        if (relativeToStart) {\n            return DH.floor(date, { unit, magnitude : increment }, relativeTo);\n        }\n        const dt = DH.clone(date);\n        if (unit === 'week') {\n            const\n                day      = dt.getDay() || 7,\n                startDay = me.weekStartDay || 7;\n            DH.add(DH.startOf(dt, 'day', false), day >= startDay ? startDay - day : -(7 - startDay + day), 'day', false);\n            // Watch out for Brazil DST craziness (see test 028_timeaxis_dst.t.js)\n            if (dt.getDay() !== startDay && dt.getHours() === 23) {\n                DH.add(dt, 1, 'hour', false);\n            }\n        }\n        else {\n            // removes \"smaller\" units from date (for example minutes; removes seconds and milliseconds)\n            DH.startOf(dt, unit, false);\n            // day and year are 1-based so need to make additional adjustments\n            const\n                modifier     = ['day', 'year'].includes(unit) ? 1 : 0,\n                useUnit      = unit === 'day' ? 'date' : unit,\n                snappedValue = snap(DH.get(dt, useUnit) - modifier, increment) + modifier;\n            DH.set(dt, useUnit, snappedValue);\n        }\n        return dt;\n    }\n    /**\n     * Rounds the date to nearest unit increment\n     * @private\n     */\n    roundDate(date, relativeTo, resolutionUnit = this.resolutionUnit, increment = this.resolutionIncrement || 1) {\n        const\n            me = this,\n            dt = DH.clone(date);\n        relativeTo = DH.clone(relativeTo || me.startDate);\n        switch (resolutionUnit) {\n            case 'week': {\n                DH.startOf(dt, 'day', false);\n                let distanceToWeekStartDay = dt.getDay() - me.weekStartDay,\n                    toAdd;\n                if (distanceToWeekStartDay < 0) {\n                    distanceToWeekStartDay = 7 + distanceToWeekStartDay;\n                }\n                if (Math.round(distanceToWeekStartDay / 7) === 1) {\n                    toAdd = 7 - distanceToWeekStartDay;\n                }\n                else {\n                    toAdd = -distanceToWeekStartDay;\n                }\n                return DH.add(dt, toAdd, 'day', false);\n            }\n            case 'month': {\n                const\n                    nbrMonths     = DH.diff(relativeTo, dt, 'month') + DH.as('month', dt.getDay() / DH.daysInMonth(dt)), //*/DH.as('month', DH.diff(relativeTo, dt)) + (dt.getDay() / DH.daysInMonth(dt)),\n                    snappedMonths = Math.round(nbrMonths / increment) * increment;\n                return DH.add(relativeTo, snappedMonths, 'month', false);\n            }\n            case 'quarter':\n                DH.startOf(dt, 'month', false);\n                return DH.add(dt, 3 - (dt.getMonth() % 3), 'month', false);\n            default: {\n                const\n                    duration        = DH.as(resolutionUnit, DH.diff(relativeTo, dt)),\n                    // Need to find the difference of timezone offsets between relativeTo and original dates. 0 if timezone offsets are the same.\n                    offset          = resolutionUnit === 'year' ? 0 : DH.as(resolutionUnit, relativeTo.getTimezoneOffset() - dt.getTimezoneOffset(), 'minute'),\n                    // Need to add the offset to the whole duration, so the divided value will take DST into account\n                    snappedDuration = Math.round((duration + offset) / increment) * increment;\n                // Now when the round is done, we need to subtract the offset, so the result also will take DST into account\n                return DH.add(relativeTo, snappedDuration - offset, resolutionUnit, false);\n            }\n        }\n    }\n    // private\n    ceilDate(date, relativeToStart, resolutionUnit, increment) {\n        const me = this;\n        relativeToStart = relativeToStart !== false;\n        increment       = increment || (relativeToStart ? me.resolutionIncrement : 1);\n        const\n            unit = resolutionUnit || (relativeToStart ? me.resolutionUnit : me.mainUnit),\n            dt   = DH.clone(date);\n        let doCall = false;\n        switch (unit) {\n            case 'minute':\n                doCall = !DH.isStartOf(dt, 'minute');\n                break;\n            case 'hour':\n                doCall = !DH.isStartOf(dt, 'hour');\n                break;\n            case 'day':\n            case 'date':\n                doCall = !DH.isStartOf(dt, 'day');\n                break;\n            case 'week':\n                DH.startOf(dt, 'day', false);\n                doCall = (dt.getDay() !== me.weekStartDay || !DH.isEqual(dt, date));\n                break;\n            case 'month':\n                DH.startOf(dt, 'day', false);\n                doCall = (dt.getDate() !== 1 || !DH.isEqual(dt, date));\n                break;\n            case 'quarter':\n                DH.startOf(dt, 'day', false);\n                doCall = (dt.getMonth() % 3 !== 0 || dt.getDate() !== 1 || !DH.isEqual(dt, date));\n                break;\n            case 'year':\n                DH.startOf(dt, 'day', false);\n                doCall = (dt.getMonth() !== 0 || dt.getDate() !== 1 || !DH.isEqual(dt, date));\n                break;\n        }\n        if (doCall) {\n            return DH.getNext(dt, unit, increment, me.weekStartDay);\n        }\n        return dt;\n    }\n    //endregion\n    //region Ticks\n    get include() {\n        return this._include;\n    }\n    set include(include) {\n        const me = this;\n        me._include   = include;\n        me.continuous = !include;\n        if (!me.isConfiguring) {\n            me.startDate = me._configuredStartDate;\n            me.endDate   = me._configuredEndDate;\n            me.internalOnReconfigure();\n            me.trigger('includeChange');\n        }\n    }\n    // Check if a certain date is included based on timeAxis.include rules\n    processExclusion(startDate, endDate, unit) {\n        const { include } = this;\n        if (include) {\n            return Object.entries(include).some(([includeUnit, rule]) => {\n                if (!rule) {\n                    return false;\n                }\n                const { from, to } = rule;\n                // Including the closest smaller unit with a { from, to} rule should affect start & end of the\n                // generated tick. Currently only works for days or smaller.\n                if (DH.compareUnits('day', unit) >= 0 && DH.getLargerUnit(includeUnit) === unit) {\n                    if (from) {\n                        DH.set(startDate, includeUnit, from);\n                    }\n                    if (to) {\n                        let stepUnit = unit;\n                        // Stepping back base on date, not day\n                        if (unit === 'day') {\n                            stepUnit = 'date';\n                        }\n                        // Since endDate is not inclusive it points to the next day etc.\n                        // Turns for example 2019-01-10T00:00 -> 2019-01-09T18:00\n                        DH.set(endDate, {\n                            [stepUnit]    : DH.get(endDate, stepUnit) - 1,\n                            [includeUnit] : to\n                        });\n                    }\n                }\n                // \"Greater\" unit being included? Then we need to care about it\n                // (for example excluding day will also affect hour, minute etc)\n                if (DH.compareUnits(includeUnit, unit) >= 0) {\n                    const datePart = (includeUnit === 'day' ? startDate.getDay() : DH.get(startDate, includeUnit));\n                    if ((from && datePart < from) || (to && datePart >= to)) {\n                        return true;\n                    }\n                }\n            });\n        }\n        return false;\n    }\n    // Calculate constants used for exclusion when scaling within larger ticks\n    initExclusion() {\n        Object.entries(this.include).forEach(([unit, rule]) => {\n            if (rule) {\n                const { from, to } = rule;\n                // For example for hour:\n                // 1. Get the next bigger unit -> day, get ratio -> 24\n                // 2. to 20 - from 8 = 12 hours visible each day. lengthFactor 24 / 12 = 2 means that each hour used\n                // needs to represent 2 hours when drawn (to stretch)\n                // |    \u2588\u2588\u2588\u2588    | -> |  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  |\n                rule.lengthFactor = DH.getUnitToBaseUnitRatio(unit, DH.getLargerUnit(unit)) / (to - from);\n                rule.lengthFactorExcl = DH.getUnitToBaseUnitRatio(unit, DH.getLargerUnit(unit)) / (to - from - 1);\n                // Calculate weighted center to stretch around |   \u2588\u2588x\u2588 |\n                rule.center = from + from / (rule.lengthFactor - 1);\n            }\n        });\n    }\n    /**\n     * Method generating the ticks for this time axis. Should return an array of ticks . Each tick is an object of the following structure:\n     * ```\n     * {\n     *    startDate : ..., // start date\n     *    endDate   : ...  // end date\n     * }\n     * ```\n     * Take notice, that this function either has to be called with `start`/`end` parameters, or create those variables.\n     *\n     * To see it in action please check out our [TimeAxis](https://bryntum.com/products/scheduler/examples/timeaxis/) example and navigate to \"Compressed non-working time\" tab.\n     *\n     * @member {Function} generateTicks\n     * @param {Date} axisStartDate The start date of the interval\n     * @param {Date} axisEndDate The end date of the interval\n     * @param {String} unit The unit of the time axis\n     * @param {Number} increment The increment for the unit specified.\n     * @returns {Array|undefined} ticks The ticks representing the time axis, or no return value to use the default tick generation\n     */\n    updateGenerateTicks() {\n        if (!this.isConfiguring) {\n            this.reconfigure(this);\n        }\n    }\n    _generateTicks(axisStartDate, axisEndDate, unit = this.unit, increment = this.increment) {\n        const\n            me            = this,\n            ticks         = [],\n            usesExclusion = Boolean(me.include);\n        let intervalEnd,\n            tickEnd,\n            isExcluded,\n            dstDiff                = 0,\n            { startDate, endDate } = me.getAdjustedDates(axisStartDate, axisEndDate);\n        me.tickCache = {};\n        if (usesExclusion) {\n            me.initExclusion();\n        }\n        while (startDate < endDate) {\n            intervalEnd = DH.getNext(startDate, unit, increment, me.weekStartDay);\n            if (!me.autoAdjust && intervalEnd > endDate) {\n                intervalEnd = endDate;\n            }\n            // Handle hourly increments crossing DST boundaries to keep the timescale looking correct\n            // Only do this for HOUR resolution currently, and only handle it once per tick generation.\n            if (unit === 'hour' && increment > 1 && ticks.length > 0 && dstDiff === 0) {\n                const prev = ticks[ticks.length - 1];\n                dstDiff = ((prev.startDate.getHours() + increment) % 24) - prev.endDate.getHours();\n                if (dstDiff !== 0) {\n                    // A DST boundary was crossed in previous tick, adjust this tick to keep timeaxis \"symmetric\".\n                    intervalEnd = DH.add(intervalEnd, dstDiff, 'hour');\n                }\n            }\n            isExcluded = false;\n            if (usesExclusion) {\n                tickEnd    = new Date(intervalEnd.getTime());\n                isExcluded = me.processExclusion(startDate, intervalEnd, unit);\n            }\n            else {\n                tickEnd = intervalEnd;\n            }\n            if (!isExcluded) {\n                ticks.push({\n                    id      : (ticks.length + 1),\n                    startDate,\n                    endDate : intervalEnd\n                });\n                me.tickCache[startDate.getTime()] = ticks.length - 1;\n            }\n            startDate = tickEnd;\n        }\n        return ticks;\n    }\n    /**\n     * How many ticks are visible across the TimeAxis.\n     *\n     * Usually, this is an integer because {@link #config-autoAdjust} means that the start and end\n     * dates are adjusted to be on tick boundaries.\n     * @property {Number}\n     * @internal\n     */\n    get visibleTickTimeSpan() {\n        const me = this;\n        return me.isContinuous ? me.visibleTickEnd - me.visibleTickStart : me.count;\n    }\n    /**\n     * Gets a tick \"coordinate\" representing the date position on the time scale. Returns -1 if the date is not part of the time axis.\n     * @param {Date} date the date\n     * @returns {Number} the tick position on the scale or -1 if the date is not part of the time axis\n     */\n    getTickFromDate(date) {\n        const\n            me     = this,\n            ticks  = me.records,\n            dateMS = date.getTime?.() ?? date;\n        let begin = 0,\n            end   = ticks.length - 1,\n            middle, tick, tickStart, tickEnd;\n        // Quickly eliminate out of range dates or if we have not been set up with a time range yet\n        if (!ticks.length || dateMS < ticks[0].startDateMS || dateMS > ticks[end].endDateMS) {\n            return -1;\n        }\n        if (me.isContinuous) {\n            // Chop tick cache in half until we find a match\n            while (begin < end) {\n                middle = (begin + end + 1) >> 1;\n                if (dateMS > ticks[middle].endDateMS) {\n                    begin = middle + 1;\n                }\n                else if (dateMS < ticks[middle].startDateMS) {\n                    end = middle - 1;\n                }\n                else {\n                    begin = middle;\n                }\n            }\n            tick      = ticks[begin];\n            tickStart = tick.startDateMS;\n            // Part way though, calculate the fraction\n            if (dateMS > tickStart) {\n                tickEnd = tick.endDateMS;\n                begin += (dateMS - tickStart) / (tickEnd - tickStart);\n            }\n            return Math.min(Math.max(begin, me.visibleTickStart), me.visibleTickEnd);\n        }\n        else {\n            for (let i = 0; i <= end; i++) {\n                tickEnd = ticks[i].endDateMS;\n                if (dateMS <= tickEnd) {\n                    tickStart = ticks[i].startDateMS;\n                    // date < tickStart can occur in filtered case\n                    tick = i + (dateMS > tickStart ? (dateMS - tickStart) / (tickEnd - tickStart) : 0);\n                    return tick;\n                }\n            }\n        }\n    }\n    getSnappedTickFromDate(date) {\n        const\n            startTickIdx = Math.floor(this.getTickFromDate(date));\n        return this.getAt(startTickIdx);\n    }\n    /**\n     * Gets the time represented by a tick \"coordinate\".\n     * @param {Number} tick the tick \"coordinate\"\n     * @param {'floor'|'round'|'ceil'} [roundingMethod] Rounding method to use. 'floor' to take the tick (lowest header\n     * in a time axis) start date, 'round' to round the value to nearest increment or 'ceil' to take the tick end date\n     * @returns {Date} The date to represented by the tick \"coordinate\", or null if invalid.\n     */\n    getDateFromTick(tick, roundingMethod) {\n        const me = this;\n        if (tick === me.visibleTickEnd) {\n            return me.endDate;\n        }\n        const\n            wholeTick = Math.floor(tick),\n            fraction  = tick - wholeTick,\n            t         = me.getAt(wholeTick);\n        if (!t) {\n            return null;\n        }\n        const\n            // if we've filtered timeaxis using filterBy, then we cannot trust to adjustedStart property and should use tick start\n            start = wholeTick === 0 && me.isContinuous ? me.adjustedStart : t.startDate,\n            // if we've filtered timeaxis using filterBy, then we cannot trust to adjustedEnd property and should use tick end\n            end   = (wholeTick === me.count - 1) && me.isContinuous ? me.adjustedEnd : t.endDate;\n        let date = DH.add(start, fraction * (end - start), 'millisecond');\n        if (roundingMethod) {\n            date = me[roundingMethod + 'Date'](date);\n        }\n        return date;\n    }\n    /**\n     * Returns the ticks of the timeaxis in an array of objects with a \"startDate\" and \"endDate\".\n     * @property {Scheduler.model.TimeSpan[]}\n     */\n    get ticks() {\n        return this.records;\n    }\n    /**\n     * Caches ticks and start/end dates for faster processing during rendering of events.\n     * @private\n     */\n    updateTickCache(onlyStartEnd = false) {\n        const me = this;\n        if (me.count) {\n            me._start   = me.first.startDate;\n            me._end     = me.last.endDate;\n            me._startMS = me.startDate.getTime();\n            me._endMS   = me.endDate.getTime();\n        }\n        else {\n            me._start = me._end = me._startMs = me._endMS = null;\n        }\n        // onlyStartEnd is true prior to clearing filters, to get start and end dates correctly during that process.\n        // No point in filling tickCache yet in that case, it will be done after the filters are cleared\n        if (!onlyStartEnd) {\n            me.tickCache = {};\n            me.forEach((tick, i) => me.tickCache[tick.startDate.getTime()] = i);\n        }\n    }\n    //endregion\n    //region Axis\n    /**\n     * Returns true if the passed date is inside the span of the current time axis.\n     * @param {Date} date The date to query for\n     * @returns {Boolean} true if the date is part of the time axis\n     */\n    dateInAxis(date, inclusiveEnd = false) {\n        const\n            me        = this,\n            axisStart = me.startDate,\n            axisEnd   = me.endDate;\n        // Date is between axis start/end and axis is not continuous - need to perform better lookup\n        if (me.isContinuous) {\n            return inclusiveEnd ? DH.betweenLesserEqual(date, axisStart, axisEnd) : DH.betweenLesser(date, axisStart, axisEnd);\n        }\n        else {\n            const length = me.getCount();\n            let tickStart, tickEnd, tick;\n            for (let i = 0; i < length; i++) {\n                tick      = me.getAt(i);\n                tickStart = tick.startDate;\n                tickEnd   = tick.endDate;\n                if ((inclusiveEnd && date <= tickEnd) || (!inclusiveEnd && date < tickEnd)) {\n                    return date >= tickStart;\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Returns true if the passed timespan is part of the current time axis (in whole or partially).\n     * @param {Date} start The start date\n     * @param {Date} end The end date\n     * @returns {Boolean} true if the timespan is part of the timeaxis\n     */\n    timeSpanInAxis(start, end) {\n        const me = this;\n        if (!end || end.getTime() === start.getTime()) {\n            return this.dateInAxis(start, true);\n        }\n        if (me.isContinuous) {\n            return DH.intersectSpans(start, end, me.startDate, me.endDate);\n        }\n        return (start < me.startDate && end > me.endDate) || me.getTickFromDate(start) !== me.getTickFromDate(end);\n    }\n    // Accepts a TimeSpan model (uses its cached MS values to be a bit faster during rendering)\n    isTimeSpanInAxis(timeSpan) {\n        const\n            me                         = this,\n            { startMS, endMS }         = me,\n            { startDateMS }            = timeSpan,\n            endDateMS                  = timeSpan.endDateMS ?? timeSpan.meta.endDateCached;\n        // only consider fully scheduled ranges\n        if (!startDateMS || !endDateMS) {\n            return false;\n        }\n        if (endDateMS === startDateMS) {\n            return me.dateInAxis(timeSpan.startDate, true);\n        }\n        if (me.isContinuous) {\n            return endDateMS > startMS && startDateMS < endMS;\n        }\n        const\n            startTick = me.getTickFromDate(timeSpan.startDate),\n            endTick   = me.getTickFromDate(timeSpan.endDate);\n        // endDate is not inclusive\n        if (\n            (startTick === me.count && DH.isEqual(timeSpan.startDate, me.last.endDate)) ||\n            (endTick === 0 && DH.isEqual(timeSpan.endDate, me.first.startDate))\n        ) {\n            return false;\n        }\n        return (\n            // Spanning entire axis\n            (startDateMS < startMS && endDateMS > endMS) ||\n            // Unintentionally 0 wide (ticks excluded or outside)\n            startTick !== endTick\n        );\n    }\n    //endregion\n    //region Iteration\n    /**\n     * Calls the supplied iterator function once per interval. The function will be called with four parameters, startDate endDate, index, isLastIteration.\n     * @internal\n     * @param {String} unit The unit to use when iterating over the timespan\n     * @param {Number} increment The increment to use when iterating over the timespan\n     * @param {Function} iteratorFn The function to call\n     * @param {Object} [thisObj] `this` reference for the function\n     */\n    forEachAuxInterval(unit, increment = 1, iteratorFn, thisObj = this) {\n        const end = this.endDate;\n        let dt = this.startDate,\n            i  = 0,\n            intervalEnd;\n        if (dt > end) throw new Error('Invalid time axis configuration');\n        while (dt < end) {\n            intervalEnd = DH.min(DH.getNext(dt, unit, increment, this.weekStartDay), end);\n            iteratorFn.call(thisObj, dt, intervalEnd, i, intervalEnd >= end);\n            dt = intervalEnd;\n            i++;\n        }\n    }\n    //endregion\n}\nTimeAxis._$name = 'TimeAxis';", "import DH from '../../../Core/helper/DateHelper.js';\nimport Events from '../../../Core/mixin/Events.js';\nimport PresetManager from '../../preset/PresetManager.js';\nimport ViewPreset from '../../preset/ViewPreset.js';\nimport '../../data/TimeAxis.js';\n/**\n * @module Scheduler/view/model/TimeAxisViewModel\n */\n/**\n * This class is an internal view model class, describing the visual representation of a {@link Scheduler.data.TimeAxis}.\n * The config for the header rows is described in the {@link Scheduler.preset.ViewPreset#field-headers headers}.\n * To calculate the size of each cell in the time axis, this class requires:\n *\n * - availableSpace  - The total width or height available for the rendering\n * - tickSize       - The fixed width or height of each cell in the lowest header row. This value is normally read from the\n * {@link Scheduler.preset.ViewPreset viewPreset} but this can also be updated programmatically using the {@link #property-tickSize} setter\n *\n * Normally you should not interact with this class directly.\n *\n * @extends Core/mixin/Events\n */\nexport default class TimeAxisViewModel extends Events() {\n    //region Default config\n    static get defaultConfig() {\n        return {\n            /**\n             * The time axis providing the underlying data to be visualized\n             * @config {Scheduler.data.TimeAxis}\n             * @internal\n             */\n            timeAxis : null,\n            /**\n             * The available width/height, this is normally not known by the consuming UI component using this model\n             * class until it has been fully rendered. The consumer of this model should set\n             * {@link #property-availableSpace} when its width has changed.\n             * @config {Number}\n             * @internal\n             */\n            availableSpace : null,\n            /**\n             * The \"tick width\" for horizontal mode or \"tick height\" for vertical mode, to use for the cells in the\n             * bottom most header row.\n             * This value is normally read from the {@link Scheduler.preset.ViewPreset viewPreset}\n             * @config {Number}\n             * @default\n             * @internal\n             */\n            tickSize : 100,\n            /**\n             * true if there is a requirement to be able to snap events to a certain view resolution.\n             * This has implications of the {@link #config-tickSize} that can be used, since all widths must be in even pixels.\n             * @config {Boolean}\n             * @default\n             * @internal\n             */\n            snap : false,\n            /**\n             * true if cells in the bottom-most row should be fitted to the {@link #property-availableSpace available space}.\n             * @config {Boolean}\n             * @default\n             * @internal\n             */\n            forceFit : false,\n            headers : null,\n            mode : 'horizontal', // or 'vertical'\n            //used for Exporting. Make sure the tick columns are not recalculated when resizing.\n            suppressFit : false,\n            // cache of the config currently used.\n            columnConfig : [],\n            // the view preset name to apply initially\n            viewPreset : null,\n            // The default header level to draw column lines for\n            columnLinesFor : null,\n            originalTickSize : null,\n            headersDatesCache : []\n        };\n    }\n    //endregion\n    //region Init & destroy\n    construct(config) {\n        const me = this;\n        // getSingleUnitInPixels results are memoized because of frequent calls during rendering.\n        me.unitToPixelsCache = {};\n        super.construct(config);\n        const viewPreset = me.timeAxis.viewPreset || me.viewPreset;\n        if (viewPreset) {\n            if (viewPreset instanceof ViewPreset) {\n                me.consumeViewPreset(viewPreset);\n            }\n            else {\n                const preset = PresetManager.getPreset(viewPreset);\n                preset && me.consumeViewPreset(preset);\n            }\n        }\n        // When time axis is changed, reconfigure the model\n        me.timeAxis.ion({ reconfigure : 'onTimeAxisReconfigure', thisObj : me });\n        me.configured = true;\n    }\n    doDestroy() {\n        this.timeAxis.un('reconfigure', this.onTimeAxisReconfigure, this);\n        super.doDestroy();\n    }\n    /**\n     * Returns an array representing the headers of the current timeAxis. Each element is an array representing the cells for that level in the header.\n     * @returns {Object[]} An array of headers, each element being an array representing each cell (with start date and end date) in the timeline representation.\n     * @internal\n     */\n    get columnConfig() {\n        return this._columnConfig;\n    }\n    set columnConfig(config) {\n        this._columnConfig = config;\n    }\n    get headers() {\n        return this._headers;\n    }\n    set headers(headers) {\n        if (headers && headers.length && headers[headers.length - 1].cellGenerator) {\n            throw new Error('`cellGenerator` cannot be used for the bottom level of your headers. Use TimeAxis#generateTicks() instead.');\n        }\n        this._headers = headers;\n    }\n    get isTimeAxisViewModel() {\n        return true;\n    }\n    //endregion\n    //region Events\n    /**\n     * Fires after the model has been updated.\n     * @event update\n     * @param {Scheduler.view.model.TimeAxisViewModel} source The model instance\n     */\n    /**\n     * Fires after the model has been reconfigured.\n     * @event reconfigure\n     * @param {Scheduler.view.model.TimeAxisViewModel} source The model instance\n     */\n    //endregion\n    //region Mode\n    /**\n     * Using horizontal mode?\n     * @returns {Boolean}\n     * @readonly\n     * @internal\n     */\n    get isHorizontal() {\n        return this.mode !== 'vertical';\n    }\n    /**\n     * Using vertical mode?\n     * @returns {Boolean}\n     * @readonly\n     * @internal\n     */\n    get isVertical() {\n        return this.mode === 'vertical';\n    }\n    /**\n     * Gets/sets the forceFit value for the model. Setting it will cause it to update its contents and fire the\n     * {@link #event-update} event.\n     * @property {Boolean}\n     * @internal\n     */\n    set forceFit(value) {\n        if (value !== this._forceFit) {\n            this._forceFit = value;\n            this.update();\n        }\n    }\n    //endregion\n    //region Reconfigure & update\n    reconfigure(config) {\n        // clear the cached headers\n        this.headers = null;\n        // Ensure correct ordering\n        this.setConfig(config);\n        this.trigger('reconfigure');\n    }\n    onTimeAxisReconfigure({ source : timeAxis, suppressRefresh }) {\n        if (this.viewPreset !== timeAxis.viewPreset) {\n            this.consumeViewPreset(timeAxis.viewPreset);\n        }\n        if (!suppressRefresh && timeAxis.count > 0) {\n            this.update();\n        }\n    }\n    /**\n     * Updates the view model current timeAxis configuration and available space.\n     * @param {Number} [availableSpace] The available space for the rendering of the axis (used in forceFit mode)\n     * @param {Boolean} [silent] Pass `true` to suppress the firing of the `update` event.\n     * @param {Boolean} [forceUpdate] Pass `true` to fire the `update` event even if the size has not changed.\n     * @internal\n     */\n    update(availableSpace, silent = false, forceUpdate = false) {\n        const\n            me                    = this,\n            { timeAxis, headers } = me,\n            spaceAvailable        = availableSpace !== 0;\n        // We're in configuration, or no change, quit\n        if (me.isConfiguring || (spaceAvailable && me._availableSpace === availableSpace)) {\n            if (forceUpdate) {\n                me.trigger('update');\n            }\n            return;\n        }\n        me._availableSpace = Math.max(availableSpace || me.availableSpace || 0, 0);\n        if (typeof me.availableSpace !== 'number') {\n            throw new Error('Invalid available space provided to TimeAxisModel');\n        }\n        me.columnConfig = [];\n        // The \"column width\" is considered to be the width of each tick in the lowest header row and this width\n        // has to be same for all cells in the lowest row.\n        const tickSize = me._tickSize = me.calculateTickSize(me.originalTickSize);\n        if (typeof tickSize !== 'number' || tickSize <= 0) {\n            throw new Error('Invalid timeAxis tick size');\n        }\n        // getSingleUnitInPixels results are memoized because of frequent calls during rendering.\n        me.unitToPixelsCache = {};\n        // totalSize is cached because of frequent calls which calculate it.\n        me._totalSize = null;\n        // Generate the underlying date ranges for each header row, which will provide input to the cell rendering\n        for (let pos = 0, { length } = headers; pos < length; pos++) {\n            const header = headers[pos];\n            if (header.cellGenerator) {\n                const headerCells = header.cellGenerator.call(me, timeAxis.startDate, timeAxis.endDate);\n                me.columnConfig[pos] = me.createHeaderRow(pos, header, headerCells);\n            }\n            else {\n                me.columnConfig[pos] = me.createHeaderRow(pos, header);\n            }\n        }\n        if (!silent) {\n            me.trigger('update');\n        }\n    }\n    //endregion\n    //region Date / position mapping\n    /**\n     * Returns the distance in pixels for a timespan with the given start and end date.\n     * @param {Date} start start date\n     * @param {Date} end end date\n     * @returns {Number} The length of the time span\n     * @category Date mapping\n     */\n    getDistanceBetweenDates(start, end) {\n        return this.getPositionFromDate(end) - this.getPositionFromDate(start);\n    }\n    /**\n     * Returns the distance in pixels for a time span\n     * @param {Number} durationMS Time span duration in ms\n     * @returns {Number} The length of the time span\n     * @category Date mapping\n     */\n    getDistanceForDuration(durationMs) {\n        return this.getSingleUnitInPixels('millisecond') * durationMs;\n    }\n    /**\n     * Gets the position of a date on the projected time axis or -1 if the date is not in the timeAxis.\n     * @param {Date} date the date to query for.\n     * @returns {Number} the coordinate representing the date\n     * @category Date mapping\n     */\n    getPositionFromDate(date, options = {}) {\n        const tick = this.getScaledTick(date, options);\n        if (tick === -1) {\n            return -1;\n        }\n        return this.tickSize * (tick - this.timeAxis.visibleTickStart);\n    }\n    // Translates a tick along the time axis to facilitate scaling events when excluding certain days or hours\n    getScaledTick(date, { respectExclusion, snapToNextIncluded, isEnd, min, max }) {\n        const\n            { timeAxis }      = this,\n            { include, unit } = timeAxis;\n        let tick = timeAxis.getTickFromDate(date);\n        if (tick !== -1 && respectExclusion && include) {\n            let tickChanged = false;\n            // Stretch if we are using a larger unit than 'hour', except if it is 'day'. If so, it is already handled\n            // by a cheaper reconfiguration of the ticks in `generateTicks`\n            if (include.hour && DH.compareUnits(unit, 'hour') > 0 && unit !== 'day') {\n                const\n                    { from, to, lengthFactor, center } = include.hour,\n                    // Original hours\n                    originalHours                      = date.getHours(),\n                    // Crop to included hours\n                    croppedHours                       = Math.min(Math.max(originalHours, from), to);\n                // If we are not asked to snap (when other part of span is not included) any cropped away hour\n                // should be considered excluded\n                if (!snapToNextIncluded && croppedHours !== originalHours) {\n                    return -1;\n                }\n                const\n                    // Should scale hour and smaller units (seconds will hardly affect visible result...)\n                    fractionalHours = croppedHours + date.getMinutes() / 60,\n                    // Number of hours from the center    |xxxx|123c----|xxx|\n                    hoursFromCenter = center - fractionalHours,\n                    // Step from center to stretch event  |x|112233c----|xxx|\n                    newHours        = center - hoursFromCenter * lengthFactor;\n                // Adding instead of setting to get a clone of the date, to not affect the original\n                date = DH.add(date, newHours - originalHours, 'h');\n                tickChanged = true;\n            }\n            if (include.day && DH.compareUnits(unit, 'day') > 0) {\n                const { from, to, lengthFactor, center } = include.day;\n                //region Crop\n                let checkDay = date.getDay();\n                // End date is exclusive, check the day before if at 00:00\n                if (isEnd && date.getHours() === 0 && date.getMinutes() === 0 && date.getSeconds() === 0 && date.getMilliseconds() === 0) {\n                    if (--checkDay < 0) {\n                        checkDay = 6;\n                    }\n                }\n                let addDays = 0;\n                if (checkDay < from || checkDay >= to) {\n                    // If end date is in view but start date is excluded, snap to next included day\n                    if (snapToNextIncluded) {\n                        // Step back to \"to-1\" (not inclusive) for end date\n                        if (isEnd) {\n                            addDays = (to - checkDay - 8) % 7;\n                        }\n                        // Step forward to \"from\" for start date\n                        else {\n                            addDays = (from - checkDay + 7) % 7;\n                        }\n                        date = DH.add(date, addDays, 'd');\n                        date = DH.startOf(date, 'd', false);\n                        // Keep end after start and vice versa\n                        if (\n                            (max && date.getTime() >= max) ||\n                            (min && date.getTime() <= min)\n                        ) {\n                            return -1;\n                        }\n                    }\n                    else {\n                        // day excluded at not snapping to next\n                        return -1;\n                    }\n                }\n                //endregion\n                const\n                    { weekStartDay } = timeAxis,\n                    // Center to stretch around, for some reason pre-calculated cannot be used for sundays :)\n                    fixedCenter      = date.getDay() === 0 ? 0 : center,\n                    // Should scale day and smaller units (minutes will hardly affect visible result...)\n                    fractionalDay    = date.getDay() + date.getHours() / 24, //+ dateClone.getMinutes() / (24 * 1440),\n                    // Number of days from the calculated center\n                    daysFromCenter   = fixedCenter - fractionalDay,\n                    // Step from center to stretch event\n                    newDay           = fixedCenter - daysFromCenter * lengthFactor;\n                // Adding instead of setting to get a clone of the date, to not affect the original\n                date = DH.add(date, newDay - fractionalDay + weekStartDay, 'd');\n                tickChanged = true;\n            }\n            // Now the date might start somewhere else (fraction of ticks)\n            if (tickChanged) {\n                // When stretching date might end up outside of time axis, making it invalid to use. Clip it to time axis\n                // to circumvent this\n                date = DH.constrain(date, timeAxis.startDate, timeAxis.endDate);\n                // Get a new tick based on the \"scaled\" date\n                tick = timeAxis.getTickFromDate(date);\n            }\n        }\n        return tick;\n    }\n    /**\n     * Gets the date for a position on the time axis\n     * @param {Number} position The page X or Y coordinate\n     * @param {'floor'|'round'|'ceil'} [roundingMethod] Rounding method to use. 'floor' to take the tick (lowest header\n     * in a time axis) start date, 'round' to round the value to nearest increment or 'ceil' to take the tick end date\n     * @param {Boolean} [allowOutOfRange=false] By default, this returns `null` if the position is outside\n     * of the time axis. Pass `true` to attempt to calculate a date outside of the time axis.\n     * @returns {Date} the Date corresponding to the xy coordinate\n     * @category Date mapping\n     */\n    getDateFromPosition(position, roundingMethod, allowOutOfRange = false) {\n        const\n            me           = this,\n            { timeAxis } = me,\n            tick         = me.getScaledPosition(position) / me.tickSize + timeAxis.visibleTickStart;\n        if (tick < 0 || tick > timeAxis.count) {\n            if (allowOutOfRange) {\n                let result;\n                // Subtract the correct number of tick units from the start date\n                if (tick < 0) {\n                    result = DH.add(timeAxis.startDate, tick, timeAxis.unit);\n                }\n                else {\n                    // Add the correct number of tick units to the end date\n                    result = DH.add(timeAxis.endDate, tick - timeAxis.count, timeAxis.unit);\n                }\n                // Honour the rounding requested\n                if (roundingMethod) {\n                    result = timeAxis[roundingMethod + 'Date'](result);\n                }\n                return result;\n            }\n            return null;\n        }\n        return timeAxis.getDateFromTick(tick, roundingMethod);\n    }\n    // Translates a position along the time axis to facilitate scaling events when excluding certain days or hours\n    getScaledPosition(position) {\n        const { include, unit, weekStartDay } = this.timeAxis;\n        // Calculations are\n        if (include) {\n            const dayWidth = this.getSingleUnitInPixels('day');\n            // Have to calculate day before hour to get end result correct\n            if (include.day && DH.compareUnits(unit, 'day') > 0) {\n                const { from, lengthFactor } = include.day,\n                    // Scaling happens within a week, determine position within it\n                    positionInWeek         = position % (dayWidth * 7),\n                    // Store were the week starts to be able to re-add it after scale\n                    weekStartPosition      = position - positionInWeek;\n                // Scale position using calculated length per day factor, adding the width of excluded days\n                position                     = positionInWeek / lengthFactor + (from - weekStartDay) * dayWidth + weekStartPosition;\n            }\n            // Hours are not taken into account when viewing days, since the day ticks are reconfigured in\n            // `generateTicks` instead\n            if (include.hour && DH.compareUnits(unit, 'hour') > 0 && unit !== 'day') {\n                const { from, lengthFactorExcl } = include.hour,\n                    hourWidth                  = this.getSingleUnitInPixels('hour'),\n                    // Scaling happens within a day, determine position within it\n                    positionInDay              = position % dayWidth,\n                    // Store were the day starts to be able to re-add it after scale\n                    dayStartPosition           = position - positionInDay;\n                // Scale position using calculated length per day factor, adding the width of excluded hours\n                position                         = positionInDay / lengthFactorExcl + from * hourWidth + dayStartPosition;\n            }\n        }\n        return position;\n    }\n    /**\n     * Returns the amount of pixels for a single unit\n     * @internal\n     * @returns {Number} The unit in pixel\n     */\n    getSingleUnitInPixels(unit) {\n        const me = this;\n        return me.unitToPixelsCache[unit] || (me.unitToPixelsCache[unit] = DH.getUnitToBaseUnitRatio(me.timeAxis.unit, unit, true) * me.tickSize / me.timeAxis.increment);\n    }\n    /**\n     * Returns the pixel increment for the current view resolution.\n     * @internal\n     * @returns {Number} The increment\n     */\n    get snapPixelAmount() {\n        if (this.snap) {\n            const { resolution } = this.timeAxis;\n            return (resolution.increment || 1) * this.getSingleUnitInPixels(resolution.unit);\n        }\n        return 1;\n    }\n    //endregion\n    //region Sizes\n    /**\n     * Get/set the current time column size (the width or height of a cell in the bottom-most time axis header row,\n     * depending on mode)\n     * @internal\n     * @property {Number}\n     */\n    get tickSize() {\n        return this._tickSize;\n    }\n    set tickSize(size) {\n        this.setTickSize(size, false);\n    }\n    setTickSize(size, suppressEvent) {\n        this._tickSize = this.originalTickSize = size;\n        this.update(undefined, suppressEvent);\n    }\n    get timeResolution() {\n        return this.timeAxis.resolution;\n    }\n    // Calculates the time column width/height based on the value defined viewPreset \"tickWidth/tickHeight\". It also\n    // checks for the forceFit view option and the snap, both of which impose constraints on the time column width\n    // configuration.\n    calculateTickSize(proposedSize) {\n        const\n            me                                  = this,\n            { forceFit, timeAxis, suppressFit } = me,\n            timelineUnit                        = timeAxis.unit;\n        let size  = 0,\n            ratio = 1; //Number.MAX_VALUE;\n        if (me.snap) {\n            const resolution = timeAxis.resolution;\n            ratio            = DH.getUnitToBaseUnitRatio(timelineUnit, resolution.unit) * resolution.increment;\n        }\n        if (!suppressFit) {\n            const fittingSize = me.availableSpace / timeAxis.visibleTickTimeSpan;\n            size = (forceFit || proposedSize < fittingSize) ? fittingSize : proposedSize;\n            if (ratio > 0 && (!forceFit || ratio < 1)) {\n                size = Math.max(1, ratio * size) / ratio;\n            }\n        }\n        else {\n            size = proposedSize;\n        }\n        return size;\n    }\n    /**\n     * Returns the total width/height of the time axis representation, depending on mode.\n     * @returns {Number} The width or height\n     * @internal\n     * @readonly\n     */\n    get totalSize() {\n        // Floor the space to prevent spurious overflow\n        return this._totalSize || (this._totalSize = Math.floor(this.tickSize * this.timeAxis.visibleTickTimeSpan));\n    }\n    /**\n     * Get/set the available space for the time axis representation. If size changes it will cause it to update its\n     * contents and fire the {@link #event-update} event.\n     * @internal\n     * @property {Number}\n     */\n    get availableSpace() {\n        return this._availableSpace;\n    }\n    set availableSpace(space) {\n        const me = this;\n        // We should only need to repaint fully if the tick width has changed (which will happen if forceFit is set, or if the full size of the time axis doesn't\n        // occupy the available space - and gets stretched\n        me._availableSpace = Math.max(0, space);\n        if (me._availableSpace > 0) {\n            const newTickSize = me.calculateTickSize(me.originalTickSize);\n            if (newTickSize > 0 && newTickSize !== me.tickSize) {\n                me.update();\n            }\n        }\n    }\n    //endregion\n    //region Fitting & snapping\n    /**\n     * Returns start dates for ticks at the specified level in format { date, isMajor }.\n     * @param {Number} level Level in headers array, `0` meaning the topmost...\n     * @param {Boolean} useLowestHeader Use lowest level\n     * @param getEnd\n     * @returns {Array}\n     * @internal\n     */\n    getDates(level = this.columnLinesFor, useLowestHeader = false, getEnd = false) {\n        const\n            me            = this,\n            ticks         = [],\n            linesForLevel = useLowestHeader ? me.lowestHeader : level,\n            majorLevel    = me.majorHeaderLevel,\n            levelUnit     = me.headers && me.headers[level].unit,\n            majorUnit     = majorLevel != null && me.headers && me.headers[majorLevel].unit,\n            validMajor    = majorLevel != null && DH.doesUnitsAlign(majorUnit, levelUnit),\n            hasGenerator  = !!(me.headers && me.headers[linesForLevel].cellGenerator);\n        if (hasGenerator) {\n            const cells = me.columnConfig[linesForLevel];\n            for (let i = 1, l = cells.length; i < l; i++) {\n                ticks.push({ date : cells[i].startDate });\n            }\n        }\n        else {\n            me.forEachInterval(linesForLevel, (start, end) => {\n                ticks.push({\n                    date    : getEnd ? end : start,\n                    // do not want to consider tick to be major tick, hence the check for majorHeaderLevel\n                    isMajor : majorLevel !== level && validMajor && me.isMajorTick(getEnd ? end : start)\n                });\n            });\n        }\n        return ticks;\n    }\n    get forceFit() {\n        return this._forceFit;\n    }\n    /**\n     * This function fits the time columns into the available space in the time axis column.\n     * @param {Boolean} suppressEvent `true` to skip firing the 'update' event.\n     * @internal\n     */\n    fitToAvailableSpace(suppressEvent) {\n        const proposedSize = Math.floor(this.availableSpace / this.timeAxis.visibleTickTimeSpan);\n        this.setTickSize(proposedSize, suppressEvent);\n    }\n    get snap() {\n        return this._snap;\n    }\n    /**\n     * Gets/sets the snap value for the model. Setting it will cause it to update its contents and fire the\n     * {@link #event-update} event.\n     * @property {Boolean}\n     * @internal\n     */\n    set snap(value) {\n        if (value !== this._snap) {\n            this._snap = value;\n            if (this.configured) {\n                this.update();\n            }\n        }\n    }\n    //endregion\n    //region Headers\n    // private\n    createHeaderRow(position, headerRowConfig, headerCells) {\n        const\n            me                            = this,\n            cells                         = [],\n            { align, headerCellCls = '' } = headerRowConfig,\n            today                         = DH.clearTime(new Date()),\n            { timeAxis }                  = me,\n            tickLevel                     = me.headers.length - 1,\n            createCellContext             = (start, end, i, isLast, data) => {\n                let value = DH.format(start, headerRowConfig.dateFormat);\n                const\n                    // So that we can use shortcut tickSize as the tickLevel cell width.\n                    // We can do this if the TimeAxis is aligned to start and end on tick boundaries\n                    // or if it's not the first or last tick.\n                    // getDistanceBetweenDates is an expensive operation.\n                    isInteriorTick = i > 0 && !isLast,\n                    cellData       = {\n                        align,\n                        start,\n                        end,\n                        value : data ? data.header : value,\n                        headerCellCls,\n                        width : tickLevel === position && me.owner && (timeAxis.fullTicks || isInteriorTick) ? me.owner.tickSize : me.getDistanceBetweenDates(start, end),\n                        index : i\n                    };\n                if (cellData.width === 0) {\n                    return;\n                }\n                // Vertical mode uses absolute positioning for header cells\n                cellData.coord = size - 1;\n                size += cellData.width;\n                me.headersDatesCache[position][start.getTime()] = 1;\n                if (headerRowConfig.renderer) {\n                    value = headerRowConfig.renderer.call(headerRowConfig.thisObj || me, start, end, cellData, i);\n                    cellData.value = value == null ? '' : value;\n                }\n                // To be able to style individual day cells, weekends or other important days\n                if (headerRowConfig.unit === 'day' && (!headerRowConfig.increment || headerRowConfig.increment === 1)) {\n                    cellData.headerCellCls += ' b-sch-dayheadercell-' + start.getDay();\n                    if (DH.clearTime(start, true) - today === 0) {\n                        cellData.headerCellCls += ' b-sch-dayheadercell-today';\n                    }\n                }\n                cells.push(cellData);\n            };\n        let size = 0;\n        me.headersDatesCache[position] = {};\n        if (headerCells) {\n            headerCells.forEach((cellData, i) => createCellContext(cellData.start, cellData.end, i, i === headerCells.length - 1, cellData));\n        }\n        else {\n            me.forEachInterval(position, createCellContext);\n        }\n        return cells;\n    }\n    get mainHeader() {\n        return ('mainHeaderLevel' in this) ? this.headers[this.mainHeaderLevel] : this.bottomHeader;\n    }\n    get bottomHeader() {\n        return this.headers[this.headers.length - 1];\n    }\n    get lowestHeader() {\n        return this.headers.length - 1;\n    }\n    /**\n     * This method is meant to return the level of the header which 2nd lowest.\n     * It is used for {@link #function-isMajorTick} method\n     * @returns {String}\n     * @private\n     */\n    get majorHeaderLevel() {\n        const { headers } = this;\n        if (headers) {\n            return Math.max(headers.length - 2, 0);\n        }\n        return null;\n    }\n    //endregion\n    //region Ticks\n    /**\n     * For vertical view (and column lines plugin) we sometimes want to know if current tick starts along with the\n     * upper header level.\n     * @param {Date} date\n     * @returns {Boolean}\n     * @private\n     */\n    isMajorTick(date) {\n        const nextLevel = this.majorHeaderLevel;\n        // if forceFit is used headersDatesCache won\u00B4t have been generated yet on the first call here,\n        // since no size is set yet\n        return nextLevel != null && this.headersDatesCache[nextLevel] && this.headersDatesCache[nextLevel][date.getTime()] || false;\n    }\n    /**\n     * Calls the supplied iterator function once per interval. The function will be called with three parameters, start date and end date and an index.\n     * Return false to break the iteration.\n     * @param {Number} position The index of the header in the headers array.\n     * @param {Function} iteratorFn The function to call, will be called with start date, end date and \"tick index\"\n     * @param {Object} [thisObj] `this` reference for the function\n     * @internal\n     */\n    forEachInterval(position, iteratorFn, thisObj = this) {\n        const { headers, timeAxis } = this;\n        if (headers) {\n            // This is the lowest header row, which should be fed the data in the tickStore (or a row above using same unit)\n            if (position === headers.length - 1) {\n                timeAxis.forEach((r, index) =>\n                    iteratorFn.call(thisObj, r.startDate, r.endDate, index, index === timeAxis.count - 1)\n                );\n            }\n            // All other rows\n            else {\n                const header = headers[position];\n                timeAxis.forEachAuxInterval(header.unit, header.increment, iteratorFn, thisObj);\n            }\n        }\n    }\n    /**\n     * Calls the supplied iterator function once per interval. The function will be called with three parameters, start date and end date and an index.\n     * Return false to break the iteration.\n     * @internal\n     * @param {Function} iteratorFn The function to call\n     * @param {Object} [thisObj] `this` reference for the function\n     */\n    forEachMainInterval(iteratorFn, thisObj) {\n        this.forEachInterval(this.mainHeaderLevel, iteratorFn, thisObj);\n    }\n    //endregion\n    //region ViewPreset\n    consumeViewPreset(preset) {\n        const me = this;\n        // clear the cached headers\n        me.headers = null;\n        me.getConfig('tickSize');\n        // Since we are bypassing the tickSize setter below, ensure that\n        // the config initial setter has been removed by referencing the property.\n        // We only do this to avoid multiple updates from this.\n        me.viewPreset = preset;\n        Object.assign(me, {\n            headers         : preset.headers,\n            columnLinesFor  : preset.columnLinesFor,\n            mainHeaderLevel : preset.mainHeaderLevel,\n            _tickSize       : me.isHorizontal ? preset.tickWidth : preset.tickHeight\n        });\n        me.originalTickSize = me.tickSize;\n    }\n    //endregion\n}\nTimeAxisViewModel._$name = 'TimeAxisViewModel';", "import Base from '../../../Core/Base.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\n// Used to avoid having to create huge amounts of Date objects\nconst tempDate = new Date();\n/**\n * @module Scheduler/view/mixin/TimelineDateMapper\n */\n/**\n * Mixin that contains functionality to convert between coordinates and dates etc.\n *\n * @mixin\n */\nexport default Target => class TimelineDateMapper extends (Target || Base) {\n    static $name = 'TimelineDateMapper';\n    static configurable = {\n        /**\n         * Set to `true` to snap to the current time resolution increment while interacting with scheduled events.\n         *\n         * The time resolution increment is either determined by the currently applied view preset, or it can be\n         * overridden using {@link #property-timeResolution}.\n         *\n         * <div class=\"note\">When the {@link Scheduler/view/mixin/TimelineEventRendering#config-fillTicks} option is\n         * enabled, snapping will align to full ticks, regardless of the time resolution.</div>\n         *\n         * @prp {Boolean}\n         * @default\n         * @category Scheduled events\n         */\n        snap : false\n    };\n    //region Coordinate <-> Date\n    getRtlX(x) {\n        if (this.rtl && this.isHorizontal) {\n            x = this.timeAxisViewModel.totalSize - x;\n        }\n        return x;\n    }\n    /**\n     * Gets the date for an X or Y coordinate, either local to the view element or the page based on the 3rd argument.\n     * If the coordinate is not in the currently rendered view, null will be returned unless the `allowOutOfRange`\n     * parameter is passed a `true`.\n     * @param {Number} coordinate The X or Y coordinate\n     * @param {'floor'|'round'|'ceil'} [roundingMethod] Rounding method to use. 'floor' to take the tick (lowest header\n     * in a time axis) start date, 'round' to round the value to nearest increment or 'ceil' to take the tick end date\n     * @param {Boolean} [local] true if the coordinate is local to the scheduler view element\n     * @param {Boolean} [allowOutOfRange] By default, this returns `null` if the position is outside\n     * of the time axis. Pass `true` to attempt to calculate a date outside of the time axis.\n     * @returns {Date} The Date corresponding to the X or Y coordinate\n     * @category Dates\n     */\n    getDateFromCoordinate(coordinate, roundingMethod, local = true, allowOutOfRange = false, ignoreRTL = false) {\n        if (!local) {\n            coordinate = this.currentOrientation.translateToScheduleCoordinate(coordinate);\n        }\n        // Time axis is flipped for RTL\n        if (!ignoreRTL) {\n            coordinate = this.getRtlX(coordinate);\n        }\n        return this.timeAxisViewModel.getDateFromPosition(coordinate, roundingMethod, allowOutOfRange);\n    }\n    getDateFromCoord(options) {\n        return this.getDateFromCoordinate(options.coord, options.roundingMethod, options.local, options.allowOutOfRange, options.ignoreRTL);\n    }\n    /**\n     * Gets the date for an XY coordinate regardless of the orientation of the time axis.\n     * @param {Array} xy The page X and Y coordinates\n     * @param {'floor'|'round'|'ceil'} [roundingMethod] Rounding method to use. 'floor' to take the tick (lowest header\n     * in a time axis) start date, 'round' to round the value to nearest increment or 'ceil' to take the tick end date\n     * @param {Boolean} [local] true if the coordinate is local to the scheduler element\n     * @param {Boolean} [allowOutOfRange] By default, this returns `null` if the position is outside\n     * of the time axis. Pass `true` to attempt to calculate a date outside of the time axis.\n     * @returns {Date} the Date corresponding to the xy coordinate\n     * @category Dates\n     */\n    getDateFromXY(xy, roundingMethod, local = true, allowOutOfRange = false) {\n        return this.currentOrientation.getDateFromXY(xy, roundingMethod, local, allowOutOfRange);\n    }\n    /**\n     * Gets the time for a DOM event such as 'mousemove' or 'click' regardless of the orientation of the time axis.\n     * @param {Event} e the Event instance\n     * @param {'floor'|'round'|'ceil'} [roundingMethod] Rounding method to use. 'floor' to take the tick (lowest header\n     * in a time axis) start date, 'round' to round the value to nearest increment or 'ceil' to take the tick end date\n     * @param {Boolean} [allowOutOfRange] By default, this returns `null` if the position is outside\n     * of the time axis. Pass `true` to attempt to calculate a date outside of the time axis.\n     * @returns {Date} The date corresponding to the EventObject's position along the orientation of the time axis.\n     * @category Dates\n     */\n    getDateFromDomEvent(e, roundingMethod, allowOutOfRange = false) {\n        return this.getDateFromXY([e.pageX, e.pageY], roundingMethod, false, allowOutOfRange);\n    }\n    /**\n     * Gets the start and end dates for an element Region\n     * @param {Core.helper.util.Rectangle} rect The rectangle to map to start and end dates\n     * @param {'floor'|'round'|'ceil'} roundingMethod Rounding method to use. 'floor' to take the tick (lowest header\n     * in a time axis) start date, 'round' to round the value to nearest increment or 'ceil' to take the tick end date\n     * @param {Number} duration The duration in MS of the underlying event\n     * @returns {Object} an object containing start/end properties\n     */\n    getStartEndDatesFromRectangle(rect, roundingMethod, duration, allowOutOfRange = false) {\n        const\n            me               = this,\n            { isHorizontal } = me,\n            startPos         = isHorizontal ? rect.x : rect.top,\n            endPos           = isHorizontal ? rect.right : rect.bottom;\n        let start, end;\n        // Element within bounds\n        if (startPos >= 0 && endPos < me.timeAxisViewModel.totalSize) {\n            start = me.getDateFromCoordinate(startPos, roundingMethod, true);\n            end = me.getDateFromCoordinate(endPos, roundingMethod, true);\n        }\n        // Starts before, start is worked backwards from end\n        else if (startPos < 0) {\n            end = me.getDateFromCoordinate(endPos, roundingMethod, true, allowOutOfRange);\n            start = end && DateHelper.add(end, -duration, 'ms');\n        }\n        // Ends after, end is calculated from the start\n        else {\n            start = me.getDateFromCoordinate(startPos, roundingMethod, true, allowOutOfRange);\n            end = start && DateHelper.add(start, duration, 'ms');\n        }\n        return {\n            start, end\n        };\n    }\n    //endregion\n    //region Date display\n    /**\n     * Method to get a displayed end date value, see {@link #function-getFormattedEndDate} for more info.\n     * @private\n     * @param {Date} endDate The date to format\n     * @param {Date} startDate The start date\n     * @returns {Date} The date value to display\n     */\n    getDisplayEndDate(endDate, startDate) {\n        if (\n            // If time is midnight,\n            endDate.getHours() === 0 && endDate.getMinutes() === 0 &&\n            // and end date is greater then start date\n            (!startDate || !(endDate.getYear() === startDate.getYear() && endDate.getMonth() === startDate.getMonth() && endDate.getDate() === startDate.getDate())) &&\n            // and UI display format doesn't contain hour info (in this case we'll just display the exact date)\n            !DateHelper.formatContainsHourInfo(this.displayDateFormat)\n        ) {\n            // format the date inclusively as 'the whole previous day'.\n            endDate = DateHelper.add(endDate, -1, 'day');\n        }\n        return endDate;\n    }\n    /**\n     * Method to get a formatted end date for a scheduled event, the grid uses the \"displayDateFormat\" property defined in the current view preset.\n     * End dates are formatted as 'inclusive', meaning when an end date falls on midnight and the date format doesn't involve any hour/minute information,\n     * 1ms will be subtracted (e.g. 2010-01-08T00:00:00 will first be modified to 2010-01-07 before being formatted).\n     * @private\n     * @param {Date} endDate The date to format\n     * @param {Date} startDate The start date\n     * @returns {String} The formatted date\n     */\n    getFormattedEndDate(endDate, startDate) {\n        return this.getFormattedDate(this.getDisplayEndDate(endDate, startDate));\n    }\n    //endregion\n    //region Other date functions\n    /**\n     * Gets the x or y coordinate relative to the scheduler element, or page coordinate (based on the 'local' flag)\n     * If the coordinate is not in the currently rendered view, -1 will be returned.\n     * @param {Date|Number} date the date to query for (or a date as ms)\n     * @param {Boolean|Object} options true to return a coordinate local to the scheduler view element (defaults to true),\n     * also accepts a config object like { local : true }.\n     * @returns {Number} the x or y position representing the date on the time axis\n     * @category Dates\n     */\n    getCoordinateFromDate(date, options = true) {\n        const\n            me                    = this,\n            { timeAxisViewModel } = me,\n            {\n                isContinuous,\n                startMS,\n                endMS,\n                startDate,\n                endDate,\n                unit\n            }                     = me.timeAxis,\n            dateMS                = date.valueOf();\n        // Avoiding to break the API while allowing passing options through to getPositionFromDate()\n        if (options === true) {\n            options = {\n                local : true\n            };\n        }\n        else if (!options) {\n            options = {\n                local : false\n            };\n        }\n        else if (!('local' in options)) {\n            options.local = true;\n        }\n        let pos;\n        if (!(date instanceof Date)) {\n            tempDate.setTime(date);\n            date = tempDate;\n        }\n        // Shortcut for continuous time axis that is using a unit that can be reliably translated to days (or smaller)\n        if (isContinuous &&\n            date.getTimezoneOffset() === startDate.getTimezoneOffset() &&\n            startDate.getTimezoneOffset() === endDate.getTimezoneOffset() &&\n            DateHelper.getUnitToBaseUnitRatio(unit, 'day') !== -1\n        ) {\n            if (dateMS < startMS || dateMS > endMS) {\n                return -1;\n            }\n            pos = (dateMS - startMS) / (endMS - startMS) * timeAxisViewModel.totalSize;\n        }\n        // Non-continuous or using for example months (vary in length)\n        else {\n            pos = timeAxisViewModel.getPositionFromDate(date, options);\n        }\n        // RTL coords from the end of the time axis\n        if (me.rtl && me.isHorizontal && !options?.ignoreRTL) {\n            pos = timeAxisViewModel.totalSize - pos;\n        }\n        if (!options.local) {\n            pos = me.currentOrientation.translateToPageCoordinate(pos);\n        }\n        return pos;\n    }\n    /**\n     * Returns the distance in pixels for the time span in the view.\n     * @param {Date} startDate The start date of the span\n     * @param {Date} endDate The end date of the span\n     * @returns {Number} The distance in pixels\n     * @category Dates\n     */\n    getTimeSpanDistance(startDate, endDate) {\n        return this.timeAxisViewModel.getDistanceBetweenDates(startDate, endDate);\n    }\n    /**\n     * Returns the center date of the currently visible timespan of scheduler.\n     *\n     * @property {Date}\n     * @readonly\n     * @category Dates\n     */\n    get viewportCenterDate() {\n        const { timeAxis, timelineScroller } = this;\n        // Take the easy way if the axis is continuous.\n        // We can just work out how far along the time axis the viewport center is.\n        if (timeAxis.isContinuous) {\n            // The offset from the start of the whole time axis\n            const timeAxisOffset = (timelineScroller.position + timelineScroller.clientSize / 2) / timelineScroller.scrollSize;\n            return new Date(timeAxis.startMS + (timeAxis.endMS - timeAxis.startMS) * timeAxisOffset);\n        }\n        return this.getDateFromCoordinate(timelineScroller.position + timelineScroller.clientSize / 2);\n    }\n    get viewportCenterDateCached() {\n        return this.cachedCenterDate || (this.cachedCenterDate = this.viewportCenterDate);\n    }\n    //endregion\n    //region TimeAxis getters/setters\n    /**\n     * Gets/sets the current time resolution object, which contains a unit identifier and an increment count\n     * `{ unit, increment }`. This value means minimal task duration you can create using UI.\n     *\n     * For example when you drag create a task or drag & drop a task, if increment is 5 and unit is 'minute'\n     * that means that you can create tasks in 5 minute increments, or move it in 5 minute steps.\n     *\n     * This value is taken from viewPreset {@link Scheduler.preset.ViewPreset#field-timeResolution timeResolution}\n     * config by default. When supplying a `Number` to the setter only the `increment` is changed and the `unit` value\n     * remains untouched.\n     *\n     * ```javascript\n     * timeResolution : {\n     *   unit      : 'minute',  //Valid values are \"millisecond\", \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\".\n     *   increment : 5\n     * }\n     * ```\n     *\n     * <div class=\"note\">When the {@link Scheduler/view/mixin/TimelineEventRendering#config-fillTicks} option is\n     * enabled, the resolution will be in full ticks regardless of configured value.</div>\n     *\n     * @property {Object|Number}\n     * @category Dates\n     */\n    get timeResolution() {\n        return this.timeAxis.resolution;\n    }\n    set timeResolution(resolution) {\n        this.timeAxis.resolution = (typeof resolution === 'number') ? {\n            increment : resolution,\n            unit      : this.timeAxis.resolution.unit\n        } : resolution;\n    }\n    //endregion\n    //region Snap\n    get snap() {\n        return this._timeAxisViewModel?.snap ?? this._snap;\n    }\n    updateSnap(snap) {\n        if (!this.isConfiguring) {\n            this.timeAxisViewModel.snap = snap;\n            this.timeAxis.forceFullTicks = snap && this.fillTicks;\n        }\n    }\n    //endregion\n    onSchedulerHorizontalScroll(subGrid, scrollLeft, scrollX, scrollingToCenter) {\n        // Invalidate cached center date unless we are scrolling to center on it.\n        if (!scrollingToCenter) {\n            this.cachedCenterDate = null;\n        }\n    }\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport BrowserHelper from '../../../Core/helper/BrowserHelper.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\nimport DomDataStore from '../../../Core/data/DomDataStore.js';\nimport GlobalEvents from '../../../Core/GlobalEvents.js';\n/**\n * @module Scheduler/view/mixin/TimelineDomEvents\n */\nconst { eventNameMap } = EventHelper;\n/**\n * An object which encapsulates a schedule timeline tick context based on a DOM event. This will include\n * the row and resource information and the tick and time information for a DOM pointer event detected\n * in the timeline.\n * @typedef {Object} TimelineContext\n * @property {Event} domEvent The DOM event which triggered the context change.\n * @property {HTMLElement} eventElement If the `domEvent` was on an event bar, this will be the event bar element.\n * @property {HTMLElement} cellElement The cell element under the `domEvent`\n * @property {Date} date The date corresponding to the `domEvent` position in the timeline\n * @property {Scheduler.model.TimeSpan} tick A {@link Scheduler.model.TimeSpan} record which encapsulates the contextual tick\n * @property {Number} tickIndex The contextual tick index. This may be fractional.\n * @property {Number} tickParentIndex The integer contextual tick index.\n * @property {Date} tickStartDate The start date of the contextual tick.\n * @property {Date} tickEndDate The end date of the contextual tick.\n * @property {Grid.row.Row} row The contextual {@link Grid.row.Row}\n * @property {Number} index The contextual row index\n * @property {Scheduler.model.EventModel} [eventRecord] The contextual event record (if any) if the event source is a `Scheduler`\n * @property {Scheduler.model.AssignmentModel} [assignmentRecord] The contextual assignment record (if any) if the event source is a `Scheduler`\n * @property {Scheduler.model.ResourceModel} [resourceRecord] The contextual resource record(if any)  if the event source is a `Scheduler`\n */\n/**\n * Mixin that handles dom events (click etc) for scheduler and rendered events.\n *\n * @mixin\n */\nexport default Target => class TimelineDomEvents extends (Target || Base) {\n    /**\n     * Fires after a click on a time axis cell\n     * @event timeAxisHeaderClick\n     * @param {Scheduler.column.TimeAxisColumn|Scheduler.column.VerticalTimeAxisColumn} source The column object\n     * @param {Date} startDate The start date of the header cell\n     * @param {Date} endDate The end date of the header cell\n     * @param {Event} event The event object\n     */\n    /**\n     * Fires after a double click on a time axis cell\n     * @event timeAxisHeaderDblClick\n     * @param {Scheduler.column.TimeAxisColumn|Scheduler.column.VerticalTimeAxisColumn} source The column object\n     * @param {Date} startDate The start date of the header cell\n     * @param {Date} endDate The end date of the header cell\n     * @param {Event} event The event object\n     */\n    /**\n     * Fires after a right click on a time axis cell\n     * @event timeAxisHeaderContextMenu\n     * @param {Scheduler.column.TimeAxisColumn|Scheduler.column.VerticalTimeAxisColumn} source The column object\n     * @param {Date} startDate The start date of the header cell\n     * @param {Date} endDate The end date of the header cell\n     * @param {Event} event The event object\n     */\n    static $name = 'TimelineDomEvents';\n    //region Default config\n    static configurable = {\n        /**\n         * The currently hovered timeline context. This is updated as the mouse or pointer moves over the timeline.\n         * @member {TimelineContext} timelineContext\n         * @readonly\n         * @category Dates\n         */\n        timelineContext : {\n            $config : {\n                // Reject non-changes so that when set from scheduleMouseMove and EventMouseMove,\n                // we only update the context and fire events when it changes.\n                equal(c1, c2) {\n                    // index is the resource index, tickParentIndex is the\n                    // tick's index in the TimeAxis.\n                    return c1?.index === c2?.index &&\n                        c1?.tickParentIndex === c2?.tickParentIndex &&\n                        !((c1?.tickStartDate || 0) - (c2?.tickStartDate || 0));\n                }\n            }\n        },\n        updateTimelineContextOnScroll : false,\n        /**\n         * Set to `true` to ignore reacting to DOM events (mouseover/mouseout etc) while scrolling. Useful if you\n         * want to maximize scroll performance.\n         * @config {Boolean}\n         * @default false\n         */\n        ignoreDomEventsWhileScrolling : null\n    };\n    static properties = {\n        schedulerEvents : {\n            pointermove : 'handleScheduleEvent',\n            mouseover   : 'handleScheduleEvent',\n            mousedown   : 'handleScheduleEvent',\n            mouseup     : 'handleScheduleEvent',\n            click       : 'handleScheduleEvent',\n            dblclick    : 'handleScheduleEvent',\n            contextmenu : 'handleScheduleEvent',\n            mousemove   : 'handleScheduleEvent',\n            mouseout    : 'handleScheduleEvent'\n        }\n    };\n    static delayable = {\n        // Allow the scroll event to complete in its thread, and dispatch the mousemove event next AF\n        onScheduleScroll : 'raf'\n    };\n    // Currently hovered events (can be parent + child)\n    hoveredEvents = new Set();\n    //endregion\n    //region Init\n    /**\n     * Adds listeners for DOM events for the scheduler and its events.\n     * Which events is specified in Scheduler#schedulerEvents.\n     * @private\n     */\n    initDomEvents() {\n        const\n            me = this,\n            { schedulerEvents }  = me;\n        // Set thisObj and element of the configured listener specs.\n        schedulerEvents.element = me.timeAxisSubGridElement;\n        schedulerEvents.thisObj = me;\n        EventHelper.on(schedulerEvents);\n        EventHelper.on({\n            element    : me.timeAxisSubGridElement,\n            mouseleave : 'handleScheduleLeaveEvent',\n            capture    : true,\n            thisObj    : me\n        });\n        // This is to handle scroll events while the mouse is over the schedule.\n        // For example magic mouse or touchpad scrolls, or scrolls caused by keyboard\n        // navigation while the mouse happens to be over the schedule.\n        // The context must update. We must consider any scroll because the document\n        // or some other wrapping element could be scrolling the Scheduler under the mouse.\n        if (me.updateTimelineContextOnScroll && BrowserHelper.supportsPointerEventConstructor) {\n            EventHelper.on({\n                element : document,\n                scroll  : 'onScheduleScroll',\n                capture : true,\n                thisObj : me\n            });\n        }\n    };\n    //endregion\n    //region Event handling\n    getTimeSpanMouseEventParams(eventElement, event) {\n        throw new Error('Implement in subclass');\n    }\n    getScheduleMouseEventParams(cellData, event) {\n        throw new Error('Implement in subclass');\n    }\n    /**\n     * Wraps dom Events for the scheduler and event bars and fires as our events.\n     * For example click -> scheduleClick or eventClick\n     * @private\n     * @param event\n     */\n    handleScheduleEvent(event) {\n        const me = this;\n        if (me.ignoreDomEventsWhileScrolling && (me.scrolling || me.timeAxisSubGrid.scrolling)) {\n            return;\n        }\n        const timelineContext = me.getTimelineEventContext(event);\n        // Cache the last pointer event so that  when scrolling below the mouse\n        // we can inject mousemove events at that point.\n        me.lastPointerEvent = event;\n        // We are over the schedule region\n        if (timelineContext) {\n            // Only fire a scheduleXXXX event if we are *not* over an event.\n            // If over an event fire (event|task)XXXX.\n            me.trigger(`${timelineContext.eventElement ? me.scheduledEventName : 'schedule'}${eventNameMap[event.type] || StringHelper.capitalize(event.type)}`, timelineContext);\n        }\n        // If the context has changed, updateTimelineContext will fire events\n        me.timelineContext = timelineContext;\n    }\n    handleScheduleLeaveEvent(event) {\n        if (event.target === this.timeAxisSubGridElement) {\n            this.handleScheduleEvent(event);\n        }\n    }\n    /**\n     * This handles the scheduler being scrolled below the mouse by trackpad or keyboard events.\n     * The context, if present needs to be recalculated.\n     * @private\n     */\n    onScheduleScroll({ target }) {\n        const me = this;\n        // If the latest mouse event resulted in setting a context, we need to reproduce that event at the same clientX,\n        // clientY in order to keep the context up to date while scrolling.\n        // If the scroll is because of a pan feature drag (on us or a partner), we must not do this.\n        // Target might be removed in salesforce by Locker Service if scroll event occurs on body\n        if (\n            target && me.updateTimelineContextOnScroll && !me.features.pan?.isActive &&\n            !me.partners.some(p => p.features.pan?.isActive) &&\n            (target.contains(me.element) || me.bodyElement.contains(target))\n        ) {\n            const { timelineContext, lastPointerEvent } = me;\n            if (timelineContext) {\n                const\n                    targetElement = DomHelper.elementFromPoint(timelineContext.domEvent.clientX, timelineContext.domEvent.clientY),\n                    pointerEvent  = new BrowserHelper.PointerEventConstructor('pointermove', lastPointerEvent),\n                    mouseEvent    = new MouseEvent('mousemove', lastPointerEvent);\n                // See https://github.com/bryntum/support/issues/6274\n                // The pointerId does not propagate correctly on the synthetic PointerEvent, but also is readonly, so\n                // redefine the property. This is required by Ext JS gesture publisher which tracks pointer movements\n                // while a pointer is down. Without the correct pointerId, Ext JS would see this move as a \"missed\"\n                // pointerdown and forever await its pointerup (i.e., it would get stuck in the activeTouches). This\n                // would cause all future events to be perceived as part of or the end of a drag and would never again\n                // dispatch pointer events correctly. Finally, lastPointerEvent.pointerId is often incorrect (undefined\n                // in fact), so check the most recent pointerdown/touchstart event and default to 1\n                Object.defineProperty(pointerEvent, 'pointerId', {\n                    value : GlobalEvents.currentPointerDown?.pointerId ?? GlobalEvents.currentTouch?.identifier ?? 1\n                });\n                // Drag code should ignore these synthetic events\n                pointerEvent.scrollInitiated = mouseEvent.scrollInitiated = true;\n                // Emulate the correct browser sequence for mouse move events\n                targetElement?.dispatchEvent(pointerEvent);\n                targetElement?.dispatchEvent(mouseEvent);\n            }\n        }\n    }\n    updateTimelineContext(context, oldContext) {\n        /**\n         * Fired when the pointer-activated {@link #property-timelineContext} has changed.\n         * @event timelineContextChange\n         * @param {TimelineContext} oldContext The tick/resource context being deactivated.\n         * @param {TimelineContext} context The tick/resource context being activated.\n         */\n        this.trigger('timelineContextChange', { oldContext, context });\n        if (context && !oldContext) {\n            this.trigger('scheduleMouseEnter', context);\n        }\n        else if (!context) {\n            this.trigger('scheduleMouseLeave', { event : oldContext.event });\n        }\n    }\n    /**\n     * Gathers contextual information about the schedule contextual position of the passed event.\n     *\n     * Used by schedule mouse event handlers, but also by the scheduleContext feature.\n     * @param {Event} domEvent The DOM event to gather context for.\n     * @returns {TimelineContext} the schedule DOM event context\n     * @internal\n     */\n    getTimelineEventContext(domEvent) {\n        const\n            me           = this,\n            eventElement = domEvent.target.closest(me.eventInnerSelector),\n            cellElement  = me.getCellElementFromDomEvent(domEvent);\n        if (cellElement) {\n            const date = me.getDateFromDomEvent(domEvent, 'floor');\n            if (!date) {\n                return;\n            }\n            const\n                cellData    = DomDataStore.get(cellElement),\n                mouseParams = eventElement ? me.getTimeSpanMouseEventParams(eventElement, domEvent) : me.getScheduleMouseEventParams(cellData, domEvent);\n            if (!mouseParams) {\n                return;\n            }\n            const\n                index     = me.isVertical ? me.resourceStore.indexOf(mouseParams.resourceRecord) : cellData.row.dataIndex,\n                tickIndex = me.timeAxis.getTickFromDate(date),\n                tick      = me.timeAxis.getAt(Math.floor(tickIndex));\n            if (tick) {\n                return {\n                    isTimelineContext : true,\n                    domEvent,\n                    eventElement,\n                    cellElement,\n                    index,\n                    tick,\n                    tickIndex,\n                    date,\n                    tickStartDate     : tick.startDate,\n                    tickEndDate       : tick.endDate,\n                    tickParentIndex   : tick.parentIndex,\n                    row               : cellData.row,\n                    event             : domEvent,\n                    ...mouseParams\n                };\n            }\n        }\n    }\n    getCellElementFromDomEvent({ target, clientY, type }) {\n        const\n            me           = this,\n            {\n                isVertical,\n                foregroundCanvas\n            }            = me,\n            eventElement = target.closest(me.eventSelector);\n        // If event was on an event bar, calculate the cell.\n        if (eventElement) {\n            const record = !isVertical && (me.resolveRowRecord(eventElement) || me.store.getAt(me.rowManager.getRowAt(clientY, false).dataIndex));\n            return me.getCell({\n                [isVertical ? 'row' : 'record'] : isVertical ? 0 : record,\n                column                          : me.timeAxisColumn\n            });\n        }\n        // If event was triggered by an element in the foreground canvas, but not an event element\n        // we need to ascertain the cell \"behind\" that element to be able to create the context.\n        else if (foregroundCanvas.contains(target)) {\n            // Only trigger a Scheduler event if the event was on the background itself.\n            // Otherwise, we will trigger unexpected events on things like dependency lines which historically\n            // have never triggered scheduleXXXX events. The exception to this is the mousemove event which\n            // needs to always fire so that timelineContext and scheduleTooltip correctly track the mouse\n            if (target === foregroundCanvas || type === 'mousemove') {\n                return me.rowManager.getRowAt(clientY, false)?.getCell(me.timeAxisColumn.id);\n            }\n        }\n        else {\n            // Event was inside a row, or on a row border.\n            return target.matches('.b-grid-row') ? target.firstElementChild : target.closest(me.timeCellSelector);\n        }\n    }\n    // Overridden by ResourceTimeRanges to \"pass events through\" to the schedule\n    matchScheduleCell(element) {\n        return element.closest(this.timeCellSelector);\n    }\n    onElementMouseButtonEvent(event) {\n        const targetCell = event.target.closest('.b-sch-header-timeaxis-cell');\n        if (targetCell) {\n            const\n                me           = this,\n                position     = targetCell.parentElement.dataset.headerPosition,\n                headerCells  = me.timeAxisViewModel.columnConfig[position],\n                index        = me.timeAxis.isFiltered ? headerCells.findIndex(cell => cell.index == targetCell.dataset.tickIndex) : targetCell.dataset.tickIndex,\n                cellConfig   = headerCells[index],\n                contextMenu  = me.features.contextMenu;\n            // Skip same events with Grid context menu triggerEvent\n            if (!contextMenu || event.type !== contextMenu.triggerEvent) {\n                this.trigger(`timeAxisHeader${StringHelper.capitalize(event.type)}`, {\n                    startDate : cellConfig.start,\n                    endDate   : cellConfig.end,\n                    event\n                });\n            }\n        }\n    }\n    onElementMouseDown(event) {\n        this.onElementMouseButtonEvent(event);\n        super.onElementMouseDown(event);\n    }\n    onElementClick(event) {\n        this.onElementMouseButtonEvent(event);\n        super.onElementClick(event);\n    }\n    onElementDblClick(event) {\n        this.onElementMouseButtonEvent(event);\n        super.onElementDblClick(event);\n    }\n    onElementContextMenu(event) {\n        this.onElementMouseButtonEvent(event);\n        super.onElementContextMenu(event);\n    }\n    /**\n     * Relays mouseover events as eventmouseenter if over rendered event.\n     * Also adds Scheduler#overScheduledEventClass to the hovered element.\n     * @private\n     */\n    onElementMouseOver(event) {\n        const\n            me                = this;\n        if (me.ignoreDomEventsWhileScrolling && (me.scrolling || me.timeAxisSubGrid.scrolling)) {\n            return;\n        }\n        super.onElementMouseOver(event);\n        const\n            { target }        = event,\n            { hoveredEvents } = me;\n        // We must be over the event or dependency terminal hover area\n        if ((target.closest(me.eventInnerSelector) || target.matches('.b-sch-terminal-hover-area')) && !me.features.eventDrag?.isDragging) {\n            const eventElement = target.closest(me.eventSelector);\n            if (!hoveredEvents.has(eventElement) && !me.preventOverCls) {\n                hoveredEvents.add(eventElement);\n                eventElement.classList.add(me.overScheduledEventClass);\n                const params = me.getTimeSpanMouseEventParams(eventElement, event);\n                if (params) {\n                    // do not fire this event if model cannot be found\n                    // this can be the case for \"b-sch-dragcreator-proxy\" elements for example\n                    me.trigger(`${me.scheduledEventName}MouseEnter`, params);\n                }\n            }\n        }\n        else if (hoveredEvents.size) {\n            me.unhoverAll(event);\n        }\n    }\n    /**\n     * Relays mouseout events as eventmouseleave if out from rendered event.\n     * Also removes Scheduler#overScheduledEventClass from the hovered element.\n     * @private\n     */\n    onElementMouseOut(event) {\n        const\n            me                        = this,\n            { features }              = me,\n            { target, relatedTarget } = event;\n        // If it's not a mouseout into an event (or anything inside one of the schedule's\n        // extra drawing canvases), continue up to the Grid base.\n        // A mouseout cell->(event|dep-line|timeRange) should *not* trigger a mouseout of the cell\n        // or row even though the event element is in fact outside. To a user, the event is in the cell.\n        if (!relatedTarget?.closest('.b-sch-canvas *')) {\n            super.onElementMouseOut(event);\n        }\n        const\n            eventWrap      = target.closest(me.eventSelector),\n            eventInner     = eventWrap?.querySelector(me.eventInnerSelector),\n            timeSpanRecord = eventWrap && me.resolveTimeSpanRecord(eventWrap);\n        // We must be over the event bar\n        if (eventInner && timeSpanRecord && me.hoveredEvents.has(eventWrap) && !features.eventDrag?.isDragging) {\n            // out to child or terminal hover area shouldn't count...\n            if (relatedTarget && (DomHelper.isDescendant(eventInner, relatedTarget) || relatedTarget.matches('.b-sch-terminal-hover-area'))) {\n                return;\n            }\n        }\n        if (eventWrap) {\n            me.unhover(eventWrap, event);\n        }\n    }\n    unhover(element, event) {\n        const me = this;\n        element.classList.remove(me.overScheduledEventClass);\n        me.trigger(`${me.scheduledEventName}MouseLeave`, me.getTimeSpanMouseEventParams(element, event));\n        me.hoveredEvents.delete(element);\n    }\n    unhoverAll(event) {\n        for (const element of this.hoveredEvents) {\n            !element.isReleased && !element.classList.contains('b-released') && this.unhover(element, event);\n        }\n        // Might not be empty because of conditional unhover above\n        this.hoveredEvents.clear();\n    }\n    //endregion\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport PresetManager from '../../preset/PresetManager.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport PresetStore from '../../preset/PresetStore.js';\nimport DateHelper, { unitMagnitudes } from '../../../Core/helper/DateHelper.js';\n/**\n * @module Scheduler/view/mixin/TimelineViewPresets\n */\n/**\n * View preset handling.\n *\n * A Scheduler's {@link #config-presets} are loaded with a default set of {@link Scheduler.preset.ViewPreset ViewPresets}\n * which are defined by the system in the {@link Scheduler.preset.PresetManager PresetManager}.\n *\n * The zooming feature works by reconfiguring the Scheduler with a new {@link Scheduler.preset.ViewPreset ViewPreset} selected\n * from the {@link #config-presets} store.\n *\n * {@link Scheduler.preset.ViewPreset ViewPresets} can be added and removed from the store to change the amount of available steps.\n * Range of zooming in/out can be also modified with {@link Scheduler.view.mixin.TimelineZoomable#config-maxZoomLevel} / {@link Scheduler.view.mixin.TimelineZoomable#config-minZoomLevel} properties.\n *\n * This mixin adds additional methods to the column : {@link Scheduler.view.mixin.TimelineZoomable#property-maxZoomLevel}, {@link Scheduler.view.mixin.TimelineZoomable#property-minZoomLevel}, {@link Scheduler.view.mixin.TimelineZoomable#function-zoomToLevel}, {@link Scheduler.view.mixin.TimelineZoomable#function-zoomIn},\n * {@link Scheduler.view.mixin.TimelineZoomable#function-zoomOut}, {@link Scheduler.view.mixin.TimelineZoomable#function-zoomInFull}, {@link Scheduler.view.mixin.TimelineZoomable#function-zoomOutFull}.\n *\n * **Notice**: Zooming is not supported when `forceFit` option is set to true for the Scheduler or for filtered timeaxis.\n *\n * @mixin\n */\nexport default Target => class TimelineViewPresets extends (Target || Base) {\n    static get $name() {\n        return 'TimelineViewPresets';\n    }\n    //region Default config\n    static get configurable() {\n        return {\n            /**\n             * A string key used to lookup a predefined {@link Scheduler.preset.ViewPreset} (e.g. 'weekAndDay', 'hourAndDay'),\n             * managed by {@link Scheduler.preset.PresetManager}. See {@link Scheduler.preset.PresetManager} for more information.\n             * Or a config object for a viewPreset.\n             *\n             * Options:\n             * - 'secondAndMinute'\n             * - 'minuteAndHour'\n             * - 'hourAndDay'\n             * - 'dayAndWeek'\n             * - 'dayAndMonth'\n             * - 'weekAndDay'\n             * - 'weekAndMonth',\n             * - 'monthAndYear'\n             * - 'year'\n             * - 'manyYears'\n             * - 'weekAndDayLetter'\n             * - 'weekDateAndMonth'\n             * - 'day'\n             * - 'week'\n             *\n             * If passed as a config object, the settings from the viewPreset with the provided `base` property will be used along\n             * with any overridden values in your object.\n             *\n             * To override:\n             * ```javascript\n             * viewPreset : {\n             *   base    : 'hourAndDay',\n             *   id      : 'myHourAndDayPreset',\n             *   headers : [\n             *       {\n             *           unit      : \"hour\",\n             *           increment : 12,\n             *           renderer  : (startDate, endDate, headerConfig, cellIdx) => {\n             *               return \"\";\n             *           }\n             *       }\n             *   ]\n             * }\n             * ```\n             * or set a new valid preset config if the preset is not registered in the {@link Scheduler.preset.PresetManager}.\n             *\n             * When you use scheduler in weekview mode, this config is used to pick view preset. If passed view preset is not\n             * supported by weekview (only 2 supported by default - 'day' and 'week') default preset will be used - 'week'.\n             * @config {String|ViewPresetConfig}\n             * @default\n             * @category Common\n             */\n            viewPreset : 'weekAndDayLetter',\n            /**\n             * Get the {@link Scheduler.preset.PresetStore} created for the Scheduler,\n             * or set an array of {@link Scheduler.preset.ViewPreset} config objects.\n             * @member {Scheduler.preset.PresetStore|ViewPresetConfig[]} presets\n             * @category Common\n             */\n            /**\n             * An array of {@link Scheduler.preset.ViewPreset} config objects\n             * which describes the available timeline layouts for this scheduler.\n             *\n             * By default, a predefined set is loaded from the {@link Scheduler.preset.PresetManager}.\n             *\n             * A {@link Scheduler.preset.ViewPreset} describes the granularity of the\n             * timeline view and the layout and subdivisions of the timeline header.\n             * @config {ViewPresetConfig[]} presets\n             *\n             * @category Common\n             */\n            presets : true,\n            /**\n             * Defines how dates will be formatted in tooltips etc. This config has priority over similar config on the\n             * view preset. For allowed values see {@link Core.helper.DateHelper#function-format-static}.\n             *\n             * By default, this is ingested from {@link Scheduler.preset.ViewPreset} upon change of\n             * {@link Scheduler.preset.ViewPreset} (Such as when zooming in or out). But Setting this\n             * to your own value, overrides that behaviour.\n             * @prp {String}\n             * @category Scheduled events\n             */\n            displayDateFormat : null\n        };\n    }\n    //endregion\n    /**\n     * Get/set the current view preset\n     * @member {Scheduler.preset.ViewPreset|ViewPresetConfig|String} viewPreset\n     * @param [viewPreset.options]\n     * @param {Date} [viewPreset.options.startDate] A new start date for the time axis\n     * @param {Date} [viewPreset.options.endDate] A new end date for the time axis\n     * @param {Date} [viewPreset.options.centerDate] Where to center the new time axis\n     * @param {Number} [viewPreset.options.scrollPosition] The scroll position to scroll\n     * the new time axis to. This takes precedence over any date-scrolling.\n     * It is used when partnering two timelines which must be scroll-synced.\n     * @category Common\n    */\n    //region Get/set\n    changePresets(presets) {\n        const config = {\n            owner : this\n        };\n        let data = [];\n        // By default includes all presets\n        if (presets === true) {\n            data = PresetManager.allRecords;\n        }\n        // Accepts an array of presets\n        else if (Array.isArray(presets)) {\n            for (const preset of presets) {\n                // If we got a presetId\n                if (typeof preset === 'string') {\n                    const presetRecord = PresetManager.getById(preset);\n                    if (presetRecord) {\n                        data.push(presetRecord);\n                    }\n                }\n                else {\n                    data.push(preset);\n                }\n            }\n        }\n        // Or a store config object\n        else {\n            ObjectHelper.assign(config, presets);\n        }\n        // Creates store first and then adds data, because data config does not support a mix of raw objects and records.\n        const presetStore = new PresetStore(config);\n        presetStore.add(data);\n        return presetStore;\n    }\n    changeViewPreset(viewPreset, oldViewPreset) {\n        const\n            me           = this,\n            { presets } = me;\n        if (viewPreset) {\n            viewPreset = presets.createRecord(viewPreset);\n            // If an existing ViewPreset id is used, this will replace it.\n            if (!presets.includes(viewPreset)) {\n                presets.add(viewPreset);\n            }\n        }\n        else {\n            viewPreset = presets.first;\n        }\n        const\n            lastOpts = me.lastViewPresetOptions || {},\n            options  = viewPreset.options || (viewPreset.options = {}),\n            event    = {\n                ...options,\n                from   : oldViewPreset,\n                to     : viewPreset,\n                preset : viewPreset\n            },\n            presetChanged  = !me._viewPreset || !me._viewPreset.equals(viewPreset);\n        delete lastOpts.event;\n        // Only return the value for onward processing if there's a change\n        if (presetChanged || !ObjectHelper.isEqual(options, lastOpts)) {\n            // Assign event after comparison, to not have it get super expensive\n            options.event = event;\n            // Bypass the no-change check if the viewPreset is the same and we only got in here\n            // because different options were asked for.\n            if (!presetChanged) {\n                me._viewPreset = null;\n            }\n            /**\n             * Fired before the {@link #config-viewPreset} is changed.\n             * @event beforePresetChange\n             * @param {Scheduler.view.Scheduler} source This Scheduler instance.\n             * @param {Date} startDate The new start date of the timeline.\n             * @param {Date} endDate The new end date of the timeline.\n             * @param {Scheduler.preset.ViewPreset} from The outgoing ViewPreset.\n             * @param {Scheduler.preset.ViewPreset} to The ViewPreset being switched to.\n             * @preventable\n             */\n            // Do not trigger events for the initial preset\n            if (me.isConfiguring || me.trigger('beforePresetChange', event) !== false) {\n                return viewPreset;\n            }\n        }\n    }\n    get displayDateFormat() {\n        return this._displayDateFormat || this.viewPreset.displayDateFormat;\n    }\n    updateDisplayDateFormat(format) {\n        // Start/EndDateColumn listens for this to change their format to match\n        this.trigger('displayDateFormatChange', { format });\n    }\n    /**\n     * Method to get a formatted display date\n     * @private\n     * @param {Date} date The date\n     * @returns {String} The formatted date\n     */\n    getFormattedDate(date) {\n        return DateHelper.format(date, this.displayDateFormat);\n    }\n    updateViewPreset(preset) {\n        const\n            me          = this,\n            { options } = preset,\n            {\n                event,\n                startDate,\n                endDate\n            }           = options,\n            {\n                isHorizontal,\n                _timeAxis : timeAxis,    // Do not tickle the getter, we are just peeking to see if it's there yet.\n                _timeAxisViewModel : timeAxisViewModel // Ditto\n            } = me,\n            rtl = isHorizontal && me.rtl;\n        let\n            {\n                centerDate,\n                zoomDate,\n                zoomPosition\n            }           = options,\n            forceUpdate = false;\n        me.syncSplits?.(split => split.viewPreset = preset);\n        // Options must not be reused when this preset is used again.\n        delete preset.options;\n        // Raise flag to prevent partner from changing view preset if one is in progress\n        me._viewPresetChanging = true;\n        if (timeAxis && !me.isConfiguring) {\n            const { timelineScroller } = me;\n            // Cache options only when they are applied so that non-change vetoing in changeViewPreset is accurate\n            me.lastViewPresetOptions = options;\n            // Timeaxis may already be configured (in case of sharing with the timeline partner), no need to reconfigure it\n            if (timeAxis.isConfigured) {\n                // None of this reconfiguring should cause a refresh\n                me.suspendRefresh();\n                // Set up these configs only if we actually have them.\n                const timeAxisCfg = ObjectHelper.copyProperties({}, me, [\n                    'weekStartDay',\n                    'startTime',\n                    'endTime'\n                ]);\n                if (me.infiniteScroll) {\n                    Object.assign(timeAxisCfg, me.calculateInfiniteScrollingDateRange(\n                        centerDate || (startDate && endDate ? new Date((startDate.getTime() + endDate.getTime()) / 2) : me.viewportCenterDateCached),\n                        true,\n                        preset\n                    ));\n                }\n                // if startDate is provided we use it and the provided endDate\n                else if (startDate) {\n                    timeAxisCfg.startDate = startDate;\n                    timeAxisCfg.endDate = endDate;\n                    // if both dates are provided we can calculate centerDate for the viewport\n                    if (!centerDate && endDate) {\n                        centerDate = new Date((startDate.getTime() + endDate.getTime()) / 2);\n                    }\n                    // when no start/end dates are provided we use the current timespan\n                }\n                else {\n                    timeAxisCfg.startDate = timeAxis.startDate;\n                    timeAxisCfg.endDate = endDate || timeAxis.endDate;\n                    if (!centerDate) {\n                        centerDate = me.viewportCenterDate;\n                    }\n                }\n                timeAxis.isConfigured = false;\n                timeAxisCfg.viewPreset = preset;\n                timeAxis.reconfigure(timeAxisCfg, true);\n                timeAxisViewModel.reconfigure({\n                    viewPreset : preset,\n                    headers    : preset.headers,\n                    // This was hardcoded to 'middle' prior to the Preset refactor.\n                    // In the old code, the default headers were 'top' and 'middle', which\n                    // meant that 'middle' meant the lowest header.\n                    // So this is now length - 1.\n                    columnLinesFor : preset.columnLinesFor != null ? preset.columnLinesFor : preset.headers.length - 1,\n                    tickSize : options.tickSize || (isHorizontal ? preset.tickWidth : preset.tickHeight || preset.tickWidth || 60)\n                });\n                // A ViewPreset is extremely opinionated about its tickSize and imposes it upon the Scheduler.\n                // Allow the caller to correct the tick size after the reconfigure using the options block.\n                if (options.tickSize) {\n                    me.tickSize = options.tickSize;\n                }\n                // Allow refresh to run after the reconfiguring, without refreshing since we will do that below anyway\n                me.resumeRefresh(false);\n            }\n            me.refresh();\n            // if view is rendered and scroll is not disabled by \"notScroll\" option\n            if (!options.notScroll && me.isPainted) {\n                if ('scrollPosition' in options) {\n                    // If we are not going to end up scrolling, we need to force an update\n                    forceUpdate = timelineScroller.position === options.scrollPosition;\n                    timelineScroller.scrollTo(options.scrollPosition);\n                }\n                else if (options.visibleDate) {\n                    me.visibleDate = options.visibleDate;\n                }\n                // If a zoom at a certain date position is being requested, scroll the zoomDate\n                // to the required zoomPosition so that the zoom happens centered where the\n                // pointer events that are driving it targeted.\n                else if (zoomDate && zoomPosition) {\n                    const\n                        unitMagnitude = unitMagnitudes[timeAxis.resolutionUnit],\n                        unit          = unitMagnitude > 3 ? 'hour' : 'minute',\n                        milliseconds  = DateHelper.asMilliseconds((unit === 'minute' ? 15 : 1), unit),\n                        // Round the date to either 15 minutes for fine levels or 1 hour for coarse levels\n                        targetDate    = new Date(Math.round(zoomDate / milliseconds) * milliseconds);\n                    // setViewPreset method on partner panels should be executed with same arguments.\n                    // if one partner was provided with zoom info, other one has to be too to generate exact\n                    // header and set same scroll\n                    event.zoomDate = zoomDate;\n                    event.zoomPosition = zoomPosition;\n                    event.zoomLevel = options.zoomLevel;\n                    // Move the targetDate back under the mouse position as indicated by zoomPosition.\n                    // That is the offset into the TimeAxisSubGridElement.\n                    if (rtl) {\n                        timelineScroller.position = timelineScroller.scrollWidth - (me.getCoordinateFromDate(targetDate) + zoomPosition);\n                    }\n                    else {\n                        timelineScroller.position = me.getCoordinateFromDate(targetDate) - zoomPosition;\n                    }\n                }\n                // and we have centerDate to scroll to\n                else if (centerDate) {\n                    // remember the central date we scroll to (it gets reset after user scroll)\n                    me.cachedCenterDate = centerDate;\n                    // setViewPreset method on partner panels should be executed with same arguments.\n                    // if one partner was provided with a centerDate, other one has to be too to generate exact\n                    // header and set same scroll\n                    event.centerDate = centerDate;\n                    const\n                        viewportSize = me.timelineScroller.clientSize,\n                        centerCoord  = rtl ? me.timeAxisViewModel.totalSize - me.getCoordinateFromDate(centerDate, true)\n                            : me.getCoordinateFromDate(centerDate, true),\n                        coord        = Math.max(centerCoord - viewportSize / 2, 0);\n                    // If preset change does not lead to a scroll we have to \"refresh\" manually at the end\n                    if (coord === (me.isHorizontal ? me.scrollLeft : me.scrollTop)) {\n                        forceUpdate = true;\n                    }\n                    else if (me.isHorizontal) {\n                        me.scrollHorizontallyTo(coord, { scrollingToCenter : true });\n                    }\n                    else {\n                        me.scrollVerticallyTo(coord, { scrollingToCenter : true });\n                    }\n                }\n                else {\n                    // If preset change does not lead to a scroll we have to \"refresh\" manually at the end\n                    if ((me.isHorizontal ? me.scrollLeft : me.scrollTop) === 0) {\n                        forceUpdate = true;\n                    }\n                    // If we don't have a center date to scroll to, we reset scroll (this is bw compatible behavior)\n                    else {\n                        me.timelineScroller.scrollTo(0);\n                    }\n                }\n            }\n        }\n        // Update Scheduler element showing what preset is applied\n        me.dataset.presetId = preset.id;\n        /**\n         * Fired after the {@link #config-viewPreset} has changed.\n         * @event presetChange\n         * @param {Scheduler.view.Scheduler} source This Scheduler instance.\n         * @param {Date} startDate The new start date of the timeline.\n         * @param {Date} centerDate The new center date of the timeline.\n         * @param {Date} endDate The new end date of the timeline.\n         * @param {Scheduler.preset.ViewPreset} from The outgoing ViewPreset.\n         * @param {Scheduler.preset.ViewPreset} to The ViewPreset being switched to.\n         * @preventable\n         */\n        me.trigger('presetChange', event);\n        me._viewPresetChanging = false;\n        if (forceUpdate) {\n            if (me.isHorizontal) {\n                me.currentOrientation.updateFromHorizontalScroll(me.scrollLeft, true);\n            }\n            else {\n                me.currentOrientation.updateFromVerticalScroll(me.scrollTop);\n            }\n        }\n    }\n    //endregion\n    doDestroy() {\n        if (this._presets.owner === this) {\n            this._presets.destroy();\n        }\n        super.doDestroy();\n    }\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    getCurrentConfig(options) {\n        const result = super.getCurrentConfig(options);\n        // Cannot store name, will not be allowed when reapplying\n        if (result.viewPreset && result.viewPreset.name && !result.viewPreset.base) {\n            delete result.viewPreset.name;\n        }\n        return result;\n    }\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\n/**\n * @module Scheduler/view/mixin/TimelineZoomable\n */\n/**\n * Options which may be used when changing the {@link Scheduler.view.Scheduler#property-viewPreset} property.\n *\n * @typedef {Object} ChangePresetOptions\n * @property {VisibleDate} [visibleDate] A `visibleDate` specification to bring into view after the new\n * `ViewPreset` is applied.\n * @property {Date} [startDate] New time frame start. If provided along with end, view will be centered in this\n * time interval, ignoring centerDate config. __Ignored if {@link Scheduler.view.Scheduler#config-infiniteScroll} is used.__\n * @property {Date} [endDate] New time frame end. __Ignored if {@link Scheduler.view.Scheduler#config-infiniteScroll} is used.__\n * @property {Date} [centerDate] Date to keep in center. Is ignored when start and end are provided.\n * @property {Date} [zoomDate] The date that should be positioned at the passed `datePosition` client offset.\n * @property {Number} [zoomPosition] The client offset at which the passed `zoomDate` should be positioned.\n * @property {Number} [width] Lowest tick width. Might be increased automatically\n */\n/**\n * Mixin providing \"zooming\" functionality.\n *\n * The zoom levels are stored as instances of {@link Scheduler.preset.ViewPreset}s, and are\n * cached centrally in the {@link Scheduler.preset.PresetManager}.\n *\n * The default presets are loaded into the {@link Scheduler.view.mixin.TimelineViewPresets#config-presets}\n * store upon Scheduler instantiation. Preset selection is covered in the\n * {@link Scheduler.view.mixin.TimelineViewPresets} mixin.\n *\n * To specify custom zoom levels please provide a set of view presets to the global PresetManager store **before**\n * scheduler creation, or provide a set of view presets to a specific scheduler only:\n *\n * ```javascript\n * const myScheduler = new Scheduler({\n *     presets : [\n *         {\n *             base : 'hourAndDay',\n *             id   : 'MyHourAndDay',\n *             // other preset configs....\n *         },\n *         {\n *             base : 'weekAndMonth',\n *             id   : 'MyWeekAndMonth',\n *             // other preset configs....\n *         }\n *     ],\n *     viewPreset : 'MyHourAndDay',\n *     // other scheduler configs....\n *     });\n * ```\n *\n * @mixin\n */\nexport default Target => class TimelineZoomable extends (Target || Base) {\n    static $name = 'TimelineZoomable';\n    static defaultConfig = {\n        /**\n         * If true, you can zoom in and out on the time axis using CTRL-key + mouse wheel.\n         * @config {Boolean}\n         * @default\n         * @category Zoom\n         */\n        zoomOnMouseWheel : true,\n        /**\n         * True to zoom to time span when double-clicking a time axis cell.\n         * @config {Boolean}\n         * @default\n         * @category Zoom\n         */\n        zoomOnTimeAxisDoubleClick : true,\n        /**\n         * The minimum zoom level to which {@link #function-zoomOut} will work. Defaults to 0 (year ticks)\n         * @config {Number}\n         * @category Zoom\n         * @default\n         */\n        minZoomLevel : 0,\n        /**\n         * The maximum zoom level to which {@link #function-zoomIn} will work. Defaults to the number of\n         * {@link Scheduler.preset.ViewPreset ViewPresets} available, see {@link Scheduler/view/mixin/TimelineViewPresets#property-presets}\n         * for information. Unless you have modified the collection of available presets, the max zoom level is\n         * milliseconds.\n         * @config {Number}\n         * @category Zoom\n         * @default 23\n         */\n        maxZoomLevel : null,\n        /**\n         * Integer number indicating the size of timespan during zooming. When zooming, the timespan is adjusted to make\n         * the scrolling area `visibleZoomFactor` times wider than the timeline area itself. Used in\n         * {@link #function-zoomToSpan} and {@link #function-zoomToLevel} functions.\n         * @config {Number}\n         * @default\n         * @category Zoom\n         */\n        visibleZoomFactor : 5,\n        /**\n         * Whether the originally rendered timespan should be preserved while zooming. By default, it is set to `false`,\n         * meaning the timeline panel will adjust the currently rendered timespan to limit the amount of HTML content to\n         * render. When setting this option to `true`, be careful not to allow to zoom a big timespan in seconds\n         * resolution for example. That will cause **a lot** of HTML content to be rendered and affect performance. You\n         * can use {@link #config-minZoomLevel} and {@link #config-maxZoomLevel} config options for that.\n         * @config {Boolean}\n         * @default\n         * @category Zoom\n         */\n        zoomKeepsOriginalTimespan : null\n    };\n    // We cache the last mousewheel position, so that during zooming we can\n    // maintain a stable zoom point even if the mouse moves a little.\n    lastWheelTime = -1;\n    lastZoomPosition = -1;\n    construct(config) {\n        const me = this;\n        super.construct(config);\n        if (me.zoomOnMouseWheel) {\n            EventHelper.on({\n                element   : me.timeAxisSubGridElement,\n                wheel     : 'onWheel',\n                // Throttle zooming with the wheel a bit to have greater control of it\n                throttled : {\n                    buffer : 100,\n                    // Prevent events from slipping through the throttle, causing scroll\n                    alt    : e => e.ctrlKey && e.preventDefault()\n                },\n                thisObj : me,\n                capture : true,\n                passive : false\n            });\n        }\n        if (me.zoomOnTimeAxisDoubleClick) {\n            me.ion({\n                timeaxisheaderdblclick : ({ startDate, endDate }) => {\n                    if (!me.forceFit) {\n                        me.zoomToSpan({\n                            startDate,\n                            endDate\n                        });\n                    }\n                }\n            });\n        }\n    }\n    get maxZoomLevel() {\n        return this._maxZoomLevel || (this.presets.count - 1);\n    }\n    /**\n     * Get/set the {@link #config-maxZoomLevel} value\n     * @property {Number}\n     * @category Zoom\n     */\n    set maxZoomLevel(level) {\n        if (typeof level !== 'number') {\n            level = this.presets.count - 1;\n        }\n        if (level < 0 || level >= this.presets.count) {\n            throw new Error('Invalid range for `maxZoomLevel`');\n        }\n        this._maxZoomLevel = level;\n    }\n    get minZoomLevel() {\n        return this._minZoomLevel;\n    }\n    /**\n     * Sets the {@link #config-minZoomLevel} value\n     * @property {Number}\n     * @category Zoom\n     */\n    set minZoomLevel(level) {\n        if (typeof level !== 'number') {\n            level = 0;\n        }\n        if (level < 0 || level >= this.presets.count) {\n            throw new Error('Invalid range for `minZoomLevel`');\n        }\n        this._minZoomLevel = level;\n    }\n    /**\n     * Current zoom level, which is equal to the {@link Scheduler.preset.ViewPreset ViewPreset} index\n     * in the provided array of {@link Scheduler.view.mixin.TimelineViewPresets#config-presets zoom levels}.\n     * @property {Number}\n     * @category Zoom\n     */\n    get zoomLevel() {\n        return this.presets.indexOf(this.viewPreset);\n    }\n    // noinspection JSAnnotator\n    set zoomLevel(level) {\n        this.zoomToLevel(level);\n    }\n    /**\n     * Returns number of milliseconds per pixel.\n     * @param {Object} level Element from array of {@link Scheduler.view.mixin.TimelineViewPresets#config-presets}.\n     * @param {Boolean} ignoreActualWidth If true, then density will be calculated using default zoom level settings.\n     * Otherwise, density will be calculated for actual tick width.\n     * @returns {Number} Return number of milliseconds per pixel.\n     * @private\n     */\n    getMilliSecondsPerPixelForZoomLevel(preset, ignoreActualWidth) {\n        const\n            { bottomHeader } = preset,\n            // Scheduler uses direction independent tickSize, but presets are allowed to define different sizes for\n            // vertical and horizontal -> cant use preset.tickSize here\n            width            = this.isHorizontal ? preset.tickWidth : preset.tickHeight;\n        // trying to convert the unit + increment to a number of milliseconds\n        // this number is not fixed (month can be 28, 30 or 31 day), but at least this conversion\n        // will be consistent (should be no DST changes at year 1)\n        return Math.round(\n            (DateHelper.add(new Date(1, 0, 1), bottomHeader.increment || 1, bottomHeader.unit) - new Date(1, 0, 1)) /\n            // `actualWidth` is a column width after view adjustments applied to it (see `calculateTickWidth`)\n            // we use it if available to return the precise index value from `getCurrentZoomLevelIndex`\n            (ignoreActualWidth ? width : preset.actualWidth || width)\n        );\n    }\n    /**\n     * Zooms to passed view preset, saving center date. Method accepts config object as a first argument, which can be\n     * reduced to primitive type (string,number) when no additional options required. e.g.:\n     * ```javascript\n     * // zooming to preset\n     * scheduler.zoomTo({ preset : 'hourAndDay' })\n     * // shorthand\n     * scheduler.zoomTo('hourAndDay')\n     *\n     * // zooming to level\n     * scheduler.zoomTo({ level : 0 })\n     * // shorthand\n     * scheduler.zoomTo(0)\n     * ```\n     *\n     * It is also possible to zoom to a time span by omitting `preset` and `level` configs, in which case scheduler sets\n     * the time frame to a specified range and applies zoom level which allows to fit all columns to this range. The\n     * given time span will be centered in the scheduling view (unless `centerDate` config provided). In the same time,\n     * the start/end date of the whole time axis will be extended to allow scrolling for user.\n     * ```javascript\n     * // zooming to time span\n     * scheduler.zoomTo({\n     *     startDate : new Date(..),\n     *     endDate : new Date(...)\n     * });\n     * ```\n     *\n     * @param {ViewPresetConfig|Object|String|Number} config Config object, preset name or zoom level index.\n     * @param {String} [config.preset] Preset name to zoom to. Ignores level config in this case\n     * @param {Number} [config.level] Zoom level to zoom to. Is ignored, if preset config is provided\n     * @param {VisibleDate} [config.visibleDate] A `visibleDate` specification to bring into view after the zoom.\n     * @param {Date} [config.startDate] New time frame start. If provided along with end, view will be centered in this\n     * time interval (unless `centerDate` is present)\n     * @param {Date} [config.endDate] New time frame end\n     * @param {Date} [config.centerDate] Date that should be kept in the center. Has priority over start and end params\n     * @param {Date} [config.zoomDate] The date that should be positioned at the passed `datePosition` client offset.\n     * @param {Number} [config.zoomPosition] The client offset at which the passed `date` should be positioned.\n     * @param {Number} [config.width] Lowest tick width. Might be increased automatically\n     * @param {Number} [config.leftMargin] Amount of pixels to extend span start on (used, when zooming to span)\n     * @param {Number} [config.rightMargin] Amount of pixels to extend span end on (used, when zooming to span)\n     * @param {Number} [config.adjustStart] Amount of units to extend span start on (used, when zooming to span)\n     * @param {Number} [config.adjustEnd] Amount of units to extend span end on (used, when zooming to span)\n     * @category Zoom\n     */\n    zoomTo(config) {\n        const me = this;\n        if (typeof config === 'object') {\n            if (config.preset) {\n                me.zoomToLevel(config.preset, config);\n            }\n            else if (config.level != null) {\n                me.zoomToLevel(config.level, config);\n            }\n            else {\n                me.zoomToSpan(config);\n            }\n        }\n        else {\n            me.zoomToLevel(config);\n        }\n    }\n    /**\n     * Allows zooming to certain level of {@link Scheduler.view.mixin.TimelineViewPresets#config-presets} array.\n     * Automatically limits zooming between {@link #config-maxZoomLevel} and {@link #config-minZoomLevel}. Can also set\n     * time axis timespan to the supplied start and end dates.\n     *\n     * @param {Number} preset Level to zoom to.\n     * @param {ChangePresetOptions} [options] Object containing options which affect how the new preset is applied.\n     * @returns {Number|null} level Current zoom level or null if it hasn't changed.\n     * @category Zoom\n     */\n    zoomToLevel(preset, options = {}) {\n        if (this.forceFit) {\n            console.warn('Warning: The forceFit setting and zooming cannot be combined');\n            return;\n        }\n        // Sanitize numeric zooming.\n        if (typeof preset === 'number') {\n            preset = Math.min(Math.max(preset, this.minZoomLevel), this.maxZoomLevel);\n        }\n        const\n            me                 = this,\n            { presets }       = me,\n            tickSizeProp       = me.isVertical ? 'tickHeight' : 'tickWidth',\n            newPreset          = presets.createRecord(preset),\n            configuredTickSize = newPreset[tickSizeProp],\n            startDate          = options.startDate ? new Date(options.startDate) : null,\n            endDate            = options.endDate ? new Date(options.endDate) : null;\n        // If an existing ViewPreset id is used, this will replace it.\n        presets.add(newPreset);\n        let span = startDate && endDate ? { startDate, endDate } : null;\n        const\n            centerDate             = options.centerDate ? new Date(options.centerDate) : (span ? new Date((startDate.getTime() + endDate.getTime()) / 2) : me.viewportCenterDateCached);\n        let scrollableViewportSize = me.isVertical ? me.scrollable.clientHeight : me.timeAxisSubGrid.width;\n        if (scrollableViewportSize === 0) {\n            const\n                { _beforeCollapseState } = me.timeAxisSubGrid;\n            if (me.isHorizontal && me.timeAxisSubGrid.collapsed && _beforeCollapseState?.width) {\n                scrollableViewportSize = _beforeCollapseState.width;\n            }\n            else {\n                return null;\n            }\n        }\n        // Always calculate an optimal date range for the new zoom level\n        if (!span) {\n            span = me.calculateOptimalDateRange(centerDate, scrollableViewportSize, newPreset);\n        }\n        // Temporarily override tick size while reconfiguring the TimeAxisViewModel\n        if ('width' in options) {\n            newPreset.setData(tickSizeProp, options.width);\n        }\n        me.isZooming = true;\n        // Passed through to the viewPreset changing method\n        newPreset.options = {\n            ...options,\n            startDate : span.startDate || me.startDate,\n            endDate   : span.endDate || me.endDate,\n            centerDate\n        };\n        me.viewPreset = newPreset;\n        // after switching the view preset the `width` config of the zoom level may change, because of adjustments\n        // we will save the real value in the `actualWidth` property, so that `getCurrentZoomLevelIndex` method\n        // will return the exact level index after zooming\n        newPreset.actualWidth = me.timeAxisViewModel.tickSize;\n        me.isZooming = false;\n        // Restore the tick size because the default presets are shared.\n        newPreset.setData(tickSizeProp, configuredTickSize);\n        return me.zoomLevel;\n    }\n    /**\n     * Changes the range of the scheduling chart to fit all the events in its event store.\n     * @param {Object} [options] Options object for the zooming operation.\n     * @param {Number} [options.leftMargin] Defines margin in pixel between the first event start date and first visible\n     * date\n     * @param {Number} [options.rightMargin] Defines margin in pixel between the last event end date and last visible\n     * date\n     */\n    zoomToFit(options) {\n        const eventStore = this.eventStore,\n            span       = eventStore.getTotalTimeSpan();\n        options = {\n            leftMargin  : 0,\n            rightMargin : 0,\n            ...options,\n            ...span\n        };\n        // Make sure we received a time span, event store might be empty\n        if (options.startDate && options.endDate) {\n            if (options.endDate > options.startDate) {\n                this.zoomToSpan(options);\n            }\n            else {\n                // If we only had a zero time span, just scroll it into view\n                this.scrollToDate(options.startDate);\n            }\n        }\n    }\n    /**\n     * Sets time frame to specified range and applies zoom level which allows to fit all columns to this range.\n     *\n     * The given time span will be centered in the scheduling view, in the same time, the start/end date of the whole\n     * time axis will be extended in the same way as {@link #function-zoomToLevel} method does, to allow scrolling for\n     * user.\n     *\n     * @param {Object} config The time frame.\n     * @param {Date} config.startDate The time frame start.\n     * @param {Date} config.endDate The time frame end.\n     * @param {Date} [config.centerDate] Date that should be kept in the center. Has priority over start and end params\n     * @param {Number} [config.leftMargin] Amount of pixels to extend span start on\n     * @param {Number} [config.rightMargin] Amount of pixels to extend span end on\n     * @param {Number} [config.adjustStart] Amount of units to extend span start on\n     * @param {Number} [config.adjustEnd] Amount of units to extend span end on\n     *\n     * @returns {Number|null} level Current zoom level or null if it hasn't changed.\n     * @category Zoom\n     */\n    zoomToSpan(config = {}) {\n        if (config.leftMargin || config.rightMargin) {\n            config.adjustStart = 0;\n            config.adjustEnd = 0;\n        }\n        if (!config.leftMargin) config.leftMargin = 0;\n        if (!config.rightMargin) config.rightMargin = 0;\n        if (!config.startDate || !config.endDate) throw new Error('zoomToSpan: must provide startDate + endDate dates');\n        const\n            me           = this,\n            { timeAxis } = me,\n            // this config enables old zoomToSpan behavior which we want to use for zoomToFit in Gantt\n            needToAdjust = config.adjustStart >= 0 || config.adjustEnd >= 0;\n        let {\n            startDate,\n            endDate\n        } = config;\n        if (needToAdjust) {\n            startDate = DateHelper.add(startDate, -config.adjustStart, timeAxis.mainUnit);\n            endDate   = DateHelper.add(endDate, config.adjustEnd, timeAxis.mainUnit);\n        }\n        if (startDate <= endDate) {\n            // get scheduling view width\n            const\n                { availableSpace } = me.timeAxisViewModel,\n                presets = me.presets.allRecords,\n                diffMS  = endDate - startDate || 1;\n            // if potential width of col is less than col width provided by zoom level\n            //   - we'll zoom out panel until col width fit into width from zoom level\n            // and if width of column is more than width from zoom level\n            //   - we'll zoom in until col width fit won't fit into width from zoom level\n            let currLevel = me.zoomLevel,\n                inc, range;\n            // if we zoomed out even more than the highest zoom level - limit it to the highest zoom level\n            if (currLevel === -1) currLevel = 0;\n            let msPerPixel             = me.getMilliSecondsPerPixelForZoomLevel(presets[currLevel], true),\n                // increment to get next zoom level:\n                // -1 means that given timespan won't fit the available width in the current zoom level, we need to zoom out,\n                // so that more content will \"fit\" into 1 px\n                //\n                // +1 mean that given timespan will already fit into available width in the current zoom level, but,\n                // perhaps if we'll zoom in a bit more, the fitting will be better\n                candidateLevel         = currLevel + (inc = diffMS / msPerPixel + config.leftMargin + config.rightMargin > availableSpace ? -1 : 1),\n                zoomLevel, levelToZoom = null;\n            // loop over zoom levels\n            while (candidateLevel >= 0 && candidateLevel <= presets.length - 1) {\n                // get zoom level\n                zoomLevel = presets[candidateLevel];\n                msPerPixel = me.getMilliSecondsPerPixelForZoomLevel(zoomLevel, true);\n                const spanWidth = diffMS / msPerPixel + config.leftMargin + config.rightMargin;\n                // if zooming out\n                if (inc === -1) {\n                    // if columns fit into available space, then all is fine, we've found appropriate zoom level\n                    if (spanWidth <= availableSpace) {\n                        levelToZoom = candidateLevel;\n                        // stop searching\n                        break;\n                    }\n                    // if zooming in\n                }\n                else {\n                    // if columns still fits into available space, we need to remember the candidate zoom level as a potential\n                    // resulting zoom level, the indication that we've found correct zoom level will be that timespan won't fit\n                    // into available view\n                    if (spanWidth <= availableSpace) {\n                        // if it's not currently active level\n                        if (currLevel !== candidateLevel - inc) {\n                            // remember this level as applicable\n                            levelToZoom = candidateLevel;\n                        }\n                    }\n                    else {\n                        // Sanity check to find the following case:\n                        // If we're already zoomed in at the appropriate level, but the current zoomLevel is \"too small\" to fit and had to be expanded,\n                        // there is an edge case where we should actually just stop and use the currently selected zoomLevel\n                        break;\n                    }\n                }\n                candidateLevel += inc;\n            }\n            // If we didn't find a large/small enough zoom level, use the lowest/highest level\n            levelToZoom = levelToZoom != null ? levelToZoom : candidateLevel - inc;\n            // presets is the array of all ViewPresets this Scheduler is using\n            zoomLevel = presets[levelToZoom];\n            const unitToZoom = zoomLevel.bottomHeader.unit;\n            // Extract the correct msPerPixel value for the new zoom level\n            msPerPixel = me.getMilliSecondsPerPixelForZoomLevel(zoomLevel, true);\n            if (config.leftMargin || config.rightMargin) {\n                // time axis doesn't yet know about new view preset (zoom level) so it cannot round/ceil date correctly\n                startDate = new Date(startDate.getTime() - msPerPixel * config.leftMargin);\n                endDate   = new Date(endDate.getTime() + msPerPixel * config.rightMargin);\n            }\n            const tickCount = DateHelper.getDurationInUnit(startDate, endDate, unitToZoom, true) / zoomLevel.bottomHeader.increment;\n            if (tickCount === 0) {\n                return null;\n            }\n            const\n                customWidth = Math.floor(availableSpace / tickCount),\n                centerDate  = config.centerDate || new Date((startDate.getTime() + endDate.getTime()) / 2);\n            if (needToAdjust) {\n                range = {\n                    startDate,\n                    endDate\n                };\n            }\n            else {\n                range = me.calculateOptimalDateRange(centerDate, availableSpace, zoomLevel);\n            }\n            let result = me.zoomLevel;\n            // No change of zoom level needed, just move to the date range\n            if (me.zoomLevel === levelToZoom) {\n                timeAxis.reconfigure(range);\n            }\n            else {\n                result = me.zoomToLevel(levelToZoom,\n                    Object.assign(range, {\n                        width : customWidth,\n                        centerDate\n                    })\n                );\n            }\n            this.trigger('zoomToSpan', { zoomLevel : levelToZoom, startDate, endDate, centerDate });\n            return result;\n        }\n        return null;\n    }\n    /**\n     * Zooms in the timeline according to the array of zoom levels. If the amount of levels to zoom is given, the view\n     * will zoom in by this value. Otherwise, a value of `1` will be used.\n     *\n     * @param {Number} [levels] (optional) amount of levels to zoom in\n     * @param {ChangePresetOptions} [options] Object containing options which affect how the new preset is applied.\n     * @returns {Number|null} currentLevel New zoom level of the panel or null if level hasn't changed.\n     * @category Zoom\n     */\n    zoomIn(levels = 1, options) {\n        // Allow zoomIn({ visibleDate : ... })\n        if (typeof levels === 'object') {\n            options = levels;\n            levels = 1;\n        }\n        const currentZoomLevelIndex = this.zoomLevel;\n        if (currentZoomLevelIndex >= this.maxZoomLevel) {\n            return null;\n        }\n        return this.zoomToLevel(currentZoomLevelIndex + levels, options);\n    }\n    /**\n     * Zooms out the timeline according to the array of zoom levels. If the amount of levels to zoom is given, the view\n     * will zoom out by this value. Otherwise, a value of `1` will be used.\n     *\n     * @param {Number} levels (optional) amount of levels to zoom out\n     * @param {ChangePresetOptions} [options] Object containing options which affect how the new preset is applied.\n     * @returns {Number|null} currentLevel New zoom level of the panel or null if level hasn't changed.\n     * @category Zoom\n     */\n    zoomOut(levels = 1, options) {\n        // Allow zoomOut({ visibleDate : ... })\n        if (typeof levels === 'object') {\n            options = levels;\n            levels = 1;\n        }\n        const currentZoomLevelIndex = this.zoomLevel;\n        if (currentZoomLevelIndex <= this.minZoomLevel) {\n            return null;\n        }\n        return this.zoomToLevel(currentZoomLevelIndex - levels, options);\n    }\n    /**\n     * Zooms in the timeline to the {@link #config-maxZoomLevel} according to the array of zoom levels.\n     *\n     * @param {ChangePresetOptions} [options] Object containing options which affect how the new preset is applied.\n     * @returns {Number|null} currentLevel New zoom level of the panel or null if level hasn't changed.\n     * @category Zoom\n     */\n    zoomInFull(options) {\n        return this.zoomToLevel(this.maxZoomLevel, options);\n    }\n    /**\n     * Zooms out the timeline to the {@link #config-minZoomLevel} according to the array of zoom levels.\n     *\n     * @param {ChangePresetOptions} [options] Object containing options which affect how the new preset is applied.\n     * @returns {Number|null} currentLevel New zoom level of the panel or null if level hasn't changed.\n     * @category Zoom\n     */\n    zoomOutFull(options) {\n        return this.zoomToLevel(this.minZoomLevel, options);\n    }\n    /*\n     * Adjusts the timespan of the panel to the new zoom level. Used for performance reasons,\n     * as rendering too many columns takes noticeable amount of time so their number is limited.\n     * @category Zoom\n     * @private\n     */\n    calculateOptimalDateRange(centerDate, viewportSize, viewPreset) {\n        const\n            me               = this,\n            { timeAxis }     = me,\n            { bottomHeader } = viewPreset,\n            tickWidth        = me.isHorizontal ? viewPreset.tickWidth : viewPreset.tickHeight;\n        if (me.zoomKeepsOriginalTimespan) {\n            return {\n                startDate : timeAxis.startDate,\n                endDate   : timeAxis.endDate\n            };\n        }\n        const\n            unit       = bottomHeader.unit,\n            difference = Math.ceil(viewportSize / tickWidth * bottomHeader.increment * me.visibleZoomFactor / 2),\n            startDate  = DateHelper.add(centerDate, -difference, unit),\n            endDate    = DateHelper.add(centerDate, difference, unit);\n        return {\n            startDate : timeAxis.floorDate(startDate, false, unit, bottomHeader.increment),\n            endDate   : timeAxis.ceilDate(endDate, false, unit, bottomHeader.increment)\n        };\n    }\n    onElementMouseMove(event) {\n        const\n            {\n                isHorizontal,\n                zoomContext\n            } = this;\n        super.onElementMouseMove(event);\n        if (event.isTrusted && zoomContext) {\n            // Invalidate the zoomContext if mouse has strayed away from it\n            if (Math.abs(event[`client${isHorizontal ? 'X' : 'Y'}`] - zoomContext.coordinate) > 10) {\n                this.zoomContext = null;\n            }\n        }\n    }\n    async onWheel(event) {\n        if (event.ctrlKey && !this.forceFit) {\n            event.preventDefault();\n            const\n                me           = this,\n                {\n                    zoomContext,\n                    isHorizontal,\n                    timelineScroller,\n                    zoomLevel\n                }            = me,\n                now          = performance.now(),\n                coordinate   = event[`client${isHorizontal ? 'X' : 'Y'}`];\n            let zoomPosition = coordinate - timelineScroller.viewport[`${isHorizontal ? 'x' : 'y'}`];\n            // zoomPosition is the offset into the TimeAxisSubGridElement.\n            if (isHorizontal && me.rtl) {\n                zoomPosition = timelineScroller.viewport.width + timelineScroller.viewport.x - coordinate;\n            }\n            // If we are in a fast-arriving stream of wheel events, we use the same zoomDate as last time.\n            // If it's a new zoom gesture or the pointer has strayed away from the context then ascertain\n            // the gesture's center date\n            if (now - me.lastWheelTime > 200 || !zoomContext || Math.abs(coordinate - me.zoomContext.coordinate) > 20) {\n                // We're creating a zoom gesture which lasts as long as the\n                // wheel events keep arriving at the same timeline position\n                me.zoomContext = {\n                    // So we can track if we're going in (to finer resolutions)\n                    zoomLevel,\n                    // Pointer client(X|Y)\n                    coordinate,\n                    // Full TimeAxis offset position at which to place the date\n                    zoomPosition,\n                    // The date to place at the position\n                    zoomDate : me.getDateFromDomEvent(event)\n                };\n            }\n            // Use the current zoomContext's zoomDate, but at each level, the relative position of that date\n            // in the TimeAxis has to be corrected as the TimeAxis grows and scrolls to keep the zoomPosition\n            // stable.\n            else {\n                // If we zoom in to a finer resolution, get a more accurate centering date.\n                // If gesture was started at a years/months level, the date will be inaccurate.\n                if (zoomLevel > zoomContext.zoomLevel) {\n                    zoomContext.zoomDate = me.getDateFromDomEvent(event);\n                    zoomContext.zoomLevel = zoomLevel;\n                }\n                zoomContext.zoomPosition = zoomPosition;\n            }\n            me.lastWheelTime = now;\n            me[`zoom${event.deltaY > 0 ? 'Out' : 'In'}`](undefined, me.zoomContext);\n        }\n    }\n    /**\n     * Changes the time axis timespan to the supplied start and end dates.\n     * @param {Date} newStartDate The new start date\n     * @param {Date} [newEndDate] The new end date. If omitted or equal to startDate, the\n     * {@link Scheduler.preset.ViewPreset#field-defaultSpan} property of the current view preset will be used to calculate the new end date.\n     * @param {Object} [options] An object containing modifiers for the time span change operation.\n     * @param {Boolean} [options.maintainVisibleStart] Specify as `true` to keep the visible start date stable.\n     * @param {Date} [options.visibleDate] The date inside the range to scroll into view\n     * @async\n     */\n    setTimeSpan(newStartDate, newEndDate, options) {\n        this.timeAxis.setTimeSpan(newStartDate, newEndDate, options);\n    }\n    /**\n     * Moves the time axis by the passed amount and unit.\n     *\n     * NOTE: If using a filtered time axis, see {@link Scheduler.data.TimeAxis#function-shift} for more information.\n     *\n     * @param {Number} amount The number of units to jump\n     * @param {'ms'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} [unit] The unit (Day, Week etc)\n     */\n    shift(amount, unit) {\n        this.timeAxis.shift(amount, unit);\n    }\n    /**\n     * Moves the time axis forward in time in units specified by the view preset `shiftUnit`, and by the amount\n     * specified by the `shiftIncrement` config of the current view preset.\n     *\n     * NOTE: If using a filtered time axis, see {@link Scheduler.data.TimeAxis#function-shiftNext} for more information.\n     *\n     * @param {Number} [amount] The number of units to jump forward\n     */\n    shiftNext(amount) {\n        this.timeAxis.shiftNext(amount);\n    }\n    /**\n     * Moves the time axis backward in time in units specified by the view preset `shiftUnit`, and by the amount\n     * specified by the `shiftIncrement` config of the current view preset.\n     *\n     * NOTE: If using a filtered time axis, see {@link Scheduler.data.TimeAxis#function-shiftPrevious} for more\n     * information.\n     *\n     * @param {Number} [amount] The number of units to jump backward\n     */\n    shiftPrevious(amount) {\n        this.timeAxis.shiftPrevious(amount);\n    }\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Popup from '../../../Core/widget/Popup.js';\n/**\n * @module Scheduler/view/recurrence/RecurrenceConfirmationPopup\n */\n/**\n * A confirmation dialog shown when modifying a recurring event or some of its occurrences.\n * For recurring events, the dialog informs the user that the change will be applied to all occurrences.\n *\n * For occurrences, the dialog lets the user choose if the change should affect all future occurrences,\n * or this occurrence only.\n *\n * Usage example:\n *\n * ```javascript\n * const confirmation = new RecurrenceConfirmationPopup();\n *\n * confirmation.confirm({\n *     eventRecord : recurringEvent,\n *     actionType  : \"delete\",\n *     changerFn   : () => recurringEvent.remove(event)\n * });\n * ```\n *\n * @classtype recurrenceconfirmation\n * @extends Core/widget/Popup\n */\nexport default class RecurrenceConfirmationPopup extends Popup {\n    static get $name() {\n        return 'RecurrenceConfirmationPopup';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'recurrenceconfirmation';\n    }\n    static get defaultConfig() {\n        return {\n            localizableProperties : [],\n            align                 : 'b-t',\n            autoShow              : false,\n            autoClose             : false,\n            closeAction           : 'onRecurrenceClose',\n            modal                 : true,\n            centered              : true,\n            scrollAction          : 'realign',\n            constrainTo           : globalThis,\n            draggable             : true,\n            closable              : true,\n            floating              : true,\n            eventRecord           : null,\n            cls                   : 'b-sch-recurrenceconfirmation',\n            bbar                  : {\n                defaults : {\n                    localeClass : this\n                },\n                items : {\n                    changeSingleButton : {\n                        weight  : 100,\n                        cls     : 'b-raised',\n                        color   : 'b-blue',\n                        text    : 'L{update-only-this-btn-text}',\n                        onClick : 'up.onChangeSingleButtonClick'\n                    },\n                    changeMultipleButton : {\n                        weight  : 200,\n                        color   : 'b-green',\n                        text    : 'L{Object.Yes}',\n                        onClick : 'up.onChangeMultipleButtonClick'\n                    },\n                    cancelButton : {\n                        weight  : 300,\n                        color   : 'b-gray',\n                        text    : 'L{Object.Cancel}',\n                        onClick : 'up.onCancelButtonClick'\n                    }\n                }\n            }\n        };\n    }\n    /**\n     * Reference to the \"Apply changes to multiple occurrences\" button, if used\n     * @property {Core.widget.Button}\n     * @readonly\n     */\n    get changeMultipleButton() {\n        return this.widgetMap.changeMultipleButton;\n    }\n    /**\n     * Reference to the button that causes changing of the event itself only, if used\n     * @property {Core.widget.Button}\n     * @readonly\n     */\n    get changeSingleButton() {\n        return this.widgetMap.changeSingleButton;\n    }\n    /**\n     * Reference to the cancel button, if used\n     * @property {Core.widget.Button}\n     * @readonly\n     */\n    get cancelButton() {\n        return this.widgetMap.cancelButton;\n    }\n    /**\n     * Handler for \"Apply changes to multiple occurrences\" {@link #property-changeMultipleButton button}.\n     * It calls {@link #function-processMultipleRecords} and then hides the dialog.\n     */\n    onChangeMultipleButtonClick() {\n        this.processMultipleRecords();\n        this.hide();\n    }\n    /**\n     * Handler for the {@link #property-changeSingleButton button} that causes changing of the event itself only.\n     * It calls {@link #function-processSingleRecord} and then hides the dialog.\n     */\n    onChangeSingleButtonClick() {\n        this.processSingleRecord();\n        this.hide();\n    }\n    /**\n     * Handler for {@link #property-cancelButton cancel button}.\n     * It calls `cancelFn` provided to {@link #function-confirm} call and then hides the dialog.\n     */\n    onCancelButtonClick() {\n        this.cancelFn && this.cancelFn.call(this.thisObj);\n        this.hide();\n    }\n    onRecurrenceClose() {\n        if (this.cancelFn) {\n            this.cancelFn.call(this.thisObj);\n        }\n        this.hide();\n    }\n    /**\n     * Displays the confirmation.\n     * Usage example:\n     *\n     * ```javascript\n     * const popup = new RecurrenceConfirmationPopup();\n     *\n     * popup.confirm({\n     *     eventRecord,\n     *     actionType : \"delete\",\n     *     changerFn  : () => eventStore.remove(record)\n     * });\n     * ```\n     *\n     * @param {Object} config The following config options are supported:\n     * @param {Scheduler.model.EventModel} config.eventRecord   Event being modified.\n     * @param {'update'|'delete'} config.actionType Type of modification to be applied to the event. Can be\n     * either \"update\" or \"delete\".\n     * @param {Function} config.changerFn A function that should be called to apply the change to the event upon user\n     * choice.\n     * @param {Function} [config.thisObj] `changerFn` and `cancelFn` functions scope.\n     * @param {Function} [config.cancelFn] Function called on `Cancel` button click.\n     */\n    confirm(config = {}) {\n        const me = this;\n        [\n            'actionType',\n            'eventRecord',\n            'title',\n            'html',\n            'changerFn',\n            'cancelFn',\n            'finalizerFn',\n            'thisObj'\n        ].forEach(prop => {\n            if (prop in config) me[prop] = config[prop];\n        });\n        me.updatePopupContent();\n        return super.show(config);\n    }\n    updatePopupContent() {\n        const\n            me                                                         = this,\n            { changeMultipleButton, changeSingleButton, cancelButton } = me.widgetMap,\n            { eventRecord, actionType = 'update' }                     = me,\n            isMaster                                                   = eventRecord?.isRecurring;\n        if (isMaster) {\n            changeMultipleButton.text = me.L('L{Object.Yes}');\n            me.html = me.L(`${actionType}-all-message`);\n        }\n        else {\n            changeMultipleButton.text = me.L(`${actionType}-further-btn-text`);\n            me.html = me.L(`${actionType}-further-message`);\n        }\n        changeSingleButton.text = me.L(`${actionType}-only-this-btn-text`);\n        cancelButton.text = me.L('L{Object.Cancel}');\n        me.width = me.L('L{width}');\n        me.title = me.L(`${actionType}-title`);\n    }\n    /**\n     * Applies changes to multiple occurrences as reaction on \"Apply changes to multiple occurrences\"\n     * {@link #property-changeMultipleButton button} click.\n     */\n    processMultipleRecords() {\n        const { eventRecord, changerFn, thisObj, finalizerFn } = this;\n        eventRecord.beginBatch();\n        // Apply changes to the occurrence.\n        // It is not joined to any stores, so this has no consequence.\n        changerFn && this.callback(changerFn, thisObj, [eventRecord]);\n        // afterChange will promote it to being an new recurring base because there's still recurrence\n        eventRecord.endBatch();\n        finalizerFn && this.callback(finalizerFn, thisObj, [eventRecord]);\n    }\n    /**\n     * Applies changes to a single record by making it a \"real\" event and adding an exception to the recurrence.\n     * The method is called as reaction on clicking the {@link #property-changeSingleButton button} that causes changing of the event itself only.\n     */\n    processSingleRecord() {\n        const { eventRecord, changerFn, thisObj, finalizerFn } = this;\n        eventRecord.beginBatch();\n        let firstOccurrence;\n        // If that's a master event get its very first occurrence\n        if (eventRecord?.isRecurring) {\n            eventRecord.recurrence.forEachOccurrence(eventRecord.startDate, null, (occurrence, isFirst, index) => {\n                // index 1 is used by to the event itself, > 1 since there might be exceptions\n                if (index > 1) {\n                    firstOccurrence = occurrence;\n                    return false;\n                }\n            });\n        }\n        // turn the 1st occurrence into a new \"master\" event\n        firstOccurrence?.convertToRealEvent();\n        // When the changes apply, because there's no recurrence, it will become an exception\n        eventRecord.recurrence = null;\n        // Apply changes to the occurrence.\n        // It is not joined to any stores, so this has no consequence.\n        changerFn && this.callback(changerFn, thisObj, [eventRecord]);\n        // Must also change after the callback in case the callback sets the rule.\n        // This will update the batch update data block to prevent it being set back to recurring.\n        eventRecord.recurrenceRule = null;\n        // afterChange will promote it to being an exception because there's no recurrence\n        eventRecord.endBatch();\n        finalizerFn && this.callback(finalizerFn, thisObj, [eventRecord]);\n    }\n    updateLocalization() {\n        this.updatePopupContent();\n        super.updateLocalization();\n    }\n};\n// Register this widget type with its Factory\nRecurrenceConfirmationPopup.initClass();\nRecurrenceConfirmationPopup._$name = 'RecurrenceConfirmationPopup';", "import Base from '../../../Core/Base.js';\nimport '../recurrence/RecurrenceConfirmationPopup.js';\n/**\n * @module Scheduler/view/mixin/RecurringEvents\n */\n/**\n * A mixin that adds recurring events functionality to the Scheduler.\n *\n * The main purpose of the code in here is displaying a {@link Scheduler.view.recurrence.RecurrenceConfirmationPopup special confirmation}\n * on user mouse dragging/resizing/deleting recurring events and their occurrences.\n *\n * @mixin\n */\nexport default Target => class RecurringEvents extends (Target || Base) {\n    static $name = 'RecurringEvents';\n    static configurable = {\n        /**\n         * Enables showing occurrences of recurring events across the scheduler's time axis.\n         *\n         * Enables extra recurrence UI fields in the system-provided event editor (not in Scheduler Pro's task editor).\n         * @config {Boolean}\n         * @default\n         * @category Scheduled events\n         */\n        enableRecurringEvents : false,\n        recurrenceConfirmationPopup : {\n            $config : ['lazy'],\n            value   : {\n                type : 'recurrenceconfirmation'\n            }\n        }\n    };\n    construct(config) {\n        super.construct(config);\n        this.ion({\n            beforeEventDropFinalize   : 'onRecurrableBeforeEventDropFinalize',\n            beforeEventResizeFinalize : 'onRecurrableBeforeEventResizeFinalize',\n            beforeAssignmentDelete    : 'onRecurrableAssignmentBeforeDelete'\n        });\n    }\n    changeRecurrenceConfirmationPopup(recurrenceConfirmationPopup, oldRecurrenceConfirmationPopup) {\n        // Widget.reconfigure reither reconfigures an existing instance, or creates a new one, or,\n        // if the configuration is null, destroys the existing instance.\n        const result = this.constructor.reconfigure(oldRecurrenceConfirmationPopup, recurrenceConfirmationPopup, 'recurrenceconfirmation');\n        result.owner = this;\n        return result;\n    }\n    findRecurringEventToConfirmDelete(eventRecords) {\n        // show confirmation if we deal with at least one recurring event (or its occurrence)\n        // and if the record is not being edited by event editor (since event editor has its own confirmation)\n        return eventRecords.find(eventRecord => eventRecord.supportsRecurring && (eventRecord.isRecurring || eventRecord.isOccurrence));\n    }\n    onRecurrableAssignmentBeforeDelete({ assignmentRecords, context }) {\n        const\n            eventRecords = assignmentRecords.map(as => as.event),\n            eventRecord  = this.findRecurringEventToConfirmDelete(eventRecords);\n        if (this.enableRecurringEvents && eventRecord) {\n            this.recurrenceConfirmationPopup.confirm({\n                actionType : 'delete',\n                eventRecord,\n                changerFn() {\n                    context.finalize(true);\n                },\n                cancelFn() {\n                    context.finalize(false);\n                }\n            });\n            return false;\n        }\n    }\n    onRecurrableBeforeEventDropFinalize({ context }) {\n        if (this.enableRecurringEvents) {\n            const\n                { eventRecords } = context,\n                recurringEvents = eventRecords.filter(eventRecord => eventRecord.supportsRecurring && (eventRecord.isRecurring || eventRecord.isOccurrence));\n            if (recurringEvents.length) {\n                context.async = true;\n                this.recurrenceConfirmationPopup.confirm({\n                    actionType  : 'update',\n                    eventRecord : recurringEvents[0],\n                    changerFn() {\n                        context.finalize(true);\n                    },\n                    cancelFn() {\n                        context.finalize(false);\n                    }\n                });\n            }\n        }\n    }\n    onRecurrableBeforeEventResizeFinalize({ context }) {\n        if (this.enableRecurringEvents) {\n            const\n                { eventRecord } = context,\n                isRecurring     = eventRecord.supportsRecurring && (eventRecord.isRecurring || eventRecord.isOccurrence);\n            if (isRecurring) {\n                context.async = true;\n                this.recurrenceConfirmationPopup.confirm({\n                    actionType : 'update',\n                    eventRecord,\n                    changerFn() {\n                        context.finalize(true);\n                    },\n                    cancelFn() {\n                        context.finalize(false);\n                    }\n                });\n            }\n        }\n    }\n    // Make sure occurrence cache is up-to-date when reassigning events\n    onAssignmentChange({ action, records : assignments, changes }) {\n        // Ignore changes coming from engine normalizing the eventId/resourceId => event/resource\n        if (action === 'update' && changes.event && changes.resource && Object.keys(changes).length === 2) {\n            return;\n        }\n        if (action !== 'dataset' && Array.isArray(assignments)) {\n            for (const assignment of assignments) {\n                if (assignment.event?.isRecurring && !assignment.event.isBatchUpdating) {\n                    assignment.event.removeOccurrences(this.eventStore);\n                }\n            }\n        }\n    }\n    /**\n     * Returns occurrences of the provided recurring event across the date range of this Scheduler.\n     * @param  {Scheduler.model.TimeSpan} recurringEvent Recurring event for which occurrences should be retrieved.\n     * @returns {Scheduler.model.TimeSpan[]} Array of the provided timespans occurrences.\n     *\n     * __Empty if the passed event is not recurring, or has no occurrences in the date range.__\n     *\n     * __If the date range encompasses the start point, the recurring event itself will be the first entry.__\n     * @category Data\n     */\n    getOccurrencesFor(recurringEvent) {\n        return this.eventStore.getOccurrencesForTimeSpan(recurringEvent, this.timeAxis.startDate, this.timeAxis.endDate);\n    }\n    /**\n     * Internal utility function to remove events. Used when pressing [DELETE] or [BACKSPACE] or when clicking the\n     * delete button in the event editor. Triggers a preventable `beforeEventDelete` or `beforeAssignmentDelete` event.\n     * @param {Scheduler.model.EventModel[]|Scheduler.model.AssignmentModel[]} eventRecords Records to remove\n     * @param {Function} [callback] Optional callback executed after triggering the event but before deletion\n     * @returns {Boolean} Returns `false` if the operation was prevented, otherwise `true`\n     * @internal\n     * @fires beforeEventDelete\n     * @fires beforeAssignmentDelete\n     */\n    async removeEvents(eventRecords, callback = null, popupOwner = this) {\n        const me = this;\n        if (!me.readOnly && eventRecords.length) {\n            const context = {\n                finalize(removeRecord = true) {\n                    if (callback) {\n                        callback(removeRecord);\n                    }\n                    if (removeRecord !== false) {\n                        if (eventRecords.some(record => record.isOccurrence || record.event?.isOccurrence)) {\n                            eventRecords.forEach(record => record.isOccurrenceAssignment ? record.event.remove() : record.remove());\n                        }\n                        else {\n                            const store = eventRecords[0].isAssignment ? me.assignmentStore : me.eventStore;\n                            store.remove(eventRecords);\n                        }\n                    }\n                }\n            };\n            let shouldFinalize;\n            if (eventRecords[0].isAssignment) {\n                /**\n                 * Fires before an assignment is removed. Can be triggered by user pressing [DELETE] or [BACKSPACE] or\n                 * by the event editor. Can for example be used to display a custom dialog to confirm deletion, in which\n                 * case records should be \"manually\" removed after confirmation:\n                 *\n                 * ```javascript\n                 * scheduler.on({\n                 *    beforeAssignmentDelete({ assignmentRecords, context }) {\n                 *        // Show custom confirmation dialog (pseudo code)\n                 *        confirm.show({\n                 *            listeners : {\n                 *                onOk() {\n                 *                    // Remove the assignments on confirmation\n                 *                    context.finalize(true);\n                 *                },\n                 *                onCancel() {\n                 *                    // do not remove the assignments if \"Cancel\" clicked\n                 *                    context.finalize(false);\n                 *                }\n                 *            }\n                 *        });\n                 *\n                 *        // Prevent default behaviour\n                 *        return false;\n                 *    }\n                 * });\n                 * ```\n                 *\n                 * @event beforeAssignmentDelete\n                 * @param {Scheduler.view.Scheduler} source  The Scheduler instance\n                 * @param {Scheduler.model.EventModel[]} eventRecords  The records about to be deleted\n                 * @param {Object} context  Additional removal context:\n                 * @param {Function} context.finalize  Function to call to finalize the removal.\n                 *      Used to asynchronously decide to remove the records or not. Provide `false` to the function to\n                 *      prevent the removal.\n                 * @param {Boolean} [context.finalize.removeRecords = true]   Provide `false` to the function to prevent\n                 *      the removal.\n                 * @preventable\n                 */\n                shouldFinalize = me.trigger('beforeAssignmentDelete', { assignmentRecords : eventRecords, context });\n            }\n            else {\n                /**\n                 * Fires before an event is removed. Can be triggered by user pressing [DELETE] or [BACKSPACE] or by the\n                 * event editor. Return `false` to immediately veto the removal (or a `Promise` yielding `true` or `false`\n                 * for async vetoing).\n                 *\n                 * Can for example be used to display a custom dialog to confirm deletion, in which case\n                 * records should be \"manually\" removed after confirmation:\n                 *\n                 * ```javascript\n                 * scheduler.on({\n                 *    beforeEventDelete({ eventRecords, context }) {\n                 *        // Show custom confirmation dialog (pseudo code)\n                 *        confirm.show({\n                 *            listeners : {\n                 *                onOk() {\n                 *                    // Remove the events on confirmation\n                 *                    context.finalize(true);\n                 *                },\n                 *                onCancel() {\n                 *                    // do not remove the events if \"Cancel\" clicked\n                 *                    context.finalize(false);\n                 *                }\n                 *            }\n                 *        });\n                 *\n                 *        // Prevent default behaviour\n                 *        return false;\n                 *    }\n                 * });\n                 * ```\n                 *\n                 * @event beforeEventDelete\n                 * @param {Scheduler.view.Scheduler} source The Scheduler instance\n                 * @typings source -> {Scheduler.view.Scheduler||any}\n                 * @param {Scheduler.model.EventModel[]} eventRecords  The records about to be deleted\n                 * @param {Object} context  Additional removal context:\n                 * @param {Function} context.finalize  Function to call to finalize the removal.\n                 *      Used to asynchronously decide to remove the records or not. Provide `false` to the function to\n                 *      prevent the removal.\n                 * @param {Boolean} [context.finalize.removeRecords = true]  Provide `false` to the function to prevent\n                 *      the removal.\n                 * @preventable\n                 * @async\n                 */\n                shouldFinalize = await me.trigger('beforeEventDelete', { eventRecords, context });\n            }\n            if (shouldFinalize !== false) {\n                const recurringEventRecord = eventRecords.find(eventRecord => eventRecord.isRecurring || eventRecord.isOccurrence);\n                if (recurringEventRecord) {\n                    me.recurrenceConfirmationPopup.owner = popupOwner;\n                    me.recurrenceConfirmationPopup.confirm({\n                        actionType  : 'delete',\n                        eventRecord : recurringEventRecord,\n                        changerFn() {\n                            context.finalize(true);\n                        },\n                        cancelFn() {\n                            context.finalize(false);\n                        }\n                    });\n                }\n                else {\n                    context.finalize(true);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n/**\n * @module Scheduler/view/mixin/TimelineEventRendering\n */\n/**\n * Functions to handle event rendering (EventModel -> dom elements).\n *\n * @mixin\n */\nexport default Target => class TimelineEventRendering extends (Target || Base) {\n    static get $name() {\n        return 'TimelineEventRendering';\n    }\n    //region Default config\n    static get defaultConfig() {\n        return {\n            /**\n             * When `true`, events are sized and positioned based on rowHeight, resourceMargin and barMargin settings.\n             * Set this to `false` if you want to control height and vertical position using CSS instead.\n             *\n             * Note that events always get an absolute top position, but when this setting is enabled that position\n             * will match row's top. To offset within the row using CSS, use `transform : translateY(y)`.\n             *\n             * @config {Boolean}\n             * @default\n             * @category Scheduled events\n             */\n            managedEventSizing : true,\n            /**\n             * The CSS class added to an event/assignment when it is newly created\n             * in the UI and unsynced with the server.\n             * @config {String}\n             * @default\n             * @private\n             * @category CSS\n             */\n            generatedIdCls : 'b-sch-dirty-new',\n            /**\n             * The CSS class added to an event when it has unsaved modifications\n             * @config {String}\n             * @default\n             * @private\n             * @category CSS\n             */\n            dirtyCls : 'b-sch-dirty',\n            /**\n             * The CSS class added to an event when it is currently committing changes\n             * @config {String}\n             * @default\n             * @private\n             * @category CSS\n             */\n            committingCls : 'b-sch-committing',\n            /**\n             * The CSS class added to an event/assignment when it ends outside of the visible time range.\n             * @config {String}\n             * @default\n             * @private\n             * @category CSS\n             */\n            endsOutsideViewCls : 'b-sch-event-endsoutside',\n            /**\n             * The CSS class added to an event/assignment when it starts outside of the visible time range.\n             * @config {String}\n             * @default\n             * @private\n             * @category CSS\n             */\n            startsOutsideViewCls : 'b-sch-event-startsoutside',\n            /**\n             * The CSS class added to an event/assignment when it is not draggable.\n             * @config {String}\n             * @default\n             * @private\n             * @category CSS\n             */\n            fixedEventCls : 'b-sch-event-fixed'\n        };\n    }\n    static configurable = {\n        /**\n         * Controls how much space to leave between stacked event bars in px.\n         *\n         * Value will be constrained by half the row height in horizontal mode.\n         *\n         * @prp {Number}\n         * @default\n         * @category Scheduled events\n         */\n        barMargin : 10,\n        /**\n         * Specify `true` to force rendered events/tasks to fill entire ticks. This only affects rendering, start\n         * and end dates retain their value on the data level.\n         *\n         * When enabling `fillTicks` you should consider either disabling EventDrag/TaskDrag and EventResize/TaskResize,\n         * or enabling {@link Scheduler/view/mixin/TimelineDateMapper#config-snap}. Otherwise their behaviour might not\n         * be what a user expects.\n         *\n         * @prp {Boolean}\n         * @default\n         * @category Scheduled events\n         */\n        fillTicks : false,\n        resourceMargin : null,\n        /**\n         * Event color used by default. Events and resources can specify their own color, with priority order being:\n         * Event -> Resource -> Scheduler default.\n         *\n         * Specify `null` to not apply a default color and take control using custom CSS (an easily overridden color\n         * will be used to make sure events are still visible).\n         *\n         * For available standard colors, see {@link Scheduler.model.mixin.EventModelMixin#typedef-EventColor}.\n         *\n         * @prp {EventColor} eventColor\n         * @category Scheduled events\n         */\n        eventColor : 'green',\n        /**\n         * Event style used by default. Events and resources can specify their own style, with priority order being:\n         * Event -> Resource -> Scheduler default. Determines the appearance of the event by assigning a CSS class\n         * to it. Available styles are:\n         *\n         * * `'plain'` (default) - flat look\n         * * `'border'` - has border in darker shade of events color\n         * * `'colored'` - has colored text and wide left border in same color\n         * * `'hollow'` - only border + text until hovered\n         * * `'line'` - as a line with the text below it\n         * * `'dashed'` - as a dashed line with the text below it\n         * * `'minimal'` - as a thin line with small text above it\n         * * `'rounded'` - minimalistic style with rounded corners\n         * * `null` - do not apply a default style and take control using custom CSS (easily overridden basic styling will be used).\n         *\n         * In addition, there are two styles intended to be used when integrating with Bryntum Calendar. To match\n         * the look of Calendar events, you can use:\n         *\n         * * `'calendar'` - a variation of the \"colored\" style matching the default style used by Calendar\n         * * `'interday'` - a variation of the \"plain\" style, for interday events\n         *\n         * @prp {'plain'|'border'|'colored'|'hollow'|'line'|'dashed'|'minimal'|'rounded'|'calendar'|'interday'|null}\n         * @default\n         * @category Scheduled events\n         */\n        eventStyle : 'plain',\n        /**\n         * The width/height (depending on vertical / horizontal mode) of all the time columns.\n         *\n         * There is a limit for the tick size value. Its minimal allowed value is calculated so ticks would fit the\n         * available space. Only applicable when {@link Scheduler.view.TimelineBase#config-forceFit} is set to\n         * `false`. To set `tickSize` freely skipping that limitation please set\n         * {@link Scheduler.view.TimelineBase#config-suppressFit} to `true`.\n         *\n         * @prp {Number}\n         * @category Scheduled events\n         */\n        tickSize : null\n    };\n    //endregion\n    //region Settings\n    updateFillTicks(fillTicks) {\n        if (!this.isConfiguring) {\n            this.timeAxis.forceFullTicks = fillTicks && this.snap;\n            this.refreshWithTransition();\n            this.trigger('stateChange');\n        }\n    }\n    changeBarMargin(margin) {\n        ObjectHelper.assertNumber(margin, 'barMargin');\n        // Run changeResourceMargin if its default value is null, to make sure resourceMarginObject is available\n        if (this._resourceMargin == null) {\n            this.changeResourceMargin(margin);\n        }\n        // bar margin should not exceed half of the row height\n        if (this.isHorizontal && this.rowHeight) {\n            return Math.min(Math.ceil(this.rowHeight / 2), margin);\n        }\n        return margin;\n    }\n    updateBarMargin() {\n        if (this.rendered) {\n            this.currentOrientation.onBeforeRowHeightChange();\n            this.refreshWithTransition();\n            this.trigger('stateChange');\n        }\n    }\n    // Documented in SchedulerEventRendering to not show up in Gantt docs\n    get resourceMargin() {\n        return this._resourceMargin == null ? this.barMargin : this._resourceMargin;\n    }\n    changeResourceMargin(margin) {\n        const me = this;\n        if (typeof margin === 'number') {\n            // resource margin should not exceed half of the row height\n            if (me.isHorizontal && me.rowHeight) {\n                margin = Math.min(Math.ceil(me.rowHeight / 2), margin);\n            }\n            me.resourceMarginObject = {\n                start : margin,\n                end   : margin,\n                total : margin * 2\n            };\n            return margin;\n        }\n        if (!margin?.start) {\n            margin.start = 0;\n        }\n        if (!margin?.end) {\n            margin.end = 0;\n        }\n        // resource margin should not exceed half of the row height\n        if (me.isHorizontal && me.rowHeight) {\n            margin.start = me.rowHeight < margin.start + margin.end ? Math.ceil(me.rowHeight / 2) : margin.start;\n            margin.end = me.rowHeight < margin.start + margin.end ? Math.ceil(me.rowHeight / 2) : margin.end;\n        }\n        me.resourceMarginObject = ObjectHelper.assign({\n            total : margin.start + margin.end\n        }, margin);\n        return margin;\n    }\n    updateResourceMargin() {\n        const me = this;\n        if (me.rendered) {\n            me.currentOrientation.onBeforeRowHeightChange();\n            me.refreshWithTransition();\n        }\n    }\n    changeTickSize(width) {\n        ObjectHelper.assertNumber(width, 'tickSize');\n        return width;\n    }\n    updateTickSize(width) {\n        this.timeAxisViewModel.tickSize = width;\n    }\n    get tickSize() {\n        return this.timeAxisViewModel.tickSize;\n    }\n    /**\n     * Predefined event colors, useful in combos etc.\n     * @type {String[]}\n     * @category Scheduled events\n     */\n    static get eventColors() {\n        // These are the colors available by default for Scheduler and Gantt\n        // They classes are located in eventstyles.scss\n        return ['red', 'pink', 'purple', 'magenta', 'violet', 'indigo', 'blue', 'cyan', 'teal', 'green', 'gantt-green', 'lime', 'yellow', 'orange', 'deep-orange', 'gray', 'light-gray'];\n    }\n    /**\n     * Predefined event styles , useful in combos etc.\n     * @type {String[]}\n     * @category Scheduled events\n     */\n    static get eventStyles() {\n        return ['plain', 'border', 'hollow', 'colored', 'line', 'dashed', 'minimal', 'rounded'];\n    }\n    updateEventStyle(style) {\n        if (!this.isConfiguring) {\n            this.refreshWithTransition();\n            this.trigger('stateChange');\n        }\n    }\n    updateEventColor(color) {\n        if (!this.isConfiguring) {\n            this.refreshWithTransition();\n            this.trigger('stateChange');\n        }\n    }\n    //endregion\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport Scroller from '../../../Core/helper/util/Scroller.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport TimelineZoomable from './TimelineZoomable.js';\n/**\n * @module Scheduler/view/mixin/TimelineScroll\n */\nconst\n    maintainVisibleStart = {\n        maintainVisibleStart : true\n    },\n    defaultScrollOptions = {\n        block : 'nearest'\n    };\n/**\n * Functions for scrolling to events, dates etc.\n *\n * Note: the mixin applies {@link Scheduler/view/mixin/TimelineZoomable} mixin if it's not applied yet.\n *\n * @mixin\n */\nexport default Target => class TimelineScroll extends (Target || Base).mixin(\n    // the mixin overrides TimelineZoomable method so should be applied after it\n    TimelineZoomable\n) {\n    static $name = 'TimelineScroll';\n    static configurable = {\n        /**\n         * This config defines the size of the start and end invisible parts of the timespan when {@link #config-infiniteScroll} set to `true`.\n         *\n         * It should be provided as a coefficient, which will be multiplied by the size of the scheduling area.\n         *\n         * For example, if `bufferCoef` is `5` and the panel view width is 200px then the timespan will be calculated to\n         * have approximately 1000px (`5 * 200`) to the left and 1000px to the right of the visible area, resulting\n         * in 2200px of totally rendered content.\n         *\n         * @config {Number}\n         * @category Infinite scroll\n         * @default\n         */\n        bufferCoef : 5,\n        /**\n         * This config defines the scroll limit, which, when exceeded will cause a timespan shift.\n         * The limit is calculated as the `panelWidth * {@link #config-bufferCoef} * bufferThreshold`. During scrolling, if the left or right side\n         * has less than that of the rendered content - a shift is triggered.\n         *\n         * For example if `bufferCoef` is `5` and the panel view width is 200px and `bufferThreshold` is 0.2, then the timespan\n         * will be shifted when the left or right side has less than 200px (5 * 200 * 0.2) of content.\n         * @config {Number}\n         * @category Infinite scroll\n         * @default\n         */\n        bufferThreshold : 0.2,\n        /**\n         * Configure as `true` to automatically adjust the panel timespan during scrolling in the time dimension,\n         * when the scroller comes close to the start/end edges.\n         *\n         * The actually rendered timespan in this mode (and thus the amount of HTML in the DOM) is calculated based\n         * on the {@link #config-bufferCoef} option, and is thus not controlled by the {@link Scheduler/view/TimelineBase#config-startDate}\n         * and {@link Scheduler/view/TimelineBase#config-endDate} configs. The moment when the timespan shift\n         * happens is determined by the {@link #config-bufferThreshold} value.\n         *\n         * To specify initial point in time to view, supply the\n         * {@link Scheduler/view/TimelineBase#config-visibleDate} config.\n         *\n         * @config {Boolean} infiniteScroll\n         * @category Infinite scroll\n         * @default\n         */\n        infiniteScroll : false\n    };\n    //region TimelineZoomable injections\n    onZoomToSpan({ startDate }) {\n        if (this.infiniteScroll) {\n            this.scrollToDate(startDate, { block : 'start' });\n        }\n    }\n    calculateOptimalDateRange(centerDate, viewportSize, viewPreset) {\n        if (this.infiniteScroll) {\n            if (this.zoomKeepsOriginalTimespan) {\n                const { startDate, endDate } = this.timeAxis;\n                return { startDate, endDate };\n            }\n            return this.calculateInfiniteScrollingDateRange(centerDate, true);\n        }\n        return super.calculateOptimalDateRange(...arguments);\n    }\n    //endregion TimelineZoomable injections\n    initScroll() {\n        const\n            me = this,\n            {\n                isHorizontal,\n                visibleDate\n            }  = me;\n        super.initScroll();\n        const { scrollable } = isHorizontal ? me.timeAxisSubGrid : me;\n        scrollable.ion({\n            scroll  : 'onTimelineScroll',\n            thisObj : me\n        });\n        // Ensure the TimeAxis starts life at the correct size with buffer zones\n        // outside the visible window.\n        if (me.infiniteScroll) {\n            // If we have infiniteScroll-partners we don't reconfigure the timeAxis for each view\n            // So we need to trigger timeAxisViewModel.update manually to refresh the view\n            if (me.partneredWith?.values.some(partner => partner.infiniteScroll)) {\n                // Use exact subpixel available space so that tick size calculation is correct.\n                const availableSpace = scrollable.element.getBoundingClientRect()[me.isHorizontal ? 'width' : 'height'];\n                me.timeAxisViewModel.update(availableSpace, false, true);\n            }\n            // no infiniteScroll partners involved - calculate & set timespan\n            else {\n                const\n                    setTimeSpanOptions     = visibleDate ? { ...visibleDate, visibleDate : visibleDate.date } : { visibleDate : me.viewportCenterDate, block : 'center' },\n                    { startDate, endDate } = me.calculateInfiniteScrollingDateRange(setTimeSpanOptions.visibleDate, setTimeSpanOptions.block === 'center');\n                // Don't ask to maintain visible start - we're initializing - there's no visible start yet.\n                // If there's a visibleDate set, it will execute its scroll on paint.\n                me.setTimeSpan(\n                    startDate,\n                    endDate,\n                    setTimeSpanOptions\n                );\n            }\n        }\n    }\n    /**\n     * A {@link Core.helper.util.Scroller} which scrolls the time axis in whatever {@link Scheduler.view.Scheduler#config-mode} the\n     * Scheduler is configured, either `horizontal` or `vertical`.\n     *\n     * The width and height dimensions are replaced by `size`. So this will expose the following properties:\n     *\n     *    - `clientSize` The size of the time axis viewport.\n     *    - `scrollSize` The full scroll size of the time axis viewport\n     *    - `position` The position scrolled to along the time axis viewport\n     *\n     * @property {Core.helper.util.Scroller}\n     * @readonly\n     * @category Scrolling\n     */\n    get timelineScroller() {\n        const me = this;\n        if (!me.scrollInitialized) {\n            me.initScroll();\n        }\n        return me._timelineScroller || (me._timelineScroller = new TimelineScroller({\n            widget       : me,\n            scrollable   : me.isHorizontal ? me.timeAxisSubGrid.scrollable : me.scrollable,\n            isHorizontal : me.isHorizontal\n        }));\n    }\n    /**\n     * Used to calculate the range to extend the TimeAxis to during infinite scroll.\n     * @param {Date} date\n     * @param {Boolean} centered\n     * @param {Scheduler.preset.ViewPreset} [preset] Optional, the preset for which to calculate the range.\n     * defaults to the currently active ViewPreset\n     * @returns {Object} `{ startDate, endDate }`\n     * @internal\n     */\n    calculateInfiniteScrollingDateRange(date, centered, preset = this.timeAxisViewModel.viewPreset) {\n        const\n            {\n                timeAxis,\n                availableSpace\n            } = this.timeAxisViewModel,\n            {\n                bufferCoef\n            } = this,\n            {\n                leafUnit,\n                leafIncrement,\n                topUnit,\n                topIncrement,\n                tickSize\n            } = preset,\n            // If the units are the same and the increments are integer, snap to the top header's unit & increment\n            useTop    = leafUnit === topUnit && Math.round(topIncrement) === topIncrement && Math.round(leafIncrement) === leafIncrement,\n            snapSize  = useTop ? topIncrement : leafIncrement,\n            snapUnit  = useTop ? topUnit      : leafUnit;\n        // if provided date is the central point on the timespan\n        if (centered) {\n            const halfSpan = Math.ceil((availableSpace * bufferCoef + (availableSpace / 2)) / tickSize);\n            return {\n                startDate : timeAxis.floorDate(DateHelper.add(date, -halfSpan * leafIncrement, leafUnit), false, snapUnit, snapSize),\n                endDate   : timeAxis.ceilDate(DateHelper.add(date, halfSpan * leafIncrement, leafUnit), false, snapUnit, snapSize)\n            };\n        }\n        // if provided date is the left coordinate of the visible timespan area\n        else {\n            const bufferedTicks = Math.ceil(availableSpace * bufferCoef / tickSize);\n            return {\n                startDate : timeAxis.floorDate(DateHelper.add(date, -bufferedTicks * leafIncrement, leafUnit), false, snapUnit, snapSize),\n                endDate   : timeAxis.ceilDate(DateHelper.add(date, Math.ceil((availableSpace / tickSize + bufferedTicks) * leafIncrement), leafUnit), false, snapUnit, snapSize)\n            };\n        }\n    }\n    doDestroy() {\n        this._timelineScroller?.destroy();\n        super.doDestroy();\n    }\n    onTimelineScroll({ source }) {\n        // On scroll, check if we are nearing the end to see if the sliding window needs moving.\n        // onSchedulerHorizontalScroll is delayed to animationFrame\n        if (this.infiniteScroll) {\n            this.checkTimeAxisScroll(source[this.isHorizontal ? 'x' : 'y']);\n        }\n    }\n    checkTimeAxisScroll(scrollPos) {\n        const\n            me             = this,\n            scrollable     = me.timelineScroller,\n            { clientSize } = scrollable,\n            requiredSize   = clientSize * me.bufferCoef,\n            limit          = requiredSize * me.bufferThreshold,\n            maxScroll      = scrollable.maxPosition,\n            { style }      = me.timeAxisSubGrid.virtualScrollerElement;\n        // if scroll violates limits let's shift timespan\n        if ((maxScroll - scrollPos < limit) || scrollPos < limit) {\n            // If they were dragging the thumb, this must be a one-time thing. They *must* lose contact\n            // with the thumb when the window shift occurs and the thumb zooms back to the center.\n            // Changing for a short time to overflow:hidden terminates the thumb drag.\n            // They can start again from the center, the reset happens very quickly.\n            style.overflow = 'hidden';\n            style.pointerEvents = 'none';\n            // Avoid content height changing when scrollbar disappears\n            style.paddingBottom = `${DomHelper.scrollBarWidth}px`;\n            me.setTimeout(() => {\n                style.overflow = '';\n                style.paddingBottom = '';\n                style.pointerEvents = '';\n            }, 100);\n            me.shiftToDate(me.getDateFromCoordinate(scrollPos, null, true, false, true));\n        }\n    }\n    shiftToDate(date, centered) {\n        const newRange = this.calculateInfiniteScrollingDateRange(date, centered);\n        // this will trigger a refresh (`refreshKeepingScroll`) which will perform `restoreScrollState` and sync the scrolling position\n        this.setTimeSpan(newRange.startDate, newRange.endDate, maintainVisibleStart);\n    }\n    // If we change to infinite scrolling dynamically, it should create the buffer zones.\n    updateInfiniteScroll(infiniteScroll) {\n        // At construction time, this is handled in initScroll.\n        // This is just here to handle dynamic updates.\n        if (!this.isConfiguring && infiniteScroll) {\n            this.checkTimeAxisScroll(this.timelineScroller.position);\n        }\n    }\n    //region Scroll to date\n    /**\n     * Scrolls the timeline \"tick\" encapsulating the passed `Date` into view according to the passed options.\n     * @param {Date} date The date to which to scroll the timeline\n     * @param {BryntumScrollOptions} [options] How to scroll.\n     * @returns {Promise} A Promise which resolves when the scrolling is complete.\n     * @category Scrolling\n     */\n    async scrollToDate(date, options = {}) {\n        const\n            me               = this,\n            {\n                timeAxis,\n                visibleDateRange,\n                infiniteScroll\n            }              = me,\n            {\n                unit,\n                increment\n            }              = timeAxis,\n            edgeOffset     = options.edgeOffset || 0,\n            visibleWidth   = DateHelper.ceil(visibleDateRange.endDate, increment + ' ' + unit) - DateHelper.floor(visibleDateRange.startDate, increment + ' ' + unit),\n            direction      = date > me.viewportCenterDate ? 1 : -1,\n            extraScroll    = (infiniteScroll ? visibleWidth * me.bufferCoef * me.bufferThreshold : (options.block === 'center' ? visibleWidth / 2 : (edgeOffset ? me.getMilliSecondsPerPixelForZoomLevel(me.viewPreset) * edgeOffset : 0))) * direction,\n            visibleDate    = new Date(date.getTime() + extraScroll),\n            shiftDirection = visibleDate > timeAxis.endDate ? 1 : visibleDate < timeAxis.startDate ? -1 : 0;\n        // Required visible date outside TimeAxis and infinite scrolling, that has opinions about how\n        // much scroll range has to be created after the target date.\n        if (shiftDirection && me.infiniteScroll) {\n            me.shiftToDate(new Date(date - extraScroll), null, true);\n            // shift to date could trigger a native browser async scroll out of our control. If a scroll\n            // happens during scrollToCoordinate, the scrolling is cancelled so we wait a bit here\n            await me.nextAnimationFrame();\n        }\n        const\n            scrollerViewport = me.timelineScroller.viewport,\n            localCoordinate  = me.getCoordinateFromDate(date, true),\n            // Available space can be less than tick size (Export.t.js in Gantt)\n            width            = Math.min(me.timeAxisViewModel.tickSize, me.timeAxisViewModel.availableSpace),\n            target           = me.isHorizontal\n                // In RTL coordinate is for the right edge of the tick, so we need to subtract width\n                ? new Rectangle(me.getCoordinateFromDate(date, false) - (me.rtl ? width : 0), scrollerViewport.y, width, scrollerViewport.height)\n                : new Rectangle(scrollerViewport.x, me.getCoordinateFromDate(date, false), scrollerViewport.width, me.timeAxisViewModel.tickSize);\n        await me.scrollToCoordinate(localCoordinate, target, date, options);\n    }\n    /**\n     * Scrolls to current time.\n     * @param {BryntumScrollOptions} [options] How to scroll.\n     * @returns {Promise} A Promise which resolves when the scrolling is complete.\n     * @category Scrolling\n     */\n    scrollToNow(options = {}) {\n        return this.scrollToDate(new Date(), options);\n    }\n    /**\n     * Used by {@link #function-scrollToDate} to scroll to correct coordinate.\n     * @param {Number} localCoordinate Coordinate to scroll to\n     * @param {Element|Core.helper.util.Rectangle} target The target\n     * @param {Date} date Date to scroll to, used for reconfiguring the time axis\n     * @param {BryntumScrollOptions} [options] How to scroll.\n     * @returns {Promise} A Promise which resolves when the scrolling is complete.\n     * @private\n     * @category Scrolling\n     */\n    async scrollToCoordinate(localCoordinate, target, date, options = {}) {\n        const me = this;\n        // Not currently have this date in a timeaxis. Ignore negative scroll in weekview, it can be just 'filtered' with\n        // startTime/endTime config\n        if (localCoordinate < 0) {\n            // adjust the timeaxis first\n            const\n                visibleSpan         = me.endDate - me.startDate,\n                { unit, increment } = me.timeAxis,\n                newStartDate        = DateHelper.floor(new Date(date.getTime() - (visibleSpan / 2)), increment + ' ' + unit),\n                newEndDate          = DateHelper.add(newStartDate, visibleSpan);\n            // We're trying to reconfigure time span to current dates, which means we are as close to center as it\n            // could be. Do nothing then.\n            // covered by 1102_panel_api\n            if (newStartDate - me.startDate !== 0 && newEndDate - me.endDate !== 0) {\n                await me.setTimeSpan(newStartDate, newEndDate);\n                return me.scrollToDate(date, options);\n            }\n            return;\n        }\n        await me.timelineScroller.scrollIntoView(target, options);\n        // Horizontal scroll is triggered on next frame in SubGrid.js, view is not up to date yet. Resolve on next frame\n        return !me.isDestroyed && me.nextAnimationFrame();\n    }\n    //endregion\n    //region Relative scrolling\n    // These methods are important to users because although they are mixed into the top level Grid/Scheduler,\n    // for X scrolling the explicitly target the SubGrid that holds the scheduler.\n    /**\n     * Get/set the `scrollLeft` value of the SubGrid that holds the scheduler.\n     *\n     * This may be __negative__ when the writing direction is right-to-left.\n     * @property {Number}\n     * @category Scrolling\n     */\n    set scrollLeft(left) {\n        this.timeAxisSubGrid.scrollable.element.scrollLeft = left;\n    }\n    get scrollLeft() {\n        return this.timeAxisSubGrid.scrollable.element.scrollLeft;\n    }\n    /**\n     * Get/set the writing direction agnostic horizontal scroll position.\n     *\n     * This is always the __positive__ offset from the scroll origin whatever the writing\n     * direction in use.\n     *\n     * Applies to the SubGrid that holds the scheduler\n     * @property {Number}\n     * @category Scrolling\n     */\n    set scrollX(x) {\n        this.timeAxisSubGrid.scrollable.x = x;\n    }\n    get scrollX() {\n        return this.timeAxisSubGrid.scrollable.x;\n    }\n    /**\n     * Get/set vertical scroll\n     * @property {Number}\n     * @category Scrolling\n     */\n    set scrollTop(top) {\n        this.scrollable.y = top;\n    }\n    get scrollTop() {\n        return this.scrollable.y;\n    }\n    /**\n     * Horizontal scrolling. Applies to the SubGrid that holds the scheduler\n     * @param {Number} x\n     * @param {BryntumScrollOptions|Boolean} [options] How to scroll. May be passed as `true` to animate.\n     * @returns {Promise} A promise which is resolved when the scrolling has finished.\n     * @category Scrolling\n     */\n    scrollHorizontallyTo(coordinate, options = true) {\n        return this.timeAxisSubGrid.scrollable.scrollTo(coordinate, null, options);\n    }\n    /**\n     * Vertical scrolling\n     * @param {Number} y\n     * @param {BryntumScrollOptions|Boolean} [options] How to scroll. May be passed as `true` to animate.\n     * @returns {Promise} A promise which is resolved when the scrolling has finished.\n     * @category Scrolling\n     */\n    scrollVerticallyTo(y, options = true) {\n        return this.scrollable.scrollTo(null, y, options);\n    }\n    /**\n     * Scrolls the subgrid that contains the scheduler\n     * @param {Number} x\n     * @param {BryntumScrollOptions|Boolean} [options] How to scroll. May be passed as `true` to animate.\n     * @returns {Promise} A promise which is resolved when the scrolling has finished.\n     * @category Scrolling\n     */\n    scrollTo(x, options = true) {\n        return this.timeAxisSubGrid.scrollable.scrollTo(x, null, options);\n    }\n    //endregion\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n// Internal class used to interrogate and manipulate the timeline scroll position.\n// This delegates all operations to the appropriate Scroller, horizontal or vertical.\nclass TimelineScroller extends Scroller {\n    static get configurable() {\n        return {\n            position : null,\n            x        : null,\n            y        : null\n        };\n    }\n    // This class is passive about configuring the element.\n    // It has no opinions about *how* the overflow is handled.\n    updateOverflowX() {}\n    updateOverflowY() {}\n    onScroll(e) {\n        super.onScroll(e);\n        this._position = null;\n    }\n    syncPartners(force) {\n        this.scrollable.syncPartners(force);\n    }\n    updatePosition(position) {\n        this.scrollable[this.isHorizontal ? 'x' : 'y'] = position;\n    }\n    get viewport() {\n        return this.scrollable.viewport;\n    }\n    get position() {\n        return this._position = this.scrollable[this.isHorizontal ? 'x' : 'y'];\n    }\n    get clientSize() {\n        return this.scrollable[`client${this.isHorizontal ? 'Width' : 'Height'}`];\n    }\n    get scrollSize() {\n        return this.scrollable[`scroll${this.isHorizontal ? 'Width' : 'Height'}`];\n    }\n    get maxPosition() {\n        return this.scrollable[`max${this.isHorizontal ? 'X' : 'Y'}`];\n    }\n    scrollTo(position, options) {\n        return this.isHorizontal ? this.scrollable.scrollTo(position, null, options) : this.scrollable.scrollTo(null, position, options);\n    }\n    scrollBy(xDelta = 0, yDelta = 0, options = defaultScrollOptions) {\n        // Use the correct delta by default, but if it's zero, accommodate axis error.\n        return this.isHorizontal ? this.scrollable.scrollBy(xDelta || yDelta, 0, options) : this.scrollable.scrollBy(0, yDelta || xDelta, options);\n    }\n    scrollIntoView() {\n        return this.scrollable.scrollIntoView(...arguments);\n    }\n    // We accommodate mistakes. Setting X and Y sets the appropriate scroll axis position\n    changeX(x) {\n        this.position = x;\n    }\n    changeY(y) {\n        this.position = y;\n    }\n    get x() {\n        return this.position;\n    }\n    set x(x) {\n        this.scrollable[this.isHorizontal ? 'x' : 'y'] = x;\n    }\n    get y() {\n        return this.position;\n    }\n    set y(y) {\n        this.scroller[this.isHorizontal ? 'x' : 'y'] = y;\n    }\n    get clientWidth() {\n        return this.clientSize;\n    }\n    get clientHeight() {\n        return this.clientSize;\n    }\n    get scrollWidth() {\n        return this.scrollSize;\n    }\n    get scrollHeight() {\n        return this.scrollSize;\n    }\n    get maxX() {\n        return this.maxPosition;\n    }\n    get maxY() {\n        return this.maxPosition;\n    }\n}\n", "import Base from '../../../Core/Base.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n/**\n * @module Scheduler/view/mixin/TimelineState\n */\nconst copyProperties = [\n    'barMargin'\n];\n/**\n * Mixin for Timeline base that handles state. It serializes the following timeline properties:\n *\n * * barMargin\n * * zoomLevel\n *\n * See {@link Grid.view.mixin.GridState} and {@link Core.mixin.State} for more information on state.\n *\n * @mixin\n */\nexport default Target => class TimelineState extends (Target || Base) {\n    static get $name() {\n        return 'TimelineState';\n    }\n    /**\n     * Gets or sets timeline's state. Check out {@link Scheduler.view.mixin.TimelineState} mixin for details.\n     * @member {Object} state\n     * @property {Object[]} state.columns\n     * @property {Number} state.rowHeight\n     * @property {Object} state.scroll\n     * @property {Number} state.scroll.scrollLeft\n     * @property {Number} state.scroll.scrollTop\n     * @property {Array} state.selectedRecords\n     * @property {String} state.style\n     * @property {String} state.selectedCell\n     * @property {Object} state.store\n     * @property {Object} state.store.sorters\n     * @property {Object} state.store.groupers\n     * @property {Object} state.store.filters\n     * @property {Object} state.subGrids\n     * @property {Number} state.barMargin\n     * @property {Number} state.zoomLevel\n     * @category State\n     */\n    /**\n     * Get timeline's current state for serialization. State includes rowHeight, headerHeight, readOnly, selectedCell,\n     * selectedRecordId, column states and store state etc.\n     * @returns {Object} State object to be serialized\n     * @private\n     */\n    getState() {\n        const\n            me    = this,\n            state = ObjectHelper.copyProperties(super.getState(), me, copyProperties);\n        state.zoomLevel = me.zoomLevel;\n        state.zoomLevelOptions = {\n            startDate  : me.startDate,\n            endDate    : me.endDate,\n            // With infinite scroll reading viewportCenterDate too early will lead to exception\n            centerDate : !me.infiniteScroll || me.timeAxisViewModel.availableSpace ? me.viewportCenterDate : undefined,\n            width      : me.tickSize\n        };\n        return state;\n    }\n    /**\n     * Apply previously stored state.\n     * @param {Object} state\n     * @private\n     */\n    applyState(state) {\n        const me = this;\n        me.suspendRefresh();\n        ObjectHelper.copyProperties(me, state, copyProperties);\n        super.applyState(state);\n        if (state.zoomLevel != null) {\n            // Do not restore left scroll, infinite scroll should do all the work\n            if (me.infiniteScroll) {\n                if (state?.scroll?.scrollLeft) {\n                    state.scroll.scrollLeft = {};\n                }\n            }\n            if (me.isPainted) {\n                me.zoomToLevel(state.zoomLevel, state.zoomLevelOptions);\n            }\n            else {\n                me._zoomAfterPaint = { zoomLevel : state.zoomLevel, zoomLevelOptions : state.zoomLevelOptions };\n            }\n        }\n        me.resumeRefresh(true);\n    }\n    onInternalPaint(...args) {\n        super.onInternalPaint(...args);\n        if (this._zoomAfterPaint) {\n            const { zoomLevel, zoomLevelOptions } = this._zoomAfterPaint;\n            this.zoomToLevel(zoomLevel, zoomLevelOptions);\n            delete this._zoomAfterPaint;\n        }\n    }\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import GridHeader from '../../Grid/view/Header.js';\n/**\n * @module Scheduler/view/Header\n */\n/**\n * Custom header subclass which handles the existence of the special TimeAxisColumn\n *\n * @extends Grid/view/Header\n * @private\n */\nexport default class Header extends GridHeader {\n    static get $name() {\n        return 'SchedulerHeader';\n    }\n    refreshContent() {\n        // Only render contents into the header once as it contains the special rendering of the TimeAxisColumn\n        // In case ResizeObserver polyfill is used headers element will have resize monitors inserted and we should\n        // take that into account\n        // https://github.com/bryntum/support/issues/3444\n        if (!this.headersElement?.querySelector('.b-sch-timeaxiscolumn')) {\n            super.refreshContent();\n        }\n    }\n}\nHeader._$name = 'Header';", "import SubGrid from '../../Grid/view/SubGrid.js';\nimport Header from './Header.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\n/**\n * @module Scheduler/view/TimeAxisSubGrid\n */\n/**\n * Widget that encapsulates the SubGrid part of the scheduler which houses the timeline view.\n * @extends Grid/view/SubGrid\n * @private\n */\nexport default class TimeAxisSubGrid extends SubGrid {\n    static get $name() {\n        return 'TimeAxisSubGrid';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'timeaxissubgrid';\n    }\n    static get configurable() {\n        return {\n            // A Scheduler's SubGrid doesn't accept external columns moving in\n            sealedColumns : true,\n            // Use Scheduler's Header class\n            headerClass : Header\n        };\n    }\n    startConfigure(config) {\n        const { grid : scheduler } = config;\n        // Scheduler references its TimeAxisSubGrid instance through this property.\n        scheduler.timeAxisSubGrid = this;\n        super.startConfigure(config);\n        if (scheduler.isHorizontal) {\n            config.header = {\n                cls : {\n                    'b-sticky-headers' : scheduler.stickyHeaders\n                }\n            };\n            // We don't use what the GridSubGrids mixin tells us to.\n            // We use the Scheduler's Header class.\n            delete config.headerClass;\n        }\n        // If user have not specified a width or flex for scheduler region, default to flex=1\n        if (!('flex' in config || 'width' in config)) {\n            config.flex = 1;\n        }\n    }\n    changeScrollable() {\n        const\n            me         = this,\n            scrollable = super.changeScrollable(...arguments);\n        // TimeAxisSubGrid's X axis is stretched by its canvas.\n        // We don't need the Scroller's default stretching implementation.\n        if (scrollable) {\n            Object.defineProperty(scrollable, 'scrollWidth', {\n                get() {\n                    return this.element?.scrollWidth ?? 0;\n                },\n                set() {\n                    // Setting the scroll width to be wide just updates the canvas side in Scheduler.\n                    // We do not need the Scroller's default stretcher element to be added.\n                    // Note that \"me\" here is the TimeAxisSubGrid, so we are calling Scheduler.\n                    me.grid.updateCanvasSize();\n                }\n            });\n        }\n        return scrollable;\n    }\n    handleHorizontalScroll(addCls = true) {\n        // Swallow scroll syncing calls that happen during view preset changes, that process triggers multiple when\n        // it first changes tickWidth, then scrolls to center and then an additional sync on scroll end\n        if (!this.grid._viewPresetChanging) {\n            super.handleHorizontalScroll(addCls);\n        }\n    }\n    /**\n     * This is an event handler triggered when the TimeAxisSubGrid changes size.\n     * Its height changes when content height changes, and that is not what we are\n     * interested in here. If the *width* changes, that means the visible viewport\n     * has changed size.\n     * @param {HTMLElement} element\n     * @param {Number} width\n     * @param {Number} height\n     * @param {Number} oldWidth\n     * @param {Number} oldHeight\n     * @private\n     */\n    onInternalResize(element, width, height, oldWidth, oldHeight) {\n        const me = this;\n        // Call super first, to clear cached width / height\n        super.onInternalResize(...arguments);\n        // We, as the TimeAxisSubGrid dictate the scheduler viewport width\n        if (me.isPainted && width !== oldWidth) {\n            const\n                scheduler     = me.grid,\n                bodyHeight    = scheduler._bodyRectangle.height,\n                // Avoid ResizeObserver errors when this operation may create a scrollbar\n                shouldSuspend = me.monitorResize && DomHelper.scrollBarWidth && width < oldWidth;\n            if (shouldSuspend) {\n                me.monitorResize = false;\n            }\n            scheduler.onSchedulerViewportResize(width, bodyHeight, oldWidth, bodyHeight);\n            // Revert to monitoring on the next animation frame.\n            // Changed to revert earlier because of issues when changing width programmatically\n            // This is to avoid \"ResizeObserver loop completed with undelivered notifications.\"\n            if (shouldSuspend) {\n                queueMicrotask(() => me.monitorResize = true);\n            }\n        }\n    }\n    get headerScrollWidth() {\n        return this.grid.isVertical ? super.headerScrollWidth : this.grid.timeAxisViewModel.totalSize;\n    }\n    // When restoring state we need to update time axis size immediately, resize event is not triggered fast enough to\n    // restore center date consistently\n    clearWidthCache() {\n        super.clearWidthCache();\n        // Check if we are in horizontal mode\n        if (this.owner.isHorizontal) {\n            this.owner.updateViewModelAvailableSpace(this.width);\n        }\n    }\n    async expand() {\n        const { owner } = this;\n        await super.expand();\n        if (owner.isPainted) {\n            owner.timeAxisViewModel.update(this.width, false, true);\n        }\n    }\n}\n// Register this widget type with its Factory\nTimeAxisSubGrid.initClass();\nTimeAxisSubGrid._$name = 'TimeAxisSubGrid';", "import GlobalEvents from '../../Core/GlobalEvents.js';\nimport GridBase from '../../Grid/view/GridBase.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport FunctionHelper from '../../Core/helper/FunctionHelper.js';\nimport ResizeMonitor from '../../Core/helper/ResizeMonitor.js';\nimport Collection from '../../Core/util/Collection.js';\nimport IdHelper from '../../Core/helper/IdHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\nimport TimeAxis from '../data/TimeAxis.js';\nimport TimeAxisViewModel from './model/TimeAxisViewModel.js';\nimport TimelineDateMapper from './mixin/TimelineDateMapper.js';\nimport TimelineDomEvents from './mixin/TimelineDomEvents.js';\nimport TimelineViewPresets from './mixin/TimelineViewPresets.js';\nimport TimelineZoomable from './mixin/TimelineZoomable.js';\nimport RecurringEvents from './mixin/RecurringEvents.js';\nimport TimelineEventRendering from './mixin/TimelineEventRendering.js';\nimport TimelineScroll from './mixin/TimelineScroll.js';\nimport TimelineState from './mixin/TimelineState.js';\nimport './TimeAxisSubGrid.js';\nimport '../../Grid/feature/RegionResize.js';\nconst\n    exitTransition = {\n        fn                : 'exitTransition',\n        delay             : 0,\n        cancelOutstanding : true\n    },\n    inRange = (v, r0, r1) => (r0 == null)\n        ? (r1 == null || v < r1)\n        : (r1 == null)\n            ? v >= r0\n            : (r0 < r1)\n                ? (r0 <= v && v < r1)       // 5 in [1, 10]  (after 1 and before 10)\n                : (v < r1 || r0 <= v),      // 5 in [10, 1]  (after 10 or before 1)\n    isWorkingTime = (d, wt) => inRange(d.getDay(), wt.fromDay, wt.toDay) && inRange(d.getHours(), wt.fromHour, wt.toHour),\n    emptyObject   = {};\n/**\n * @module Scheduler/view/TimelineBase\n */\n/**\n * Options accepted by the Scheduler's {@link Scheduler.view.Scheduler#config-visibleDate} property.\n *\n * @typedef {Object} VisibleDate\n * @property {Date} date The date to bring into view.\n * @property {'start'|'end'|'center'|'nearest'} [block] How far to scroll the date.\n * @property {Number} [edgeOffset] edgeOffset A margin around the date to bring into view.\n * @property {AnimateScrollOptions|Boolean|Number} [animate] Set to `true` to animate the scroll by 300ms,\n * or the number of milliseconds to animate over, or an animation config object.\n */\n/**\n * Abstract base class used by timeline based components such as Scheduler and Gantt. Based on Grid, supplies a \"locked\"\n * region for columns and a \"normal\" for rendering of events etc.\n * @abstract\n *\n * @mixes Scheduler/view/mixin/TimelineDateMapper\n * @mixes Scheduler/view/mixin/TimelineDomEvents\n * @mixes Scheduler/view/mixin/TimelineEventRendering\n * @mixes Scheduler/view/mixin/TimelineZoomable\n * @mixes Scheduler/view/mixin/TimelineScroll\n * @mixes Scheduler/view/mixin/TimelineState\n * @mixes Scheduler/view/mixin/TimelineViewPresets\n * @mixes Scheduler/view/mixin/RecurringEvents\n *\n * @extends Grid/view/Grid\n */\nexport default class TimelineBase extends GridBase.mixin(\n    TimelineDateMapper,\n    TimelineDomEvents,\n    TimelineEventRendering,\n    TimelineZoomable,\n    TimelineScroll,\n    TimelineState,\n    TimelineViewPresets,\n    RecurringEvents\n) {\n    //region Config\n    /**\n     * @prp animateTreeNodeToggle\n     * @hide\n     */\n    static $name = 'TimelineBase';\n    // Factoryable type name\n    static type = 'timelinebase';\n    static configurable = {\n        // Not yet supported\n        animateTreeNodeToggle : false,\n        partnerSharedConfigs : {\n            value : ['timeAxisViewModel', 'timeAxis', 'viewPreset', 'infiniteScroll'],\n            $config : {\n                merge : 'distinct'\n            }\n        },\n        /**\n         * Get/set startDate. Defaults to current date if none specified.\n         *\n         * When using {@link #config-infiniteScroll}, use {@link #config-visibleDate} to control initially visible date\n         * instead.\n         *\n         * **Note:** If you need to set start and end date at the same time, use {@link #function-setTimeSpan} method.\n         * @member {Date} startDate\n         * @category Common\n         */\n        /**\n         * The start date of the timeline (if not configure with {@link #config-infiniteScroll}).\n         *\n         * If omitted, and a TimeAxis has been set, the start date of the provided {@link Scheduler.data.TimeAxis} will\n         * be used. If no TimeAxis has been configured, it'll use the start/end dates of the loaded event dataset. If no\n         * date information exists in the event data set, it defaults to the current date and time.\n         *\n         * If a string is supplied, it will be parsed using\n         * {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat}.\n         *\n         * When using {@link #config-infiniteScroll}, use {@link #config-visibleDate} to control initially visible date\n         * instead.\n         *\n         * **Note:** If you need to set start and end date at the same time, use the {@link #function-setTimeSpan} method.\n         * @config {Date|String}\n         * @category Common\n         */\n        startDate : {\n            $config : {\n                equal : 'date'\n            },\n            value : null\n        },\n        /**\n         * Get/set endDate. Defaults to startDate + default span of the used ViewPreset.\n         *\n         * **Note:** If you need to set start and end date at the same time, use {@link #function-setTimeSpan} method.\n         * @member {Date} endDate\n         * @category Common\n         */\n        /**\n         * The end date of the timeline (if not configure with {@link #config-infiniteScroll}).\n         *\n         * If omitted, it will be calculated based on the {@link #config-startDate} setting and the 'defaultSpan'\n         * property of the current {@link #config-viewPreset}.\n         *\n         * If a string is supplied, it will be parsed using\n         * {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat}.\n         *\n         * **Note:** If you need to set start and end date at the same time, use the {@link #function-setTimeSpan} method.\n         * @config {Date|String}\n         * @category Common\n         */\n        endDate : {\n            $config : {\n                equal : 'date'\n            },\n            value : null\n        },\n        /**\n         * Partners this Timeline panel with another Timeline in order to sync their region sizes (sub-grids like locked, normal will get the same width),\n         * start and end dates, view preset, zoom level and scrolling position. All these values will be synced with the timeline defined as the `partner`.\n         *\n         * - To add a new partner dynamically see {@link #function-addPartner} method.\n         * - To remove existing partner see {@link #function-removePartner} method.\n         * - To check if timelines are partners see {@link #function-isPartneredWith} method.\n         *\n         * Column widths and hide/show state are synced between partnered schedulers when the column set is identical.\n         * @config {Scheduler.view.TimelineBase}\n         * @category Time axis\n         */\n        partner : null,\n        /**\n         * When set, the text in the major time axis header sticks in the scrolling viewport as long as possible.\n         * @config {Boolean}\n         * @default\n         * @category Time axis\n         */\n        stickyHeaders : true,\n        /**\n         * A scrolling `options` object describing the scroll action, including a `date` option\n         * which references a `Date`. See {@link #function-scrollToDate} for details about scrolling options.\n         *\n         * ```javascript\n         *     // The date we want in the center of the Scheduler viewport\n         *     myScheduler.visibleDate = {\n         *         date    : new Date(2023, 5, 17, 12),\n         *         block   : 'center',\n         *         animate : true\n         *     };\n         * ```\n         * @member {Object} visibleDate\n         * @category Common\n         */\n        /**\n         * A date to bring into view initially on the scrollable timeline.\n         *\n         * This may be configured as either a `Date` or a scrolling `options` object describing\n         * the scroll action, including a `date` option which references a `Date`.\n         *\n         * See {@link #function-scrollToDate} for details about scrolling options.\n         *\n         * Note that if a naked `Date` is passed, it will be stored internally as a scrolling options object\n         * using the following defaults:\n         *\n         * ```javascript\n         * {\n         *     date  : <The Date object>,\n         *     block : 'nearest'\n         * }\n         * ```\n         *\n         * This moves the date into view by the shortest scroll, so that it just appears at an edge.\n         *\n         * To bring your date of interest to the center of the viewport, configure your\n         * Scheduler thus:\n         *\n         * ```javascript\n         *     visibleDate : {\n         *         date  : new Date(2023, 5, 17, 12),\n         *         block : 'center'\n         *     }\n         * ```\n         * @config {Date|VisibleDate}\n         * @category Common\n         */\n        visibleDate : null,\n        /**\n         * CSS class to add to rendered events\n         * @config {String}\n         * @category CSS\n         * @private\n         */\n        eventCls : null,\n        /**\n         * Set to `true` to force the time columns to fit to the available space (horizontal or vertical depends on mode).\n         * Note that setting {@link #config-suppressFit} to `true`, will disable `forceFit` functionality. Zooming\n         * cannot be used when `forceFit` is set.\n         * @prp {Boolean}\n         * @default\n         * @category Time axis\n         */\n        forceFit : false,\n        /**\n         * Set to a time zone or a UTC offset. This will set the projects\n         * {@link Scheduler.model.ProjectModel#config-timeZone} config accordingly. As this config is only a referer,\n         * please se project's config {@link Scheduler.model.ProjectModel#config-timeZone documentation} for more\n         * information.\n         *\n         * ```javascript\n         * new Calendar(){\n         *   timeZone : 'America/Chicago'\n         * }\n         * ```\n         * @prp {String|Number} timeZone\n         * @category Misc\n         */\n        timeZone : null,\n        /**\n         * By default the row hover effect is not visible in the Scheduler part of the grid.\n         *\n         * Set this to `false` to show the hover effect in Scheduler rows.\n         * @prp {Boolean} hideRowHover\n         * @default true\n         * @category Misc\n         */\n        hideRowHover : {\n            $config : 'lazy',\n            value   : true\n        }\n    };\n    static get defaultConfig() {\n        return {\n            /**\n             * A valid JS day index between 0-6 (0: Sunday, 1: Monday etc.) to be considered the start day of the week.\n             * When omitted, the week start day is retrieved from the active locale class.\n             * @config {Number} weekStartDay\n             * @category Time axis\n             */\n            /**\n             * An object with format `{ fromDay, toDay, fromHour, toHour }` that describes the working days and hours.\n             * This object will be used to populate TimeAxis {@link Scheduler.data.TimeAxis#config-include} property.\n             *\n             * Using it results in a non-continuous time axis. Any ticks not covered by the working days and hours will\n             * be excluded. Events within larger ticks (for example if using week as the unit for ticks) will be\n             * stretched to fill the gap otherwise left by the non working hours.\n             *\n             * As with end dates, `toDay` and `toHour` are exclusive. Thus `toDay : 6` means that day 6 (saturday) will\n             * not be included.\n             *\n             *\n             * **NOTE:** When this feature is enabled {@link Scheduler.view.mixin.TimelineZoomable Zooming feature} is\n             * not supported. It's recommended to disable zooming controls:\n             *\n             * ```javascript\n             * new Scheduler({\n             *     zoomOnMouseWheel          : false,\n             *     zoomOnTimeAxisDoubleClick : false,\n             *     ...\n             * });\n             * ```\n             *\n             * @config {Object}\n             * @category Time axis\n             */\n            workingTime : null,\n            /**\n             * A backing data store of 'ticks' providing the input date data for the time axis of timeline panel.\n             * @member {Scheduler.data.TimeAxis} timeAxis\n             * @readonly\n             * @category Time axis\n             */\n            /**\n             * A {@link Scheduler.data.TimeAxis} config object or instance, used to create a backing data store of\n             * 'ticks' providing the input date data for the time axis of timeline panel. Created automatically if none\n             * supplied.\n             * @config {TimeAxisConfig|Scheduler.data.TimeAxis}\n             * @category Time axis\n             */\n            timeAxis : null,\n            /**\n             * The backing view model for the visual representation of the time axis.\n             * Either a real instance or a simple config object.\n             * @private\n             * @config {Scheduler.view.model.TimeAxisViewModel|TimeAxisViewModelConfig}\n             * @category Time axis\n             */\n            timeAxisViewModel : null,\n            /**\n             * You can set this option to `false` to make the timeline panel start and end on the exact provided\n             * {@link #config-startDate}/{@link #config-endDate} w/o adjusting them.\n             * @config {Boolean}\n             * @default\n             * @category Time axis\n             */\n            autoAdjustTimeAxis : true,\n            /**\n             * Affects drag drop and resizing of events when {@link Scheduler/view/mixin/TimelineDateMapper#config-snap}\n             * is enabled.\n             *\n             * If set to `true`, dates will be snapped relative to event start. e.g. for a zoom level with\n             * `timeResolution = { unit: \"s\", increment: \"20\" }`, an event that starts at 10:00:03 and is dragged would\n             * snap its start date to 10:00:23, 10:00:43 etc.\n             *\n             * When set to `false`, dates will be snapped relative to the timeAxis startDate (tick start)\n             * - 10:00:03 -> 10:00:20, 10:00:40 etc.\n             *\n             * @config {Boolean}\n             * @default\n             * @category Scheduled events\n             */\n            snapRelativeToEventStartDate : false,\n            /**\n             * Set to `true` to prevent auto calculating of a minimal {@link Scheduler.view.mixin.TimelineEventRendering#property-tickSize}\n             * to always fit the content to the screen size. Setting this property on `true` will disable {@link #config-forceFit} behaviour.\n             * @config {Boolean}\n             * @default false\n             * @category Time axis\n             */\n            suppressFit : false,\n            /**\n             * CSS class to add to cells in the timeaxis column\n             * @config {String}\n             * @category CSS\n             * @private\n             */\n            timeCellCls : null,\n            scheduledEventName : null,\n            //dblClickTime : 200,\n            /**\n             * A CSS class to apply to each event in the view on mouseover.\n             * @config {String}\n             * @category CSS\n             * @private\n             */\n            overScheduledEventClass : null,\n            // allow the panel to prevent adding the hover CSS class in some cases - during drag drop operations\n            preventOverCls : false,\n            /**\n             * Set to `false` if you don't want event bar DOM updates to animate.\n             * @prp {Boolean}\n             * @default true\n             * @category Scheduled events\n             */\n            enableEventAnimations : true,\n            disableGridRowModelWarning : true,\n            // does not look good with locked columns and also interferes with event animations\n            animateRemovingRows : false,\n            schedulerRegion : 'normal',\n            transitionDuration : 200,\n            // internal timer id reference\n            animationTimeout   : null,\n            /**\n             * Region to which columns are added when they have none specified\n             * @config {String}\n             * @default\n             * @category Misc\n             */\n            defaultRegion : 'locked',\n            /**\n             * Decimal precision used when displaying durations, used by tooltips and DurationColumn.\n             * Specify `false` to use raw value\n             * @config {Number|Boolean}\n             * @default\n             * @category Common\n             */\n            durationDisplayPrecision : 1,\n            asyncEventSuffix : 'PreCommit'\n        };\n    }\n    timeCellSelector = null;\n    updateTimeZone(timeZone) {\n        if (this.project) {\n            if (this.isConfiguring) {\n                this.project._isConfiguringTimeZone = true;\n            }\n            this.project.timeZone = timeZone;\n        }\n    }\n    get timeZone() {\n        return this.project?.timeZone;\n    }\n    //endregion\n    //region Feature hooks\n    /**\n     * Populates the event context menu. Chained in features to add menu items.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown.\n     * @param {Scheduler.model.EventModel} options.eventRecord The context event.\n     * @param {Scheduler.model.ResourceModel} options.resourceRecord The context resource.\n     * @param {Scheduler.model.AssignmentModel} options.assignmentRecord The context assignment if any.\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items.\n     * @internal\n     */\n    populateEventMenu() {}\n    /**\n     * Populates the time axis context menu. Chained in features to add menu items.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown.\n     * @param {Scheduler.model.ResourceModel} options.resourceRecord The context resource.\n     * @param {Date} options.date The Date corresponding to the mouse position in the time axis.\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items.\n     * @internal\n     */\n    populateScheduleMenu() {}\n    // Called when visible date range potentially changes such as when scrolling in\n    // the time axis.\n    internalOnVisibleDateRangeChange(range) {\n        if (!this.handlingVisibleDateRangeChange) {\n            const\n                me                    = this,\n                { _visibleDateRange } = me,\n                dateRangeChange       = !_visibleDateRange || (_visibleDateRange.startDate - range.startDate || _visibleDateRange.endDate - range.endDate);\n            if (dateRangeChange) {\n                me.timeView.range                 = range;\n                me.handlingVisibleDateRangeChange = true;\n                /**\n                 * Fired when the range of dates visible within the viewport changes. This will be when\n                 * scrolling along a time axis.\n                 *\n                 * __Note__ that this event will fire frequently during scrolling, so any listener\n                 * should probably be added with the `buffer` option to slow down the calls to your\n                 * handler function :\n                 *\n                 * ```javascript\n                 * listeners : {\n                 *     visibleDateRangeChange({ old, new }) {\n                 *         this.updateRangeRequired(old, new);\n                 *     },\n                 *     // Only call once. 300 ms after the last event was detected\n                 *     buffer : 300\n                 * }\n                 * ```\n                 * @event visibleDateRangeChange\n                 * @param {Scheduler.view.Scheduler} source This Scheduler instance.\n                 * @param {Object} old The old date range\n                 * @param {Date} old.startDate the old start date.\n                 * @param {Date} old.endDate the old end date.\n                 * @param {Object} new The new date range\n                 * @param {Date} new.startDate the new start date.\n                 * @param {Date} new.endDate the new end date.\n                 */\n                me.trigger('visibleDateRangeChange', {\n                    old : _visibleDateRange,\n                    new : range\n                });\n                me.handlingVisibleDateRangeChange = false;\n                me._visibleDateRange              = range;\n            }\n        }\n    }\n    // Called when visible resource range changes in vertical mode\n    onVisibleResourceRangeChange() {}\n    //endregion\n    //region Init\n    construct(config = {}) {\n        const me = this;\n        super.construct(config);\n        me.$firstVerticalOverflow = true;\n        me.initDomEvents();\n        me.currentOrientation.init();\n        me.rowManager.ion({\n            refresh : () => {\n                me.forceLayout = false;\n            }\n        });\n    }\n    // Override from Grid.view.GridSubGrids\n    createSubGrid(region, config = {}) {\n        const\n            me                = this,\n            { stickyHeaders } = me;\n        // We are creating the TimeAxisSubGrid\n        if (region === (me.schedulerRegion || 'normal')) {\n            config.type = 'timeaxissubgrid';\n        }\n        // The assumption is that if we are in vertical mode, the locked SubGrid\n        // is used to house the verticalTimeAxis, and so it must all be overflow:visible\n        else if (region === 'locked' && stickyHeaders && me.isVertical) {\n            config.scrollable = {\n                overflowX : 'visible',\n                overflowY : 'visible'\n            };\n            // It's the child of the overflowElement\n            me.bodyContainer.classList.add('b-sticky-headers');\n        }\n        return super.createSubGrid(region, config);\n    }\n    doDestroy() {\n        const\n            me                                    = this,\n            { partneredWith, currentOrientation } = me;\n        currentOrientation?.destroy();\n        // Break links between this TimeLine and any partners.\n        if (partneredWith) {\n            partneredWith.forEach(p => {\n                me.removePartner(p);\n            });\n            partneredWith.destroy();\n        }\n        else {\n            me.timeAxisViewModel.destroy();\n            me.timeAxis.destroy();\n        }\n        super.doDestroy();\n    }\n    startConfigure(config) {\n        super.startConfigure(config);\n        // When the body height changes, we must update the SchedulerViewport's height\n        ResizeMonitor.addResizeListener(this.bodyContainer, this.onBodyResize.bind(this));\n        // partner needs to be initialized first so that the various shared\n        // configs are assigned first before we default them in.\n        this.getConfig('partner');\n    }\n    changeStartDate(startDate) {\n        if (typeof startDate === 'string') {\n            startDate = DateHelper.parse(startDate);\n        }\n        return startDate;\n    }\n    onInternalPaint({ firstPaint }) {\n        // Upon first paint we need to pass the forceUpdate flag in case we are sharing the TimAxisViewModel\n        // with another Timeline which will already have done this.\n        if (firstPaint) {\n            // Take height from container element\n            const\n                me             = this,\n                scrollable     = me.isHorizontal ? me.timeAxisSubGrid.scrollable : me.scrollable,\n                // Use exact subpixel available space so that tick size calculation is correct.\n                availableSpace = scrollable.element.getBoundingClientRect()[me.isHorizontal ? 'width' : 'height'];\n            // silent = true if infiniteScroll. If that is set, TimelineScroll.initScroll which is\n            // called by the base class's onInternalPaint reconfigures the TAVM when it initializes.\n            me.timeAxisViewModel.update(availableSpace, me.infiniteScroll, true);\n            // If infiniteScroll caused the TAVM update to be silent, force the rendering to\n            // get hold of the scroll state and visible range\n            if (me.infiniteScroll) {\n                me.currentOrientation.doUpdateTimeView?.();\n            }\n            // Lazy config needs to be ingested only when the TimeAxisSubGrid exists\n            me.getConfig('hideRowHover');\n        }\n        super.onInternalPaint(...arguments);\n    }\n    onSchedulerHorizontalScroll(subGrid, scrollLeft, scrollX, scrollingToCenter) {\n        // rerender cells in scheduler column on horizontal scroll to display events in view\n        this.currentOrientation.updateFromHorizontalScroll(scrollX);\n        super.onSchedulerHorizontalScroll(subGrid, scrollLeft, scrollX, scrollingToCenter);\n    }\n    /**\n     * Overrides initScroll from Grid, listens for horizontal scroll to do virtual event rendering\n     * @private\n     */\n    initScroll() {\n        const me = this;\n        let frameCount = 0;\n        super.initScroll();\n        me.ion({\n            horizontalScroll : ({ subGrid, scrollLeft, scrollX, scrollingToCenter }) => {\n                if (me.isPainted && subGrid === me.timeAxisSubGrid && !me.isDestroying && !me.refreshSuspended) {\n                    me.onSchedulerHorizontalScroll(subGrid, scrollLeft, scrollX, scrollingToCenter);\n                }\n                frameCount++;\n            }\n        });\n        if (me.testPerformance === 'horizontal') {\n            me.setTimeout(() => {\n                const start     = performance.now();\n                let scrollSpeed = 5,\n                    direction   = 1;\n                const scrollInterval = me.setInterval(() => {\n                    scrollSpeed = scrollSpeed + 5;\n                    me.scrollX += (10 + Math.floor(scrollSpeed)) * direction;\n                    if (direction === 1 && me.scrollX > 5500) {\n                        direction   = -1;\n                        scrollSpeed = 5;\n                    }\n                    if (direction === -1 && me.scrollX <= 0) {\n                        const\n                            done    = performance.now(), // eslint-disable-line no-undef\n                            elapsed = done - start;\n                        const\n                            timePerFrame = elapsed / frameCount,\n                            fps          = Math.round((1000 / timePerFrame) * 10) / 10;\n                        clearInterval(scrollInterval);\n                        console.log(me.eventPositionMode, me.eventScrollMode, fps + 'fps');\n                    }\n                }, 0);\n            }, 500);\n        }\n    }\n    //endregion\n    /**\n     * Calls the specified function (returning its return value) and preserves the timeline center\n     * point. This is a useful way of retaining the user's visual context while making updates\n     * and changes to the view which require major changes or a full refresh.\n     * @param {Function} fn The function to call.\n     * @param {Object} thisObj The `this` context for the function.\n     * @param {...*} args Parameters to the function.\n     */\n    preserveViewCenter(fn, thisObj = this, ...args) {\n        const\n            me             = this,\n            centerDate     = me.viewportCenterDate,\n            result         = fn.apply(thisObj, args),\n            scroller       = me.timelineScroller,\n            { clientSize } = scroller,\n            scrollStart    = Math.max(Math.floor(me.getCoordinateFromDate(centerDate, true) - clientSize / 2), 0);\n        scroller.scrollTo(scrollStart, { scrollingToCenter : true });\n        return result;\n    }\n    /**\n     * Changes this Scheduler's time axis timespan to the supplied start and end dates.\n     *\n     * @async\n     * @param {Date} newStartDate The new start date\n     * @param {Date} newEndDate The new end date\n     * @param {Object} [options] An object containing modifiers for the time span change operation.\n     * @param {Boolean} [options.maintainVisibleStart] Specify as `true` to keep the visible start date stable.\n     * @param {Date} [options.visibleDate] The date inside the range to scroll into view\n     */\n    setTimeSpan(newStartDate, newEndDate, options = emptyObject) {\n        const\n            me           = this,\n            { timeAxis } = me,\n            {\n                preventThrow = false, // Private, only used by the shift method.\n                maintainVisibleStart = false,\n                visibleDate\n            }            = options,\n            {\n                startDate,\n                endDate\n            }            = timeAxis.getAdjustedDates(newStartDate, newEndDate),\n            startChanged = timeAxis.startDate - startDate !== 0,\n            endChanged   = timeAxis.endDate - endDate !== 0;\n        if (startChanged || endChanged) {\n            if (maintainVisibleStart) {\n                const\n                    {\n                        timeAxisViewModel\n                    }             = me,\n                    { totalSize } = timeAxisViewModel,\n                    oldTickSize   = timeAxisViewModel.tickSize,\n                    scrollable    = me.timelineScroller,\n                    currentScroll = scrollable.position,\n                    visibleStart  = timeAxisViewModel.getDateFromPosition(currentScroll);\n                // If the current visibleStart is in the new range, maintain it\n                // So that there is no visual jump.\n                if (visibleStart >= startDate && visibleStart < endDate) {\n                    // We need to correct the scroll position as soon as the TimeAxisViewModel\n                    // has updated itself and before any other UI updates which that may trigger.\n                    timeAxisViewModel.ion({\n                        update() {\n                            const tickSizeChanged = timeAxisViewModel.tickSize !== oldTickSize;\n                            // Ensure the canvas element matches the TimeAxisViewModel's new totalSize.\n                            // This creates the required scroll range to be able to have the scroll\n                            // position correct before any further UI updates.\n                            me.updateCanvasSize();\n                            // If *only* the start moved, we can keep scroll position the same\n                            // by adjusting it by the amount the start moved.\n                            if (startChanged && !endChanged && !tickSizeChanged) {\n                                scrollable.position += (timeAxisViewModel.totalSize - totalSize);\n                            }\n                            // If only the end has changed, and tick size is same, we can maintain\n                            // the same scroll position.\n                            else if (!startChanged && !tickSizeChanged) {\n                                scrollable.position = currentScroll;\n                            }\n                            // Fall back to restoring the position by restoring the visible start time\n                            else {\n                                scrollable.position = timeAxisViewModel.getPositionFromDate(visibleStart);\n                            }\n                            // Force partners to sync with what we've just done to reset the scroll.\n                            // We are now in control.\n                            scrollable.syncPartners(true);\n                        },\n                        prio : 10000,\n                        once : true\n                    });\n                }\n            }\n            const returnValue = timeAxis.reconfigure({\n                startDate,\n                endDate\n            }, false, preventThrow);\n            if (visibleDate) {\n                return me.scrollToDate(visibleDate, options).then(() => returnValue);\n            }\n            return returnValue;\n        }\n    }\n    //region Config getters/setters\n    /**\n     * Returns `true` if any of the events/tasks or feature injected elements (such as ResourceTimeRanges) are within\n     * the {@link #config-timeAxis}\n     * @property {Boolean}\n     * @readonly\n     * @category Scheduled events\n     */\n    get hasVisibleEvents() {\n        return !this.noFeatureElementsInAxis() || this.eventStore.storage.values.some(t => this.timeAxis.isTimeSpanInAxis(t));\n    }\n    // Template function to be chained in features to determine if any elements are in time axis (needed since we cannot\n    // currently chain getters). Negated to not break chain. First feature that has elements visible returns false,\n    // which prevents other features from being queried.\n    noFeatureElementsInAxis() { }\n    // Private getter used to piece together event names such as beforeEventDrag / beforeTaskDrag. Could also be used\n    // in templates.\n    get capitalizedEventName() {\n        if (!this._capitalizedEventName) {\n            this._capitalizedEventName = StringHelper.capitalize(this.scheduledEventName);\n        }\n        return this._capitalizedEventName;\n    }\n    updatePartner(partner) {\n        if (partner) {\n            this.addPartner(partner);\n        }\n    }\n    /**\n     * Partners this Timeline with the passed Timeline in order to sync the horizontal scrolling position and zoom level.\n     *\n     * - To remove existing partner see {@link #function-removePartner} method.\n     * - To get the list of partners see {@link #property-partners} getter.\n     *\n     * The following properties are imported into this component from the added partner and shared:\n     *\n     * - {@link #property-timeAxisViewModel}\n     * - {@link #property-timeAxis}\n     * - {@link #property-viewPreset}\n     *\n     * In a set of partnered Timelines, there will only be a single instance of the above properties.\n     * The time range and scroll position in that time range are always the same among all\n     * partnered timelines.\n     *\n     * @param {Scheduler.view.TimelineBase} otherTimeline The timeline to partner with\n     */\n    addPartner(partner) {\n        const me = this;\n        if (!me.isPartneredWith(partner)) {\n            if (me._partner == null) {\n                me._partner = partner;\n            }\n            const partneredWith = me.partneredWith || (me.partneredWith = new Collection());\n            // Each must know about the other so that they can sync others upon region resize\n            partneredWith.add(partner);\n            (partner.partneredWith || (partner.partneredWith = new Collection())).add(me);\n            // Flush through viewPreset initGetter so that the setup in setConfig doesn't\n            // take them to be the class's defined getters.\n            me.getConfig('viewPreset');\n            me.getConfig('infiniteScroll');\n            partner.ion({\n                presetchange : 'onPartnerPresetChange',\n                thisObj      : me\n            });\n            partner.scrollable.ion({\n                overflowChange : 'onPartnerOverflowChange',\n                thisObj        : me\n            });\n            // collect configs that are meant to be shared between partners\n            const partnerSharedConfig = me.partnerSharedConfigs.reduce((config, configName) => {\n                config[configName] = partner[configName];\n                return config;\n            }, {});\n            // We have to use the same tick size as the partner,\n            // and we have to sync to its scroll position\n            partnerSharedConfig.viewPreset.options = {\n                scrollPosition : partner.timelineScroller.position,\n                tickSize       : partner.tickSize\n            };\n            me.setConfig(partnerSharedConfig);\n            me.ion({\n                presetchange : 'onPartnerPresetChange',\n                thisObj      : partner\n            });\n            me.scrollable.ion({\n                overflowChange : 'onPartnerOverflowChange',\n                thisObj        : partner\n            });\n            if (me.isPainted) {\n                partner.scrollable.addPartner(me.scrollable, me.isHorizontal ? 'x' : 'y');\n                partner.syncPartnerSubGrids();\n            }\n            else {\n                // When initScroll comes round, make sure it syncs with the partner\n                me.initScroll = FunctionHelper.createSequence(me.initScroll, () => {\n                    partner.scrollable.addPartner(me.scrollable, me.isHorizontal ? 'x' : 'y');\n                    partner.syncPartnerSubGrids();\n                }, me);\n            }\n        }\n    }\n    /**\n     * Breaks the link between current Timeline and the passed Timeline\n     *\n     * - To add a new partner see {@link #function-addPartner} method.\n     * - To get the list of partners see {@link #property-partners} getter.\n     *\n     * @param {Scheduler.view.TimelineBase} otherTimeline The timeline to unlink from\n     */\n    removePartner(partner) {\n        const\n            me                = this,\n            { partneredWith } = me;\n        if (me.isPartneredWith(partner)) {\n            if (me._partner === partner) {\n                me._partner = null;\n            }\n            partneredWith.remove(partner);\n            me.scrollable.removePartner(partner.scrollable);\n            me.un({\n                presetchange : 'onPartnerPresetChange',\n                thisObj      : partner\n            });\n            me.scrollable.un({\n                overflowChange : 'onPartnerOverflowChange',\n                thisObj        : partner\n            });\n            partner.removePartner(me);\n        }\n    }\n    /**\n     * Checks whether the passed timeline is partnered with the current timeline.\n     * @param {Scheduler.view.TimelineBase} partner The timeline to check the partnering with\n     * @returns {Boolean} Returns `true` if the timelines are partnered\n     */\n    isPartneredWith(partner) {\n        return Boolean(this.partneredWith?.includes(partner));\n    }\n    /**\n     * Called when a partner scheduler changes its overflowing state. The scrollable\n     * of a Grid/Scheduler only handles overflowY, so this will mean the addition\n     * or removal of a vertical scrollbar.\n     *\n     * All partners must stay in sync. If another parter has a vertical scrollbar\n     * and we do not, we must set our overflowY to 'scroll' so that we show an empty\n     * scrollbar to keep widths synchronized.\n     * @param {Object} event A {@link Core.helper.util.Scroller#event-overflowChange} event\n     * @internal\n     */\n    onPartnerOverflowChange({ source : otherScrollable, y }) {\n        const\n            { scrollable } = this,\n            ourY           = scrollable.hasOverflow('y') || scrollable.overflowY === 'scroll';\n        // If we disagree with our partner, the partner which doesn't have\n        // overflow, has to become overflowY : scroll\n        if (ourY !== y) {\n            // If we had forced scroller to be shown, we can return it to auto\n            if (scrollable.overflowY === 'scroll') {\n                scrollable.overflowY = true;\n                this.refreshVirtualScrollbars();\n            }\n            else if (ourY) {\n                otherScrollable.overflowY = 'scroll';\n            }\n            else {\n                otherScrollable.overflowY = true;\n                scrollable.overflowY      = 'scroll';\n                this.refreshVirtualScrollbars();\n            }\n        }\n        // If we agree with our partner, we can reset ourselves to overflowY : auto\n        else {\n            scrollable.overflowY = true;\n        }\n    }\n    onPartnerPresetChange({ preset, startDate, endDate, centerDate, zoomDate, zoomPosition, zoomLevel }) {\n        if (!this._viewPresetChanging && this.viewPreset !== preset) {\n            // Passed through to the viewPreset changing method\n            preset.options  = {\n                startDate,\n                endDate,\n                centerDate,\n                zoomDate,\n                zoomPosition,\n                zoomLevel\n            };\n            this.viewPreset = preset;\n        }\n    }\n    /**\n     * Returns the partnered timelines.\n     *\n     * - To add a new partner see {@link #function-addPartner} method.\n     * - To remove existing partner see {@link #function-removePartner} method.\n     *\n     * @readonly\n     * @member {Scheduler.view.TimelineBase[]} partners\n     * @category Time axis\n     */\n    get partners() {\n        const partners = this.partner ? [this.partner] : [];\n        if (this.partneredWith) {\n            partners.push.apply(partners, this.partneredWith.allValues);\n        }\n        return [...new Set(partners)];\n    }\n    get timeAxisColumn() {\n        return this.columns && this._timeAxisColumn;\n    }\n    changeColumns(columns, currentStore) {\n        const me = this;\n        let timeAxisColumnIndex, timeAxisColumnConfig;\n        // No columns means destroy\n        if (columns) {\n            const isArray = Array.isArray(columns);\n            let cols = columns;\n            if (!isArray) {\n                cols = columns.data;\n            }\n            timeAxisColumnIndex = cols && cols.length;\n            cols.some((col, index) => {\n                if (col.type === 'timeAxis') {\n                    timeAxisColumnIndex  = index;\n                    timeAxisColumnConfig = ObjectHelper.assign(col, me.timeAxisColumn);\n                    return true;\n                }\n                return false;\n            });\n            if (me.isVertical) {\n                cols = [\n                    ObjectHelper.assign({\n                        type : 'verticalTimeAxis'\n                    }, me.verticalTimeAxisColumn),\n                    // Make space for a regular TimeAxisColumn after the VerticalTimeAxisColumn\n                    cols[timeAxisColumnIndex]\n                ];\n                timeAxisColumnIndex = 1;\n            }\n            else {\n                // We're going to mutate this array which we do not own, so copy it first.\n                cols = cols.slice();\n            }\n            // Fix up the timeAxisColumn config in place\n            cols[timeAxisColumnIndex] = this._timeAxisColumn || {\n                type    : 'timeAxis',\n                cellCls : me.timeCellCls,\n                mode    : me.mode,\n                ...timeAxisColumnConfig\n            };\n            // If we are passed a raw array, or the Store we are passed is owned by another\n            // Scheduler, pass the raw column data ro the Grid's changeColumns\n            if (isArray || (columns.isStore && columns.owner !== this)) {\n                columns = cols;\n            }\n            else {\n                columns.data = cols;\n            }\n        }\n        return super.changeColumns(columns, currentStore);\n    }\n    updateColumns(columns, was) {\n        super.updateColumns(columns, was);\n        // Extract the known columns by type. Sorting will have placed them into visual order.\n        if (columns) {\n            const\n                me             = this,\n                timeAxisColumn = me._timeAxisColumn = me.columns.find(c => c.isTimeAxisColumn);\n            if (me.isVertical) {\n                me.verticalTimeAxisColumn = me.columns.find(c => c.isVerticalTimeAxisColumn);\n                me.verticalTimeAxisColumn.relayAll(me);\n            }\n            // Set up event relaying early\n            timeAxisColumn.relayAll(me);\n        }\n    }\n    onColumnsChanged({ action, changes, record : column, records }) {\n        const { timeAxisColumn, columns } = this;\n        // If someone replaces the column set (syncing leads to batch), ensure time axis is always added\n        if ((action === 'dataset' || action === 'batch') && !columns.includes(timeAxisColumn)) {\n            columns.add(timeAxisColumn, true);\n        }\n        else if (column === timeAxisColumn && 'width' in changes) {\n            this.updateCanvasSize();\n        }\n        column && this.partneredWith?.forEach(partner => {\n            const partnerColumn = partner.columns.getAt(column.allIndex);\n            if (partnerColumn?.shouldSync(column)) {\n                const partnerChanges = {};\n                for (const k in changes) {\n                    partnerChanges[k] = changes[k].value;\n                }\n                partnerColumn.set(partnerChanges);\n            }\n        });\n        super.onColumnsChanged(...arguments);\n    }\n    get timeView() {\n        const me = this;\n        // Maintainer, we need to ensure that the columns property is initialized\n        // if this getter is called at configuration time before columns have been ingested.\n        return me.columns && me.isVertical\n            ? me.verticalTimeAxisColumn?.view\n            : me.timeAxisColumn?.timeAxisView;\n    }\n    updateEventCls(eventCls) {\n        const me = this;\n        if (!me.eventSelector) {\n            // No difference with new rendering, released have 'b-released' only\n            me.unreleasedEventSelector = me.eventSelector = `.${eventCls}-wrap`;\n        }\n        if (!me.eventInnerSelector) {\n            me.eventInnerSelector = `.${eventCls}`;\n        }\n    }\n    set timeAxisViewModel(timeAxisViewModel) {\n        const\n            me            = this,\n            currentModel  = me._timeAxisViewModel,\n            tavmListeners = {\n                name    : 'timeAxisViewModel',\n                update  : 'onTimeAxisViewModelUpdate',\n                prio    : 100,\n                thisObj : me\n            };\n        if ((me.partner && !timeAxisViewModel) || (currentModel && currentModel === timeAxisViewModel)) {\n            return;\n        }\n        if (currentModel?.owner === me) {\n            // We created this model, destroy it\n            currentModel.destroy();\n        }\n        me.detachListeners('timeAxisViewModel');\n        // Getting rid of instanceof check to allow using code from different bundles\n        if (timeAxisViewModel?.isTimeAxisViewModel) {\n            timeAxisViewModel.ion(tavmListeners);\n        }\n        else {\n            timeAxisViewModel = TimeAxisViewModel.new({\n                mode              : me._mode,\n                snap              : me.snap,\n                forceFit          : me.forceFit,\n                timeAxis          : me.timeAxis,\n                suppressFit       : me.suppressFit,\n                internalListeners : tavmListeners,\n                owner             : me\n            }, timeAxisViewModel);\n        }\n        // Replace in dependent classes relying on the model\n        if (!me.isConfiguring) {\n            if (me.isHorizontal) {\n                me.timeAxisColumn.timeAxisViewModel = timeAxisViewModel;\n            }\n            else {\n                me.verticalTimeAxisColumn.view.model = timeAxisViewModel;\n            }\n        }\n        me._timeAxisViewModel = timeAxisViewModel;\n        me.relayEvents(timeAxisViewModel, ['update'], 'timeAxisViewModel');\n        if (currentModel && timeAxisViewModel) {\n            me.trigger('timeAxisViewModelChange', { timeAxisViewModel });\n        }\n    }\n    /**\n     * The internal view model, describing the visual representation of the time axis.\n     * @property {Scheduler.view.model.TimeAxisViewModel}\n     * @readonly\n     * @category Time axis\n     */\n    get timeAxisViewModel() {\n        if (!this._timeAxisViewModel) {\n            this.timeAxisViewModel = null;\n        }\n        return this._timeAxisViewModel;\n    }\n    get suppressFit() {\n        return this._timeAxisViewModel?.suppressFit ?? this._suppressFit;\n    }\n    set suppressFit(value) {\n        if (this._timeAxisViewModel) {\n            this.timeAxisViewModel.suppressFit = value;\n        }\n        else {\n            this._suppressFit = value;\n        }\n    }\n    set timeAxis(timeAxis) {\n        const\n            me                = this,\n            currentTimeAxis   = me._timeAxis,\n            timeAxisListeners = {\n                name        : 'timeAxis',\n                reconfigure : 'onTimeAxisReconfigure',\n                thisObj     : me\n            };\n        if (me.partner && !timeAxis || (currentTimeAxis && currentTimeAxis === timeAxis)) {\n            return;\n        }\n        if (currentTimeAxis) {\n            if (currentTimeAxis.owner === me) {\n                // We created this model, destroy it\n                currentTimeAxis.destroy();\n            }\n        }\n        me.detachListeners('timeAxis');\n        // Getting rid of instanceof check to allow using code from different bundles\n        if (!timeAxis?.isTimeAxis) {\n            timeAxis = ObjectHelper.assign({\n                owner          : me,\n                viewPreset     : me.viewPreset,\n                autoAdjust     : me.autoAdjustTimeAxis,\n                weekStartDay   : me.weekStartDay,\n                forceFullTicks : me.fillTicks && me.snap\n            }, timeAxis);\n            if (me.startDate) {\n                timeAxis.startDate = me.startDate;\n            }\n            if (me.endDate) {\n                timeAxis.endDate = me.endDate;\n            }\n            if (me.workingTime) {\n                me.applyWorkingTime(timeAxis);\n            }\n            timeAxis = new TimeAxis(timeAxis);\n        }\n        // Inform about reconfiguring the timeaxis, to allow users to react to start & end date changes\n        timeAxis.ion(timeAxisListeners);\n        me._timeAxis = timeAxis;\n    }\n    onTimeAxisReconfigure({ config, oldConfig }) {\n        if (config) {\n            const dateRangeChange = !oldConfig || (oldConfig.startDate - config.startDate || oldConfig.endDate - config.endDate);\n            if (dateRangeChange) {\n                /**\n                 * Fired when the range of dates encapsulated by the UI changes. This will be when\n                 * moving a view in time by reconfiguring its {@link #config-timeAxis}. This will happen\n                 * when zooming, or changing {@link #config-viewPreset}.\n                 *\n                 * Contrast this with the {@link #event-visibleDateRangeChange} event which fires much\n                 * more frequently, during scrolling along the time axis and changing the __visible__\n                 * date range.\n                 * @event dateRangeChange\n                 * @param {Scheduler.view.TimelineBase} source This Scheduler/Gantt instance.\n                 * @param {Object} old The old date range\n                 * @param {Date} old.startDate the old start date.\n                 * @param {Date} old.endDate the old end date.\n                 * @param {Object} new The new date range\n                 * @param {Date} new.startDate the new start date.\n                 * @param {Date} new.endDate the new end date.\n                 */\n                this.trigger('dateRangeChange', {\n                    old : {\n                        startDate : oldConfig.startDate,\n                        endDate   : oldConfig.endDate\n                    },\n                    new : {\n                        startDate : config.startDate,\n                        endDate   : config.endDate\n                    }\n                });\n            }\n        }\n        /**\n         * Fired when the timeaxis has changed, for example by zooming or configuring a new time span.\n         * @event timeAxisChange\n         * @param {Scheduler.view.Scheduler} source - This Scheduler\n         * @param {Object} config Config object used to reconfigure the time axis.\n         * @param {Date} config.startDate New start date (if supplied)\n         * @param {Date} config.endDate New end date (if supplied)\n         */\n        this.trigger('timeAxisChange', { config });\n    }\n    get timeAxis() {\n        if (!this._timeAxis) {\n            this.timeAxis = null;\n        }\n        return this._timeAxis;\n    }\n    updateForceFit(value) {\n        if (this._timeAxisViewModel) {\n            this._timeAxisViewModel.forceFit = value;\n        }\n    }\n    /**\n     * Get/set working time. Assign `null` to stop using working time. See {@link #config-workingTime} config for details.\n     * @property {Object}\n     * @category Scheduled events\n     */\n    set workingTime(config) {\n        this._workingTime = config;\n        if (!this.isConfiguring) {\n            this.applyWorkingTime(this.timeAxis);\n        }\n    }\n    get workingTime() {\n        return this._workingTime;\n    }\n    // Translates the workingTime configs into TimeAxis#include rules, applies them and then refreshes the header and\n    // redraws the events\n    applyWorkingTime(timeAxis) {\n        const me     = this,\n            config = me._workingTime;\n        if (config) {\n            let hour = null;\n            // Only use valid values\n            if (config.fromHour >= 0 && config.fromHour < 24 && config.toHour > config.fromHour && config.toHour <= 24 && config.toHour - config.fromHour < 24) {\n                hour = { from : config.fromHour, to : config.toHour };\n            }\n            let day = null;\n            // Only use valid values\n            if (config.fromDay >= 0 && config.fromDay < 7 && config.toDay > config.fromDay && config.toDay <= 7 && config.toDay - config.fromDay < 7) {\n                day = { from : config.fromDay, to : config.toDay };\n            }\n            if (hour || day) {\n                timeAxis.include = {\n                    hour,\n                    day\n                };\n            }\n            else {\n                // No valid rules, restore timeAxis\n                timeAxis.include = null;\n            }\n        }\n        else {\n            // No rules, restore timeAxis\n            timeAxis.include = null;\n        }\n        if (me.isPainted) {\n            // Refreshing header, which also recalculate tickSize and header data\n            me.timeAxisColumn.refreshHeader();\n            // Update column lines\n            me.features.columnLines?.refresh();\n            // Animate event changes\n            me.refreshWithTransition();\n        }\n    }\n    updateStartDate(date) {\n        this.setStartDate(date);\n    }\n    /**\n     * Sets the timeline start date.\n     *\n     * **Note:**\n     * - If you need to set start and end date at the same time, use the {@link #function-setTimeSpan} method.\n     * - If keepDuration is false and new start date is greater than end date, it will throw an exception.\n     *\n     * @param {Date} date The new start date\n     * @param {Boolean} keepDuration Pass `true` to keep the duration of the timeline (\"move\" the timeline),\n     * `false` to change the duration (\"resize\" the timeline). Defaults to `true`.\n     */\n    setStartDate(date, keepDuration = true) {\n        const\n            me = this,\n            ta = me._timeAxis,\n            {\n                startDate,\n                endDate,\n                mainUnit\n            }  = ta || emptyObject;\n        if (typeof date === 'string') {\n            date = DateHelper.parse(date);\n        }\n        if (ta && endDate) {\n            if (date) {\n                let calcEndDate = endDate;\n                if (keepDuration && startDate) {\n                    const diff  = DateHelper.diff(startDate, endDate, mainUnit, true);\n                    calcEndDate = DateHelper.add(date, diff, mainUnit);\n                }\n                me.setTimeSpan(date, calcEndDate);\n            }\n        }\n        else {\n            me._tempStartDate = date;\n        }\n    }\n    get startDate() {\n        let ret = this._timeAxis?.startDate || this._tempStartDate;\n        if (!ret) {\n            ret = new Date();\n            const { workingTime } = this;\n            if (workingTime) {\n                while (!isWorkingTime(ret, workingTime)) {\n                    ret.setHours(ret.getHours() + 1);\n                }\n            }\n            this._tempStartDate = ret;\n        }\n        return ret;\n    }\n    changeEndDate(date) {\n        if (typeof date === 'string') {\n            date = DateHelper.parse(date);\n        }\n        this.setEndDate(date);\n    }\n    /**\n     * Sets the timeline end date\n     *\n     * **Note:**\n     * - If you need to set start and end date at the same time, use the {@link #function-setTimeSpan} method.\n     * - If keepDuration is false and new end date is less than start date, it will throw an exception.\n     *\n     * @param {Date} date The new end date\n     * @param {Boolean} keepDuration Pass `true` to keep the duration of the timeline (\"move\" the timeline),\n     * `false` to change the duration (\"resize\" the timeline). Defaults to `false`.\n     */\n    setEndDate(date, keepDuration = false) {\n        const\n            me = this,\n            ta = me._timeAxis,\n            {\n                startDate,\n                endDate,\n                mainUnit\n            }  = ta || emptyObject;\n        if (typeof date === 'string') {\n            date = DateHelper.parse(date);\n        }\n        if (ta && startDate) {\n            if (date) {\n                let calcStartDate = startDate;\n                if (keepDuration && endDate) {\n                    const diff    = DateHelper.diff(startDate, endDate, mainUnit, true);\n                    calcStartDate = DateHelper.add(date, -diff, mainUnit);\n                }\n                me.setTimeSpan(calcStartDate, date);\n            }\n        }\n        else {\n            me._tempEndDate = date;\n        }\n    }\n    get endDate() {\n        const me = this;\n        if (me._timeAxis) {\n            return me._timeAxis.endDate;\n        }\n        return me._tempEndDate || DateHelper.add(me.startDate, me.viewPreset.defaultSpan, me.viewPreset.mainHeader.unit);\n    }\n    changeVisibleDate(options) {\n        if (options instanceof Date) {\n            return { date : options, block : this.isConfiguring ? 'start' : 'nearest' };\n        }\n        if (options instanceof Object) {\n            return {\n                date  : options.date,\n                block : options.block || this.isConfiguring ? 'start' : 'nearest',\n                ...options\n            };\n        }\n    }\n    updateVisibleDate(options) {\n        const me = this;\n        // Infinite scroll initialization takes care of its visibleDate after\n        // calculating the optimum scroll range in TimelineScroll#initScroll\n        if (!(me.infiniteScroll && me.isConfiguring)) {\n            if (me.isPainted) {\n                me.scrollToDate(options.date, options);\n            }\n            else {\n                me.ion({\n                    paint : () => me.scrollToDate(options.date, options),\n                    once  : true\n                });\n            }\n        }\n    }\n    get features() {\n        return super.features;\n    }\n    // add region resize by default\n    set features(features) {\n        features = features === true ? {} : features;\n        if (!('regionResize' in features)) {\n            features.regionResize = true;\n        }\n        super.features = features;\n    }\n    //endregion\n    //region Event handlers\n    onLocaleChange() {\n        super.onLocaleChange();\n        const oldAutoAdjust = this.timeAxis.autoAdjust;\n        // Time axis should rebuild as weekStartDay may have changed\n        this.timeAxis.reconfigure({\n            autoAdjust : false\n        });\n        // Silently set it back to what the user had for next view refresh\n        this.timeAxis.autoAdjust = oldAutoAdjust;\n    }\n    /**\n     * Called when the element which encapsulates the Scheduler's visible height changes size.\n     * We only respond to *height* changes here. The TimeAxisSubGrid monitors its own width.\n     * @param {HTMLElement} element\n     * @param {DOMRect} oldRect\n     * @param {DOMRect} newRect\n     * @private\n     */\n    onBodyResize(element, oldRect, { width, height }) {\n        // Uncache old value upon element resize, not upon initial sizing\n        if (this.isVertical && oldRect && width !== oldRect.width) {\n            delete this.timeAxisSubGrid._width;\n        }\n        const newWidth = this.timeAxisSubGrid.element.offsetWidth;\n        // The Scheduler (The Grid) dictates the viewport height.\n        // Don't react on first invocation which will be initial size.\n        if (this._bodyRectangle && oldRect && (height !== oldRect.height)) {\n            this.onSchedulerViewportResize(newWidth, height, newWidth, oldRect.height);\n        }\n    }\n    onSchedulerViewportResize(width, height, oldWidth, oldHeight) {\n        if (this.isPainted) {\n            const\n                me = this,\n                {\n                    isHorizontal,\n                    partneredWith\n                }  = me;\n            me.currentOrientation.onViewportResize(width, height, oldWidth, oldHeight);\n            // Raw width is always correct for horizontal layout because the TimeAxisSubGrid\n            // never shows a scrollbar. It's always contained by an owning Grid which shows\n            // the vertical scrollbar.\n            me.updateViewModelAvailableSpace(isHorizontal ? width : Math.floor(height));\n            if (partneredWith && !me.isSyncingFromPartner) {\n                me.syncPartnerSubGrids();\n            }\n            /**\n             * Fired when the *scheduler* viewport (not the overall Scheduler element) changes size.\n             * This happens when the grid changes height, or when the subgrid which encapsulates the\n             * scheduler column changes width.\n             * @event timelineViewportResize\n             * @param {Core.widget.Widget} source - This Scheduler\n             * @param {Number} width The new width\n             * @param {Number} height The new height\n             * @param {Number} oldWidth The old width\n             * @param {Number} oldHeight The old height\n             */\n            me.trigger('timelineViewportResize', { width, height, oldWidth, oldHeight });\n        }\n    }\n    updateViewModelAvailableSpace(space) {\n        this.timeAxisViewModel.availableSpace = space;\n    }\n    onTimeAxisViewModelUpdate() {\n        if (!this._viewPresetChanging && !this.timeAxisSubGrid.collapsed) {\n            this.updateCanvasSize();\n            this.currentOrientation.onTimeAxisViewModelUpdate();\n        }\n    }\n    syncPartnerSubGrids() {\n        this.partneredWith.forEach(partner => {\n            if (!partner.isSyncingFromPartner) {\n                partner.isSyncingFromPartner = true;\n                this.eachSubGrid(subGrid => {\n                    const partnerSubGrid = partner.subGrids[subGrid.region];\n                    // If there is a difference, sync the partner SubGrid state\n                    if (partnerSubGrid.width !== subGrid.width) {\n                        if (subGrid.collapsed) {\n                            partnerSubGrid.collapse();\n                        }\n                        else {\n                            if (partnerSubGrid.collapsed) {\n                                partnerSubGrid.expand();\n                            }\n                            // When using flexed subgrid, make sure flex values has prio over width\n                            if (subGrid.flex) {\n                                // If flex values match, resize should be fine without changing anything\n                                if (subGrid.flex !== partnerSubGrid.flex) {\n                                    partnerSubGrid.flex = subGrid.flex;\n                                }\n                            }\n                            else {\n                                partnerSubGrid.width = subGrid.width;\n                            }\n                        }\n                    }\n                });\n                partner.isSyncingFromPartner = false;\n            }\n        });\n    }\n    //endregion\n    //region Mode\n    get currentOrientation() {\n        throw new Error('Implement in subclass');\n    }\n    // Horizontal is the default, overridden in scheduler\n    get isHorizontal() {\n        return true;\n    }\n    //endregion\n    //region Canvases and elements\n    get foregroundCanvas() {\n        return this._foregroundCanvas;\n    }\n    get svgCanvas() {\n        const me = this;\n        if (!me._svgCanvas) {\n            const svg = me._svgCanvas = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n            svg.setAttribute('id', IdHelper.generateId('svg'));\n            svg.classList.add('b-sch-canvas', 'b-sch-dependencies-canvas');\n            // To not be recycled by DomSync\n            svg.retainElement = true;\n            me.timeAxisSubGridElement.appendChild(svg);\n            me.trigger('svgCanvasCreated', { svg });\n        }\n        return me._svgCanvas;\n    }\n    /**\n     * Returns the subGrid containing the time axis\n     * @member {Grid.view.SubGrid} timeAxisSubGrid\n     * @readonly\n     * @category Time axis\n     */\n    /**\n     * Returns the html element for the subGrid containing the time axis\n     * @property {HTMLElement}\n     * @readonly\n     * @category Time axis\n     */\n    get timeAxisSubGridElement() {\n        // Hit a lot, caching the element (it will never change)\n        if (!this._timeAxisSubGridElement) {\n            // We need the TimeAxisSubGrid to exist, so regions must be initialized\n            this.getConfig('regions');\n            this._timeAxisSubGridElement = this.timeAxisColumn?.subGridElement;\n        }\n        return this._timeAxisSubGridElement;\n    }\n    updateCanvasSize() {\n        const me = this;\n        let result = false;\n        if (me.isVertical) {\n            const { totalSize } = me.timeAxisViewModel;\n            // Ensure vertical scroll range accommodates the TimeAxis\n            if (me.isPainted) {\n                // We used to have a bug here from not including the row border in the total height. Border is now\n                // removed, but leaving code here just in case some client is using border\n                me.refreshTotalHeight(totalSize + me._rowBorderHeight, true);\n            }\n            // Canvas might need a height in vertical mode, if ticks does not fill height (suppressFit : true)\n            if (me.suppressFit) {\n                DomHelper.setLength(me.foregroundCanvas, 'height', totalSize);\n            }\n            result = true;\n        }\n        return result;\n    }\n    /**\n     * A chainable function which Features may hook to add their own content to the timeaxis header.\n     * @param {Array} configs An array of domConfigs, append to it to have the config applied to the header\n     */\n    getHeaderDomConfigs(configs) {}\n    /**\n     * A chainable function which Features may hook to add their own content to the foreground canvas\n     * @param {Array} configs An array of domConfigs, append to it to have the config applied to the foreground canvas\n     */\n    getForegroundDomConfigs(configs) {}\n    //endregion\n    //region Grid overrides\n    async onStoreDataChange({ action }) {\n        const me = this;\n        // Only update the UI immediately if we are visible\n        if (me.isVisible) {\n            // When repopulating stores (pro and up on data reload), the engine is not in a valid state until committed.\n            // Don't want to commit here, since it might be repopulating multiple stores.\n            // Instead delay grids refresh until project is ready\n            if (action === 'dataset' && me.project?.isRepopulatingStores) {\n                await me.project.await('refresh', false);\n            }\n            super.onStoreDataChange(...arguments);\n        }\n        // Otherwise wait till next time we get painted (shown, or a hidden ancestor shown)\n        else {\n            me.whenVisible('refresh', me, [true]);\n        }\n    }\n    refresh(forceLayout = true) {\n        const me = this;\n        if (me.isPainted && !me.refreshSuspended) {\n            // We need to refresh if there are Features laying claim to the visible time axis.\n            // Or there are events which fall inside the time axis.\n            // Or (if no events fall inside the time axis) there are event elements to remove.\n            if (me.isVertical || me.hasVisibleEvents || me.timeAxisSubGridElement.querySelector(me.eventSelector)) {\n                if (!me.project || me.isEngineReady) {\n                    me.refreshRows(false, forceLayout);\n                }\n                else {\n                    me.refreshAfterProjectRefresh             = true;\n                    me.currentOrientation.refreshAllWhenReady = true;\n                }\n            }\n            // Even if there are no events in our timeline, Features\n            // assume there will be a refresh event from the RowManager\n            // after a refresh request so fire it here.\n            else {\n                me.rowManager.trigger('refresh');\n            }\n        }\n    }\n    render() {\n        const\n            me          = this,\n            { total }   = me.resourceMarginObject,\n            schedulerEl = me.timeAxisSubGridElement;\n        // The font-size trick is no longer used by scheduler, since it allows per resource margins\n        const\n            fgCanvas = me._foregroundCanvas = DomHelper.createElement({\n                className : 'b-sch-canvas b-sch-foreground-canvas',\n                style     : `font-size:${(me.rowHeight - total)}px`,\n                parent    : schedulerEl\n            });\n        me.timeAxisSubGrid.insertRowsBefore = fgCanvas;\n        // Size correctly in case ticks does not fill height\n        if (me.isVertical && me.suppressFit) {\n            me.updateCanvasSize();\n        }\n        super.render(...arguments);\n    }\n    refreshRows(returnToTop = false, reLayoutEvents = true) {\n        const me = this;\n        if (me.isConfiguring) {\n            return;\n        }\n        me.currentOrientation.refreshRows(reLayoutEvents);\n        super.refreshRows(returnToTop);\n    }\n    updateHideHeaders(hide) {\n        const\n            me         = this,\n            scrollLeft = me.isPainted ? me.scrollLeft : 0;\n        super.updateHideHeaders(hide);\n        if (me.isPainted) {\n            if (!hide) {\n                me.timeAxisColumn.refreshHeader(null, true);\n            }\n            me.nextAnimationFrame().then(() => me.scrollLeft = scrollLeft);\n        }\n    }\n    updateHideRowHover(hideRowHover) {\n        this.timeAxisSubGridElement.classList.toggle('b-hide-row-hover', hideRowHover);\n    }\n    getCellDataFromEvent(event, includeSingleAxisMatch) {\n        if (includeSingleAxisMatch) {\n            includeSingleAxisMatch = !Boolean(event.target.closest('.b-sch-foreground-canvas'));\n        }\n        return super.getCellDataFromEvent(event, includeSingleAxisMatch);\n    }\n    // This GridSelection override disables drag-selection in timeaxis column for scheduler and gantt\n    onCellNavigate(me, from, to) {\n        const toTarget = to.target;\n        if (to.cell?.classList.contains('b-timeaxis-cell') && !GlobalEvents.currentMouseDown?.target.classList.contains('b-grid-cell')) {\n            this.preventDragSelect = true;\n        }\n        if ((!toTarget?.matches(this.eventSelector) || this.selectResourceOnEventNavigate !== false) &&\n        (!toTarget?.matches('.b-timeaxis-cell') || this.selectResourceOnScheduleClick !== false)) {\n            super.onCellNavigate(...arguments);\n        }\n    }\n    //endregion\n    //region Other\n    /**\n     * Runs a function with transitions enabled (row height, event size etc.). Useful if you want to alter the UI\n     * state with a transition.\n     *\n     * @param {Function} fn The function to run\n     */\n    runWithTransition(fn, duration = this.transitionDuration /* duration = false prevents transition */) {\n        const me = this;\n        // Do not attempt to enter animating state if we are not visible\n        if (me.isVisible && me._animationSuspendedCounter === 0) {\n            // Allow calling with true/false to keep code simpler in other places\n            if (duration == null || duration === true) {\n                duration = me.transitionDuration;\n            }\n            // Ask Grid superclass to enter the animated state if requested and enabled.\n            if (duration && me.enableEventAnimations) {\n                if (!me.hasTimeout('exitTransition')) {\n                    me.isAnimating = true;\n                }\n                // Exit animating state in duration milliseconds with a little buffer to not interrupt.\n                exitTransition.delay = duration + 50;\n                me.setTimeout(exitTransition);\n            }\n        }\n        fn();\n    }\n    _animationSuspendedCounter = 0;\n    /**\n     * Suspends CSS transitions after a row / event has been updated\n     *\n     * Multiple calls to `suspendAnimations` stack up, and will require an equal number of `resumeAnimations` calls to\n     * actually resume animations.\n     */\n    suspendAnimations() {\n        this._animationSuspendedCounter++;\n    }\n    /**\n     * Resumes CSS transitions after a row / event has been updated\n     */\n    resumeAnimations() {\n        this._animationSuspendedCounter--;\n    }\n    exitTransition() {\n        this.isAnimating = false;\n        this.trigger('transitionend');\n    }\n    // Awaited by CellEdit to make sure that the editor is not moved until row heights have transitioned, to avoid it\n    // ending up misaligned\n    async waitForAnimations() {\n        // If project is calculating, we should await that too. It might lead to transitions\n        if (!this.isEngineReady && this.project) {\n            await this.project.await('dataReady', false);\n        }\n        await super.waitForAnimations();\n    }\n    /**\n     * Refreshes the grid with transitions enabled.\n     */\n    refreshWithTransition(forceLayout, duration) {\n        const me = this;\n        // No point in starting a transition if we cant refresh anyway\n        if (!me.refreshSuspended && me.isPainted) {\n            // Since we suspend refresh when loading with CrudManager, rows might not have been initialized yet\n            if (!me.rowManager.topRow) {\n                me.rowManager.reinitialize();\n            }\n            else {\n                me.runWithTransition(() => me.refresh(forceLayout), duration);\n            }\n        }\n    }\n    /**\n     * Returns an object representing the visible date range\n     * @property {Object}\n     * @property {Date} visibleDateRange.startDate\n     * @property {Date} visibleDateRange.endDate\n     * @readonly\n     * @category Dates\n     */\n    get visibleDateRange() {\n        return this.currentOrientation.visibleDateRange;\n    }\n    // This override will force row selection on timeaxis column selection, effectively disabling cell selection there\n    isRowNumberSelecting(...selectors) {\n        return super.isRowNumberSelecting(...selectors) ||\n            selectors.some(cs => cs.column ? cs.column.isTimeAxisColumn : cs.cell?.closest('.b-timeaxis-cell'));\n    }\n    //endregion\n    /**\n     * Returns a rounded duration value to be displayed in UI (tooltips, labels etc)\n     * @param {Number} duration The raw duration value\n     * @param {Number} [nbrDecimals] The number of decimals, defaults to {@link #config-durationDisplayPrecision}\n     * @returns {Number} The rounded duration\n     */\n    formatDuration(duration, nbrDecimals = this.durationDisplayPrecision) {\n        const multiplier = Math.pow(10, nbrDecimals);\n        return Math.round(duration * multiplier) / multiplier;\n    }\n    beginListeningForBatchedUpdates() {\n        this.listenToBatchedUpdates = (this.listenToBatchedUpdates || 0) + 1;\n        // Allow live resizing (etc) in all splits\n        this.syncSplits?.(other => other.beginListeningForBatchedUpdates());\n    }\n    endListeningForBatchedUpdates() {\n        if (this.listenToBatchedUpdates) {\n            this.listenToBatchedUpdates -= 1;\n        }\n        this.syncSplits?.(other => other.endListeningForBatchedUpdates());\n    }\n    onConnectedCallback(connected, initialConnect) {\n        if (connected && !initialConnect) {\n            this.timeAxisSubGrid.scrollable.x += 0.5;\n        }\n    }\n    updateRtl(rtl) {\n        const\n            me                = this,\n            { isConfiguring } = me;\n        let visibleDateRange;\n        if (!isConfiguring) {\n            visibleDateRange = me.visibleDateRange;\n        }\n        super.updateRtl(rtl);\n        if (!isConfiguring) {\n            me.currentOrientation.clearAll();\n            if (me.infiniteScroll) {\n                me.shiftToDate(visibleDateRange.startDate);\n                me.scrollToDate(visibleDateRange.startDate, { block : 'start' });\n            }\n            else {\n                me.timelineScroller.position += 0.5;\n            }\n        }\n    }\n    /**\n     * Applies the start and end date to each event store request (formatted in the same way as the start date field,\n     * defined in the EventStore Model class).\n     * @category Data\n     * @private\n     */\n    applyStartEndParameters(params) {\n        const\n            me    = this,\n            field = me.eventStore.modelClass.fieldMap.startDate;\n        if (me.passStartEndParameters) {\n            params[me.startParamName] = field.print(me.startDate);\n            params[me.endParamName] = field.print(me.endDate);\n        }\n    }\n}\n// Register this widget type with its Factory\nTimelineBase.initClass();\n// Has to be here because Gantt extends TimelineBase\nVersionHelper.setVersion('scheduler', '5.6.2');\nTimelineBase._$name = 'TimelineBase';", "import Base from '../../../Core/Base.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\n/**\n * @module Scheduler/view/mixin/Describable\n */\nconst\n    arrayify = format => (!format || Array.isArray(format)) ? format : [format],\n    pickFormat = (formats, index, defaultFormat) => (formats && formats[index] !== true) ? formats[index] : defaultFormat;\n/**\n * Mixin that provides a consistent method for describing the ranges of time presented by a view. This is currently\n * consumed only by the Calendar widget for describing its child views. This mixin is defined here to facilitate using\n * a Scheduler as a child view of a Calendar.\n *\n * @mixin\n */\nexport default Target => class Describable extends (Target || Base) {\n    static $name = 'Describable';\n    static configurable = {\n        /**\n         * A {@link Core.helper.DateHelper} format string to use to create date output for view descriptions.\n         * @prp {String}\n         * @default\n         */\n        dateFormat : 'MMMM d, YYYY',\n        /**\n         * A string used to separate start and end dates in the {@link #config-descriptionFormat}.\n         * @prp {String}\n         * @default\n         */\n        dateSeparator : ' - ',\n        /**\n         * The date format used by the default {@link #config-descriptionRenderer} for rendering the view's description.\n         * If this value is `null`, the {@link #config-dateFormat} (and potentially {@link #config-dateSeparator}) will\n         * be used.\n         *\n         * For views that can span a range of dates, this can be a 2-item array with the following interpretation:\n         *\n         * - `descriptionFormat[0]` is either a date format string or `true` (to use {@link #config-dateFormat}). The\n         *   result of formatting the `startDate` with this format specification is used when the formatting both the\n         *   `startDate` and `endDate` with this specification produces the same result. For example, a week view\n         *   displays only the month and year components of the date, so this will be used unless the end of the week\n         *   crosses into the next month.\n         *\n         * - `descriptionFormat[1]` is used with {@link Core.helper.DateHelper#function-formatRange-static} when the\n         *  `startDate` and `endDate` format differently using `descriptionFormat[0]` (as described above). This one\n         *  format string produces a result for both dates. If this value is `true`, the {@link #config-dateFormat} and\n         *  {@link #config-dateSeparator} are combined to produce the range format.\n         *\n         * @prp {String|String[]|Boolean[]}\n         * @default\n         */\n        descriptionFormat : null,\n        /**\n         * A function that provides the textual description for this view. If provided, this function overrides the\n         * {@link #config-descriptionFormat}.\n         *\n         * ```javascript\n         *  descriptionRenderer() {\n         *      const\n         *          eventsInView = this.eventStore.records.filter(\n         *              eventRec => DateHelper.intersectSpans(\n         *                  this.startDate, this.endDate,\n         *                  eventRec.startDate, eventRec.endDate)).length,\n         *          sd = DateHelper.format(this.startDate, 'DD/MM/YYY'),\n         *          ed = DateHelper.format(this.endDate, 'DD/MM/YYY');\n         *\n         *     return `${sd} - ${ed}, ${eventsInView} event${eventsInView === 1 ? '' : 's'}`;\n         * }\n         * ```\n         * @config {Function} descriptionRenderer\n         * @param {Core.widget.Widget} view The active view in case the function is in another scope.\n         * @returns {String} Description string\n         */\n        descriptionRenderer : null\n    };\n    /**\n     * Returns the date or ranges of included dates as an array. If there is only one significant date, the array will\n     * have only one element. Otherwise, a range of dates is returned as a two-element array with `[0]` being the\n     * `startDate` and `[1]` the `lastDate`.\n     * @member {Date[]}\n     * @internal\n     */\n    get dateBounds() {\n        return [this.date];\n    }\n    /**\n     * The textual description generated by the {@link #config-descriptionRenderer} if present, or by the\n     * view's date (or date *range* if it has a range) and the {@link #config-descriptionFormat}.\n     * @property {String}\n     * @readonly\n     */\n    get description() {\n        const\n            me = this,\n            { descriptionRenderer } = me;\n        return descriptionRenderer ? me.callback(descriptionRenderer, me, [me]) : me.formattedDescription;\n    }\n    get formattedDescription() {\n        const\n            me = this,\n            { dateBounds, dateFormat } = me,\n            descriptionFormat = me.descriptionFormat ?? arrayify(me.defaultDescriptionFormat),\n            format0 = pickFormat(descriptionFormat, 0, dateFormat),\n            end = dateBounds.length > 1 && descriptionFormat?.length > 1 && (\n                DateHelper.format(dateBounds[0], format0) !== DateHelper.format(dateBounds[1], format0)\n            );\n        // Format the startDate and endDate using the first format\n        let ret = DateHelper.format(dateBounds[0], format0);\n        if (end) {\n            // The endDate renders a different description, and we have a range format.\n            ret = DateHelper.formatRange(dateBounds,\n                pickFormat(descriptionFormat, 1, `S${dateFormat}${me.dateSeparator}E${dateFormat}`));\n        }\n        return ret;\n    }\n    changeDescriptionFormat(format) {\n        return arrayify(format);\n    }\n    get widgetClass() {}  // no b-describable class\n};\n", "import Base from '../../../Core/Base.js';\n/**\n * @module Scheduler/view/mixin/SchedulerDom\n */\n/**\n * Mixin with EventModel and ResourceModel <-> HTMLElement mapping functions\n *\n * @mixin\n */\nexport default Target => class SchedulerDom extends (Target || Base) {\n    static get $name() {\n        return 'SchedulerDom';\n    }\n    //region Get\n    /**\n     * Returns a single HTMLElement representing an event record assigned to a specific resource.\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord An assignment record\n     * @returns {HTMLElement} The element representing the event record\n     * @category DOM\n     */\n    getElementFromAssignmentRecord(assignmentRecord, returnWrapper = false, checkReleased = false) {\n        if (this.isPainted && assignmentRecord) {\n            let wrapper = this.foregroundCanvas.syncIdMap?.[assignmentRecord.id];\n            // When using links, the original might not be rendered but a link might\n            if (!wrapper && assignmentRecord.resource?.hasLinks) {\n                for (const link of assignmentRecord.resource.$links) {\n                    wrapper = this.foregroundCanvas.syncIdMap?.[`${assignmentRecord.id}_${link.id}`];\n                    if (!wrapper) {\n                        if (checkReleased) {\n                            // When event is released, it needs to retrieve it from releasedIdMap\n                            wrapper = this.foregroundCanvas.releasedIdMap?.[`${assignmentRecord.id}_${link.id}`];\n                            if (wrapper) {\n                                break;\n                            }\n                        }\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n            // When event is released, it needs to retrieve it from releasedIdMap\n            if (!wrapper && checkReleased) {\n                wrapper = this.foregroundCanvas.releasedIdMap?.[assignmentRecord.id];\n            }\n            // Wrapper won't have syncIdMap when saving dragcreated event from editor\n            return returnWrapper ? wrapper : wrapper?.syncIdMap?.event;\n        }\n        return null;\n    }\n    /**\n     * Returns a single HTMLElement representing an event record assigned to a specific resource.\n     * @param {Scheduler.model.EventModel} eventRecord An event record\n     * @param {Scheduler.model.ResourceModel} resourceRecord A resource record\n     * @returns {HTMLElement} The element representing the event record\n     * @category DOM\n     */\n    getElementFromEventRecord(eventRecord, resourceRecord = eventRecord.resources?.[0], returnWrapper = false, checkReleased = false) {\n        if (eventRecord.isResourceTimeRange) {\n            const wrapper = this.foregroundCanvas.syncIdMap?.[eventRecord.domId];\n            return returnWrapper ? wrapper : wrapper?.syncIdMap.event;\n        }\n        const assignmentRecord = this.assignmentStore.getAssignmentForEventAndResource(eventRecord, resourceRecord);\n        return this.getElementFromAssignmentRecord(assignmentRecord, returnWrapper, checkReleased);\n    }\n    /**\n     * Returns all the HTMLElements representing an event record.\n     *\n     * @param {Scheduler.model.EventModel} eventRecord An event record\n     * @param {Scheduler.model.ResourceModel} [resourceRecord] A resource record\n     *\n     * @returns {HTMLElement[]} The element(s) representing the event record\n     * @category DOM\n     */\n    getElementsFromEventRecord(eventRecord, resourceRecord, returnWrapper = false, checkReleased = false) {\n        // Single event instance, as array\n        if (resourceRecord) {\n            return [this.getElementFromEventRecord(eventRecord, resourceRecord, returnWrapper, checkReleased)];\n        }\n        // All instances\n        else {\n            return eventRecord.resources.reduce((result, resourceRecord) => {\n                const el = this.getElementFromEventRecord(eventRecord, resourceRecord, returnWrapper, checkReleased);\n                el && result.push(el);\n                return result;\n            }, []);\n        }\n    }\n    //endregion\n    //region Resolve\n    /**\n     * Resolves the resource based on a dom element or event. In vertical mode, if resolving from an element higher up in\n     * the hierarchy than event elements, then it is required to supply an coordinates since resources are virtual\n     * columns.\n     * @param {HTMLElement|Event} elementOrEvent The HTML element or DOM event to resolve a resource from\n     * @param {Number[]} [xy] X and Y coordinates, required in some cases in vertical mode, disregarded in horizontal\n     * @returns {Scheduler.model.ResourceModel} The resource corresponding to the element, or null if not found.\n     * @category DOM\n     */\n    resolveResourceRecord(elementOrEvent, xy) {\n        return this.currentOrientation.resolveRowRecord(elementOrEvent, xy);\n    }\n    /**\n     * Product agnostic method which yields the {@link Scheduler.model.ResourceModel} record which underpins the row which\n     * encapsulates the passed element. The element can be a grid cell, or an event element, and the result\n     * will be a {@link Scheduler.model.ResourceModel}\n     * @param {HTMLElement|Event} elementOrEvent The HTML element or DOM event to resolve a record from\n     * @returns {Scheduler.model.ResourceModel} The resource corresponding to the element, or null if not found.\n     * @category DOM\n     */\n    resolveRowRecord(elementOrEvent) {\n        return this.resolveResourceRecord(elementOrEvent);\n    }\n    /**\n     * Returns the event record for a DOM element\n     * @param {HTMLElement|Event} elementOrEvent The DOM node to lookup\n     * @returns {Scheduler.model.EventModel} The event record\n     * @category DOM\n     */\n    resolveEventRecord(elementOrEvent) {\n        if (elementOrEvent instanceof Event) {\n            elementOrEvent = elementOrEvent.target;\n        }\n        const element = elementOrEvent?.closest(this.eventSelector);\n        if (element) {\n            if (element.dataset.eventId) {\n                return this.eventStore.getById(element.dataset.eventId);\n            }\n            if (element.dataset.assignmentId) {\n                return this.assignmentStore.getById(element.dataset.assignmentId).event;\n            }\n        }\n        return null;\n    }\n    // Used by shared features to resolve an event or task\n    resolveTimeSpanRecord(element) {\n        return this.resolveEventRecord(element);\n    }\n    /**\n     * Returns an assignment record for a DOM element\n     * @param {HTMLElement} element The DOM node to lookup\n     * @privateparam {Boolean} allowReleased Whether to allow resolving from a released event\n     * @returns {Scheduler.model.AssignmentModel} The assignment record\n     * @category DOM\n     */\n    resolveAssignmentRecord(element, allowReleased = false) {\n        const\n            eventElement     = element.closest(allowReleased ? '[data-assignment-id][data-event-id]' : this.eventSelector),\n            assignmentRecord = eventElement && this.assignmentStore.getById(eventElement.dataset.assignmentId),\n            eventRecord      = eventElement && this.eventStore.getById(eventElement.dataset.eventId);\n        // When resolving a recurring event, we might be resolving an occurrence\n        return this.assignmentStore.getOccurrence(assignmentRecord, eventRecord);\n    }\n    //endregion\n    // Decide if a record is inside a collapsed tree node, or inside a collapsed group (using grouping feature)\n    isRowVisible(resourceRecord) {\n        // records in collapsed groups/branches etc. are removed from processedRecords\n        return this.store.indexOf(resourceRecord) >= 0;\n    }\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\n/**\n * @module Scheduler/view/mixin/SchedulerDomEvents\n */\n/**\n * Mixin that handles dom events (click etc) for scheduler and rendered events.\n *\n * @mixin\n */\nexport default Target => class SchedulerDomEvents extends (Target || Base) {\n    static get $name() {\n        return 'SchedulerDomEvents';\n    }\n    //region Events\n    /**\n     * Triggered when user mousedowns over an empty area in the schedule.\n     * @event scheduleMouseDown\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Resource index\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when mouse enters an empty area in the schedule.\n     * @event scheduleMouseEnter\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Resource index\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when mouse leaves an empty area in the schedule.\n     * @event scheduleMouseLeave\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when user mouseups over an empty area in the schedule.\n     * @event scheduleMouseUp\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Resource index\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when user moves mouse over an empty area in the schedule.\n     * @event scheduleMouseMove\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Scheduler.model.TimeSpan} tick A record which encapsulates the time axis tick clicked on.\n     * @param {Number} tickIndex The index of the time axis tick clicked on.\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Resource index\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when user clicks an empty area in the schedule.\n     * @event scheduleClick\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Scheduler.model.TimeSpan} tick A record which encapsulates the time axis tick clicked on.\n     * @param {Number} tickIndex The index of the time axis tick clicked on.\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Resource index\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when user double-clicks an empty area in the schedule.\n     * @event scheduleDblClick\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Scheduler.model.TimeSpan} tick A record which encapsulates the time axis tick clicked on.\n     * @param {Number} tickIndex The index of the time axis tick clicked on.\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Index of double-clicked resource\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when user right-clicks an empty area in the schedule.\n     * @event scheduleContextMenu\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Scheduler.model.TimeSpan} tick A record which encapsulates the time axis tick clicked on.\n     * @param {Number} tickIndex The index of the time axis tick clicked on.\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Resource index\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered for mouse down on an event.\n     * @event eventMouseDown\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered for mouse up on an event.\n     * @event eventMouseUp\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered for click on an event.\n     * @event eventClick\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered for double-click on an event.\n     * @event eventDblClick\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered for right-click on an event.\n     * @event eventContextMenu\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when the mouse enters an event bar.\n     * @event eventMouseEnter\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when the mouse leaves an event bar.\n     * @event eventMouseLeave\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered for mouse over events when moving into and within an event bar.\n     *\n     * Note that `mouseover` events bubble, therefore this event will fire while moving from\n     * element to element *within* an event bar.\n     *\n     * _If only an event when moving into the event bar is required, use the {@link #event-eventMouseEnter} event._\n     * @event eventMouseOver\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered for mouse out events within and when moving out of an event bar.\n     *\n     * Note that `mouseout` events bubble, therefore this event will fire while moving from\n     * element to element *within* an event bar.\n     *\n     * _If only an event when moving out of the event bar is required, use the {@link #event-eventMouseLeave} event._\n     * @event eventMouseOut\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n    //endregion\n    //region Event handling\n    getTimeSpanMouseEventParams(eventElement, event) {\n        // May have hovered a record being removed / faded out\n        const eventRecord = this.resolveEventRecord(eventElement);\n        return eventRecord && {\n            eventRecord,\n            resourceRecord   : this.resolveResourceRecord(eventElement),\n            assignmentRecord : this.resolveAssignmentRecord(eventElement),\n            eventElement,\n            event\n        };\n    }\n    getScheduleMouseEventParams(cellData, event) {\n        const resourceRecord = this.isVertical ? this.resolveResourceRecord(event) : this.store.getById(cellData.id);\n        return { resourceRecord };\n    }\n    /**\n     * Relays keydown events as eventkeydown if we have a selected task.\n     * @private\n     */\n    onElementKeyDown(event) {\n        const\n            result = super.onElementKeyDown(event),\n            me     = this;\n        if (me.selectedEvents.length) {\n            me.trigger(me.scheduledEventName + 'KeyDown', {\n                eventRecords      : me.selectedEvents,\n                assignmentRecords : me.selectedAssignments,\n                event,\n                eventRecord       : me.selectedEvents,\n                assignmentRecord  : me.selectedAssignments\n            });\n        }\n        return result;\n    }\n    /**\n     * Relays keyup events as eventkeyup if we have a selected task.\n     * @private\n     */\n    onElementKeyUp(event) {\n        super.onElementKeyUp(event);\n        const me = this;\n        if (me.selectedEvents.length) {\n            me.trigger(me.scheduledEventName + 'KeyUp', {\n                eventRecords      : me.selectedEvents,\n                assignmentRecords : me.selectedAssignments,\n                event,\n                eventRecord      : me.selectedEvents,\n                assignmentRecord : me.selectedAssignments\n            });\n        }\n    }\n    //endregion\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../Core/Base.js';\n/**\n * @module Scheduler/eventlayout/HorizontalLayout\n */\n/**\n * Base class for horizontal layouts (HorizontalLayoutPack and HorizontalLayoutStack). Should not be used directly,\n * instead specify {@link Scheduler.view.mixin.SchedulerEventRendering#config-eventLayout} in Scheduler config (stack,\n * pack or none):\n *\n * ```javascript\n * let scheduler = new Scheduler({\n *   eventLayout: 'stack'\n * });\n * ```\n *\n * @abstract\n * @private\n */\nexport default class HorizontalLayout extends Base {\n    static get defaultConfig() {\n        return {\n            nbrOfBandsByResource        : {},\n            bandIndexToPxConvertFn      : null,\n            bandIndexToPxConvertThisObj : null\n        };\n    }\n    clearCache(resource) {\n        if (resource) {\n            delete this.nbrOfBandsByResource[resource.id];\n        }\n        else {\n            this.nbrOfBandsByResource = {};\n        }\n    }\n    /**\n     * This method performs layout on an array of event render data and returns amount of _bands_. Band is a multiplier of a\n     * configured {@link Scheduler.view.Scheduler#config-rowHeight} to calculate total row height required to fit all\n     * events.\n     * This method should not be used directly, it is called by the Scheduler during the row rendering process.\n     * @param {EventRenderData[]} events Unordered array of event render data, sorting may be required\n     * @param {Scheduler.model.ResourceModel} resource The resource for which the events are being laid out.\n     * @returns {Number}\n     */\n    applyLayout(events, resource) {\n        // Return number of bands required\n        return this.nbrOfBandsByResource[resource.id] = this.layoutEventsInBands(events, resource);\n    }\n    /**\n     * This method iterates over events and calculates top position for each of them. Default layouts calculate\n     * positions to avoid events overlapping horizontally (except for the 'none' layout). Pack layout will squeeze events to a single\n     * row by reducing their height, Stack layout will increase the row height and keep event height intact.\n     * This method should not be used directly, it is called by the Scheduler during the row rendering process.\n     * @param {EventRenderData[]} events Unordered array of event render data, sorting may be required\n     * @param {Scheduler.model.ResourceModel} resource The resource for which the events are being laid out.\n     */\n    layoutEventsInBands(events, resource) {\n        throw new Error('Implement in subclass');\n    }\n}\nHorizontalLayout._$name = 'HorizontalLayout';", "import HorizontalLayout from './HorizontalLayout.js';\n/**\n * @module Scheduler/eventlayout/HorizontalLayoutStack\n */\n/**\n * Handles layout of events within a row (resource) in horizontal mode. Stacks events, increasing row height when to fit\n * all overlapping events.\n *\n * This layout is used by default in horizontal mode.\n *\n * @extends Scheduler/eventlayout/HorizontalLayout\n * @private\n */\nexport default class HorizontalLayoutStack extends HorizontalLayout {\n    static get $name() {\n        return 'HorizontalLayoutStack';\n    }\n    static get configurable() {\n        return {\n            type : 'stack'\n        };\n    }\n    // Input: Array of event layout data\n    // heightRun is used when pre-calculating row heights, taking a cheaper path\n    layoutEventsInBands(events, resource, heightRun = false) {\n        let verticalPosition = 0;\n        do {\n            let eventIndex = 0,\n                event      = events[0];\n            while (event) {\n                if (!heightRun) {\n                    // Apply band height to the event cfg\n                    event.top = this.bandIndexToPxConvertFn.call(\n                        this.bandIndexToPxConvertThisObj || this,\n                        verticalPosition,\n                        event.eventRecord,\n                        event.resourceRecord\n                    );\n                }\n                // Remove it from the array and continue searching\n                events.splice(eventIndex, 1);\n                eventIndex = this.findClosestSuccessor(event, events);\n                event = events[eventIndex];\n            }\n            verticalPosition++;\n        } while (events.length > 0);\n        // Done!\n        return verticalPosition;\n    }\n    findClosestSuccessor(eventRenderData, events) {\n        const\n            { endMS, group } = eventRenderData,\n            isMilestone      = eventRenderData.eventRecord?.duration === 0;\n        let minGap      = Infinity,\n            closest,\n            gap,\n            event,\n            eventIsMilestone;\n        for (let i = 0, l = events.length; i < l; i++) {\n            event = events[i];\n            gap = event.startMS - endMS;\n            eventIsMilestone = event.endMS - event.startMS === 0 && !event.eventRecord?.meta.isDragCreating;\n            if (\n                gap >= 0 && gap < minGap &&\n                // Two milestones should not overlap\n                (gap > 0 || !eventIsMilestone || !isMilestone) &&\n                // Milestone at events endDate goes on next band\n                !(gap === 0 && eventIsMilestone && !isMilestone)\n            ) {\n                // Events are sorted by group, so when we find first event with a different group, we can stop iteration\n                if (this.grouped && group !== event.group) {\n                    break;\n                }\n                closest = i;\n                minGap  = gap;\n            }\n        }\n        return closest;\n    }\n}\nHorizontalLayoutStack._$name = 'HorizontalLayoutStack';", "import Base from '../../Core/Base.js';\n/**\n * @module Scheduler/eventlayout/PackMixin\n */\nconst rangesIntersect = (range1Start, range1End, range2Start, range2End) => {\n    return (range2Start <= range1Start && range1Start < range2End) ||\n    (range1Start <= range2Start && range2Start < range1End);\n};\n/**\n * Mixin holding functionality shared between HorizontalLayoutPack and VerticalLayout.\n *\n * @mixin\n * @private\n */\nexport default Target => class PackMixin extends (Target || Base) {\n    static get $name() {\n        return 'PackMixin';\n    }\n    static get defaultConfig() {\n        return {\n            coordProp       : 'top',\n            sizeProp        : 'height',\n            inBandCoordProp : 'inBandTop',\n            inBandSizeProp  : 'inBandHeight'\n        };\n    }\n    isSameGroup(a, b) {\n        return this.grouped ? a.group === b.group : true;\n    }\n    // Packs the events to consume as little space as possible\n    packEventsInBands(events, applyClusterFn) {\n        const\n            me                      = this,\n            { coordProp, sizeProp } = me;\n        let slot,\n            firstInCluster,\n            cluster,\n            j;\n        for (let i = 0, l = events.length; i < l; i++) {\n            firstInCluster = events[i];\n            slot = me.findStartSlot(events, firstInCluster);\n            cluster = me.getCluster(events, i);\n            if (cluster.length > 1) {\n                firstInCluster[coordProp] = slot.start;\n                firstInCluster[sizeProp]  = slot.end - slot.start;\n                // If there are multiple slots, and events in the cluster have multiple start dates, group all same-start events into first slot\n                j = 1;\n                while (j < (cluster.length - 1) && cluster[j + 1].start - firstInCluster.start === 0) {\n                    j++;\n                }\n                // See if there's more than 1 slot available for this cluster, if so - first group in cluster consumes the entire first slot\n                const nextSlot = me.findStartSlot(events, cluster[j]);\n                if (nextSlot && nextSlot.start < 0.8) {\n                    cluster.length = j;\n                }\n            }\n            const\n                clusterSize = cluster.length,\n                slotSize    = (slot.end - slot.start) / clusterSize;\n            // Apply fraction values\n            for (j = 0; j < clusterSize; j++) {\n                applyClusterFn(cluster[j], j, slot, slotSize);\n            }\n            i += clusterSize - 1;\n        }\n        return 1;\n    }\n    findStartSlot(events, event) {\n        const\n            {\n                inBandSizeProp,\n                inBandCoordProp,\n                coordProp,\n                sizeProp\n            }                = this,\n            priorOverlappers = this.getPriorOverlappingEvents(events, event);\n        let i;\n        if (priorOverlappers.length === 0) {\n            return {\n                start : 0,\n                end   : 1\n            };\n        }\n        for (i = 0; i < priorOverlappers.length; i++) {\n            const\n                item       = priorOverlappers[i],\n                COORD_PROP = inBandCoordProp in item ? inBandCoordProp : coordProp,\n                SIZE_PROP  = inBandSizeProp in item ? inBandSizeProp : sizeProp;\n            if (i === 0 && item[COORD_PROP] > 0) {\n                return {\n                    start : 0,\n                    end   : item[COORD_PROP]\n                };\n            }\n            else {\n                if (item[COORD_PROP] + item[SIZE_PROP] < (i < priorOverlappers.length - 1 ? priorOverlappers[i + 1][COORD_PROP] : 1)) {\n                    return {\n                        start : item[COORD_PROP] + item[SIZE_PROP],\n                        end   : i < priorOverlappers.length - 1 ? priorOverlappers[i + 1][COORD_PROP] : 1\n                    };\n                }\n            }\n        }\n        return false;\n    }\n    getPriorOverlappingEvents(events, event) {\n        const\n            { startMS, endMS }       = event,\n            overlappers = [];\n        for (let i = 0, l = events.indexOf(event); i < l; i++) {\n            const item = events[i];\n            if (this.isSameGroup(item, event) && rangesIntersect(startMS, endMS, item.startMS, item.endMS)) {\n                overlappers.push(item);\n            }\n        }\n        overlappers.sort(this.sortOverlappers.bind(this));\n        return overlappers;\n    }\n    sortOverlappers(e1, e2) {\n        const { coordProp } = this;\n        return e1[coordProp] - e2[coordProp];\n    }\n    getCluster(events, startIndex) {\n        const\n            startEvent = events[startIndex],\n            result     = [startEvent];\n        if (startIndex >= events.length - 1) {\n            return result;\n        }\n        let { startMS, endMS } = startEvent;\n        for (let i = startIndex + 1, l = events.length; i < l; i++) {\n            const item = events[i];\n            if (!this.isSameGroup(item, startEvent) || !rangesIntersect(startMS, endMS, item.startMS, item.endMS)) {\n                break;\n            }\n            result.push(item);\n            startMS = Math.max(startMS, item.startMS);\n            endMS   = Math.min(item.endMS, endMS);\n        }\n        return result;\n    }\n};\n", "import HorizontalLayout from './HorizontalLayout.js';\nimport PackMixin from './PackMixin.js';\n/**\n * @module Scheduler/eventlayout/HorizontalLayoutPack\n */\n/**\n * Handles layout of events within a row (resource) in horizontal mode. Packs events (adjusts their height) to fit\n * available row height\n *\n * @extends Scheduler/eventlayout/HorizontalLayout\n * @mixes Scheduler/eventlayout/PackMixin\n * @private\n */\nexport default class HorizontalLayoutPack extends HorizontalLayout.mixin(PackMixin) {\n    static get $name() {\n        return 'HorizontalLayoutPack';\n    }\n    static get configurable() {\n        return {\n            type : 'pack'\n        };\n    }\n    // Packs the events to consume as little space as possible\n    layoutEventsInBands(events) {\n        const result = this.packEventsInBands(events, (event, j, slot, slotSize) => {\n            event.height = slotSize;\n            event.top    = slot.start + (j * slotSize);\n        });\n        events.forEach(event => {\n            Object.assign(\n                event,\n                this.bandIndexToPxConvertFn.call(\n                    this.bandIndexToPxConvertThisObj || this,\n                    event.top,\n                    event.height,\n                    event.eventRecord,\n                    event.resourceRecord\n                )\n            );\n        });\n        return result;\n    }\n}\nHorizontalLayoutPack._$name = 'HorizontalLayoutPack';", "import Base from '../../../Core/Base.js';\n/**\n * @module Scheduler/view/mixin/SchedulerResourceRendering\n */\n/**\n * Configs and functions used for resource rendering\n * and by the {@link Scheduler/column/ResourceInfoColumn} class.\n *\n * @mixin\n */\nexport default Target => class SchedulerResourceRendering extends (Target || Base) {\n    static $name = 'SchedulerResourceRendering';\n    //region Default config\n    static configurable = {\n        /**\n         * Control how much space to leave between the first event/last event and the resources edge (top/bottom\n         * margin within the resource row in horizontal mode, left/right margin within the resource column in\n         * vertical mode), in px. Defaults to the value of {@link Scheduler.view.Scheduler#config-barMargin}.\n         *\n         * Can be configured per resource by setting {@link Scheduler.model.ResourceModel#field-resourceMargin\n         * resource.resourceMargin}.\n         *\n         * It's also possible to set different values for top/left and bottom/right\n         * by assigning  an object to `resourceMargin` with `start` (margin top in horizontal mode,\n         * margin left in vertical mode) and `end` (margin bottom / margin right) properties:\n         * ```javascript\n         * scheduler = new Scheduler({\n         *     resourceMargin : {\n         *         start : 15,\n         *         end   : 1\n         *     }\n         * });\n         * ```\n         *\n         * @prp {Number|ResourceMarginConfig}\n         * @category Scheduled events\n         */\n        resourceMargin : null,\n        /**\n         * A config object used to configure the resource columns in vertical mode.\n         * See {@link Scheduler.view.ResourceHeader} for more details on available properties.\n         *\n         * ```javascript\n         * new Scheduler({\n         *     resourceColumns : {\n         *         columnWidth    : 100,\n         *         headerRenderer : ({ resourceRecord }) => `${resourceRecord.id} - ${resourceRecord.name}`\n         *     }\n         * })\n         * ```\n         * @config {ResourceHeaderConfig}\n         * @category Resources\n         */\n        resourceColumns : null,\n        /**\n         * Path to load resource images from. Used by the resource header in vertical mode and the\n         * {@link Scheduler.column.ResourceInfoColumn} in horizontal mode. Set this to display miniature\n         * images for each resource using their `image` or `imageUrl` fields.\n         *\n         * * `image` represents image name inside the specified `resourceImagePath`,\n         * * `imageUrl` represents fully qualified image URL.\n         *\n         *  If set and a resource has no `imageUrl` or `image` specified it will try show miniature using\n         *  the resource's name with {@link #config-resourceImageExtension} appended.\n         *\n         * **NOTE**: The path should end with a `/`:\n         *\n         * ```\n         * new Scheduler({\n         *   resourceImagePath : 'images/resources/'\n         * });\n         * ```\n         * @config {String}\n         * @category Resources\n         */\n        resourceImagePath : null,\n        /**\n         * Generic resource image, used when provided `imageUrl` or `image` fields or path calculated from resource\n         * name are all invalid. If left blank, resource name initials will be shown when no image can be loaded.\n         * @default\n         * @config {String}\n         * @category Resources\n         */\n        defaultResourceImageName : null,\n        /**\n         * Resource image extension, used when creating image path from resource name.\n         * @default\n         * @config {String}\n         * @category Resources\n         */\n        resourceImageExtension : '.jpg'\n    };\n    //endregion\n    //region Resource header/columns\n    // NOTE: The configs below are initially applied to the resource header in `TimeAxisColumn#set mode`\n    /**\n     * Use it to manipulate resource column properties at runtime.\n     * @property {Scheduler.view.ResourceHeader}\n     * @readonly\n     */\n    get resourceColumns() {\n        return this.timeAxisColumn?.resourceColumns || this._resourceColumns;\n    }\n    /**\n     * Get resource column width. Only applies to vertical mode. To set it, assign to\n     * `scheduler.resourceColumns.columnWidth`.\n     * @property {Number}\n     * @readonly\n     */\n    get resourceColumnWidth() {\n        return this.resourceColumns?.columnWidth || null;\n    }\n    //endregion\n    //region Event rendering\n    // Returns a resource specific resourceMargin, falling back to Schedulers setting\n    // This fn could be made public to allow hooking it as an alternative to only setting this in data\n    getResourceMarginObject(resourceRecord) {\n        if (resourceRecord?.resourceMargin) {\n            const margin = resourceRecord?.resourceMargin ?? this.resourceMargin;\n            if (typeof margin === 'number') {\n                return {\n                    start : margin,\n                    end   : margin,\n                    total : margin * 2\n                };\n            }\n            else {\n                margin.total = margin.start + margin.end;\n                return margin;\n            }\n        }\n        else {\n            return this.resourceMarginObject;\n        }\n    }\n    // Returns a resource specific barMargin, falling back to Schedulers setting\n    // This fn could be made public to allow hooking it as an alternative to only setting this in data\n    getBarMargin(resourceRecord) {\n        return resourceRecord?.barMargin ?? this.barMargin;\n    }\n    // Returns a resource specific rowHeight, falling back to Schedulers setting\n    // Prio order: Height from record, configured height\n    // This fn could be made public to allow hooking it as an alternative to only setting this in data\n    getResourceHeight(resourceRecord) {\n        return resourceRecord.rowHeight ?? (this.isHorizontal ? this.rowHeight : this.getResourceWidth(resourceRecord));\n    }\n    getResourceWidth(resourceRecord) {\n        return resourceRecord.columnWidth ?? this.resourceColumnWidth;\n    }\n    // Similar to getResourceHeight(), but for usage later in the process to take height set by renderers into account.\n    // Cant be used earlier in the process because then the row will grow\n    // Prio order: Height requested by renderer, height from record, configured height\n    getAppliedResourceHeight(resourceRecord) {\n        const row = this.getRowById(resourceRecord);\n        return row?.maxRequestedHeight ?? this.getResourceHeight(resourceRecord);\n    }\n    // Combined convenience getter for destructuring on calling side\n    // Second arg only passed for nested events, handled by NestedEvent feature\n    getResourceLayoutSettings(resourceRecord, parentEventRecord = null) {\n        const\n            resourceMarginObject = this.getResourceMarginObject(resourceRecord, parentEventRecord),\n            rowHeight = this.getAppliedResourceHeight(resourceRecord, parentEventRecord);\n        return {\n            barMargin     : this.getBarMargin(resourceRecord, parentEventRecord),\n            contentHeight : Math.max(rowHeight - resourceMarginObject.total, 1),\n            rowHeight,\n            resourceMarginObject\n        };\n    }\n    //endregion\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport DomClassList from '../../../Core/helper/util/DomClassList.js';\nimport HorizontalLayoutStack from '../../eventlayout/HorizontalLayoutStack.js';\nimport HorizontalLayoutPack from '../../eventlayout/HorizontalLayoutPack.js';\nimport BrowserHelper from '../../../Core/helper/BrowserHelper.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport VersionHelper from '../../../Core/helper/VersionHelper.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport SchedulerResourceRendering from './SchedulerResourceRendering.js';\n/**\n * @module Scheduler/view/mixin/SchedulerEventRendering\n */\n/**\n * Layout data object used to lay out an event record.\n * @typedef {Object} EventRenderData\n * @property {Scheduler.model.EventModel} eventRecord Event instance\n * @property {Scheduler.model.ResourceModel} resourceRecord Assigned resource\n * @property {Scheduler.model.AssignmentModel} assignmentRecord Assignment instance\n * @property {Number} startMS Event start date time in milliseconds\n * @property {Number} endMS Event end date in milliseconds\n * @property {Number} height Calculated event element height\n * @property {Number} width Calculated event element width\n * @property {Number} top Calculated event element top position in the row (or column)\n * @property {Number} left Calculated event element left position in the row (or column)\n */\n/**\n * Functions to handle event rendering (EventModel -> dom elements).\n *\n * @mixes Scheduler/view/mixin/SchedulerResourceRendering\n * @mixin\n */\nexport default Target => class SchedulerEventRendering extends SchedulerResourceRendering(Target || Base) {\n    static get $name() {\n        return 'SchedulerEventRendering';\n    }\n    //region Default config\n    static get configurable() {\n        return {\n            /**\n             * Position of the milestone text:\n             * * 'inside' - for short 1-char text displayed inside the diamond, not applicable when using\n             *   {@link #config-milestoneLayoutMode})\n             * * 'outside' - for longer text displayed outside the diamond, but inside it when using\n             *   {@link #config-milestoneLayoutMode}\n             * * 'always-outside' - outside even when combined with {@link #config-milestoneLayoutMode}\n             *\n             * @prp {'inside'|'outside'|'always-outside'}\n             * @default\n             * @category Milestones\n             */\n            milestoneTextPosition : 'outside',\n            /**\n             * How to align milestones in relation to their startDate. Only applies when using a `milestoneLayoutMode`\n             * other than `default`. Valid values are:\n             * * start\n             * * center (default)\n             * * end\n             * @prp {'start'|'center'|'end'}\n             * @default\n             * @category Milestones\n             */\n            milestoneAlign : 'center',\n            /**\n             * Factor representing the average char width in pixels used to determine milestone width when configured\n             * with `milestoneLayoutMode: 'estimate'`.\n             * @prp {Number}\n             * @default\n             * @category Milestones\n             */\n            milestoneCharWidth : 10,\n            /**\n             * How to handle milestones during event layout. How the milestones are displayed when part of the layout\n             * are controlled using {@link #config-milestoneTextPosition}.\n             *\n             * Options are:\n             * * default - Milestones do not affect event layout\n             * * estimate - Milestone width is estimated by multiplying text length with Scheduler#milestoneCharWidth\n             * * data - Milestone width is determined by checking EventModel#milestoneWidth\n             * * measure - Milestone width is determined by measuring label width\n             * Please note that currently text width is always determined using EventModel#name.\n             * Also note that only 'default' is supported by eventStyles line, dashed and minimal.\n             * @prp {'default'|'estimate'|'data'|'measure'}\n             * @default\n             * @category Milestones\n             */\n            milestoneLayoutMode : 'default',\n            /**\n             * Defines how to handle overlapping events. Valid values are:\n             * - `stack`, adjusts row height (only horizontal)\n             * - `pack`, adjusts event height\n             * - `mixed`, allows two events to overlap, more packs (only vertical)\n             * - `none`, allows events to overlap\n             *\n             * This config can also accept an object:\n             *\n             * ```javascript\n             * new Scheduler({\n             *     eventLayout : { type : 'stack' }\n             * })\n             * ```\n             *\n             * @prp {'stack'|'pack'|'mixed'|'none'|Object}\n             * @default\n             * @category Scheduled events\n             */\n            eventLayout : 'stack',\n            /**\n             * Override this method to provide a custom sort function to sort any overlapping events. See {@link\n             * #config-overlappingEventSorter} for more details.\n             *\n             * @param  {Scheduler.model.EventModel} a First event\n             * @param  {Scheduler.model.EventModel} b Second event\n             * @returns {Number} Return -1 to display `a` above `b`, 1 for `b` above `a`\n             * @member {Function} overlappingEventSorter\n             * @category Misc\n             */\n            /**\n             * Override this method to provide a custom sort function to sort any overlapping events. This only applies\n             * to the horizontal mode, where the order the events are sorted in determines their vertical placement\n             * within a resource.\n             *\n             * By default, overlapping events are laid out based on the start date. If the start date is equal, events\n             * with earlier end date go first. And lastly the name of events is taken into account.\n             *\n             * Here's a sample sort function, sorting on start- and end date. If this function returns -1, then event\n             * `a` is placed above event `b`:\n             *\n             * ```javascript\n             * overlappingEventSorter(a, b) {\n             *\n             *   const startA = a.startDate, endA = a.endDate;\n             *   const startB = b.startDate, endB = b.endDate;\n             *\n             *   const sameStart = (startA - startB === 0);\n             *\n             *   if (sameStart) {\n             *     return endA > endB ? -1 : 1;\n             *   } else {\n             *     return (startA < startB) ? -1 : 1;\n             *   }\n             * }\n             * ```\n             *\n             * NOTE: The algorithms (stack, pack) that lay the events out expects them to be served in chronological\n             * order, be sure to first sort by `startDate` to get predictable results.\n             *\n             * @param  {Scheduler.model.EventModel} a First event\n             * @param  {Scheduler.model.EventModel} b Second event\n             * @returns {Number} Return -1 to display `a` above `b`, 1 for `b` above `a`\n             * @config {Function}\n             * @category Misc\n             */\n            overlappingEventSorter : null,\n            /**\n             * Deprecated, to be removed in version 6.0. Replaced by {@link #config-overlappingEventSorter}.\n             * @deprecated Since 5.0. Use {@link #config-overlappingEventSorter} instead.\n             * @config {Function}\n             * @category Misc\n             */\n            horizontalEventSorterFn : null,\n            /**\n             * By default, scheduler fade events in on load. Specify `false` to prevent this animation or specify one\n             * of the available animation types to use it (`true` equals `'fade-in'`):\n             * * fade-in (default)\n             * * slide-from-left\n             * * slide-from-top\n             * ```\n             * // Slide events in from the left on load\n             * scheduler = new Scheduler({\n             *     useInitialAnimation : 'slide-from-left'\n             * });\n             * ```\n             * @prp {Boolean|'fade-in'|'slide-from-left'|'slide-from-top'|String}\n             * @default\n             * @category Misc\n             */\n            useInitialAnimation : true,\n            /**\n             * An empty function by default, but provided so that you can override it. This function is called each time\n             * an event is rendered into the schedule to render the contents of the event. It's called with the event,\n             * its resource and a `renderData` object which allows you to populate data placeholders inside the event\n             * template. **IMPORTANT** You should never modify any data on the EventModel inside this method.\n             *\n             * By default, the DOM markup of an event bar includes placeholders for 'cls' and 'style'. The cls property\n             * is a {@link Core.helper.util.DomClassList} which will be added to the event element. The style property\n             * is an inline style declaration for the event element.\n             *\n             * IMPORTANT: When returning content, be sure to consider how that content should be encoded to avoid XSS\n             * (Cross-Site Scripting) attacks. This is especially important when including user-controlled data such as\n             * the event's `name`. The function {@link Core.helper.StringHelper#function-encodeHtml-static} as well as\n             * {@link Core.helper.StringHelper#function-xss-static} can be helpful in these cases.\n             *\n             * ```javascript\n             *  eventRenderer({ eventRecord, resourceRecord, renderData }) {\n             *      renderData.style = 'color:white';                 // You can use inline styles too.\n             *\n             *      // Property names with truthy values are added to the resulting elements CSS class.\n             *      renderData.cls.isImportant = this.isImportant(eventRecord);\n             *      renderData.cls.isModified = eventRecord.isModified;\n             *\n             *      // Remove a class name by setting the property to false\n             *      renderData.cls[scheduler.generatedIdCls] = false;\n             *\n             *      // Or, you can treat it as a string, but this is less efficient, especially\n             *      // if your renderer wants to *remove* classes that may be there.\n             *      renderData.cls += ' extra-class';\n             *\n             *      return StringHelper.xss`${DateHelper.format(eventRecord.startDate, 'YYYY-MM-DD')}: ${eventRecord.name}`;\n             *  }\n             * ```\n             *\n             * @param {Object} detail An object containing the information needed to render an Event.\n             * @param {Scheduler.model.EventModel} detail.eventRecord The event record.\n             * @param {Scheduler.model.ResourceModel} detail.resourceRecord The resource record.\n             * @param {Scheduler.model.AssignmentModel} detail.assignmentRecord The assignment record.\n             * @param {Object} detail.renderData An object containing details about the event rendering.\n             * @param {Scheduler.model.EventModel} detail.renderData.event The event record.\n             * @param {Core.helper.util.DomClassList|String} detail.renderData.cls An object whose property names\n             * represent the CSS class names to be added to the event bar element. Set a property's value to truthy or\n             * falsy to add or remove the class name based on the property name. Using this technique, you do not have\n             * to know whether the class is already there, or deal with concatenation.\n             * @param {Core.helper.util.DomClassList|String} detail.renderData.wrapperCls An object whose property names\n             * represent the CSS class names to be added to the event wrapper element. Set a property's value to truthy\n             * or falsy to add or remove the class name based on the property name. Using this technique, you do not\n             * have to know whether the class is already there, or deal with concatenation.\n             * @param {Core.helper.util.DomClassList|String} detail.renderData.iconCls An object whose property names\n             * represent the CSS class names to be added to an event icon element.\n             *\n             * Note that an element carrying this icon class is injected into the event element *after*\n             * the renderer completes, *before* the renderer's created content.\n             *\n             * To disable this if the renderer takes full control and creates content using the iconCls,\n             * you can set `renderData.iconCls = null`.\n             * @param {Number} detail.renderData.left Vertical offset position (in pixels) on the time axis.\n             * @param {Number} detail.renderData.width Width in pixels of the event element.\n             * @param {Number} detail.renderData.height Height in pixels of the event element.\n             * @param {String|Object<String,String>} detail.renderData.style Inline styles for the event bar DOM element.\n             * Use either 'border: 1px solid black' or `{ border: '1px solid black' }`\n             * @param {String|Object<String,String>} detail.renderData.wrapperStyle Inline styles for wrapper of the\n             * event bar DOM element. Use either 'border: 1px solid green' or `{ border: '1px solid green' }`\n             * @param {String} detail.renderData.eventStyle The `eventStyle` of the event. Use this to apply custom\n             * styles to the event DOM element\n             * @param {String} detail.renderData.eventColor The `eventColor` of the event. Use this to set a custom\n             * color for the rendered event\n             * @param {DomConfig[]} detail.renderData.children An array of DOM configs used as children to the\n             * `b-sch-event` element. Can be populated with additional DOM configs to have more control over contents.\n             * @returns {String|Object|DomConfig|DomConfig[]} A simple string, or a custom object which will be applied to the\n             * {@link #config-eventBodyTemplate}, creating the actual HTML\n             * @config {Function}\n             * @category Scheduled events\n             */\n            eventRenderer : null,\n            /**\n             * `this` reference for the {@link #config-eventRenderer} function\n             * @config {Object}\n             * @category Scheduled events\n             */\n            eventRendererThisObj : null,\n            /**\n             * Field from EventModel displayed as text in the bar when rendering\n             * @config {String}\n             * @default\n             * @category Scheduled events\n             */\n            eventBarTextField : 'name',\n            /**\n             * The template used to generate the markup of your events in the scheduler. To 'populate' the\n             * eventBodyTemplate with data, use the {@link #config-eventRenderer} method.\n             * @config {Function}\n             * @param {*} data Data passed from {@link #config-eventRenderer} method.\n             * @returns {DomConfig|String|null}\n             * @deprecated Since 5.6.2. Return markup/DomConfigs from {@link #config-eventRenderer} instead, will be\n             * removed in 6.0.0\n             * @category Scheduled events\n             */\n            eventBodyTemplate : null,\n            /**\n             * The class responsible for the packing horizontal event layout process.\n             * Override this to take control over the layout process.\n             * @config {Scheduler.eventlayout.HorizontalLayout}\n             * @typings {typeof HorizontalLayout}\n             * @default\n             * @private\n             * @category Misc\n             */\n            horizontalLayoutPackClass : HorizontalLayoutPack,\n            /**\n             * The class name responsible for the stacking horizontal event layout process.\n             * Override this to take control over the layout process.\n             * @config {Scheduler.eventlayout.HorizontalLayout}\n             * @typings {typeof HorizontalLayout}\n             * @default\n             * @private\n             * @category Misc\n             */\n            horizontalLayoutStackClass : HorizontalLayoutStack,\n            /**\n             * Controls how much space to leave between stacked event bars in px.\n             *\n             * Can be configured per resource by setting {@link Scheduler.model.ResourceModel#field-barMargin\n             * resource.barMargin}.\n             *\n             * @config {Number} barMargin\n             * @default\n             * @category Scheduled events\n             */\n            // Used to animate events on first render\n            isFirstRender : true,\n            initialAnimationDuration : 2000,\n            /**\n             * When an event bar has a width less than this value, it gets the CSS class `b-sch-event-narrow`\n             * added. You may apply custom CSS rules using this class.\n             *\n             * In vertical mode, this class causes the text to be rotated so that it runs vertically.\n             * @default\n             * @config {Number}\n             * @category Scheduled events\n             */\n            narrowEventWidth : 10,\n            internalEventLayout : null,\n            eventPositionMode   : 'translate',\n            eventScrollMode     : 'move'\n        };\n    }\n    //endregion\n    //region Settings\n    changeEventLayout(eventLayout) {\n        // Pass layout config to internal config to normalize its form\n        this.internalEventLayout = eventLayout;\n        // Return normalized string type\n        return this.internalEventLayout.type;\n    }\n    changeInternalEventLayout(eventLayout) {\n        return this.getEventLayout(eventLayout);\n    }\n    updateInternalEventLayout(eventLayout, oldEventLayout) {\n        const me = this;\n        if (oldEventLayout) {\n            me.element.classList.remove(`b-eventlayout-${oldEventLayout.type}`);\n        }\n        me.element.classList.add(`b-eventlayout-${eventLayout.type}`);\n        if (!me.isConfiguring) {\n            me.refreshWithTransition();\n            me.trigger('stateChange');\n        }\n    }\n    changeHorizontalEventSorterFn(fn) {\n        VersionHelper.deprecate('Scheduler', '6.0.0', 'Replaced by overlappingEventSorter()');\n        this.overlappingEventSorter = fn;\n    }\n    updateOverlappingEventSorter(fn) {\n        if (!this.isConfiguring) {\n            this.refreshWithTransition();\n        }\n    }\n    updateEventBodyTemplate() {\n        VersionHelper.deprecate('Scheduler', '6.0.0', 'Return markup/DomConfigs from eventRenderer() instead');\n    }\n    //endregion\n    //region Layout helpers\n    // Wraps string config to object with type\n    getEventLayout(value) {\n        if (value?.isModel) {\n            value = value.eventLayout || this.internalEventLayout;\n        }\n        if (typeof value === 'string') {\n            value = { type : value };\n        }\n        return value;\n    }\n    /**\n     * Get event layout handler. The handler decides the vertical placement of events within a resource.\n     * Returns null if no eventLayout is used (if {@link #config-eventLayout} is set to \"none\")\n     * @internal\n     * @returns {Scheduler.eventlayout.HorizontalLayout}\n     * @readonly\n     * @category Scheduled events\n     */\n    getEventLayoutHandler(eventLayout) {\n        const me = this;\n        if (!me.isHorizontal) {\n            return null;\n        }\n        const\n            { timeAxisViewModel, horizontal } = me,\n            { type }                          = eventLayout;\n        if (!me.layouts) {\n            me.layouts = {};\n        }\n        switch (type) {\n            // stack, adjust row height to fit all events\n            case 'stack': {\n                if (!me.layouts.horizontalStack) {\n                    me.layouts.horizontalStack = new me.horizontalLayoutStackClass(ObjectHelper.assign({\n                        scheduler                   : me,\n                        timeAxisViewModel,\n                        bandIndexToPxConvertFn      : horizontal.layoutEventVerticallyStack,\n                        bandIndexToPxConvertThisObj : horizontal\n                    }, eventLayout));\n                }\n                return me.layouts.horizontalStack;\n            }\n            // pack, fit all events in available height by adjusting their height\n            case 'pack': {\n                if (!me.layouts.horizontalPack) {\n                    me.layouts.horizontalPack = new me.horizontalLayoutPackClass(ObjectHelper.assign({\n                        scheduler                   : me,\n                        timeAxisViewModel,\n                        bandIndexToPxConvertFn      : horizontal.layoutEventVerticallyPack,\n                        bandIndexToPxConvertThisObj : horizontal\n                    }, eventLayout));\n                }\n                return me.layouts.horizontalPack;\n            }\n            default:\n                return null;\n        }\n    }\n    //endregion\n    //region Event rendering\n    // Chainable function called with the events to render for a specific resource. Allows features to add/remove.\n    // Chained by ResourceTimeRanges\n    getEventsToRender(resource, events) {\n        return events;\n    }\n    /**\n     * Rerenders events for specified resource (by rerendering the entire row).\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @category Rendering\n     */\n    repaintEventsForResource(resourceRecord) {\n        this.currentOrientation.repaintEventsForResource(resourceRecord);\n    }\n    /**\n     * Rerenders the events for all resources connected to the specified event\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @private\n     */\n    repaintEvent(eventRecord) {\n        const resources = this.eventStore.getResourcesForEvent(eventRecord);\n        resources.forEach(resourceRecord => this.repaintEventsForResource(resourceRecord));\n    }\n    getEventStyle(eventRecord, resourceRecord) {\n        return eventRecord.eventStyle || resourceRecord.eventStyle || this.eventStyle;\n    }\n    getEventColor(eventRecord, resourceRecord) {\n        return eventRecord.eventColor || eventRecord.event?.eventColor || eventRecord.parent?.eventColor || resourceRecord.eventColor || this.eventColor;\n    }\n    //endregion\n    //region Template\n    /**\n     * Generates data used in the template when rendering an event. For example which css classes to use. Also applies\n     * #eventBodyTemplate and calls the {@link #config-eventRenderer}.\n     * @private\n     * @param {Scheduler.model.EventModel} eventRecord Event to generate data for\n     * @param {Scheduler.model.ResourceModel} resourceRecord Events resource\n     * @param {Boolean|Object} includeOutside Specify true to get boxes for timespans outside the rendered zone in both\n     * dimensions. This option is used when calculating dependency lines, and we need to include routes from timespans\n     * which may be outside the rendered zone.\n     * @param {Boolean} includeOutside.timeAxis Pass as `true` to include timespans outside the TimeAxis's bounds\n     * @param {Boolean} includeOutside.viewport Pass as `true` to include timespans outside the vertical timespan viewport's bounds.\n     * @returns {Object} Data to use in event template, or `undefined` if the event is outside the rendered zone.\n     */\n    generateRenderData(eventRecord, resourceRecord, includeOutside = { viewport : true }) {\n        const\n            me               = this,\n            // generateRenderData calculates layout for events which are outside the vertical viewport\n            // because the RowManager needs to know a row height.\n            renderData       = me.currentOrientation.getTimeSpanRenderData(eventRecord, resourceRecord, includeOutside),\n            { isEvent }      = eventRecord,\n            { eventResize }  = me.features,\n            // Don't want events drag created to zero duration to render as milestones\n            isMilestone      = !eventRecord.meta.isDragCreating && eventRecord.isMilestone,\n            // $originalId allows lookup to yield same result for original resources and linked resources\n            assignmentRecord = isEvent && eventRecord.assignments.find(a => a.resourceId === resourceRecord.$originalId),\n            // Events inner element, will be populated by renderer and/or eventBodyTemplate\n            eventContent     = {\n                className : 'b-sch-event-content',\n                role      : 'presentation',\n                dataset   : {\n                    taskBarFeature : 'content'\n                }\n            };\n        // Events excluded by time axis filtering get no renderData\n        if (renderData) {\n            renderData.tabIndex = '0';\n            let resizable = eventRecord.isResizable;\n            if (eventResize && resizable) {\n                if (renderData.startsOutsideView) {\n                    if (resizable === true) {\n                        resizable = 'end';\n                    }\n                    else if (resizable === 'start') {\n                        resizable = false;\n                    }\n                }\n                if (renderData.endsOutsideView) {\n                    if (resizable === true) {\n                        resizable = 'start';\n                    }\n                    else if (resizable === 'end') {\n                        resizable = false;\n                    }\n                }\n                // Let the feature veto start/end handles\n                if (resizable) {\n                    if (me.isHorizontal) {\n                        if ((!me.rtl && !eventResize.leftHandle) || (me.rtl && !eventResize.rightHandle)) {\n                            resizable = resizable === 'start' ? false : 'end';\n                        }\n                        else if ((!me.rtl && !eventResize.rightHandle) || (me.rtl && !eventResize.leftHandle)) {\n                            resizable = resizable === 'end' ? false : 'start';\n                        }\n                    }\n                    else {\n                        if (!eventResize.topHandle) {\n                            resizable = resizable === 'start' ? false : 'end';\n                        }\n                        else if (!eventResize.bottomHandle) {\n                            resizable = resizable === 'end' ? false : 'start';\n                        }\n                    }\n                }\n            }\n            // Event record cls properties are now DomClassList instances, so clone them\n            // so that they can be manipulated here and by renderers.\n            // Truthy value means the key will be added as a class name.\n            // ResourceTimeRanges applies custom cls to wrapper.\n            const\n                // Boolean needed here, otherwise DomSync will dig into comparing the modifications\n                isDirty           = Boolean(\n                    eventRecord.hasPersistableChanges || assignmentRecord?.hasPersistableChanges\n                ),\n                clsListObj        = {\n                    [resourceRecord.cls]      : resourceRecord.cls,\n                    [me.generatedIdCls]       : !eventRecord.isOccurrence && eventRecord.hasGeneratedId,\n                    [me.dirtyCls]             : isDirty,\n                    [me.committingCls]        : eventRecord.isCommitting,\n                    [me.endsOutsideViewCls]   : renderData.endsOutsideView,\n                    [me.startsOutsideViewCls] : renderData.startsOutsideView,\n                    'b-clipped-start'         : renderData.clippedStart,\n                    'b-clipped-end'           : renderData.clippedEnd,\n                    'b-iscreating'            : eventRecord.isCreating,\n                    'b-rtl'                   : me.rtl\n                },\n                wrapperClsListObj = {\n                    [`${me.eventCls}-parent`] : resourceRecord.isParent,\n                    'b-readonly'              : eventRecord.readOnly || assignmentRecord?.readOnly,\n                    'b-linked-resource'       : resourceRecord.isLinked,\n                    'b-original-resource'     : resourceRecord.hasLinks\n                },\n                clsList           = eventRecord.isResourceTimeRange ? new DomClassList() : eventRecord.internalCls.clone(),\n                wrapperClsList    = eventRecord.isResourceTimeRange ? eventRecord.internalCls.clone() : new DomClassList();\n            renderData.wrapperStyle = '';\n            // mark as wrapper to make sure fire render events for this level only\n            renderData.isWrap = true;\n            // Event specifics, things that do not apply to ResourceTimeRanges\n            if (isEvent) {\n                const selected = assignmentRecord && me.isAssignmentSelected(assignmentRecord);\n                ObjectHelper.assign(clsListObj, {\n                    [me.eventCls]                          : 1,\n                    'b-milestone'                          : isMilestone,\n                    'b-sch-event-narrow'                   : !isMilestone && renderData.width < me.narrowEventWidth,\n                    [me.fixedEventCls]                     : eventRecord.isDraggable === false,\n                    [`b-sch-event-resizable-${resizable}`] : Boolean(eventResize && !eventRecord.readOnly),\n                    [me.eventSelectedCls]                  : selected,\n                    [me.eventAssignHighlightCls]           : me.eventAssignHighlightCls && !selected && me.isEventSelected(eventRecord),\n                    'b-recurring'                          : eventRecord.isRecurring,\n                    'b-occurrence'                         : eventRecord.isOccurrence,\n                    'b-inactive'                           : eventRecord.inactive\n                });\n                renderData.eventId  = eventRecord.id;\n                const\n                    eventStyle   = me.getEventStyle(eventRecord, resourceRecord),\n                    eventColor   = me.getEventColor(eventRecord, resourceRecord),\n                    hasAnimation = me.isFirstRender && me.useInitialAnimation && globalThis.bryntum.noAnimations !== true;\n                ObjectHelper.assign(wrapperClsListObj, {\n                    [`${me.eventCls}-wrap`] : 1,\n                    'b-milestone-wrap'      : isMilestone,\n                    [me.navigator.focusCls] : eventRecord.assignments.some(a => a === me.activeAssignment)\n                });\n                if (hasAnimation) {\n                    const\n                        index   = renderData.row ? renderData.row.index : (renderData.top - me.scrollTop) / me.tickSize,\n                        delayMS = index / 20 * 1000;\n                    renderData.wrapperStyle = `animation-delay: ${delayMS}ms;`;\n                    me.maxDelay = Math.max(me.maxDelay || 0, delayMS);\n                    // Add an extra delay to wait for the most delayed animation to finish\n                    // before we call stopInitialAnimation. In this way, we allow them all to finish\n                    // before we remove the b-initial-${me._useInitialAnimation} class.\n                    if (!me.initialAnimationDetacher) {\n                        me.initialAnimationDetacher = EventHelper.on({\n                            element  : me.foregroundCanvas,\n                            delegate : me.eventSelector,\n                            // Just listen for the first animation end fired by our event els\n                            once         : true,\n                            animationend : () => me.setTimeout({\n                                fn                : 'stopInitialAnimation',\n                                delay             : me.maxDelay,\n                                cancelOutstanding : true\n                            }),\n                            // Fallback in case animation is interrupted\n                            expires : {\n                                alt   : 'stopInitialAnimation',\n                                delay : me.initialAnimationDuration + me.maxDelay\n                            },\n                            thisObj : me\n                        });\n                    }\n                }\n                renderData.eventColor = eventColor;\n                renderData.eventStyle = eventStyle;\n                renderData.assignmentRecord = renderData.assignment = assignmentRecord;\n            }\n            // If not using a wrapping div, this cls will be added to event div for correct rendering\n            renderData.wrapperCls = ObjectHelper.assign(wrapperClsList, wrapperClsListObj);\n            renderData.cls = ObjectHelper.assign(clsList, clsListObj);\n            renderData.iconCls = new DomClassList(eventRecord.getValue(me.eventBarIconClsField) || eventRecord.iconCls);\n            // ResourceTimeRanges applies custom style to the wrapper\n            if (eventRecord.isResourceTimeRange) {\n                renderData.style = '';\n                renderData.wrapperStyle += eventRecord.style || '';\n            }\n            // Others to inner\n            else {\n                renderData.style = eventRecord.style || '';\n            }\n            renderData.resource = renderData.resourceRecord = resourceRecord;\n            renderData.resourceId = renderData.rowId;\n            if (isEvent) {\n                let childContent = null,\n                    milestoneLabelConfig = null,\n                    value;\n                if (me.eventRenderer) {\n                    // User has specified a renderer fn, either to return a simple string, or an object intended for the eventBodyTemplate\n                    const\n                        rendererValue = me.eventRenderer.call(me.eventRendererThisObj || me, {\n                            eventRecord,\n                            resourceRecord,\n                            assignmentRecord : renderData.assignmentRecord,\n                            renderData\n                        });\n                    // If the user's renderer coerced it into a string, recreate a DomClassList.\n                    if (typeof renderData.cls === 'string') {\n                        renderData.cls = new DomClassList(renderData.cls);\n                    }\n                    if (typeof renderData.wrapperCls === 'string') {\n                        renderData.wrapperCls = new DomClassList(renderData.wrapperCls);\n                    }\n                    // Same goes for iconCls\n                    if (typeof renderData.iconCls === 'string') {\n                        renderData.iconCls = new DomClassList(renderData.iconCls);\n                    }\n                    if (me.eventBodyTemplate) {\n                        value = me.eventBodyTemplate(rendererValue);\n                    }\n                    else {\n                        value = rendererValue;\n                    }\n                }\n                else if (me.eventBodyTemplate) {\n                    // User has specified an eventBodyTemplate, but no renderer - just apply the entire event record data.\n                    value = me.eventBodyTemplate(eventRecord);\n                }\n                else if (me.eventBarTextField) {\n                    // User has specified a field in the data model to read from\n                    value = StringHelper.encodeHtml(eventRecord.getValue(me.eventBarTextField) || '');\n                }\n                if (!me.eventBodyTemplate || Array.isArray(value)) {\n                    eventContent.children = [];\n                    // Give milestone a dedicated label element so we can use padding\n                    if (isMilestone && (me.milestoneLayoutMode === 'default' || me.milestoneTextPosition === 'always-outside') && value != null && value !== '') {\n                        eventContent.children.unshift(milestoneLabelConfig = {\n                            tag      : 'label',\n                            children : []\n                        });\n                    }\n                    if (renderData.iconCls?.length) {\n                        eventContent.children.unshift({\n                            tag       : 'i',\n                            className : renderData.iconCls\n                        });\n                    }\n                    // Array, assumed to contain DOM configs for eventContent children (or milestone label)\n                    if (Array.isArray(value)) {\n                        (milestoneLabelConfig || eventContent).children.push(...value);\n                    }\n                    // Likely HTML content\n                    else if (StringHelper.isHtml(value)) {\n                        if (eventContent.children.length) {\n                            childContent = {\n                                tag   : 'span',\n                                class : 'b-event-text-wrap',\n                                html  : value\n                            };\n                        }\n                        else {\n                            eventContent.children = null;\n                            eventContent.html = value;\n                        }\n                    }\n                    // DOM config or plain string can be used as is\n                    else if (typeof value === 'string' || typeof value === 'object') {\n                        childContent = value;\n                    }\n                    // Other, use string\n                    else if (value != null) {\n                        childContent = String(value);\n                    }\n                    // Must allow empty string as valid content\n                    if (childContent != null) {\n                        // Milestones have content in their label, other events in their \"body\"\n                        (milestoneLabelConfig || eventContent).children.push(childContent);\n                        renderData.cls.add('b-has-content');\n                    }\n                    if (eventContent.html != null || eventContent.children.length) {\n                        renderData.children.push(eventContent);\n                    }\n                }\n                else {\n                    eventContent.html = value;\n                    renderData.children.push(eventContent);\n                }\n            }\n            const { eventStyle, eventColor, wrapperCls } = renderData;\n            // Renderers have last say on style & color\n            wrapperCls[`b-sch-style-${eventStyle || 'none'}`] = 1;\n            // Named colors are applied as a class to the wrapper\n            if (DomHelper.isNamedColor(eventColor)) {\n                wrapperCls[`b-sch-color-${eventColor}`] = eventColor;\n            }\n            else if (eventColor) {\n                const\n                    colorProp = eventStyle ? 'color' : 'background-color',\n                    style     = `${colorProp}:${eventColor};`;\n                renderData.style = style + renderData.style;\n                wrapperCls['b-sch-custom-color'] = 1;\n                renderData._customColorStyle = style; // Saves the styling string to be able to remove it if needed\n            }\n            else {\n                wrapperCls[`b-sch-color-none`] = 1;\n            }\n            // Milestones has to apply styling to b-sch-event-content\n            if (renderData.style && isMilestone && eventContent) {\n                eventContent.style = renderData.style;\n                delete renderData.style;\n            }\n            // If there are any iconCls entries...\n            renderData.cls['b-sch-event-withicon'] = renderData.iconCls?.length;\n            // For comparison in sync, cheaper than comparing DocumentFragments\n            renderData.eventContent = eventContent;\n            renderData.wrapperChildren = [];\n            // Method which features may chain in to\n            me.onEventDataGenerated(renderData);\n        }\n        return renderData;\n    }\n    /**\n     * A method which may be chained by features. It is called when an event's render\n     * data is calculated so that features may update the style, class list or body.\n     * @param {Object} eventData\n     * @internal\n     */\n    onEventDataGenerated(eventData) {}\n    //endregion\n    //region Initial animation\n    changeUseInitialAnimation(name) {\n        return name === true ? 'fade-in' : name;\n    }\n    updateUseInitialAnimation(name, old) {\n        const { classList } = this.element;\n        if (old) {\n            classList.remove(`b-initial-${old}`);\n        }\n        if (name) {\n            classList.add(`b-initial-${name}`);\n            // Transition block for FF, to not interfere with animations\n            if (BrowserHelper.isFirefox) {\n                classList.add('b-prevent-event-transitions');\n            }\n        }\n    }\n    /**\n     * Restarts initial events animation with new value {@link #config-useInitialAnimation}.\n     * @param {Boolean|String} initialAnimation new initial animation value\n     * @category Misc\n     */\n    restartInitialAnimation(initialAnimation) {\n        const me = this;\n        me.initialAnimationDetacher?.();\n        me.initialAnimationDetacher = null;\n        me.useInitialAnimation = initialAnimation;\n        me.isFirstRender = true;\n        me.refresh();\n    }\n    stopInitialAnimation() {\n        const me = this;\n        me.initialAnimationDetacher();\n        me.isFirstRender = false;\n        // Prevent any further initial animations\n        me.useInitialAnimation = false;\n        // Remove transition block for FF a bit later, to not interfere with animations\n        if (BrowserHelper.isFirefox) {\n            me.setTimeout(() => me.element.classList.remove('b-prevent-event-transitions'), 100);\n        }\n    }\n    //endregion\n    //region Milestones\n    /**\n     * Determines width of a milestones label. How width is determined is decided by configuring\n     * {@link #config-milestoneLayoutMode}. Please note that text width is always determined using the events\n     * {@link Scheduler/model/EventModel#field-name}.\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @returns {Number}\n     * @category Milestones\n     */\n    getMilestoneLabelWidth(eventRecord, resourceRecord) {\n        const\n            me   = this,\n            mode = me.milestoneLayoutMode,\n            size = me.getResourceLayoutSettings(resourceRecord).contentHeight;\n        if (mode === 'measure') {\n            const\n                html    = StringHelper.encodeHtml(eventRecord.name),\n                color   = me.getEventColor(eventRecord, resourceRecord),\n                style   = me.getEventStyle(eventRecord, resourceRecord),\n                element = me.milestoneMeasureElement || (me.milestoneMeasureElement = DomHelper.createElement({\n                    className : {\n                        'b-sch-event-wrap'       : 1,\n                        'b-milestone-wrap'       : 1,\n                        'b-measure'              : 1,\n                        [`b-sch-color-${color}`] : color,\n                        [`b-sch-style-${style}`] : style\n                    },\n                    children : [\n                        {\n                            className : 'b-sch-event b-milestone',\n                            children  : [\n                                {\n                                    className : 'b-sch-event-content',\n                                    children  : [\n                                        { tag : 'label' }\n                                    ]\n                                }\n                            ]\n                        }\n                    ],\n                    parent : me.foregroundCanvas\n                }));\n            // DomSync should not touch\n            element.retainElement = true;\n            element.style.fontSize = `${size}px`;\n            if (me.milestoneTextPosition === 'always-outside') {\n                const label = element.firstElementChild.firstElementChild.firstElementChild;\n                label.innerHTML = html;\n                const bounds = Rectangle.from(label, label.parentElement);\n                // +2 for a little margin\n                return bounds.left + bounds.width + 2;\n            }\n            else {\n                // b-sch-event-content\n                element.firstElementChild.firstElementChild.innerHTML = `<label></label>${html}`;\n                return element.firstElementChild.offsetWidth;\n            }\n        }\n        if (mode === 'estimate') {\n            return eventRecord.name.length * me.milestoneCharWidth + (me.milestoneTextPosition === 'always-outside' ? size : 0);\n        }\n        if (mode === 'data') {\n            return eventRecord.milestoneWidth;\n        }\n        return 0;\n    }\n    updateMilestoneLayoutMode(mode) {\n        const\n            me            = this,\n            alwaysOutside = me.milestoneTextPosition === 'always-outside';\n        me.element.classList.toggle('b-sch-layout-milestones', mode !== 'default' && !alwaysOutside);\n        me.element.classList.toggle('b-sch-layout-milestone-labels', mode !== 'default' && alwaysOutside);\n        if (!me.isConfiguring) {\n            me.refreshWithTransition();\n        }\n    }\n    updateMilestoneTextPosition(position) {\n        this.element.classList.toggle('b-sch-layout-milestone-text-position-inside', position === 'inside');\n        this.updateMilestoneLayoutMode(this.milestoneLayoutMode);\n    }\n    updateMilestoneAlign() {\n        if (!this.isConfiguring) {\n            this.refreshWithTransition();\n        }\n    }\n    updateMilestoneCharWidth() {\n        if (!this.isConfiguring) {\n            this.refreshWithTransition();\n        }\n    }\n    // endregion\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport ProjectModel from '../../model/ProjectModel.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport TimeZoneHelper from '../../../Core/helper/TimeZoneHelper.js';\n/**\n * @module Scheduler/data/mixin/ProjectConsumer\n */\nconst engineStoreNames = [\n    'assignmentStore',\n    'dependencyStore',\n    'eventStore',\n    'resourceStore'\n];\n/**\n * Creates a Project using any configured stores, and sets the stores configured into the project into\n * the host object.\n *\n * @mixin\n */\nexport default Target => class ProjectConsumer extends (Target || Base) {\n    static get $name() {\n        return 'ProjectConsumer';\n    }\n    //region Default config\n    static get declarable() {\n        return ['projectStores'];\n    }\n    static get configurable() {\n        return {\n            projectModelClass : ProjectModel,\n            /**\n             * A {@link Scheduler.model.ProjectModel} instance or a config object. The project holds all Scheduler data.\n             * Can be omitted in favor of individual store configs or {@link Scheduler.view.mixin.SchedulerStores#config-crudManager} config.\n             *\n             * **Note:** In SchedulerPro the project is instance of SchedulerPro.model.ProjectModel class.\n             * @prp {Scheduler.model.ProjectModel|ProjectModelConfig} project\n             * @typings {ProjectModel|ProjectModelConfig}\n             * @category Data\n             */\n            project : {},\n            /**\n             * Configure as `true` to destroy the Project and stores when `this` is destroyed.\n             * @config {Boolean}\n             * @category Data\n             */\n            destroyStores : null,\n            // Will be populated by AttachToProjectMixin which features mix in\n            projectSubscribers : []\n        };\n    }\n    #suspendedByRestore;\n    //endregion\n    startConfigure(config) {\n        // process the project first which ingests any configured data sources,\n        this.getConfig('project');\n        super.startConfigure(config);\n    }\n    //region Project\n    // This is where all the ingestion happens.\n    // At config time, the changers inject incoming values into the project config object\n    // that we are building. At the end we instantiate the project with all incoming\n    // config values filled in.\n    changeProject(project, oldProject) {\n        const\n            me = this,\n            {\n                projectStoreNames,\n                projectDataNames\n            }  = me.constructor;\n        me.projectCallbacks = new Set();\n        if (project) {\n            // Flag for changes to know what stage we are at\n            me.buildingProjectConfig = true;\n            if (!project.isModel) {\n                // When configuring, prio order:\n                // 1. If using an already existing CrudManager, it is assumed to already have the stores we should use,\n                //    adopt them as ours.\n                // 2. If a supplied store already has a project, it is assumed to be shared with another scheduler and\n                //    that project is adopted as ours. Unless we are given some store not part of that project,\n                //    in which case we create a new project.\n                // 3. Use stores from a supplied project config.\n                // 4. Use stores configured on scheduler.\n                // + Pass on inline data (events, resources, dependencies, assignments -> xxData on the project config)\n                //\n                // What happens during project initialization is this:\n                // this._project is the project *config* object.\n                // changeXxxx methods put incoming values directly into it through this.project\n                // to be used as its configuration.\n                // So when it is instantiated, it has had all configs injected.\n                if (me.isConfiguring) {\n                    // Set property for changers to put incoming values into\n                    me._project = project;\n                    // crudManager will be a clone of the raw config if it is a raw config.\n                    const { crudManager } = me;\n                    // Pull in stores from the crudManager config first\n                    if (crudManager) {\n                        const { isCrudManager } = crudManager;\n                        for (const storeName of projectStoreNames) {\n                            if (crudManager[storeName]) {\n                                // We configure the project with the stores, and *not* the CrudManager.\n                                // The CrudManager ends up having its project set and thereby adopting ours.\n                                me[storeName] = crudManager[storeName];\n                                // If it's just a config, take the stores out.\n                                // We will *configure* it with this project and it will ingest\n                                // its stores from there.\n                                if (!isCrudManager) {\n                                    delete crudManager[storeName];\n                                }\n                            }\n                        }\n                    }\n                    // Pull in all our configured stores into the project config object.\n                    // That also extracts any project into this.sharedProject\n                    me.getConfig('projectStores');\n                    // Referencing these data configs causes them to be pulled into\n                    // the _project.xxxData config property if they are present.\n                    for (const dataName of projectDataNames) {\n                        me.getConfig(dataName);\n                    }\n                }\n                const { eventStore } = project;\n                let { sharedProject : sharedProject } = me;\n                // Delay autoLoading until listeners are set up, to be able to inject params\n                if (eventStore && !eventStore.isEventStoreMixin && eventStore.autoLoad && !eventStore.count) {\n                    eventStore.autoLoad = false;\n                    me.delayAutoLoad = true;\n                }\n                // We should not adopt a project from a store if we are given any store not part of that project\n                if (sharedProject && engineStoreNames.some(store => project[store] && project[store] !== sharedProject[store])) {\n                    // We have to chain any store used by the other project, they can only belong to one\n                    for (const store of engineStoreNames) {\n                        if (project[store] && project[store] === sharedProject[store]) {\n                            project[store] = project[store].chain();\n                        }\n                    }\n                    sharedProject = null;\n                }\n                // Use sharedProject if found, else instantiate our config.\n                project = sharedProject || new me.projectModelClass(project);\n                // Clear the property so that the updater is called.\n                delete me._project;\n            }\n            // In the updater, configs are live\n            me.buildingProjectConfig = false;\n        }\n        return project;\n    }\n    /**\n     * Implement in subclass to take action when project is replaced.\n     *\n     * __`super.updateProject(...arguments)` must be called first.__\n     *\n     * @param {Scheduler.model.ProjectModel} project\n     * @category Data\n     */\n    updateProject(project, oldProject) {\n        const\n            me = this,\n            {\n                projectListeners,\n                crudManager\n            }  = me;\n        me.detachListeners('projectConsumer');\n        // When we set the crudManager now, it will go through to the CrudManagerVIew\n        delete me._crudManager;\n        if (project) {\n            projectListeners.thisObj = me;\n            project.ion(projectListeners);\n            // If the project is a CrudManager, use it as such.\n            if (project.isCrudManager) {\n                me.crudManager = project;\n            }\n            // Apply the project to CrudManager, making sure the same stores are used there and here\n            else if (crudManager) {\n                crudManager.project = project;\n                // CrudManager goes through the changer as usual and is initialized\n                // from the Project, not any stores it was originally configured with.\n                me.crudManager = crudManager;\n            }\n            // Notifies classes that mix AttachToProjectMixin that we have a new project\n            me.projectSubscribers.forEach(subscriber => {\n                subscriber.detachFromProject(oldProject);\n                subscriber.attachToProject(project);\n            });\n            // Sets the project's stores into the host object\n            for (const storeName of me.constructor.projectStoreNames) {\n                me[storeName] = project[storeName];\n            }\n            // Listeners are set up, if EventStore was configured with autoLoad now is the time to load\n            if (me.delayAutoLoad) {\n                // Restore the flag, not needed but to look good on inspection\n                project.eventStore.autoLoad = true;\n                project.eventStore.load();\n            }\n            project.stm?.ion({\n                name           : 'projectConsumer',\n                restoringStart : 'onProjectRestoringStart',\n                restoringStop  : 'onProjectRestoringStop',\n                thisObj        : me\n            });\n        }\n        me.trigger('projectChange', { project });\n    }\n    // Implementation here because we need to get first look at it to adopt its stores\n    changeCrudManager(crudManager) {\n        // Set the property to be scanned for incoming stores.\n        // If it's a config, it will be stripped of those stores prior to construction.\n        if (this.buildingProjectConfig) {\n            this._crudManager = crudManager.isCrudManager ? crudManager : Object.assign({}, crudManager);\n        }\n        else {\n            return super.changeCrudManager(crudManager);\n        }\n    }\n    // Called when project changes are committed, after data is written back to records\n    onProjectDataReady() {\n        const me = this;\n        // Only update the UI when we are visible\n        me.whenVisible(() => {\n            if (me.projectCallbacks.size) {\n                me.projectCallbacks.forEach(callback => callback());\n                me.projectCallbacks.clear();\n            }\n        }, null, null, 'onProjectDataReady');\n    }\n    onProjectRestoringStart({ stm }) {\n        const { rawQueue } = stm;\n        // Suspend refresh if undo/redo potentially leads to multiple refreshes\n        if (rawQueue.length && rawQueue[rawQueue.length - 1].length > 1) {\n            this.#suspendedByRestore = true;\n            this.suspendRefresh();\n        }\n    }\n    onProjectRestoringStop() {\n        if (this.#suspendedByRestore) {\n            this.#suspendedByRestore = false;\n            this.resumeRefresh(true);\n        }\n    }\n    // Overridden in CalendarStores.js\n    onBeforeTimeZoneChange() {}\n    // When project changes time zone, change start and end dates\n    onTimeZoneChange({ timeZone, oldTimeZone }) {\n        const me = this;\n        // The timeAxis timeZone could be equal to timeZone if we are a partnered scheduler\n        if (me.startDate && me.timeAxis.timeZone !== timeZone) {\n            const startDate = oldTimeZone != null ? TimeZoneHelper.fromTimeZone(me.startDate, oldTimeZone) : me.startDate;\n            me.startDate = timeZone != null ? TimeZoneHelper.toTimeZone(startDate, timeZone) : startDate;\n            // Saves the timeZone on the timeAxis as it is shared between partnered schedulers\n            me.timeAxis.timeZone = timeZone;\n        }\n    }\n    onStartApplyChangeset() {\n        this.suspendRefresh();\n    }\n    onEndApplyChangeset() {\n        this.resumeRefresh(true);\n    }\n    /**\n     * Accepts a callback that will be called when the underlying project is ready (no commit pending and current commit\n     * finalized)\n     * @param {Function} callback\n     * @category Data\n     */\n    whenProjectReady(callback) {\n        // Might already be ready, call directly\n        if (this.isEngineReady) {\n            callback();\n        }\n        else {\n            this.projectCallbacks.add(callback);\n        }\n    }\n    /**\n     * Returns `true` if engine is in a stable calculated state, `false` otherwise.\n     * @property {Boolean}\n     * @category Misc\n     */\n    get isEngineReady() {\n        // NonWorkingTime calls this during destruction, hence the ?.\n        return Boolean(this.project.isEngineReady?.());\n    }\n    //endregion\n    //region Destroy\n    // Cleanup, destroys stores if this.destroyStores is true.\n    doDestroy() {\n        super.doDestroy();\n        if (this.destroyStores) {\n            // Shared project might already be destroyed\n            !this.project.isDestroyed && this.project.destroy();\n        }\n    }\n    //endregion\n    get projectStores() {\n        const { projectStoreNames } = this.constructor;\n        return projectStoreNames.map(storeName => this[storeName]);\n    }\n    static get projectStoreNames() {\n        return Object.keys(this.projectStores);\n    }\n    static get projectDataNames() {\n        return this.projectStoreNames.reduce((result, storeName) => {\n            const { dataName } = this.projectStores[storeName];\n            if (dataName) {\n                result.push(dataName);\n            }\n            return result;\n        }, []);\n    }\n    static setupProjectStores(cls, meta) {\n        const { projectStores } = cls;\n        if (projectStores) {\n            const\n                projectListeners  = {\n                    name                 : 'projectConsumer',\n                    dataReady            : 'onProjectDataReady',\n                    change               : 'relayProjectDataChange',\n                    beforeTimeZoneChange : 'onBeforeTimeZoneChange',\n                    timeZoneChange       : 'onTimeZoneChange',\n                    startApplyChangeset  : 'onStartApplyChangeset',\n                    endApplyChangeset    : 'onEndApplyChangeset'\n                },\n                storeConfigs      = {\n                    projectListeners\n                };\n            let previousDataName;\n            // Create a property and updater for each dataName and a changer for each store\n            for (const storeName in projectStores) {\n                const { dataName } = projectStores[storeName];\n                // Define \"eventStore\" and \"events\" configs\n                storeConfigs[storeName] = storeConfigs[dataName] = null;\n                // Define up the \"events\" property\n                if (dataName) {\n                    // Getter to return store data\n                    Object.defineProperty(meta.class.prototype, dataName, {\n                        configurable : true, // So that Config can add its setter.\n                        get() {\n                            // get events() { return this.project.eventStore.records; }\n                            return this.project[storeName]?.records;\n                        }\n                    });\n                    // Create an updater for the data name;\n                    this.createDataUpdater(storeName, dataName, previousDataName, meta);\n                }\n                this.createStoreDescriptor(meta, storeName, projectStores[storeName], projectListeners);\n                // The next data updater must reference this data name\n                previousDataName = dataName;\n            }\n            // Create the projectListeners config.\n            this.setupConfigs(meta, storeConfigs);\n        }\n    }\n    static createDataUpdater(storeName, dataName, previousDataName, meta) {\n        // Create eg \"updateEvents(data)\".\n        // We need it to call this.getConfig('resources') so that ordering of\n        // data ingestion is corrected.\n        meta.class.prototype[`update${StringHelper.capitalize(dataName)}`] = function(data) {\n            const { project } = this;\n            // Ensure a dataName that we depend on is called in.\n            // For example dependencies must load in order after the events.\n            previousDataName && this.getConfig(previousDataName);\n            if (this.buildingProjectConfig) {\n                // Set the property in the project config object.\n                // eg project.eventsData = [...]\n                project[`${dataName}Data`] = data;\n            }\n            else {\n                // Live update the project when in use.\n                project[storeName].data = data;\n            }\n        };\n    }\n    // eslint-disable-next-line bryntum/no-listeners-in-lib\n    static createStoreDescriptor(meta, storeName, { listeners }, projectListeners) {\n        const\n            { prototype : clsProto } = meta.class,\n            storeNameCap             = StringHelper.capitalize(storeName);\n        // Set up onProjectEventStoreChange to set this.eventStore\n        projectListeners[`${storeName}Change`] = function({ store }) {\n            this[storeName] = store;\n        };\n        // create changeEventStore\n        clsProto[`change${storeNameCap}`] = function(store, oldStore) {\n            const\n                me           = this,\n                { project }  = me,\n                storeProject = store?.project;\n            if (me.buildingProjectConfig) {\n                // Capture any project found at project config time\n                // to use as our shared project\n                if (storeProject?.isProjectModel) {\n                    me.sharedProject = storeProject;\n                }\n                // Set the property in the project config object.\n                // Must not go through the updater. It's too early to\n                // inform host of store change.\n                project[storeName] = store;\n                return;\n            }\n            // Live update the project when in use.\n            if (!me.initializingProject) {\n                if (project[storeName] !== store) {\n                    project[`set${storeNameCap}`](store);\n                    store = project[storeName];\n                }\n            }\n            // Implement processing here instead of creating a separate updater.\n            // Subclasses can implement updaters.\n            if (store !== oldStore) {\n                if (listeners) {\n                    listeners.thisObj = me;\n                    listeners.name = `${storeName}Listeners`;\n                    // Ensure we don't trigger one refresh per record during data loading\n                    listeners.startApplyChangeset = 'onProjectStoreStartApplyChangeset';\n                    listeners.endApplyChangeset = 'onProjectStoreEndApplyChangeset';\n                    me.detachListeners(listeners.name);\n                    store.ion(listeners);\n                }\n                // Set backing var temporarily, so it can be accessed from AttachToProjectMixin subscribers\n                me[`_${storeName}`] = store;\n                // Notifies classes that mix AttachToProjectMixin that we have a new XxxxxStore\n                me.projectSubscribers.forEach(subscriber => {\n                    subscriber[`attachTo${storeNameCap}`]?.(store);\n                });\n                me[`_${storeName}`] = null;\n            }\n            return store;\n        };\n    }\n    onProjectStoreStartApplyChangeset() {\n        this.suspendRefresh();\n    }\n    onProjectStoreEndApplyChangeset() {\n        this.resumeRefresh(true);\n    }\n    relayProjectDataChange(event) {\n        // Don't trigger change event for tree node collapse/expand\n        if ((event.isExpand || event.isCollapse) && !event.records[0].fieldMap.expanded.persist) {\n            return;\n        }\n        /**\n         * Fired when data in any of the projects stores changes.\n         *\n         * Basically a relayed version of each store's own change event, decorated with which store it originates from.\n         * See the {@link Core.data.Store#event-change store change event} documentation for more information.\n         *\n         * @event dataChange\n         * @param {Scheduler.data.mixin.ProjectConsumer} source Owning component\n         * @typings source -> {typeof Scheduler.data.mixin.ProjectConsumer||any}\n         * @param {Scheduler.model.mixin.ProjectModelMixin} project Project model\n         * @typings project -> {typeof Scheduler.model.mixin.ProjectModelMixin||any}\n         * @param {Core.data.Store} store Affected store\n         * @param {'remove'|'removeAll'|'add'|'updatemultiple'|'clearchanges'|'filter'|'update'|'dataset'|'replace'} action\n         * Name of action which triggered the change. May be one of:\n         * * `'remove'`\n         * * `'removeAll'`\n         * * `'add'`\n         * * `'updatemultiple'`\n         * * `'clearchanges'`\n         * * `'filter'`\n         * * `'update'`\n         * * `'dataset'`\n         * * `'replace'`\n         * @param {Core.data.Model} record Changed record, for actions that affects exactly one record (`'update'`)\n         * @param {Core.data.Model[]} records Changed records, passed for all actions except `'removeAll'`\n         * @param {Object} changes Passed for the `'update'` action, info on which record fields changed\n         */\n        return this.trigger('dataChange', { project : event.source, ...event, source : this });\n    }\n    //region WidgetClass\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n    //endregion\n};\n", "import Base from '../../../Core/Base.js';\nimport Store from '../../../Core/data/Store.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport VersionHelper from '../../../Core/helper/VersionHelper.js';\nimport ProjectConsumer from '../../data/mixin/ProjectConsumer.js';\n/**\n * @module Scheduler/view/mixin/SchedulerStores\n */\n/**\n * Functions for store assignment and store event listeners.\n *\n * @mixin\n * @extends Scheduler/data/mixin/ProjectConsumer\n */\nexport default Target => class SchedulerStores extends ProjectConsumer(Target || Base) {\n    static get $name() {\n        return 'SchedulerStores';\n    }\n    //region Default config\n    // This is the static definition of the Stores we consume from the project, and\n    // which we must provide *TO* the project if we or our CrudManager is configured\n    // with them.\n    // The property name is the store name, and within that there is the dataName which\n    // is the property which provides static data definition. And there is a listeners\n    // definition which specifies the listeners *on this object* for each store.\n    //\n    // To process incoming stores, implement an updateXxxxxStore method such\n    // as `updateEventStore(eventStore)`.\n    //\n    // To process an incoming Project implement `updateProject`. __Note that\n    // `super.updateProject(...arguments)` must be called first.__\n    static get projectStores() {\n        return {\n            resourceStore : {\n                dataName : 'resources'\n            },\n            eventStore : {\n                dataName  : 'events',\n                // eslint-disable-next-line bryntum/no-listeners-in-lib\n                listeners : {\n                    batchedUpdate   : 'onEventStoreBatchedUpdate',\n                    changePreCommit : 'onInternalEventStoreChange',\n                    commitStart     : 'onEventCommitStart',\n                    commit          : 'onEventCommit',\n                    exception       : 'onEventException',\n                    idchange        : 'onEventIdChange',\n                    beforeLoad      : 'onBeforeLoad'\n                }\n            },\n            assignmentStore : {\n                dataName  : 'assignments',\n                // eslint-disable-next-line bryntum/no-listeners-in-lib\n                listeners : {\n                    changePreCommit : 'onAssignmentChange', // In EventSelection.js\n                    commitStart     : 'onAssignmentCommitStart',\n                    commit          : 'onAssignmentCommit',\n                    exception       : 'onAssignmentException',\n                    beforeRemove    : {\n                        fn   : 'onAssignmentBeforeRemove',\n                        // We must go last in case an app vetoes a remove\n                        // by returning false from a handler.\n                        prio : -1000\n                    }\n                }\n            },\n            dependencyStore : {\n                dataName : 'dependencies'\n            },\n            calendarManagerStore   : {},\n            timeRangeStore         : {},\n            resourceTimeRangeStore : {}\n        };\n    }\n    static get configurable() {\n        return {\n            /**\n             * Overridden to *not* auto create a store at the Scheduler level.\n             * The store is the {@link Scheduler.data.ResourceStore} of the backing project\n             * @config {Core.data.Store}\n             * @private\n             */\n            store : null,\n            /**\n             * The name of the start date parameter that will be passed to in every `eventStore` load request.\n             * @config {String}\n             * @category Data\n             */\n            startParamName : 'startDate',\n            /**\n             * The name of the end date parameter that will be passed to in every `eventStore` load request.\n             * @config {String}\n             * @category Data\n             */\n            endParamName : 'endDate',\n            /**\n             * Set to true to include `startDate` and `endDate` params indicating the currently viewed date range.\n             * Dates are formatted using the same format as the `startDate` field on the EventModel\n             * (e.g. 2023-03-08T00:00:00+01:00).\n             *\n             * Enabled by default in version 6.0 and above.\n             *\n             * @config {Boolean}\n             */\n            passStartEndParameters : VersionHelper.checkVersion('core', '6.0', '>='),\n            /**\n             * Class that should be used to instantiate a CrudManager in case it's provided as a simple object to\n             * {@link #config-crudManager} config.\n             * @config {Scheduler.data.CrudManager}\n             * @typings {typeof CrudManager}\n             * @category Data\n             */\n            crudManagerClass : null,\n            /**\n             * Get/set the CrudManager instance\n             * @member {Scheduler.data.CrudManager} crudManager\n             * @category Data\n             */\n            /**\n             * Supply a {@link Scheduler.data.CrudManager} instance or a config object if you want to use\n             * CrudManager for handling data.\n             * @config {CrudManagerConfig|Scheduler.data.CrudManager}\n             * @category Data\n             */\n            crudManager : null\n        };\n    }\n    //endregion\n    //region Project\n    updateProject(project, oldProject) {\n        super.updateProject(project, oldProject);\n        this.detachListeners('schedulerStores');\n        project.ion({\n            name    : 'schedulerStores',\n            refresh : 'onProjectRefresh',\n            thisObj : this\n        });\n    }\n    // Called when project changes are committed, before data is written back to records (but still ready to render\n    // since data is fetched from engine)\n    onProjectRefresh({ isInitialCommit }) {\n        const me = this;\n        // Only update the UI immediately if we are visible\n        if (me.isVisible) {\n            if (isInitialCommit) {\n                if (me.isVertical) {\n                    me.refreshAfterProjectRefresh = false;\n                    me.refreshWithTransition();\n                }\n            }\n            if (me.refreshAfterProjectRefresh) {\n                me.refreshWithTransition(false, !isInitialCommit);\n                me.refreshAfterProjectRefresh = false;\n            }\n            if (me.navigateToAfterRefresh) {\n                me.navigateTo(me.navigateToAfterRefresh, {\n                    scrollIntoView : false\n                });\n                me.navigateToAfterRefresh = null;\n            }\n        }\n        // Otherwise wait till next time we get painted (shown, or a hidden ancestor shown)\n        else {\n            me.whenVisible('refresh', me, [true]);\n        }\n    }\n    //endregion\n    //region CrudManager\n    changeCrudManager(crudManager) {\n        const me = this;\n        if (crudManager && !crudManager.isCrudManager) {\n            // CrudManager injects itself into is Scheduler's _crudManager property\n            // because code it triggers needs to access it through its getter.\n            crudManager = me.crudManagerClass.new({\n                scheduler : me\n            }, crudManager);\n        }\n        // config setter will veto because of above described behaviour\n        // of setting the property early on creation\n        me._crudManager = crudManager;\n        me.bindCrudManager(crudManager);\n    }\n    //endregion\n    //region Row store\n    get store() {\n        // Vertical uses a dummy store\n        if (!this._store && this.isVertical) {\n            this._store = new Store({\n                data : [\n                    {\n                        id  : 'verticalTimeAxisRow', \n                        cls : 'b-verticaltimeaxis-row'\n                    }\n                ]\n            });\n        }\n        return super.store;\n    }\n    set store(store) {\n        super.store = store;\n    }\n    // Wrap w/ transition refreshFromRowOnStoreAdd() inherited from Grid\n    refreshFromRowOnStoreAdd(row, { isExpand, records }) {\n        const args = arguments;\n        this.runWithTransition(() => {\n            // Postpone drawing of events for a new resource until the following project refresh. Previously the draw\n            // would not happen because engine was not ready, but now when we allow commits and can read values during\n            // commit that block is no longer there\n            this.currentOrientation.suspended = !isExpand && !records.some(r => r.isLinked);\n            super.refreshFromRowOnStoreAdd(row, ...args);\n            this.currentOrientation.suspended = false;\n        }, !isExpand);\n    }\n    onStoreAdd(event) {\n        super.onStoreAdd(event);\n        if (this.isPainted) {\n            this.calculateRowHeights(event.records);\n        }\n    }\n    onStoreUpdateRecord({ source : store, record, changes }) {\n        // Ignore engine changes that do not affect row rendering\n        let ignoreCount = 0;\n        if ('assigned' in changes) {\n            ignoreCount++;\n        }\n        if ('calendar' in changes) {\n            ignoreCount++;\n        }\n        if (ignoreCount !== Object.keys(changes).length) {\n            super.onStoreUpdateRecord(...arguments);\n        }\n    }\n    //endregion\n    //region ResourceStore\n    updateResourceStore(resourceStore) {\n        // Reconfigure grid if resourceStore is backing the rows\n        if (resourceStore && this.isHorizontal) {\n            resourceStore.metaMapId = this.id;\n            this.store = resourceStore;\n        }\n    }\n    get usesDisplayStore() {\n        return this.store !== this.resourceStore;\n    }\n    //endregion\n    //region Events\n    onEventIdChange(params) {\n        this.currentOrientation.onEventStoreIdChange && this.currentOrientation.onEventStoreIdChange(params);\n    }\n    /**\n     * Listener to the batchedUpdate event which fires when a field is changed on a record which\n     * is batch updating. Occasionally UIs must keep in sync with batched changes.\n     * For example, the EventResize feature performs batched updating of the startDate/endDate\n     * and it tells its client to listen to batchedUpdate.\n     * @private\n     */\n    onEventStoreBatchedUpdate(event) {\n        if (this.listenToBatchedUpdates) {\n            return this.onInternalEventStoreChange(event);\n        }\n    }\n    /**\n     * Calls appropriate functions for current event layout when the event store is modified.\n     * @private\n     */\n    // Named as Internal to avoid naming collision with wrappers that relay events\n    onInternalEventStoreChange(params) {\n        // Too early, bail out\n        // Also bail out if this is a reassign using resourceId, any updates will be handled by AssignmentStore instead\n        if (!this.isPainted || !this._mode || params.isAssign || this.assignmentStore.isRemovingAssignment) {\n            return;\n        }\n        // Only respond if we are visible. If not, defer until we are shown\n        if (this.isVisible) {\n            this.currentOrientation.onEventStoreChange(params);\n        }\n        else {\n            this.whenVisible(this.onInternalEventStoreChange, this, [params]);\n        }\n    }\n    /**\n     * Refreshes committed events, to remove dirty/committing flag.\n     * CSS is added\n     * @private\n     */\n    onEventCommit({ changes }) {\n        let resourcesToRepaint = [...changes.added, ...changes.modified].map(\n            eventRecord => this.eventStore.getResourcesForEvent(eventRecord)\n        );\n        // getResourcesForEvent returns an array, so need to flatten resourcesToRepaint\n        resourcesToRepaint = Array.prototype.concat.apply([], resourcesToRepaint);\n        // repaint relevant resource rows\n        new Set(resourcesToRepaint).forEach(\n            resourceRecord => this.repaintEventsForResource(resourceRecord)\n        );\n    }\n    /**\n     * Adds the committing flag to changed events before commit.\n     * @private\n     */\n    onEventCommitStart({ changes }) {\n        const { currentOrientation, committingCls } = this;\n        // Committing sets a flag in meta that during event rendering applies a CSS class. But to not mess up drag and\n        // drop between resources no redraw is performed before committing, so class is never applied to the element(s).\n        // Applying here instead\n        [...changes.added, ...changes.modified].forEach(eventRecord =>\n            eventRecord.assignments.forEach(\n                assignmentRecord => currentOrientation.toggleCls(assignmentRecord, committingCls, true)\n            )\n        );\n    }\n    // Clear committing flag\n    onEventException({ action }) {\n        if (action === 'commit') {\n            const { changes } = this.eventStore;\n            [...changes.added, ...changes.modified, ...changes.removed].forEach(eventRecord =>\n                this.repaintEvent(eventRecord)\n            );\n        }\n    }\n    onAssignmentCommit({ changes }) {\n        this.repaintEventsForAssignmentChanges(changes);\n    }\n    onAssignmentCommitStart({ changes }) {\n        const { currentOrientation, committingCls } = this;\n        [...changes.added, ...changes.modified].forEach(assignmentRecord => {\n            currentOrientation.toggleCls(assignmentRecord, committingCls, true);\n        });\n    }\n    // Clear committing flag\n    onAssignmentException({ action }) {\n        if (action === 'commit') {\n            this.repaintEventsForAssignmentChanges(this.assignmentStore.changes);\n        }\n    }\n    repaintEventsForAssignmentChanges(changes) {\n        const resourcesToRepaint = [...changes.added, ...changes.modified, ...changes.removed].map(\n            assignmentRecord => assignmentRecord.getResource()\n        );\n        // repaint relevant resource rows\n        new Set(resourcesToRepaint).forEach(\n            resourceRecord => this.repaintEventsForResource(resourceRecord)\n        );\n    }\n    onAssignmentBeforeRemove({ records, removingAll }) {\n        if (removingAll) {\n            return;\n        }\n        const\n            me                       = this,\n            { activeAssignment }     = me,\n            deletingActiveAssignment = records.includes(activeAssignment);\n        let moveTo;\n        // Deassigning the active assignment\n        if (!me.isConfiguring &&\n            // If we have current active assignment or we scheduled navigating to an assignment, we should check\n            // if we're removing that assignment in order to avoid navigating to it\n            (me.navigateToAfterRefresh || activeAssignment && deletingActiveAssignment)\n        ) {\n            // If next navigation target is removed, clean up the flag\n            if (records.includes(me.navigateToAfterRefresh)) {\n                me.navigateToAfterRefresh = null;\n            }\n            const fromEl = me.getElementFromAssignmentRecord(activeAssignment, true);\n            // When deleting active assignment, if still part of this scheduler (when dragging to another, it might not\n            // be in Safari where focus out happens later), look for a close target until we find an existing record,\n            // not scheduled for removal and in view. Otherwise, push focus to the Scheduler.\n            if (deletingActiveAssignment && fromEl) {\n                const\n                    viewport     = me.timeAxisSubGrid.rectangle().intersect(me._bodyRectangle),\n                    fromRect     = Rectangle.from(fromEl),\n                    fromCenter   = fromRect.center,\n                    resourceDim  = me.isHorizontal ? 'y' : 'x',\n                    distanceSort = ({ element : e1, distance : d1, center : c1, edgeDistance : ed1 }, { element : e2, distance : d2, center : c2, edgeDistance : ed2 }) => {\n                        // Sort blocks which are closer in the Y axis to earlier\n                        // Unless we're in the same row, in which case use only distance.\n                        if (e1.dataset.resourceId !== e2.dataset.resourceId) {\n                            if (Math.abs(c1[resourceDim] - fromCenter[resourceDim]) < Math.abs(c2[resourceDim] - fromCenter[resourceDim])) {\n                                return -1;\n                            }\n                            if (Math.abs(c1[resourceDim] - fromCenter[resourceDim]) > Math.abs(c2[resourceDim] - fromCenter[resourceDim])) {\n                                return 1;\n                            }\n                        }\n                        return Math.min(ed1, d1) - Math.min(ed2, d2) || c2[resourceDim] - c1[resourceDim];\n                    },\n                    to = Array.from(me.foregroundCanvas.querySelectorAll(me.navigator.itemSelector)).reduce((result, element) => {\n                        // Don't consider the from element\n                        if (element !== fromEl) {\n                            const\n                                rectangle  = Rectangle.from(element).intersect(viewport),\n                                assignment = rectangle && me.resolveAssignmentRecord(element);\n                            // If there's an intersection with the viewport, add to candidate array\n                            if (assignment) {\n                                const\n                                    { center } = rectangle,\n                                    d          = fromCenter.getDelta(center),\n                                    vertGap    = center.y < fromCenter.y ? fromRect.y - rectangle.bottom : center.y > fromCenter.y ? rectangle.y - fromRect.bottom : 0,\n                                    horizGap   = center.x < fromCenter.x ? fromRect.x - rectangle.right  : center.x > fromCenter.x ? rectangle.x - fromRect.right  : 0;\n                                result.push({\n                                    element,\n                                    assignment,\n                                    center,\n                                    distance     : Math.sqrt(d[0] ** 2 + d[1] ** 2),\n                                    edgeDistance : Math.max(\n                                        vertGap, horizGap\n                                    )\n                                });\n                            }\n                        }\n                        return result;\n                    }, []).sort(distanceSort)[0];\n                if (to) {\n                    moveTo  = to.assignment;\n                }\n            }\n            // Move focus away from the element which will soon have no backing data.\n            // Only if a UI element for it is in view.\n            if (moveTo) {\n                // Although removing records from assignment store will trigger project commit and consequently\n                // `refresh` event on the project which will use this record to navigate to, some tests expect\n                // immediate navigation\n                me.navigateTo(moveTo, {\n                    scrollIntoView : false\n                });\n                me.navigateToAfterRefresh = moveTo;\n            }\n            // Focus must exit the Scheduler's subgrid, otherwise, if a navigation\n            // key gesture is delivered before the outgoing event's element has faded\n            // out and been removed, navigation will be attempted from a deleted\n            // event. Animated hiding is problematic.\n            //\n            // We cannot just revertFocus() because that might move focus back to an\n            // element in a floating EventEditor which is not yet faded out and\n            // been removed. Animated hiding is problematic.\n            //\n            // We cannot focus scheduler.timeAxisColumn.element because the browser\n            // would scroll it in some way if we have horizontal overflow.\n            //\n            // The only thing we can know about to focus here is the Scheduler itself.\n            else {\n                DomHelper.focusWithoutScrolling(me.focusElement);\n            }\n        }\n    }\n    //endregion\n    //region TimeRangeStore & TimeRanges\n    /**\n     * Inline time ranges, will be loaded into an internally created store if {@link Scheduler.feature.TimeRanges}\n     * is enabled.\n     * @config {Scheduler.model.TimeSpan[]|TimeSpanConfig[]} timeRanges\n     * @category Data\n     */\n    /**\n     * Get/set time ranges, applies to the backing project's TimeRangeStore.\n     * @member {Scheduler.model.TimeSpan[]} timeRanges\n     * @accepts {Scheduler.model.TimeSpan[]|TimeSpanConfig[]}\n     * @category Data\n     */\n    /**\n     * Get/set the time ranges store instance or config object for {@link Scheduler.feature.TimeRanges} feature.\n     * @member {Core.data.Store} timeRangeStore\n     * @accepts {Core.data.Store|StoreConfig}\n     * @category Data\n     */\n    /**\n     * The time ranges store instance for {@link Scheduler.feature.TimeRanges} feature.\n     * @config {Core.data.Store|StoreConfig} timeRangeStore\n     * @category Data\n     */\n    set timeRanges(timeRanges) {\n        this.project.timeRanges = timeRanges;\n    }\n    get timeRanges() {\n        return this.project.timeRanges;\n    }\n    //endregion\n    //region ResourceTimeRangeStore\n    /**\n     * Inline resource time ranges, will be loaded into an internally created store if\n     * {@link Scheduler.feature.ResourceTimeRanges} is enabled.\n     * @prp {Scheduler.model.ResourceTimeRangeModel[]} resourceTimeRanges\n     * @accepts {Scheduler.model.ResourceTimeRangeModel[]|ResourceTimeRangeModelConfig[]}\n     * @category Data\n     */\n    /**\n     * Get/set the resource time ranges store instance for {@link Scheduler.feature.ResourceTimeRanges} feature.\n     * @member {Scheduler.data.ResourceTimeRangeStore} resourceTimeRangeStore\n     * @accepts {Scheduler.data.ResourceTimeRangeStore|ResourceTimeRangeStoreConfig}\n     * @category Data\n     */\n    /**\n     * Resource time ranges store instance or config object for {@link Scheduler.feature.ResourceTimeRanges} feature.\n     * @config {Scheduler.data.ResourceTimeRangeStore|ResourceTimeRangeStoreConfig} resourceTimeRangeStore\n     * @category Data\n     */\n    set resourceTimeRanges(resourceTimeRanges) {\n        this.project.resourceTimeRanges = resourceTimeRanges;\n    }\n    get resourceTimeRanges() {\n        return this.project.resourceTimeRanges;\n    }\n    //endregion\n    //region Other functions\n    onBeforeLoad({ params }) {\n        this.applyStartEndParameters(params);\n    }\n    /**\n     * Get events grouped by timeAxis ticks from resources array\n     * @category Data\n     * @param {Scheduler.model.ResourceModel[]} resources An array of resources to process. If not passed, all resources\n     * will be used.\n     * @param {Function} filterFn filter function to filter events if required. Optional.\n     * @private\n     */\n    getResourcesEventsPerTick(resources, filterFn) {\n        const\n            { timeAxis, resourceStore } = this,\n            eventsByTick                = [];\n        resources = resources || resourceStore.records;\n        resources.forEach(resource => {\n            resource.events.forEach(event => {\n                if (!timeAxis.isTimeSpanInAxis(event) || (filterFn && !filterFn.call(this, { resource, event }))) {\n                    return;\n                }\n                // getTickFromDate may return float if event starts/ends in a middle of a tick\n                let startTick = Math.floor(timeAxis.getTickFromDate(event.startDate)),\n                    endTick = Math.ceil(timeAxis.getTickFromDate(event.endDate));\n                // if startDate/endDate of the event is out of timeAxis' bounds, use first/last tick id instead\n                if (startTick == -1) {\n                    startTick = 0;\n                }\n                if (endTick === -1) {\n                    endTick = timeAxis.ticks.length;\n                }\n                do {\n                    if (!eventsByTick[startTick]) {\n                        eventsByTick[startTick] = [event];\n                    }\n                    else {\n                        eventsByTick[startTick].push(event);\n                    }\n                } while (++startTick < endTick);\n            });\n        });\n        return eventsByTick;\n    }\n    //endregion\n    //region WidgetClass\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n    //endregion\n};\n", "import Base from '../../../Core/Base.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport AsyncHelper from '../../../Core/helper/AsyncHelper.js';\n/**\n * @module Scheduler/view/mixin/SchedulerScroll\n */\nconst\n    defaultScrollOptions = {\n        block      : 'nearest',\n        edgeOffset : 20\n    };\n/**\n * Functions for scrolling to events, dates etc.\n *\n * @mixin\n */\nexport default Target => class SchedulerScroll extends (Target || Base) {\n    static get $name() {\n        return 'SchedulerScroll';\n    }\n    //region Scroll to event\n    /**\n     * Scrolls an event record into the viewport.\n     * If the resource store is a tree store, this method will also expand all relevant parent nodes to locate the event.\n     *\n     * This function is not applicable for events with multiple assignments, please use #scrollResourceEventIntoView instead.\n     *\n     * @param {Scheduler.model.EventModel} eventRecord the event record to scroll into view\n     * @param {BryntumScrollOptions} [options] How to scroll.\n     * @returns {Promise} A Promise which resolves when the scrolling is complete.\n     * @async\n     * @category Scrolling\n     */\n    async scrollEventIntoView(eventRecord, options = defaultScrollOptions) {\n        const\n            me        = this,\n            resources = eventRecord.resources || [eventRecord];\n        if (resources.length > 1) {\n            throw new Error('scrollEventIntoView() is not applicable for events with multiple assignments, please use scrollResourceEventIntoView() instead.');\n        }\n        if (!resources.length) {\n            console.warn('You have asked to scroll to an event which is not assigned to a resource');\n        }\n        await me.scrollResourceEventIntoView(resources[0], eventRecord, options);\n    }\n    /**\n     * Scrolls an assignment record into the viewport.\n     *\n     * If the resource store is a tree store, this method will also expand all relevant parent nodes\n     * to locate the event.\n     *\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord A resource record an event record is assigned to\n     * @param {BryntumScrollOptions} [options] How to scroll.\n     * @returns {Promise} A Promise which resolves when the scrolling is complete.\n     * @category Scrolling\n     */\n    scrollAssignmentIntoView(assignmentRecord, ...args) {\n        return this.scrollResourceEventIntoView(assignmentRecord.resource, assignmentRecord.event, ...args);\n    }\n    /**\n     * Scrolls a resource event record into the viewport.\n     *\n     * If the resource store is a tree store, this method will also expand all relevant parent nodes\n     * to locate the event.\n     *\n     * @param {Scheduler.model.ResourceModel} resourceRecord A resource record an event record is assigned to\n     * @param {Scheduler.model.EventModel} eventRecord An event record to scroll into view\n     * @param {BryntumScrollOptions} [options] How to scroll.\n     * @returns {Promise} A Promise which resolves when the scrolling is complete.\n     * @category Scrolling\n     * @async\n     */\n    async scrollResourceEventIntoView(resourceRecord, eventRecord, options = defaultScrollOptions) {\n        const\n            me             = this,\n            eventStart     = eventRecord.startDate,\n            eventEnd       = eventRecord.endDate,\n            eventIsOutside = eventRecord.isScheduled && eventStart < me.timeAxis.startDate | ((eventEnd > me.timeAxis.endDate) << 1);\n        if (arguments.length > 3) {\n            options = arguments[3];\n        }\n        let el;\n        if (options.edgeOffset == null) {\n            options.edgeOffset = 20;\n        }\n        // Make sure event is within TimeAxis time span unless extendTimeAxis passed as false.\n        // The EventEdit feature passes false because it must not mutate the TimeAxis.\n        // Bitwise flag:\n        //  1 === start is before TimeAxis start.\n        //  2 === end is after TimeAxis end.\n        if (eventIsOutside && options.extendTimeAxis !== false) {\n            const currentTimeSpanRange = me.timeAxis.endDate - me.timeAxis.startDate;\n            // Event is too wide, expand the range to encompass it.\n            if (eventIsOutside === 3) {\n                await me.setTimeSpan(\n                    new Date(eventStart.getTime() - currentTimeSpanRange / 2),\n                    new Date(eventEnd.getTime()  + currentTimeSpanRange / 2)\n                );\n            }\n            else if (me.infiniteScroll) {\n                const\n                    { visibleDateRange } = me,\n                    visibleMS = visibleDateRange.endMS - visibleDateRange.startMS,\n                    // If event starts before time axis, scroll to a date one full viewport after target date\n                    // (reverse for an event starting after time axis), to allow a scroll animation\n                    sign = eventIsOutside & 1 ? 1 : -1;\n                await me.setTimeSpan(\n                    new Date(eventStart.getTime()  - currentTimeSpanRange / 2),\n                    new Date(eventStart.getTime() + currentTimeSpanRange / 2),\n                    {\n                        visibleDate : new Date(eventEnd.getTime() + (sign * visibleMS))\n                    }\n                );\n            }\n            // Event is partially or wholly outside but will fit.\n            // Move the TimeAxis to include it. That will maintain visual position.\n            else {\n                // Event starts before\n                if (eventIsOutside & 1) {\n                    await me.setTimeSpan(\n                        new Date(eventStart),\n                        new Date(eventStart.getTime() + currentTimeSpanRange)\n                    );\n                }\n                // Event ends after\n                else {\n                    await me.setTimeSpan(\n                        new Date(eventEnd.getTime() - currentTimeSpanRange),\n                        new Date(eventEnd)\n                    );\n                }\n            }\n        }\n        if (me.isDestroyed) {\n            return;\n        }\n        if (me.store.tree) {\n            // If we're a tree, ensure parents are expanded first\n            await me.expandTo?.(resourceRecord);\n        }\n        // Handle nested events too\n        if (me.features.nestedEvents?.enabled && eventRecord.parent && !eventRecord.parent.isRoot) {\n            await me.scrollEventIntoView(eventRecord.parent);\n        }\n        // Establishing element to scroll to\n        el = me.getElementFromEventRecord(eventRecord, resourceRecord);\n        if (el) {\n            // It's usually the event wrapper that holds focus\n            if (!DomHelper.isFocusable(el)) {\n                el = el.parentNode;\n            }\n            const scroller = me.timeAxisSubGrid.scrollable;\n            // Scroll into view with animation and highlighting if needed.\n            await scroller.scrollIntoView(el, options);\n            if (me.isDestroyed) {\n                return;\n            }\n            let element;\n            do {\n                element = me.getElementFromEventRecord(eventRecord, resourceRecord);\n                // need to await a frame for event to be rendered again\n                // (it seems it can be un-rendered during the scroll somehow)\n                if (!element) {\n                    await AsyncHelper.animationFrame();\n                }\n                if (me.isDestroyed) {\n                    return;\n                }\n            } while (!element);\n        }\n        // If event is fully outside the range, and we are not allowed to extend\n        // the range, then we cannot perform the operation.\n        else if (eventIsOutside === 3 && options.extendTimeAxis === false) {\n            console.warn('You have asked to scroll to an event which is outside the current view and extending timeaxis is disabled');\n        }\n        else if (!eventRecord.isOccurrence && !me.eventStore.isAvailable(eventRecord)) {\n            console.warn('You have asked to scroll to an event which is not available');\n        }\n        else if (eventRecord.isScheduled) {\n            // Event scheduled but not rendered, scroll to calculated location\n            await me.scrollUnrenderedEventIntoView(resourceRecord, eventRecord, options);\n        }\n        else {\n            // Event not scheduled, just scroll resource row into view\n            await me.scrollResourceIntoView(resourceRecord, options);\n        }\n    }\n    /**\n     * Scrolls an unrendered event into view. Internal function used from #scrollResourceEventIntoView.\n     * @private\n     * @category Scrolling\n     */\n    scrollUnrenderedEventIntoView(resourceRec, eventRec, options = defaultScrollOptions) {\n        // We must only resolve when the event's element has been painted\n        // *and* the scroll has fully completed.\n        // eslint-disable-next-line no-async-promise-executor\n        return new Promise(async resolve => {\n            const\n                me               = this,\n                scroller         = me.timeAxisSubGrid.scrollable,\n                scrollerViewport = scroller.viewport,\n                { rowManager }   = me,\n                initialY         = scroller.y;\n            // Event may fall on a time not included by workingTime settings\n            if (!scrollerViewport) {\n                resolve();\n                return;\n            }\n            let eventElement, delta, counter = 0;\n            do {\n                // don't risk with the infinite loop, better to throw\n                if (++counter >= 50) {\n                    throw new Error(`Too many preparational scrolls during 'scrollIntoView' for event id = ${ eventRec.id }`);\n                }\n                // note, that this box is only a rough estimation of the event position\n                // it will be precise only in trivial cases\n                // in general case, it indicates the direction in which we should scroll\n                // and our best guess on the distance\n                // this is because we don't know the row heights (even if `preCalculateHeightLimit` is used)\n                // row height might change because of:\n                // - horizontal scroll (predictable with certain effort)\n                // - row height set in some column renderer (completely unpredictable)\n                // so we scroll several times, until we have the event's element (meaning the event is rendered)\n                const box = me.getResourceEventBox(eventRec, resourceRec);\n                // Event may fall on a time not included by workingTime settings\n                if (!box) {\n                    resolve();\n                    return;\n                }\n                // In case of subPixel position, scroll the whole pixel into view\n                box.x = Math.ceil(box.x);\n                box.y = Math.ceil(box.y);\n                if (me.rtl) {\n                    // RTL scrolls in negative direction but coordinates are still LTR\n                    box.translate(-me.timeAxisViewModel.totalSize + scrollerViewport.width, 0);\n                }\n                // Note use of scroller.scrollLeft here. We need the natural DOM scrollLeft value\n                // not the +ve X position along the scrolling axis.\n                box.translate(scrollerViewport.x - scroller.scrollLeft, scrollerViewport.y - scroller.y);\n                const instantScrollOptions = Object.assign({}, defaultScrollOptions);\n                // only interested in the direction of initial jump\n                if (delta === undefined) {\n                    delta = scroller.getDeltaTo(box, instantScrollOptions);\n                }\n                const scrollPromise = scroller.scrollIntoView(box, instantScrollOptions);\n                await scrollPromise;\n                if (scrollPromise.cancelled || me.isDestroyed) {\n                    resolve();\n                    return true;\n                }\n                await AsyncHelper.animationFrame();\n                if (me.isDestroyed) {\n                    resolve();\n                    return true;\n                }\n                eventElement = me.getElementFromEventRecord(eventRec, resourceRec);\n            } while (!eventElement);\n            // now we have arrived to the local area of the event\n            // probably we don't need to suspend/resume events on scroller, since DOM `scroll` event is fired\n            // asynchronously, and we resume the events right away in the synchronous flow below\n            scroller.suspendEvents();\n            // position the scroller above/below of all rows, but not exceeding the initial Y position\n            if (delta.yDelta >= 0) {\n                scroller.y = Math.max(rowManager.topRow.top - scroller.viewport.height, initialY);\n            }\n            else {\n                scroller.y = Math.min(rowManager.bottomRow.bottom, initialY);\n            }\n            // this is a quite important call, which fixes the internal scroller state after the scrolls above\n            me.fixElementHeights();\n            scroller.resumeEvents();\n            // now make a final animated scroll, pretending we arrived there from the very 1st jump\n            const scrollPromise2 = scroller.scrollIntoView(\n                eventElement,\n                Object.assign({}, options, { elementAfterScroll : () => me.getElementFromEventRecord(eventRec, resourceRec) })\n            );\n            await scrollPromise2;\n            if (scrollPromise2.canceled || me.isDestroyed) {\n                resolve();\n                return true;\n            }\n            // final await for animation frame for the event element rendering to complete\n            await AsyncHelper.animationFrame();\n            resolve();\n        });\n    }\n    /**\n     * Scrolls the specified resource into view, works for both horizontal and vertical modes.\n     * @param {Scheduler.model.ResourceModel} resourceRecord A resource record an event record is assigned to\n     * @param {BryntumScrollOptions} [options] How to scroll.\n     * @returns {Promise} A promise which is resolved when the scrolling has finished.\n     * @category Scrolling\n     */\n    scrollResourceIntoView(resourceRecord, options = defaultScrollOptions) {\n        if (this.isVertical) {\n            return this.currentOrientation.scrollResourceIntoView(resourceRecord, options);\n        }\n        return this.scrollRowIntoView(resourceRecord, options);\n    }\n    //endregion\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\n/**\n * @module Scheduler/view/mixin/SchedulerRegions\n */\n/**\n * Functions to get regions (bounding boxes) for scheduler, events etc.\n *\n * @mixin\n */\nexport default Target => class SchedulerRegions extends (Target || Base) {\n    static get $name() {\n        return 'SchedulerRegions';\n    }\n    //region Orientation dependent regions\n    /**\n     * Gets the region represented by the schedule and optionally only for a single resource. The view will ask the\n     * scheduler for the resource availability by calling getResourceAvailability. By overriding that method you can\n     * constrain events differently for different resources.\n     * @param {Scheduler.model.ResourceModel} resourceRecord (optional) The resource record\n     * @param {Scheduler.model.EventModel} eventRecord (optional) The event record\n     * @returns {Core.helper.util.Rectangle} The region of the schedule\n     */\n    getScheduleRegion(resourceRecord, eventRecord, local = true, dateConstraints) {\n        return this.currentOrientation.getScheduleRegion(...arguments);\n    }\n    /**\n     * Gets the region, relative to the timeline view element, representing the passed resource and optionally just for a certain date interval.\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {Date} startDate A start date constraining the region\n     * @param {Date} endDate An end date constraining the region\n     * @returns {Core.helper.util.Rectangle} A Rectangle which encapsulates the resource time span\n     */\n    getResourceRegion(resourceRecord, startDate, endDate) {\n        return this.currentOrientation.getRowRegion(...arguments);\n    }\n    //endregion\n    //region ResourceEventBox\n    getAssignmentEventBox(assignmentRecord, includesOutside) {\n        return this.getResourceEventBox(assignmentRecord.event, assignmentRecord.resource, includesOutside);\n    }\n    /**\n     * Get the region for a specified resources specified event.\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @param {Boolean} includeOutside Specify true to get boxes for events outside of the rendered zone in both\n     *   dimensions. This option is used when calculating dependency lines, and we need to include routes from events\n     *   which may be outside the rendered zone.\n     * @returns {Core.helper.util.Rectangle}\n     */\n    getResourceEventBox(eventRecord, resourceRecord, includeOutside = false, roughly = false) {\n        return this.currentOrientation.getResourceEventBox(...arguments);\n    }\n    //endregion\n    //region Item box\n    /**\n     * Gets box for displayed item designated by the record. If several boxes are displayed for the given item\n     * then the method returns all of them. Box coordinates are in view coordinate system.\n     *\n     * Boxes outside scheduling view timeaxis timespan and inside collapsed rows (if row defining store is a tree store)\n     * will not be returned. Boxes outside scheduling view vertical visible area (i.e. boxes above currently visible\n     * top row or below currently visible bottom row) will be calculated approximately.\n     *\n     * @param {Scheduler.model.EventModel} event\n     * @returns {Object|Object[]}\n     * @returns {Boolean} return.isPainted Whether the box was calculated for the rendered scheduled record or was\n     *    approximately calculated for the scheduled record outside of the current vertical view area.\n     * @returns {Number} return.top\n     * @returns {Number} return.bottom\n     * @returns {Number} return.start\n     * @returns {Number} return.end\n     * @returns {'before'|'after'} return.relPos if the item is not rendered then provides a view relative\n     * position one of 'before', 'after'\n     * @internal\n     */\n    getItemBox(event, includeOutside = false) {\n        return event.resources.map(resource => this.getResourceEventBox(event, resource, includeOutside));\n    }\n    //endregion\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n/**\n * @module Scheduler/view/mixin/SchedulerState\n */\nconst copyProperties = [\n    'eventLayout',\n    'mode',\n    'eventColor',\n    'eventStyle',\n    'tickSize',\n    'fillTicks'\n];\n/**\n * A Mixin for Scheduler that handles state. It serializes the following scheduler properties, in addition to what\n * is already stored by its superclass {@link Grid/view/mixin/GridState}:\n *\n * * eventLayout\n * * barMargin\n * * mode\n * * tickSize\n * * zoomLevel\n * * eventColor\n * * eventStyle\n *\n * See {@link Grid.view.mixin.GridState} and {@link Core.mixin.State} for more information on state.\n *\n * @mixin\n */\nexport default Target => class SchedulerState extends (Target || Base) {\n    static get $name() {\n        return 'SchedulerState';\n    }\n    /**\n     * Gets or sets scheduler's state. Check out {@link Scheduler.view.mixin.SchedulerState} mixin\n     * and {@link Grid.view.mixin.GridState} for more details.\n     * @member {Object} state\n     * @property {String} state.eventLayout\n     * @property {String} state.eventStyle\n     * @property {String} state.eventColor\n     * @property {Number} state.barMargin\n     * @property {Number} state.tickSize\n     * @property {Boolean} state.fillTicks\n     * @property {Number} state.zoomLevel\n     * @property {'horizontal'|'vertical'} state.mode\n     * @property {Object[]} state.columns\n     * @property {Boolean} state.readOnly\n     * @property {Number} state.rowHeight\n     * @property {Object} state.scroll\n     * @property {Number} state.scroll.scrollLeft\n     * @property {Number} state.scroll.scrollTop\n     * @property {Array} state.selectedRecords\n     * @property {String} state.selectedCell\n     * @property {String} state.style\n     * @property {Object} state.subGrids\n     * @property {Object} state.store\n     * @property {Object} state.store.sorters\n     * @property {Object} state.store.groupers\n     * @property {Object} state.store.filters\n     * @category State\n     */\n    /**\n     * Get scheduler's current state for serialization. State includes rowHeight, headerHeight, readOnly, selectedCell,\n     * selectedRecordId, column states and store state etc.\n     * @returns {Object} State object to be serialized\n     * @private\n     */\n    getState() {\n        return ObjectHelper.copyProperties(super.getState(), this, copyProperties);\n    }\n    /**\n     * Apply previously stored state.\n     * @param {Object} state\n     * @private\n     */\n    applyState(state) {\n        this.suspendRefresh();\n        let propsToCopy = copyProperties.slice();\n        if (state?.eventLayout === 'layoutFn') {\n            delete state.eventLayout;\n            propsToCopy.splice(propsToCopy.indexOf('eventLayout'), 1);\n        }\n        // Zoom level will set tick size, no need to update model additionally\n        if (state?.zoomLevelOptions?.width) {\n            propsToCopy = propsToCopy.filter(p => p !== 'tickSize');\n        }\n        ObjectHelper.copyProperties(this, state, propsToCopy);\n        super.applyState(state);\n        this.resumeRefresh(true, false);\n    }\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport Collection from '../../../Core/util/Collection.js';\nimport ArrayHelper from '../../../Core/helper/ArrayHelper.js';\n/**\n * @module Scheduler/view/mixin/EventSelection\n */\n/**\n * Mixin that tracks event or assignment selection by clicking on one or more events in the scheduler.\n * @mixin\n */\nexport default Target => class EventSelection extends (Target || Base) {\n    static get $name() {\n        return 'EventSelection';\n    }\n    //region Default config\n    static get configurable() {\n        return {\n            /**\n             * Configure as `true`, or set property to `true` to highlight dependent events as well when selecting an event.\n             * @config {Boolean}\n             * @default\n             * @category Selection\n             */\n            highlightPredecessors : false,\n            /**\n             * Configure as `true`, or set property to `true` to highlight dependent events as well when selecting an event.\n             * @config {Boolean}\n             * @default\n             * @category Selection\n             */\n            highlightSuccessors : false,\n            /**\n             * Configure as `true` to deselect a selected event upon click.\n             * @config {Boolean}\n             * @default\n             * @category Selection\n             */\n            deselectOnClick : false,\n            /**\n             * Configure as `false` to preserve selection when clicking the empty schedule area.\n             * @config {Boolean}\n             * @default\n             * @category Selection\n             */\n            deselectAllOnScheduleClick : true,\n            /**\n             * Set to `false` to not select the resource of the event when clicking an event bar.\n             * @prp {Boolean}\n             * @default\n             * @category Selection\n             */\n            selectResourceOnEventNavigate : true,\n            /**\n             * Set to `false` to not select the row/resource when clicking the empty area in a time axis cell.\n             * @prp {Boolean}\n             * @default\n             * @category Selection\n             */\n            selectResourceOnScheduleClick : true,\n            /**\n             * Collection to store selection.\n             * @config {Core.util.Collection}\n             * @private\n             */\n            selectedCollection : {}\n        };\n    }\n    static get defaultConfig() {\n        return {\n            /**\n             * Configure as `true` to allow `CTRL+click` to select multiple events in the scheduler.\n             * @config {Boolean}\n             * @category Selection\n             */\n            multiEventSelect : false,\n            /**\n             * Configure as `true`, or set property to `true` to disable event selection.\n             * @config {Boolean}\n             * @default\n             * @category Selection\n             */\n            eventSelectionDisabled : false,\n            /**\n             * CSS class to add to selected events.\n             * @config {String}\n             * @default\n             * @category CSS\n             * @private\n             */\n            eventSelectedCls : 'b-sch-event-selected',\n            /**\n             * Configure as `true` to trigger `selectionChange` when removing a selected event/assignment.\n             * @config {Boolean}\n             * @default\n             * @category Selection\n             */\n            triggerSelectionChangeOnRemove : false,\n            /**\n             * This flag controls whether Scheduler should preserve its selection of events when loading a new dataset\n             * (if selected event ids are included in the newly loaded dataset).\n             * @config {Boolean}\n             * @default\n             * @category Selection\n             */\n            maintainSelectionOnDatasetChange : true,\n            /**\n             * CSS class to add to other instances of a selected event, to highlight them.\n             * @config {String}\n             * @default\n             * @category CSS\n             * @private\n             */\n            eventAssignHighlightCls : 'b-sch-event-assign-selected'\n        };\n    }\n    //endregion\n    //region Events\n    /**\n     * Fired any time there is a change to the events selected in the Scheduler.\n     * @event eventSelectionChange\n     * @param {'select'|'deselect'|'update'|'clear'} action One of the actions 'select', 'deselect', 'update',\n     * 'clear'\n     * @param {Scheduler.model.EventModel[]} selected An array of the Events added to the selection.\n     * @param {Scheduler.model.EventModel[]} deselected An array of the Event removed from the selection.\n     * @param {Scheduler.model.EventModel[]} selection The new selection.\n     */\n    /**\n     * Fired any time there is going to be a change to the events selected in the Scheduler.\n     * Returning `false` prevents the change\n     * @event beforeEventSelectionChange\n     * @preventable\n     * @param {String} action One of the actions 'select', 'deselect', 'update', 'clear'\n     * @param {Scheduler.model.EventModel[]} selected An array of events that will be added to the selection.\n     * @param {Scheduler.model.EventModel[]} deselected An array of events that will be removed from the selection.\n     * @param {Scheduler.model.EventModel[]} selection The currently selected events, before applying `selected` and `deselected`.\n     */\n    /**\n     * Fired any time there is a change to the assignments selected in the Scheduler.\n     * @event assignmentSelectionChange\n     * @param {'select'|'deselect'|'update'|'clear'} action One of the actions 'select', 'deselect', 'update',\n     * 'clear'\n     * @param {Scheduler.model.AssignmentModel[]} selected An array of the Assignments added to the selection.\n     * @param {Scheduler.model.AssignmentModel[]} deselected An array of the Assignments removed from the selection.\n     * @param {Scheduler.model.AssignmentModel[]} selection The new selection.\n     */\n    /**\n     * Fired any time there is going to be a change to the assignments selected in the Scheduler.\n     * Returning `false` prevents the change\n     * @event beforeAssignmentSelectionChange\n     * @preventable\n     * @param {String} action One of the actions 'select', 'deselect', 'update', 'clear'\n     * @param {Scheduler.model.EventModel[]} selected An array of assignments that will be added to the selection.\n     * @param {Scheduler.model.EventModel[]} deselected An array of assignments that will be removed from the selection.\n     * @param {Scheduler.model.EventModel[]} selection The currently selected assignments, before applying `selected` and `deselected`.\n     */\n    //endregion\n    //region Init\n    afterConstruct() {\n        super.afterConstruct();\n        this.navigator?.ion({\n            navigate : 'onEventNavigate',\n            thisObj  : this\n        });\n    }\n    //endregion\n    //region Selected Collection\n    changeSelectedCollection(selectedCollection) {\n        if (!selectedCollection.isCollection) {\n            selectedCollection = new Collection(selectedCollection);\n        }\n        return selectedCollection;\n    }\n    updateSelectedCollection(selectedCollection) {\n        const me = this;\n        // When sharing collection, only the owner should destroy it\n        if (!selectedCollection.owner) {\n            selectedCollection.owner = me;\n        }\n        // Fire row change events from onSelectedCollectionChange\n        selectedCollection.ion({\n            change : (...args) => me.project.deferUntilRepopulationIfNeeded(\n                'onSelectedCollectionChange',\n                (...args) => !me.isDestroying && me.onSelectedCollectionChange(...args),\n                args\n            ),\n            // deferring this handler breaks the UI\n            beforeSplice : 'onBeforeSelectedCollectionSplice',\n            thisObj      : me\n        });\n    }\n    get selectedCollection() {\n        return this._selectedCollection;\n    }\n    getActionType(selection, selected, deselected, before) {\n        if ((before && selection.length > 0 && deselected.length === selection.length && selected.length === 0) ||\n            (!before && selection.length === 0 && deselected.length > 0)) {\n            return 'clear';\n        }\n        return (selected.length > 0 && deselected.length > 0) ? 'update' : (selected.length > 0\n            ? 'select'  : 'deselect');\n    }\n    //endregion\n    //region Modify selection\n    getEventsFromAssignments(assignments) {\n        return ArrayHelper.unique(assignments.map(assignment => assignment.event));\n    }\n    /**\n     * The {@link Scheduler.model.EventModel events} which are selected.\n     * @property {Scheduler.model.EventModel[]}\n     * @category Selection\n     */\n    get selectedEvents() {\n        return this.getEventsFromAssignments(this.selectedCollection.values);\n    }\n    set selectedEvents(events) {\n        // Select all assignments\n        const assignments = [];\n        events = ArrayHelper.asArray(events);\n        events?.forEach(event => {\n            if (this.isEventSelectable(event) !== false) {\n                if (event.isOccurrence) {\n                    event.assignments.forEach(as => {\n                        assignments.push(this.assignmentStore.getOccurrence(as, event));\n                    });\n                }\n                else {\n                    assignments.push(...event.assignments);\n                }\n            }\n        });\n        // Replace the entire selected collection with the new record set\n        this.selectedCollection.splice(0, this.selectedCollection.count, assignments);\n    }\n    /**\n     * The {@link Scheduler.model.AssignmentModel events} which are selected.\n     * @property {Scheduler.model.AssignmentModel[]}\n     * @category Selection\n     */\n    get selectedAssignments() {\n        return this.selectedCollection.values;\n    }\n    set selectedAssignments(assignments) {\n        // Replace the entire selected collection with the new record set\n        this.selectedCollection.splice(0, this.selectedCollection.count, assignments || []);\n    }\n    /**\n     * Returns `true` if the {@link Scheduler.model.EventModel event} is selected.\n     * @param {Scheduler.model.EventModel} event The event\n     * @returns {Boolean} Returns `true` if the event is selected\n     * @category Selection\n     */\n    isEventSelected(event) {\n        const { selectedCollection } = this;\n        return Boolean(selectedCollection.count && selectedCollection.includes(event.assignments));\n    }\n    /**\n     * A template method (empty by default) allowing you to control if an event can be selected or not.\n     *\n     * ```javascript\n     * new Scheduler({\n     *     isEventSelectable(event) {\n     *         return event.startDate >= Date.now();\n     *     }\n     * })\n     * ```\n     *\n     * This selection process is applicable to calendar too:\n     *\n     * ```javascript\n     * new Calendar({\n     *     isEventSelectable(event) {\n     *         return event.startDate >= Date.now();\n     *     }\n     * })\n     * ```\n     *\n     * @param {Scheduler.model.EventModel} event The event record\n     * @returns {Boolean} true if event can be selected, otherwise false\n     * @prp {Function}\n     * @category Selection\n     */\n    isEventSelectable(event) {}\n    /**\n     * Returns `true` if the {@link Scheduler.model.AssignmentModel assignment} is selected.\n     * @param {Scheduler.model.AssignmentModel} assignment The assignment\n     * @returns {Boolean} Returns `true` if the assignment is selected\n     * @category Selection\n     */\n    isAssignmentSelected(assignment) {\n        return this.selectedCollection.includes(assignment);\n    }\n    /**\n     * Selects the passed {@link Scheduler.model.EventModel event} or {@link Scheduler.model.AssignmentModel assignment}\n     * *if it is not selected*. Selecting events results in all their assignments being selected.\n     * @param {Scheduler.model.EventModel|Scheduler.model.AssignmentModel} eventOrAssignment The event or assignment to select\n     * @param {Boolean} [preserveSelection] Pass `true` to preserve any other selected events or assignments\n     * @category Selection\n     */\n    select(eventOrAssignment, preserveSelection = false) {\n        if (eventOrAssignment.isAssignment) {\n            this.selectAssignment(eventOrAssignment, preserveSelection);\n        }\n        else {\n            this.selectEvent(eventOrAssignment, preserveSelection);\n        }\n    }\n    /**\n     * Selects the passed {@link Scheduler.model.EventModel event} *if it is not selected*. Selecting an event will\n     * select all its assignments.\n     * @param {Scheduler.model.EventModel} event The event to select\n     * @param {Boolean} [preserveSelection] Pass `true` to preserve any other selected events\n     * @category Selection\n     */\n    selectEvent(event, preserveSelection = false) {\n        // If the event is already selected, this is a no-op.\n        // In this case, selection must not be cleared even in the absence of preserveSelection\n        if (!this.isEventSelected(event)) {\n            this.selectEvents([event], preserveSelection);\n        }\n    }\n    /**\n     * Selects the passed {@link Scheduler.model.AssignmentModel assignment} *if it is not selected*.\n     * @param {Scheduler.model.AssignmentModel} assignment The assignment to select\n     * @param {Boolean} [preserveSelection] Pass `true` to preserve any other selected assignments\n     * @param {Event} [event] If this method was invoked as a result of a user action, this is the DOM event that triggered it\n     * @category Selection\n     */\n    selectAssignment(assignment, preserveSelection = false, event) {\n        // If the event is already selected, this is a no-op.\n        // In this case, selection must not be cleared even in the absence of preserveSelection\n        if (!this.isAssignmentSelected(assignment)) {\n            preserveSelection ? this.selectedCollection.add(assignment) : this.selectedAssignments = assignment;\n        }\n    }\n    /**\n     * Deselects the passed {@link Scheduler.model.EventModel event} or {@link Scheduler.model.AssignmentModel assignment}\n     * *if it is selected*.\n     * @param {Scheduler.model.EventModel|Scheduler.model.AssignmentModel} eventOrAssignment The event or assignment to deselect.\n     * @category Selection\n     */\n    deselect(eventOrAssignment) {\n        if (eventOrAssignment.isAssignment) {\n            this.deselectAssignment(eventOrAssignment);\n        }\n        else {\n            this.deselectEvent(eventOrAssignment);\n        }\n    }\n    /**\n     * Deselects the passed {@link Scheduler.model.EventModel event} *if it is selected*.\n     * @param {Scheduler.model.EventModel} event The event to deselect.\n     * @category Selection\n     */\n    deselectEvent(event) {\n        if (this.isEventSelected(event)) {\n            this.selectedCollection.remove(...event.assignments);\n        }\n    }\n    /**\n     * Deselects the passed {@link Scheduler.model.AssignmentModel assignment} *if it is selected*.\n     * @param {Scheduler.model.AssignmentModel} assignment The assignment to deselect\n     * @param {Event} [event] If this method was invoked as a result of a user action, this is the DOM event that triggered it\n     * @category Selection\n     */\n    deselectAssignment(assignment) {\n        if (this.isAssignmentSelected(assignment)) {\n            this.selectedCollection.remove(assignment);\n        }\n    }\n    /**\n     * Adds {@link Scheduler.model.EventModel events} to the selection.\n     * @param {Scheduler.model.EventModel[]} events Events to be selected\n     * @param {Boolean} [preserveSelection] Pass `true` to preserve any other selected events\n     * @category Selection\n     */\n    selectEvents(events, preserveSelection = false) {\n        if (preserveSelection) {\n            const assignments = (events.reduce((assignments, event) => {\n                if (this.isEventSelectable(event) !== false) {\n                    assignments.push(...event.assignments);\n                }\n                return assignments;\n            }, []));\n            this.selectedCollection.add(assignments);\n        }\n        else {\n            this.selectedEvents = events;\n        }\n    }\n    /**\n     * Removes {@link Scheduler.model.EventModel events} from the selection.\n     * @param {Scheduler.model.EventModel[]} events Events or assignments  to be deselected\n     * @category Selection\n     */\n    deselectEvents(events) {\n        this.selectedCollection.remove(events.reduce((assignments, event) => {\n            assignments.push(...event.assignments);\n            return assignments;\n        }, []));\n    }\n    /**\n     * Adds {@link Scheduler.model.AssignmentModel assignments} to the selection.\n     * @param {Scheduler.model.AssignmentModel[]} assignments Assignments to be selected\n     * @category Selection\n     */\n    selectAssignments(assignments) {\n        this.selectedCollection.add(assignments);\n    }\n    /**\n     * Removes {@link Scheduler.model.AssignmentModel assignments} from the selection.\n     * @param {Scheduler.model.AssignmentModel[]} assignments Assignments  to be deselected\n     * @category Selection\n     */\n    deselectAssignments(assignments) {\n        this.selectedCollection.remove(assignments);\n    }\n    /**\n     * Deselects all {@link Scheduler.model.EventModel events} and {@link Scheduler.model.AssignmentModel assignments}.\n     * @category Selection\n     */\n    clearEventSelection() {\n        this.selectedAssignments = [];\n    }\n    //endregion\n    //region Events\n    /**\n     * Responds to mutations of the underlying selection Collection.\n     * Keeps the UI synced, eventSelectionChange and assignmentSelectionChange event is fired when `me.silent` is falsy.\n     * @private\n     */\n    onBeforeSelectedCollectionSplice({ toAdd, toRemove, index }) {\n        const\n            me         = this,\n            selection  = me._selectedCollection.values,\n            selected   = toAdd,\n            deselected = toRemove > 0 ? selection.slice(index, toRemove + index) : [],\n            action     = me.getActionType(selection, selected, deselected, true);\n        if (toAdd.length === 0 && toRemove === 0) {\n            return;\n        }\n        if (me.trigger('beforeEventSelectionChange', {\n            action,\n            selection  : me.getEventsFromAssignments(selection) || [],\n            selected   : me.getEventsFromAssignments(selected) || [],\n            deselected : me.getEventsFromAssignments(deselected) || []\n        }) === false) {\n            return false;\n        }\n        if (me.trigger('beforeAssignmentSelectionChange', {\n            action,\n            selection,\n            selected,\n            deselected\n        }) === false) {\n            return false;\n        }\n    }\n    onSelectedCollectionChange({ added, removed }) {\n        const\n            me         = this,\n            selection  = me.selectedAssignments,\n            selected   = added || [],\n            deselected = removed || [];\n        function updateSelection(assignmentRecord, select) {\n            const eventRecord    = assignmentRecord.event;\n            if (eventRecord) {\n                const\n                    returnWrapper               = false,\n                    checkReleased               = true,\n                    { eventAssignHighlightCls } = me,\n                    element                     = me.getElementFromAssignmentRecord(assignmentRecord, returnWrapper, checkReleased);\n                me.currentOrientation.toggleCls(assignmentRecord, me.eventSelectedCls, select, returnWrapper, checkReleased);\n                eventAssignHighlightCls && me.getElementsFromEventRecord(eventRecord, null, returnWrapper, checkReleased).forEach(el => {\n                    if (el !== element) {\n                        const otherAssignmentRecord = me.resolveAssignmentRecord(el, checkReleased);\n                        me.currentOrientation.toggleCls(otherAssignmentRecord, eventAssignHighlightCls, select, returnWrapper, checkReleased);\n                        // When selection changes, we toggle classes also for released events above, to make sure the\n                        // element & lastDomConfig matches (to not get incorrect state later). But we do not want to\n                        // animate that (cant be seen anyway)\n                        if (select && !el.parentElement.isReleased) {\n                            // Need to force a reflow to get the highlightning animation triggered\n                            el.style.animation = 'none';\n                            el.offsetHeight;\n                            el.style.animation = '';\n                        }\n                        el.classList.toggle(eventAssignHighlightCls, select);\n                    }\n                });\n            }\n        }\n        deselected.forEach(record => updateSelection(record, false));\n        selected.forEach(record => updateSelection(record, true));\n        if (me.highlightSuccessors || me.highlightPredecessors) {\n            me.highlightLinkedEvents(me.selectedEvents);\n        }\n        // To be able to restore selection after reloading resources (which might lead to regenerated assignments in\n        // the single assignment scenario, so cannot rely on records or ids)\n        me.$selectedAssignments = selection.map(assignment => ({\n            eventId    : assignment.eventId,\n            resourceId : assignment.resourceId\n        }));\n        if (!me.silent) {\n            const action = this.getActionType(selection, selected, deselected);\n            me.trigger('assignmentSelectionChange', {\n                action,\n                selection,\n                selected,\n                deselected\n            });\n            me.trigger('eventSelectionChange', {\n                action,\n                selection  : me.selectedEvents,\n                selected   : me.getEventsFromAssignments(selected),\n                deselected : me.getEventsFromAssignments(deselected)\n            });\n        }\n    }\n    /**\n     * Assignment change listener to remove events from selection which are no longer in the assignments.\n     * @private\n     */\n    onAssignmentChange(event) {\n        super.onAssignmentChange(event);\n        const\n            me = this,\n            { action, records : assignments } = event;\n        me.silent = !me.triggerSelectionChangeOnRemove;\n        if (action === 'remove') {\n            me.deselectAssignments(assignments);\n        }\n        else if (action === 'removeall' && !me.eventStore.isSettingData) {\n            me.clearEventSelection();\n        }\n        else if (action === 'dataset' && me.$selectedAssignments) {\n            if (!me.maintainSelectionOnDatasetChange) {\n                me.clearEventSelection();\n            }\n            else {\n                const newAssignments = me.$selectedAssignments.map(selector =>\n                    assignments.find(a =>\n                        a.eventId === selector.eventId &&\n                        a.resourceId === selector.resourceId\n                    )\n                );\n                me.selectedAssignments = ArrayHelper.clean(newAssignments);\n            }\n        }\n        me.silent = false;\n    }\n    onInternalEventStoreChange({ source, action, records }) {\n        // Setting empty event dataset cannot be handled in onAssignmentChange above, no assignments might be affected\n        if (!source.isResourceTimeRangeStore && action === 'dataset' && !records.length) {\n            this.clearEventSelection();\n        }\n        super.onInternalEventStoreChange(...arguments);\n    }\n    /**\n     * Mouse listener to update selection.\n     * @private\n     */\n    onAssignmentSelectionClick(event, clickedRecord) {\n        const me = this;\n        // Multi selection: CTRL means preserve selection, just add or remove the event.\n        // Single selection: CTRL deselects already selected event\n        if (me.isAssignmentSelected(clickedRecord)) {\n            if (me.deselectOnClick || event.ctrlKey) {\n                me.deselectAssignment(clickedRecord, me.multiEventSelect, event);\n            }\n        }\n        else if (this.isEventSelectable(clickedRecord.event) !== false) {\n            me.selectAssignment(clickedRecord, event.ctrlKey && me.multiEventSelect, event);\n        }\n    }\n    /**\n     * Navigation listener to update selection.\n     * @private\n     */\n    onEventNavigate({ event, item }) {\n        if (!this.eventSelectionDisabled) {\n            const assignment = item && (item.nodeType === Element.ELEMENT_NODE ? this.resolveAssignmentRecord(item) : item);\n            if (assignment) {\n                this.onAssignmentSelectionClick(event, assignment);\n            }\n            // The click was not an event or assignment\n            else if (this.deselectAllOnScheduleClick) {\n                this.clearEventSelection();\n            }\n        }\n    }\n    changeHighlightSuccessors(value) {\n        return this.changeLinkedEvents(value);\n    }\n    changeHighlightPredecessors(value) {\n        return this.changeLinkedEvents(value);\n    }\n    changeLinkedEvents(value) {\n        const me = this;\n        if (value) {\n            me.highlighted = me.highlighted || new Set();\n            me.highlightLinkedEvents(me.selectedEvents);\n        }\n        else if (me.highlighted) {\n            me.highlightLinkedEvents();\n        }\n        return value;\n    }\n    // Function that highlights/unhighlights events in a dependency chain\n    highlightLinkedEvents(eventRecords = []) {\n        const\n            me                  = this,\n            {\n                highlighted,\n                eventStore\n            }                   = me,\n            dependenciesFeature = me.features.dependencies;\n        // Unhighlight previously highlighted records\n        highlighted.forEach(eventRecord => {\n            if (!eventRecords.includes(eventRecord)) {\n                eventRecord.meta.highlight = false;\n                highlighted.delete(eventRecord);\n                if (eventStore.includes(eventRecord)) {\n                    eventRecord.dependencies.forEach(dep => dependenciesFeature.unhighlight(dep, 'b-highlight'));\n                }\n            }\n        });\n        eventRecords.forEach(eventRecord => {\n            const toWalk = [eventRecord];\n            // Collect all events along the dependency chain\n            while (toWalk.length) {\n                const record = toWalk.pop();\n                highlighted.add(record);\n                if (me.highlightSuccessors) {\n                    record.outgoingDeps.forEach(outgoing => {\n                        dependenciesFeature.highlight(outgoing, 'b-highlight');\n                        !highlighted.has(outgoing.toEvent) && toWalk.push(outgoing.toEvent);\n                    });\n                }\n                if (me.highlightPredecessors) {\n                    record.incomingDeps.forEach(incoming => {\n                        dependenciesFeature.highlight(incoming, 'b-highlight');\n                        !highlighted.has(incoming.fromEvent) && toWalk.push(incoming.fromEvent);\n                    });\n                }\n            }\n            // Highlight them\n            highlighted.forEach(record => record.meta.highlight = true);\n        });\n        // Toggle flag on schedulers element, to fade others in or out\n        me.element.classList.toggle('b-highlighting', eventRecords.length > 0);\n        me.refreshWithTransition();\n    }\n    onEventDataGenerated(renderData) {\n        if (this.highlightSuccessors || this.highlightPredecessors) {\n            renderData.cls['b-highlight'] = renderData.eventRecord.meta.highlight;\n        }\n        super.onEventDataGenerated(renderData);\n    }\n    updateProject(project, old) {\n        this.clearEventSelection();\n        super.updateProject(project, old);\n    }\n    //endregion\n    doDestroy() {\n        this._selectedCollection?.owner === this && this._selectedCollection.destroy();\n        super.doDestroy();\n    }\n    //region Getters/Setters\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n    //endregion\n};\n", "import Base from '../../../Core/Base.js';\nimport Navigator from '../../../Core/helper/util/Navigator.js';\nimport Delayable from '../../../Core/mixin/Delayable.js';\nimport Location from '../../../Grid/util/Location.js';\n/**\n * @module Scheduler/view/mixin/EventNavigation\n */\nconst\n    preventDefault  = e => e.preventDefault(),\n    isArrowKey = {\n        ArrowRight : 1,\n        ArrowLeft  : 1,\n        ArrowUp    : 1,\n        ArrowDown  : 1\n    },\n    animate100 = {\n        animate : 100\n    },\n    emptyObject = Object.freeze({});\n/**\n * Mixin that tracks event or assignment selection by clicking on one or more events in the scheduler.\n * @mixin\n */\nexport default Target => class EventNavigation extends Delayable(Target || Base) {\n    static get $name() {\n        return 'EventNavigation';\n    }\n    //region Default config\n    static get configurable() {\n        return {\n            /**\n             * A config object to use when creating the {@link Core.helper.util.Navigator}\n             * to use to perform keyboard navigation in the timeline.\n             * @config {NavigatorConfig}\n             * @default\n             * @category Misc\n             * @internal\n             */\n            navigator : {\n                allowCtrlKey   : true,\n                scrollSilently : true,\n                keys           : {\n                    Space     : 'onEventSpaceKey',\n                    Enter     : 'onEventEnterKey',\n                    Delete    : 'onDeleteKey',\n                    Backspace : 'onDeleteKey',\n                    ArrowUp   : 'onArrowUpKey',\n                    ArrowDown : 'onArrowDownKey',\n                    Escape    : 'onEscapeKey',\n                    // These are processed by GridNavigation's handlers\n                    Tab         : 'onTab',\n                    'SHIFT+Tab' : 'onShiftTab'\n                }\n            },\n            isNavigationKey : {\n                ArrowDown  : 1,\n                ArrowUp    : 1,\n                ArrowLeft  : 1,\n                ArrowRight : 1\n            }\n        };\n    }\n    static get defaultConfig() {\n        return {\n            /**\n             * A CSS class name to add to focused events.\n             * @config {String}\n             * @default\n             * @category CSS\n             * @private\n             */\n            focusCls : 'b-active',\n            /**\n             * Allow using [Delete] and [Backspace] to remove events/assignments\n             * @config {Boolean}\n             * @default\n             * @category Misc\n             */\n            enableDeleteKey : true,\n            // Number in milliseconds to buffer handlers execution. See `Delayable.throttle` function docs.\n            onDeleteKeyBuffer      : 500,\n            navigatePreviousBuffer : 200,\n            navigateNextBuffer     : 200,\n            testConfig : {\n                onDeleteKeyBuffer : 1\n            }\n        };\n    }\n    //endregion\n    //region Events\n    /**\n     * Fired when a user gesture causes the active item to change.\n     * @event navigate\n     * @param {Event} event The browser event which instigated navigation. May be a click or key or focus event.\n     * @param {HTMLElement|null} item The newly active item, or `null` if focus moved out.\n     * @param {HTMLElement|null} oldItem The previously active item, or `null` if focus is moving in.\n     */\n    //endregion\n    construct(config) {\n        const me = this;\n        me.isInTimeAxis = me.isInTimeAxis.bind(me);\n        me.onDeleteKey = me.throttle(me.onDeleteKey, me.onDeleteKeyBuffer, me);\n        super.construct(config);\n    }\n    changeNavigator(navigator) {\n        const me = this;\n        me.getConfig('subGridConfigs');\n        return new Navigator(me.constructor.mergeConfigs({\n            ownerCmp         : me,\n            target           : me.timeAxisSubGridElement,\n            processEvent     : me.processEvent,\n            itemSelector     : `.${me.eventCls}-wrap`,\n            focusCls         : me.focusCls,\n            navigatePrevious : me.throttle(me.navigatePrevious, { delay : me.navigatePreviousBuffer, throttled : preventDefault }),\n            navigateNext     : me.throttle(me.navigateNext, { delay : me.navigateNextBuffer, throttled : preventDefault })\n        }, navigator));\n    }\n    doDestroy() {\n        this.navigator.destroy();\n        super.doDestroy();\n    }\n    isInTimeAxis(record) {\n        // If event is hidden by workingTime configs, horizontal mapper would raise a flag on instance meta\n        // We still need to check if time span is included in axis\n        return !record.instanceMeta(this).excluded && this.timeAxis.isTimeSpanInAxis(record);\n    }\n    onElementKeyDown(keyEvent) {\n        const\n            me              = this,\n            { navigator }   = me;\n        // If we're focused in the time axis, and *not* on an event, then ENTER means\n        // jump down into the first visible assignment in the cell.\n        if (me.focusedCell?.rowIndex !== -1 && me.focusedCell?.column === me.timeAxisColumn && !keyEvent.target.closest(navigator.itemSelector) && keyEvent.key === 'Enter') {\n            const firstAssignment = me.getFirstVisibleAssignment();\n            if (firstAssignment) {\n                me.navigateTo(firstAssignment, {\n                    uiEvent : keyEvent\n                });\n                return false;\n            }\n        }\n        else {\n            super.onElementKeyDown?.(keyEvent);\n        }\n    }\n    getFirstVisibleAssignment(location = this.focusedCell) {\n        const\n            me = this,\n            {\n                currentOrientation,\n                rowManager,\n                eventStore\n            } = me;\n        if (me.isHorizontal) {\n            let renderedEvents = currentOrientation.rowMap.get(rowManager.getRow(location.rowIndex));\n            if (renderedEvents?.length) {\n                return renderedEvents[0]?.elementData.assignmentRecord;\n            }\n            else {\n                renderedEvents = currentOrientation.resourceMap.get(location.id)?.eventsData;\n                if (renderedEvents?.length) {\n                    // When events are gathered from resource, we need to check they're available\n                    return renderedEvents.filter(e => eventStore.isAvailable(e.eventRecord))[0]?.assignmentRecord;\n                }\n            }\n        }\n        else {\n            const\n                firstResource = [...currentOrientation.resourceMap.values()][0],\n                renderedEvents = firstResource && Object.values(firstResource);\n            if (renderedEvents?.length) {\n                return renderedEvents.filter(e => eventStore.isAvailable(e.renderData.eventRecord))[0].renderData.assignmentRecord;\n            }\n        }\n    }\n    onGridBodyFocusIn(focusEvent) {\n        const isGridCellFocus = focusEvent.target.closest(this.focusableSelector);\n        // Event navigation only has a say when navigation is inside the TimeAxisSubGrid\n        if (this.timeAxisSubGridElement.contains(focusEvent.target)) {\n            const\n                me                  = this,\n                { navigationEvent } = me,\n                { target }          = focusEvent,\n                eventFocus          = target.closest(me.navigator.itemSelector),\n                destinationCell     = eventFocus ? me.normalizeCellContext({\n                    rowIndex : me.isVertical ? 0\n                        : me.resourceStore.indexOf(me.resolveResourceRecord(target)),\n                    column : me.timeAxisColumn,\n                    target\n                }) : new Location(target);\n            // Don't take over what the event navigator does if it's doing event navigation.\n            // Just silently cache our actionable location.\n            if (eventFocus) {\n                const { _focusedCell } = me;\n                me._focusedCell = destinationCell;\n                me.onCellNavigate?.(me, _focusedCell, destinationCell, navigationEvent, true);\n                return;\n            }\n            // Depending on how we got here, try to focus the first event in the cell *if we're in a cell*.\n            if (isGridCellFocus && (!navigationEvent || isArrowKey[navigationEvent.key])) {\n                const firstAssignment = me.getFirstVisibleAssignment(destinationCell);\n                if (firstAssignment) {\n                    me.navigateTo(firstAssignment, {\n                        // Only change scroll if focus came from key press\n                        scrollIntoView : Boolean(navigationEvent && navigationEvent.type !== 'mousedown'),\n                        uiEvent        : navigationEvent || focusEvent\n                    });\n                    return;\n                }\n            }\n        }\n        // Grid-level focus movement, let superclass handle it.\n        if (isGridCellFocus) {\n            super.onGridBodyFocusIn(focusEvent);\n        }\n    }\n    /*\n     * Override of GridNavigation#focusCell method to handle the TimeAxisColumn.\n     * Not needed until we implement full keyboard accessibility.\n     */\n    accessibleFocusCell(cellSelector, options) {\n        const me                     = this;\n        cellSelector = me.normalizeCellContext(cellSelector);\n        if (cellSelector.columnId === me.timeAxisColumn.id) {\n        }\n        else {\n            return super.focusCell(cellSelector, options);\n        }\n    }\n    // Interface method to extract the navigated to record from a populated 'navigate' event.\n    // Gantt, Scheduler and Calendar handle event differently, adding different properties to it.\n    // This method is meant to be overridden to return correct target from event\n    normalizeTarget(event) {\n        return event.assignmentRecord;\n    }\n    getPrevious(assignmentRecord, isDelete) {\n        const\n            me                     = this,\n            { resourceStore }      = me,\n            { eventSorter }        = me.currentOrientation,\n            // start/end dates are required to limit time span to look at in case recurrence feature is enabled\n            { startDate, endDate } = me.timeAxis,\n            eventRecord            = assignmentRecord.event,\n            resourceEvents         = me.eventStore\n                .getEvents({\n                    resourceRecord : assignmentRecord.resource,\n                    startDate,\n                    endDate\n                })\n                .filter(this.isInTimeAxis)\n                .sort(eventSorter);\n        let resourceRecord = assignmentRecord.resource,\n            previousEvent  = resourceEvents[resourceEvents.indexOf(eventRecord) - 1];\n        // At first event for resource, traverse up the resource store.\n        if (!previousEvent) {\n            // If we are deleting an event, skip other instances of the event which we may encounter\n            // due to multi-assignment.\n            for (\n                let rowIdx = resourceStore.indexOf(resourceRecord) - 1;\n                (!previousEvent || (isDelete && previousEvent === eventRecord)) && rowIdx >= 0;\n                rowIdx--\n            ) {\n                resourceRecord = resourceStore.getAt(rowIdx);\n                const events = me.eventStore\n                    .getEvents({\n                        resourceRecord,\n                        startDate,\n                        endDate\n                    })\n                    .filter(me.isInTimeAxis)\n                    .sort(eventSorter);\n                previousEvent = events.length && events[events.length - 1];\n            }\n        }\n        return me.assignmentStore.getAssignmentForEventAndResource(previousEvent, resourceRecord);\n    }\n    navigatePrevious(keyEvent) {\n        const\n            me                 = this,\n            previousAssignment = me.getPrevious(me.normalizeTarget(keyEvent));\n        keyEvent.preventDefault();\n        if (previousAssignment) {\n            if (!keyEvent.ctrlKey) {\n                me.clearEventSelection();\n            }\n            return me.navigateTo(previousAssignment, {\n                uiEvent : keyEvent\n            });\n        }\n        // No previous event/task, fall back to Grid's handling of this gesture\n        return me.doGridNavigation(keyEvent);\n    }\n    getNext(assignmentRecord, isDelete) {\n        const\n            me                     = this,\n            { resourceStore }      = me,\n            { eventSorter }        = me.currentOrientation,\n            // start/end dates are required to limit time span to look at in case recurrence feature is enabled\n            { startDate, endDate } = me.timeAxis,\n            eventRecord            = assignmentRecord.event,\n            resourceEvents         = me.eventStore\n                .getEvents({\n                    resourceRecord : assignmentRecord.resource,\n                    // start/end are required to limit time\n                    startDate,\n                    endDate\n                })\n                .filter(this.isInTimeAxis)\n                .sort(eventSorter);\n        let resourceRecord = assignmentRecord.resource,\n            nextEvent      = resourceEvents[resourceEvents.indexOf(eventRecord) + 1];\n        // At last event for resource, traverse down the resource store\n        if (!nextEvent) {\n            // If we are deleting an event, skip other instances of the event which we may encounter\n            // due to multi-assignment.\n            for (let rowIdx = resourceStore.indexOf(resourceRecord) + 1; (!nextEvent || (isDelete && nextEvent === eventRecord)) && rowIdx < resourceStore.count; rowIdx++) {\n                resourceRecord = resourceStore.getAt(rowIdx);\n                const events = me.eventStore\n                    .getEvents({\n                        resourceRecord,\n                        startDate,\n                        endDate\n                    })\n                    .filter(me.isInTimeAxis)\n                    .sort(eventSorter);\n                nextEvent = events[0];\n            }\n        }\n        return me.assignmentStore.getAssignmentForEventAndResource(nextEvent, resourceRecord);\n    }\n    navigateNext(keyEvent) {\n        const\n            me             = this,\n            nextAssignment = me.getNext(me.normalizeTarget(keyEvent));\n        keyEvent.preventDefault();\n        if (nextAssignment) {\n            if (!keyEvent.ctrlKey) {\n                me.clearEventSelection();\n            }\n            return me.navigateTo(nextAssignment, {\n                uiEvent : keyEvent\n            });\n        }\n        // No next event/task, fall back to Grid's handling of this gesture\n        return me.doGridNavigation(keyEvent);\n    }\n    doGridNavigation(keyEvent) {\n        if (!keyEvent.handled && keyEvent.key.indexOf('Arrow') === 0) {\n            this[`navigate${keyEvent.key.substring(5)}ByKey`](keyEvent);\n        }\n    }\n    async navigateTo(targetAssignment, {\n        scrollIntoView = true,\n        uiEvent        = {}\n    } = emptyObject) {\n        const\n            me                      = this,\n            { navigator }           = me,\n            { skipScrollIntoView }  = navigator;\n        if (targetAssignment) {\n            if (scrollIntoView) {\n                // No key processing during scroll\n                navigator.disabled = true;\n                await me.scrollAssignmentIntoView(targetAssignment, animate100);\n                navigator.disabled = false;\n            }\n            else {\n                navigator.skipScrollIntoView = true;\n            }\n            // Panel can be destroyed before promise is resolved\n            // Perform a sanity check to make sure element is still in the DOM (syncIdMap actually).\n            if (!me.isDestroyed && this.getElementFromAssignmentRecord(targetAssignment)) {\n                me.activeAssignment = targetAssignment;\n                navigator.skipScrollIntoView = skipScrollIntoView;\n                navigator.trigger('navigate', {\n                    event : uiEvent,\n                    item  : me.getElementFromAssignmentRecord(targetAssignment).closest(navigator.itemSelector)\n                });\n            }\n        }\n    }\n    set activeAssignment(assignmentRecord) {\n        const assignmentEl = this.getElementFromAssignmentRecord(assignmentRecord, true);\n        if (assignmentEl) {\n            this.navigator.activeItem = assignmentEl;\n        }\n    }\n    get activeAssignment() {\n        const { activeItem } = this.navigator;\n        if (activeItem) {\n            return this.resolveAssignmentRecord(activeItem);\n        }\n    }\n    get previousActiveEvent() {\n        const { previousActiveItem } = this.navigator;\n        if (previousActiveItem) {\n            return this.resolveEventRecord(previousActiveItem);\n        }\n    }\n    processEvent(keyEvent) {\n        const\n            me           = this,\n            eventElement = keyEvent.target.closest(me.eventSelector);\n        if (!me.navigator.disabled && eventElement) {\n            keyEvent.assignmentRecord = me.resolveAssignmentRecord(eventElement);\n            keyEvent.eventRecord = me.resolveEventRecord(eventElement);\n            keyEvent.resourceRecord = me.resolveResourceRecord(eventElement);\n        }\n        return keyEvent;\n    }\n    onDeleteKey(keyEvent) {\n        const me = this;\n        if (!me.readOnly && me.enableDeleteKey) {\n            const records = me.eventStore.usesSingleAssignment ? me.selectedEvents : me.selectedAssignments;\n            me.removeEvents(records.filter(r => !r.readOnly));\n        }\n    }\n    onArrowUpKey(keyEvent) {\n        this.focusCell({\n            rowIndex : this.focusedCell.rowIndex - 1,\n            column   : this.timeAxisColumn\n        });\n        keyEvent.handled = true;\n    }\n    onArrowDownKey(keyEvent) {\n        if (this.focusedCell.rowIndex < this.resourceStore.count - 1) {\n            this.focusCell({\n                rowIndex : this.focusedCell.rowIndex + 1,\n                column   : this.timeAxisColumn\n            });\n            keyEvent.handled = true;\n        }\n    }\n    onEscapeKey(keyEvent) {\n        if (!keyEvent.target.closest('.b-dragging')) {\n            this.focusCell({\n                rowIndex : this.focusedCell.rowIndex,\n                column   : this.timeAxisColumn\n            });\n            keyEvent.handled = true;\n        }\n    }\n    onEventSpaceKey(keyEvent) {\n        // Empty, to be chained by features\n    }\n    onEventEnterKey(keyEvent) {\n        // Empty, to be chained by features\n    }\n    get isActionableLocation() {\n        // Override from grid if the Navigator's location is an event (or task if we're in Gantt)\n        // Being focused on a task/event means that it's *not* actionable. It's not valid to report\n        // that we're \"inside\" the cell in a TimeLine, so ESC must not attempt to focus the cell.\n        if (!this.navigator.activeItem) {\n            return super.isActionableLocation;\n        }\n    }\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "/**\n * @module Scheduler/view/mixin/TransactionalFeatureMixin\n */\n/**\n * This mixin declares a common config to disable feature transactions in components which support scheduling engine:\n * SchedulerPro and Gantt.\n * @mixin\n */\nexport default Target => class TransactionalFeatureMixin extends Target {\n    static get $name() {\n        return 'TransactionalFeatureMixin';\n    }\n    static configurable = {\n        /**\n         * When true, some features will start a project transaction, blocking the project queue, suspending\n         * store events and preventing UI from updates. It behaves similar to\n         * {@link Grid.column.Column#config-instantUpdate} set to `false`.\n         * Set `false` to not use project queue.\n         * @config {Boolean}\n         * @internal\n         * @default\n         */\n        enableTransactionalFeatures : false,\n        testConfig : {\n            enableTransactionalFeatures : false\n        }\n    };\n    get widgetClass() {}\n    /**\n     * Returns `true` if queue is supported and enabled\n     * @member {Boolean}\n     * @internal\n     * @readonly\n     */\n    get transactionalFeaturesEnabled() {\n        return this.enableTransactionalFeatures && this.project?.queue;\n    }\n};\n", "/**\n * @module Scheduler/data/mixin/AttachToProjectMixin\n */\n/**\n * Mixin that calls the target class `attachToProject()` function when a new project is assigned to Scheduler/Gantt.\n *\n * @mixin\n */\nexport default Target => class AttachToProjectMixin extends Target {\n    static get $name() {\n        return 'AttachToProjectMixin';\n    }\n    async afterConstruct() {\n        super.afterConstruct();\n        const\n            me            = this,\n            projectHolder = (me.client || me.grid),\n            { project }   = projectHolder;\n        projectHolder.projectSubscribers?.push(me);\n        // Attach to already existing stores\n        if (project) {\n            me.attachToProject(project);\n            me.attachToResourceStore(project.resourceStore);\n            me.attachToEventStore(project.eventStore);\n            me.attachToAssignmentStore(project.assignmentStore);\n            me.attachToDependencyStore(project.dependencyStore);\n            me.attachToCalendarManagerStore(project.calendarManagerStore);\n        }\n    }\n    /**\n     * Override to take action when the project instance is replaced.\n     *\n     * @param {Scheduler.model.ProjectModel} project\n     */\n    attachToProject(project) {\n        this.detachListeners('project');\n        this._project = project;\n        super.attachToProject?.(project);\n    }\n    detachFromProject(project) {\n        super.detachFromProject?.(project);\n    }\n    /**\n     * Override to take action when the EventStore instance is replaced, either from being replaced on the project or\n     * from assigning a new project.\n     *\n     * @param {Scheduler.data.EventStore} store\n     */\n    attachToEventStore(store) {\n        this.detachListeners('eventStore');\n        super.attachToEventStore?.(store);\n    }\n    /**\n     * Override to take action when the ResourceStore instance is replaced, either from being replaced on the project\n     * or from assigning a new project.\n     *\n     * @param {Scheduler.data.ResourceStore} store\n     */\n    attachToResourceStore(store) {\n        this.detachListeners('resourceStore');\n        super.attachToResourceStore?.(store);\n    }\n    /**\n     * Override to take action when the AssignmentStore instance is replaced, either from being replaced on the project\n     * or from assigning a new project.\n     *\n     * @param {Scheduler.data.AssignmentStore} store\n     */\n    attachToAssignmentStore(store) {\n        this.detachListeners('assignmentStore');\n        super.attachToAssignmentStore?.(store);\n    }\n    /**\n     * Override to take action when the DependencyStore instance is replaced, either from being replaced on the project\n     * or from assigning a new project.\n     *\n     * @param {Scheduler.data.DependencyStore} store\n     */\n    attachToDependencyStore(store) {\n        this.detachListeners('dependencyStore');\n        super.attachToDependencyStore?.(store);\n    }\n    /**\n     * Override to take action when the CalendarManagerStore instance is replaced, either from being replaced on the\n     * project or from assigning a new project.\n     *\n     * @param {Core.data.Store} store\n     */\n    attachToCalendarManagerStore(store) {\n        this.detachListeners('calendarManagerStore');\n        super.attachToCalendarManagerStore?.(store);\n    }\n    get project() {\n        return this._project;\n    }\n    get calendarManagerStore() {\n        return this.project.calendarManagerStore;\n    }\n    get assignmentStore() {\n        return this.project.assignmentStore;\n    }\n    get resourceStore() {\n        return this.project.resourceStore;\n    }\n    get eventStore() {\n        return this.project.eventStore;\n    }\n    get dependencyStore() {\n        return this.project.dependencyStore;\n    }\n};\n", "import BrowserHelper from '../../../Core/helper/BrowserHelper.js';\nimport DomSync from '../../../Core/helper/DomSync.js';\nimport Base from '../../../Core/Base.js';\nimport Model from '../../../Core/data/Model.js';\nimport ArrayHelper from '../../../Core/helper/ArrayHelper.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport AttachToProjectMixin from '../../data/mixin/AttachToProjectMixin.js';\n/**\n * @module Scheduler/view/orientation/HorizontalRendering\n */\n/**\n * @typedef HorizontalRenderData\n * @property {Scheduler.model.EventModel} eventRecord\n * @property {Date} start Span start\n * @property {Date} end Span end\n * @property {String} rowId Id of the resource row\n * @property {DomConfig[]} children Child elements\n * @property {Number} startMS Wrap element start in milliseconds\n * @property {Number} endMS Span Wrap element end in milliseconds\n * @property {Number} durationMS Wrap duration in milliseconds (not just a difference between start and end)\n * @property {Number} innerStartMS Actual event start in milliseconds\n * @property {Number} innerEndMS Actual event end in milliseconds\n * @property {Number} innerDurationMS Actual event duration in milliseconds\n * @property {Boolean} startsOutsideView True if span starts before time axis start\n * @property {Boolean} endsOutsideView True if span ends after time axis end\n * @property {Number} left Absolute left coordinate of the wrap element\n * @property {Number} width\n * @property {Number} top Absolute top coordinate of the wrap element (can be changed by layout)\n * @property {Number} height\n * @property {Boolean} clippedStart True if start is clipped\n * @property {Boolean} clippedEnd True if end is clipped\n * @private\n */\nconst\n    releaseEventActions = {\n        releaseElement : 1, // Not used at all at the moment\n        reuseElement   : 1  // Used by some other element\n    },\n    renderEventActions  = {\n        newElement      : 1,\n        reuseOwnElement : 1,\n        reuseElement    : 1\n    },\n    MAX_WIDTH           = 9999999,\n    heightEventSorter   = ({ startDateMS : lhs }, { startDateMS : rhs }) => lhs - rhs,\n    chronoFields        = {\n        startDate : 1,\n        endDate   : 1,\n        duration  : 1\n    };\nfunction getStartEnd(scheduler, eventRecord, useEnd, fieldName, useEventBuffer) {\n    // Must use Model.get in order to get latest values in case we are inside a batch.\n    // EventResize changes the endDate using batching to enable a tentative change\n    // via the batchedUpdate event which is triggered when changing a field in a batch.\n    // Fall back to accessor if propagation has not populated date fields.\n    const\n        { timeAxis }     = scheduler,\n        date             = eventRecord.isBatchUpdating && !useEventBuffer ? eventRecord.get(fieldName) : eventRecord[fieldName],\n        hasBatchedChange = eventRecord.hasBatchedChange?.(fieldName),\n        // fillTicks shouldn't be used during resizing for changing date for smooth animation.\n        // correct date will be applied after resize, when `isResizing` will be falsy\n        useTickDates     = scheduler.fillTicks && (!eventRecord.meta?.isResizing || !hasBatchedChange);\n    if (useTickDates) {\n        let tick = timeAxis.getTickFromDate(date);\n        if (tick >= 0) {\n            // If date matches a tick start/end, use the earlier tick\n            if (useEnd && tick === Math.round(tick) && tick > 0) {\n                tick--;\n            }\n            const\n                tickIndex  = Math.floor(tick),\n                tickRecord = timeAxis.getAt(tickIndex);\n            return tickRecord[fieldName].getTime();\n        }\n    }\n    return date?.getTime();\n}\n/**\n * Handles event rendering in Schedulers horizontal mode. Reacts to project/store changes to keep the UI up to date.\n *\n * @internal\n */\nexport default class HorizontalRendering extends Base.mixin(AttachToProjectMixin) {\n    //region Config & Init\n    static $name = 'HorizontalRendering';\n    static get configurable() {\n        return {\n            /**\n             * Amount of pixels to extend the current visible range at both ends with when deciding which events to\n             * render. Only applies when using labels or for milestones\n             * @config {Number}\n             * @default\n             */\n            bufferSize : 150,\n            verticalBufferSize : 150\n        };\n    }\n    static get properties() {\n        return {\n            // Map with event DOM configs, keyed by resource id\n            resourceMap            : new Map(),\n            // Map with visible events DOM configs, keyed by row instance\n            rowMap                 : new Map(),\n            eventConfigs           : [],\n            // Flag to avoid transitioning on first refresh\n            isFirstRefresh         : true,\n            toDrawOnProjectRefresh : new Set(),\n            toDrawOnDataReady      : new Set()\n        };\n    }\n    construct(scheduler) {\n        const me = this;\n        me.client = me.scheduler = scheduler;\n        me.eventSorter = me.eventSorter.bind(scheduler);\n        me.scrollBuffer = scheduler.scrollBuffer;\n        // Catch scroll before renderers are called\n        scheduler.scrollable.ion({\n            scroll  : 'onEarlyScroll',\n            prio    : 1,\n            thisObj : me\n        });\n        scheduler.rowManager.ion({\n            name            : 'rowManager',\n            renderDone      : 'onRenderDone',\n            removeRows      : 'onRemoveRows',\n            translateRow    : 'onTranslateRow',\n            offsetRows      : 'onOffsetRows',\n            beforeRowHeight : 'onBeforeRowHeightChange',\n            thisObj         : me\n        });\n        super.construct({});\n    }\n    init() {}\n    updateVerticalBufferSize() {\n        const { rowManager } = this.scheduler;\n        if (this.scheduler.isPainted) {\n            // Refresh rows when vertical buffer size changes to trigger event repaint. Required for the export feature.\n            rowManager.renderRows(rowManager.rows);\n        }\n    }\n    //endregion\n    //region Region, dates & coordinates\n    get visibleDateRange() {\n        return this._visibleDateRange;\n    }\n    getDateFromXY(xy, roundingMethod, local, allowOutOfRange = false) {\n        const { scheduler } = this;\n        let coord = xy[0];\n        if (!local) {\n            coord = this.translateToScheduleCoordinate(coord);\n        }\n        coord = scheduler.getRtlX(coord);\n        return scheduler.timeAxisViewModel.getDateFromPosition(coord, roundingMethod, allowOutOfRange);\n    }\n    translateToScheduleCoordinate(x) {\n        const\n            { scheduler }  = this,\n            { scrollable } = scheduler.timeAxisSubGrid;\n        let result = x - scheduler.timeAxisSubGridElement.getBoundingClientRect().left - globalThis.scrollX;\n        // Because we use getBoundingClientRect's left, we have to adjust for page scroll.\n        // The vertical counterpart uses the _bodyRectangle which was created with that adjustment.\n        if (scheduler.rtl) {\n            result += scrollable.maxX - Math.abs(scheduler.scrollLeft);\n        }\n        else {\n            result += scheduler.scrollLeft;\n        }\n        return result;\n    }\n    translateToPageCoordinate(x) {\n        const\n            { scheduler }  = this,\n            { scrollable } = scheduler.timeAxisSubGrid;\n        let result = x + scheduler.timeAxisSubGridElement.getBoundingClientRect().left;\n        if (scheduler.rtl) {\n            result -= scrollable.maxX - Math.abs(scheduler.scrollLeft);\n        }\n        else {\n            result -= scheduler.scrollLeft;\n        }\n        return result;\n    }\n    /**\n     * Gets the region, relative to the page, represented by the schedule and optionally only for a single resource.\n     * This method will call getDateConstraints to allow for additional resource/event based constraints. By overriding\n     * that method you can constrain events differently for different resources.\n     * @param {Scheduler.model.ResourceModel} [resourceRecord] (optional) The row record\n     * @param {Scheduler.model.EventModel} [eventRecord] (optional) The event record\n     * @returns {Core.helper.util.Rectangle} The region of the schedule\n     */\n    getScheduleRegion(resourceRecord, eventRecord, local = true, dateConstraints, stretch = false) {\n        const\n            me                                   = this,\n            { scheduler }                        = me,\n            { timeAxisSubGridElement, timeAxis } = scheduler,\n            { start, end }                       = (!stretch || resourceRecord) && scheduler.getResourceMarginObject(resourceRecord) || { start : 0, end : 0 };\n        let region;\n        if (resourceRecord) {\n            const\n                row          = scheduler.getRowById(resourceRecord.id),\n                eventElement = eventRecord && scheduler.getElementsFromEventRecord(eventRecord, resourceRecord)[0];\n            // If the row is in rendered space, use its rectangle.\n            // If not, use the calculated rectangle. This will be adjusted as we respond\n            // to change events\n            region = row ? Rectangle.from(row.getElement('normal'), timeAxisSubGridElement) : scheduler.getRecordCoords(resourceRecord, true);\n            if (eventElement) {\n                const eventRegion = Rectangle.from(eventElement, timeAxisSubGridElement);\n                region.y      = eventRegion.y;\n                region.bottom = eventRegion.bottom;\n            }\n            else {\n                region.y      = region.y + start;\n                region.bottom = region.bottom - end;\n            }\n        }\n        else {\n            // The coordinate space needs to be sorted out here!\n            region       = Rectangle.from(timeAxisSubGridElement).moveTo(null, 0);\n            region.width = timeAxisSubGridElement.scrollWidth;\n            region.y      = region.y + start;\n            region.bottom = region.bottom - end;\n        }\n        const\n            taStart = timeAxis.startDate,\n            taEnd   = timeAxis.endDate;\n        dateConstraints = (dateConstraints?.start && dateConstraints) || scheduler.getDateConstraints?.(resourceRecord, eventRecord) || {\n            start : taStart,\n            end   : taEnd\n        };\n        let startX = scheduler.getCoordinateFromDate(dateConstraints.start ? DateHelper.max(taStart, dateConstraints.start) : taStart),\n            endX   = scheduler.getCoordinateFromDate(dateConstraints.end ? DateHelper.min(taEnd, dateConstraints.end) : taEnd);\n        if (!local) {\n            startX = me.translateToPageCoordinate(startX);\n            endX   = me.translateToPageCoordinate(endX);\n        }\n        region.left  = Math.min(startX, endX);\n        region.right = Math.max(startX, endX);\n        return region;\n    }\n    /**\n     * Gets the Region, relative to the timeline view element, representing the passed row and optionally just for a\n     * certain date interval.\n     * @param {Core.data.Model} rowRecord The row record\n     * @param {Date} startDate A start date constraining the region\n     * @param {Date} endDate An end date constraining the region\n     * @returns {Core.helper.util.Rectangle} The Rectangle which encapsulates the row\n     */\n    getRowRegion(rowRecord, startDate, endDate) {\n        const\n            { scheduler } = this,\n            { timeAxis }  = scheduler,\n            row           = scheduler.getRowById(rowRecord.id);\n        // might not be rendered\n        if (!row) {\n            return null;\n        }\n        const\n            taStart = timeAxis.startDate,\n            taEnd   = timeAxis.endDate,\n            start   = startDate ? DateHelper.max(taStart, startDate) : taStart,\n            end     = endDate ? DateHelper.min(taEnd, endDate) : taEnd,\n            startX  = scheduler.getCoordinateFromDate(start),\n            endX    = scheduler.getCoordinateFromDate(end, true, true),\n            y       = row.top,\n            x       = Math.min(startX, endX),\n            bottom  = y + row.offsetHeight;\n        return new Rectangle(x, y, Math.max(startX, endX) - x, bottom - y);\n    }\n    getResourceEventBox(eventRecord, resourceRecord, includeOutside, roughly = false) {\n        const\n            { scheduler } = this,\n            resourceData  = this.resourceMap.get(resourceRecord.id);\n        let eventLayout = null,\n            approx      = false;\n        if (resourceData) {\n            eventLayout = resourceData.eventsData.find(d => d.eventRecord === eventRecord);\n        }\n        // Outside of view, layout now if supposed to be included\n        if (!eventLayout) {\n            eventLayout = this.getTimeSpanRenderData(\n                eventRecord,\n                resourceRecord,\n                { viewport : true, timeAxis : includeOutside }\n            );\n            approx = true;\n        }\n        if (eventLayout) {\n            // Event layout is relative to row, need to make to absolute before returning\n            const\n                // Event might be outside visible area, estimate the height (for managedEventSizing = false case)\n                boxHeight   = eventLayout.height ?? scheduler.getResourceLayoutSettings(resourceRecord).contentHeight,\n                rowBox      = scheduler.rowManager.getRecordCoords(resourceRecord, true, roughly),\n                absoluteTop = eventLayout.top + rowBox.top,\n                box         = new Rectangle(eventLayout.left, absoluteTop, eventLayout.width, boxHeight);\n            // Flag informing other parts of the code that this box is approximated\n            box.layout    = !approx;\n            box.rowTop    = rowBox.top;\n            box.rowBottom = rowBox.bottom;\n            box.resourceId = resourceRecord.id;\n            return box;\n        }\n        return null;\n    }\n    //endregion\n    //region Element <-> Record mapping\n    resolveRowRecord(elementOrEvent) {\n        const\n            me            = this,\n            { scheduler } = me,\n            element       = elementOrEvent.nodeType ? elementOrEvent : elementOrEvent.target,\n            // Fix for FF on Linux having text nodes as event.target\n            el            = element.nodeType === Element.TEXT_NODE ? element.parentElement : element,\n            eventNode     = el.closest(scheduler.eventSelector);\n        if (eventNode) {\n            return me.resourceStore.getById(eventNode.dataset.resourceId);\n        }\n        // When resourceNonWorkingTime.enableMouseEvents is set to true, and the current element is a resource non working time range,\n        // in order to get the corresponding resource row, we need to read from data-resource-id attribute.\n        // That's because element has not a .b-grid-row as parent when enableMouseEvents is set to true.\n        if (!el.closest('.b-grid-row') && el.dataset.resourceId) {\n            return me.resourceStore.getById(el.dataset.resourceId);\n        }\n        return scheduler.getRecordFromElement(el);\n    }\n    //endregion\n    //region Project\n    attachToProject(project) {\n        super.attachToProject(project);\n        this.refreshAllWhenReady = true;\n        // Perform a full clear when replacing the project, to not leave any references to old project in DOM\n        if (!this.scheduler.isConfiguring) {\n            this.clearAll({ clearDom : true });\n        }\n        project?.ion({\n            name            : 'project',\n            refresh         : 'onProjectRefresh',\n            commitFinalized : 'onProjectCommitFinalized',\n            thisObj         : this\n        });\n    }\n    onProjectCommitFinalized() {\n        const { scheduler, toDrawOnDataReady, project } = this;\n        // Only update the UI immediately if we are visible\n        if (scheduler.isVisible) {\n            if (scheduler.isPainted && !scheduler.refreshSuspended) {\n                // If this is a timezone commit, we got here from a store dataset\n                // We need to do a full refresh\n                if (!toDrawOnDataReady.size && project.timeZone != null && project.ignoreRecordChanges) {\n                    project.resourceStore.forEach(r => toDrawOnDataReady.add(r.id));\n                }\n                if (toDrawOnDataReady.size) {\n                    this.clearResources(toDrawOnDataReady);\n                    this.refreshResources(toDrawOnDataReady);\n                }\n                toDrawOnDataReady.clear();\n            }\n        }\n        // Otherwise wait till next time we get painted (shown, or a hidden ancestor shown)\n        else {\n            scheduler.whenVisible('refreshRows');\n        }\n    }\n    onProjectRefresh({ isCalculated, isInitialCommit }) {\n        const\n            me                                    = this,\n            { scheduler, toDrawOnProjectRefresh } = me;\n        // Only update the UI immediately if we are visible\n        if (scheduler.isVisible) {\n            if (scheduler.isPainted && !scheduler.isConfiguring && !scheduler.refreshSuspended) {\n                // Either refresh all rows (on for example dataset or when delayed calculations are finished)\n                if (me.refreshAllWhenReady || (isInitialCommit && isCalculated)) {\n                    scheduler.calculateAllRowHeights(true);\n                    const { rowManager } = scheduler;\n                    // Rows rendered? Refresh\n                    if (rowManager.topRow) {\n                        me.clearAll();\n                        // Refresh only if it won't be refreshed elsewhere (SchedulerStore#onProjectRefresh())\n                        if (!scheduler.refreshAfterProjectRefresh) {\n                            // If refresh was suspended when replacing the dataset in a scrolled view we might end up with a\n                            // topRow outside of available range -> reset it. Call renderRows() to mimic what normally happens\n                            // when refresh is not suspended\n                            if (rowManager.topRow.dataIndex >= scheduler.store.count) {\n                                scheduler.renderRows(false);\n                            }\n                            else {\n                                // Don't transition first refresh / early render\n                                scheduler.refreshWithTransition(false, !me.isFirstRefresh && isCalculated && !isInitialCommit);\n                            }\n                        }\n                        me.isFirstRefresh = false;\n                    }\n                    // No rows yet, reinitialize (happens if initial project empty and then non empty project assigned)\n                    else {\n                        rowManager.reinitialize();\n                    }\n                    me.refreshAllWhenReady = false;\n                }\n                // Or only affected rows (if any)\n                else if (toDrawOnProjectRefresh.size) {\n                    me.refreshResources(toDrawOnProjectRefresh);\n                }\n                toDrawOnProjectRefresh.clear();\n            }\n        }\n        // Otherwise wait till next time we get painted (shown, or a hidden ancestor shown)\n        else {\n            scheduler.whenVisible('refresh', scheduler, [true]);\n        }\n    }\n    //endregion\n    //region AssignmentStore\n    attachToAssignmentStore(assignmentStore) {\n        this.refreshAllWhenReady = true;\n        super.attachToAssignmentStore(assignmentStore);\n        if (assignmentStore) {\n            assignmentStore.ion({\n                name             : 'assignmentStore',\n                changePreCommit  : 'onAssignmentStoreChange',\n                refreshPreCommit : 'onAssignmentStoreRefresh',\n                thisObj          : this\n            });\n        }\n    }\n    onAssignmentStoreChange({ source, action, records : assignmentRecords = [], replaced, changes }) {\n        const\n            me            = this,\n            { scheduler } = me,\n            resourceIds   = new Set(assignmentRecords.flatMap(assignmentRecord => ([\n                assignmentRecord.resourceId,\n                // Also include any linked resources (?. twice since resource might not be resolved and point to id)\n                ...assignmentRecord.resource?.$links?.map(link => link.id) ?? []\n            ])));\n        // Ignore assignment changes caused by removing resources, the remove will redraw things anyway\n        // Also ignore case when resource id is changed. In this case row will be refreshed by the grid\n        if (me.resourceStore.isRemoving || me.resourceStore.isChangingId) {\n            return;\n        }\n        switch (action) {\n            // These operations will invalidate the graph, need to draw later\n            case 'dataset': {\n                // Ignore dataset when using single assignment mode\n                if (!me.eventStore.usesSingleAssignment) {\n                    if (resourceIds.size) {\n                        me.refreshResourcesWhenReady(resourceIds);\n                    }\n                    else {\n                        me.clearAll();\n                        scheduler.refreshWithTransition();\n                    }\n                }\n                return;\n            }\n            case 'add':\n            case 'remove':\n            case 'updateMultiple':\n                me.refreshResourcesWhenReady(resourceIds);\n                return;\n            case 'removeall':\n                me.refreshAllWhenReady = true;\n                return;\n            case 'replace':\n                // Gather resources from both the old record and the new one\n                replaced.forEach(([oldAssignment, newAssignment]) => {\n                    resourceIds.add(oldAssignment.resourceId);\n                    resourceIds.add(newAssignment.resourceId);\n                });\n                // And refresh them\n                me.refreshResourcesWhenReady(resourceIds);\n                return;\n            // These operations won't invalidate the graph, redraw now\n            case 'filter':\n                me.clearAll();\n                scheduler.calculateAllRowHeights(true);\n                scheduler.refreshWithTransition();\n                return;\n            case 'update': {\n                if ('eventId' in changes || 'resourceId' in changes || 'id' in changes) {\n                    // When reassigning, clear old resource also\n                    if ('resourceId' in changes) {\n                        resourceIds.add(changes.resourceId.oldValue);\n                    }\n                    // When chaining stores in single assignment mode, we might not be the project store\n                    if (source === scheduler.project.assignmentStore) {\n                        me.refreshResourcesOnDataReady(resourceIds);\n                    }\n                    // Refresh directly when we are not\n                    else {\n                        me.refreshResources(resourceIds);\n                    }\n                }\n                break;\n            }\n            case 'clearchanges': {\n                const { added, modified, removed } = changes;\n                // If modified records appear in the clearchanges action we need to refresh entire view\n                // because we have not enough information about previously assigned resource\n                if (modified.length) {\n                    scheduler.refreshWithTransition();\n                }\n                else {\n                    added.forEach(r => resourceIds.add(r.resourceId));\n                    removed.forEach(r => resourceIds.add(r.resourceId));\n                    me.refreshResourcesOnDataReady(resourceIds);\n                }\n            }\n        }\n    }\n    onAssignmentStoreRefresh({ action, records }) {\n        if (action === 'batch') {\n            this.clearAll();\n            this.scheduler.refreshWithTransition();\n        }\n    }\n    //endregion\n    //region EventStore\n    attachToEventStore(eventStore) {\n        this.refreshAllWhenReady = true;\n        super.attachToEventStore(eventStore);\n        if (eventStore) {\n            eventStore.ion({\n                name             : 'eventStore',\n                addConfirmed     : 'onEventStoreAddConfirmed',\n                refreshPreCommit : 'onEventStoreRefresh',\n                thisObj          : this\n            });\n        }\n    }\n    onEventStoreAddConfirmed({ record }) {\n        for (const element of this.client.getElementsFromEventRecord(record)) {\n            element.classList.remove('b-iscreating');\n        }\n    }\n    onEventStoreRefresh({ action }) {\n        if (action === 'batch') {\n            const { scheduler } = this;\n            if (scheduler.isEngineReady && scheduler.isPainted) {\n                this.clearAll();\n                scheduler.refreshWithTransition();\n            }\n        }\n    }\n    onEventStoreChange({ action, records : eventRecords = [], record, replaced, changes, source }) {\n        const\n            me                  = this,\n            { scheduler }       = me,\n            isResourceTimeRange = source.isResourceTimeRangeStore,\n            resourceIds         = new Set();\n        if (!scheduler.isPainted) {\n            return;\n        }\n        eventRecords.forEach(eventRecord => {\n            // Update all resource rows to which this event is assigned *if* the resourceStore\n            // contains that resource (We could have filtered the resourceStore)\n            const renderedEventResources = eventRecord.$linkedResources?.filter(r => me.resourceStore.includes(r));\n            // When rendering a Gantt project, the project model also passes through here -> no `resources`\n            renderedEventResources?.forEach(resourceRecord => resourceIds.add(resourceRecord.id));\n        });\n        if (isResourceTimeRange) {\n            switch (action) {\n                // - dataset cant pass through same path as events, which relies on project being invalidated. and\n                // resource time ranges does not pass through engine\n                // - removeall also needs special path, since no resources to redraw will be collected\n                case 'removeall':\n                case 'dataset':\n                    me.clearAll();\n                    scheduler.refreshWithTransition();\n                    return;\n            }\n            me.refreshResources(resourceIds);\n        }\n        else {\n            switch (action) {\n                // No-ops\n                case 'batch': // Handled elsewhere, don't want it to clear again\n                case 'sort':  // Order in EventStore does not matter, so these actions are no-ops\n                case 'group':\n                case 'move':\n                    return;\n                case 'remove':\n                    // Remove is a no-op since assignment will also be removed\n                    return;\n                case 'clearchanges':\n                    me.clearAll();\n                    scheduler.refreshWithTransition();\n                    return;\n                case 'dataset': {\n                    me.clearAll();\n                    // This is mainly for chained stores, where data is set from main store without project being\n                    // invalidated. Nothing to wait for, refresh now\n                    if (scheduler.isEngineReady) {\n                        scheduler.refreshWithTransition();\n                    }\n                    else {\n                        me.refreshAllWhenReady = true;\n                    }\n                    return;\n                }\n                case 'add':\n                case 'updateMultiple':\n                    // Just refresh below\n                    break;\n                case 'replace':\n                    // Gather resources from both the old record and the new one\n                    replaced.forEach(([, newEvent]) => {\n                        // Old cleared by changed assignment\n                        newEvent.resources.map(resourceRecord => resourceIds.add(resourceRecord.id));\n                    });\n                    break;\n                case 'removeall':\n                case 'filter':\n                    // Filter might be caused by add retriggering filters, in which case we need to refresh later\n                    if (!scheduler.isEngineReady) {\n                        me.refreshAllWhenReady = true;\n                        return;\n                    }\n                    // Clear all when filtering for simplicity. If that turns out to give bad performance, one would need to\n                    // figure out which events was filtered out and only clear their resources.\n                    me.clearAll();\n                    scheduler.calculateAllRowHeights(true);\n                    scheduler.refreshWithTransition();\n                    return;\n                case 'update': {\n                    // Check if changes are graph related or not\n                    const allChrono = record.$entity\n                        ? !Object.keys(changes).some(name => !record.$entity.getField(name))\n                        : !Object.keys(changes).some(name => !chronoFields[name]);\n                    let dateChanges = 0;\n                    'startDate' in changes && dateChanges++;\n                    'endDate' in changes && dateChanges++;\n                    'duration' in changes && dateChanges++;\n                    if ('resourceId' in changes) {\n                        resourceIds.add(changes.resourceId.oldValue);\n                    }\n                    // If we have a set of resources to update, refresh them.\n                    // Always redraw non chrono changes (name etc) and chrono changes that can affect appearance\n                    if (\n                        resourceIds.size && (\n                            !allChrono ||\n                            // Skip case when changed \"duration\" only (w/o start/end affected)\n                            dateChanges && !('duration' in changes && dateChanges === 1) ||\n                            'percentDone' in changes ||\n                            'inactive' in changes ||\n                            'constraintDate' in changes ||\n                            'constraintType' in changes ||\n                            'segments' in changes\n                        )\n                    ) {\n                        const { eventResize, eventDragCreate } = scheduler.features;\n                        // Cheaper updates when resizing/drag creating using lockLayout\n                        if (record.isBatchUpdating && ((eventResize?.isResizing && eventResize.lockLayout) || (eventDragCreate?.isResizing && eventDragCreate.lockLayout))) {\n                            for (const id of resourceIds) {\n                                me.refreshEventsForResource(scheduler.resourceStore.getById(id), undefined, false);\n                            }\n                            me.onRenderDone();\n                        }\n                        // If we are finalizing data loading let's delay the resources refresh till all the\n                        // propagation results get into stores\n                        else if (me.project?.propagatingLoadChanges || me.project?.isWritingData) {\n                            me.refreshResourcesOnDataReady(resourceIds);\n                        }\n                        else {\n                            me.refreshResources(resourceIds);\n                        }\n                    }\n                    return;\n                }\n            }\n            me.refreshResourcesWhenReady(resourceIds);\n        }\n    }\n    //endregion\n    //region ResourceStore\n    attachToResourceStore(resourceStore) {\n        this.refreshAllWhenReady = true;\n        super.attachToResourceStore(resourceStore);\n        if (resourceStore) {\n            this.clearAll({ clearLayoutCache : true });\n            resourceStore.ion({\n                name            : 'resourceStore',\n                changePreCommit : 'onResourceStoreChange',\n                thisObj         : this\n            });\n        }\n    }\n    get resourceStore() {\n        return this.client.store;\n    }\n    onResourceStoreChange({ action, isExpand, records, changes }) {\n        const\n            me          = this,\n            // Update link + original when asked for link\n            resourceIds = records?.flatMap(r => r.isLinked ? [r.id, r.$originalId] : [r.id]);\n        if (!me.scheduler.isPainted) {\n            return;\n        }\n        switch (action) {\n            case 'add':\n                // #635 Events disappear when toggling other node\n                // If we are expanding project won't fire refresh event\n                if (!isExpand) {\n                    // Links won't cause calculations, refresh now\n                    if (records.every(r => r.isLinked)) {\n                        me.refreshResources(resourceIds);\n                    }\n                    // Otherwise refresh when project is ready\n                    else {\n                        me.refreshResourcesWhenReady(resourceIds);\n                    }\n                }\n                return;\n            case 'update': {\n                // Ignore changes from project commit, if they affect events they will be redrawn anyway\n                // Also ignore explicit transformation of leaf <-> parent\n                if (!me.project.isChangeTrackingSuspended && !changes.isLeaf) {\n                    // Resource changes might affect events, refresh\n                    me.refreshResources(resourceIds);\n                }\n                return;\n            }\n            case 'filter':\n                // Bail out on filter action. Map was already updated on `refresh` event triggered before this `change`\n                // one. And extra records are removed from rowMap by `onRemoveRows`\n                return;\n            case 'removeall':\n                me.clearAll({ clearLayoutCache : true });\n                return;\n            // We must not clear all resources when whole dataset changes\n            // https://github.com/bryntum/support/issues/3292\n            case 'dataset':\n                return;\n        }\n        resourceIds && me.clearResources(resourceIds);\n    }\n    //endregion\n    //region RowManager\n    onTranslateRow({ row }) {\n        // Newly added rows are translated prior to having an id, rule those out since they will be rendered later\n        if (row.id != null) {\n            // Event layouts are stored relative to the resource, only need to rerender the row to have its absolute\n            // position updated to match new translation\n            this.refreshEventsForResource(row, false);\n        }\n    }\n    // RowManager error correction, cached layouts will no longer match.\n    // Redraw to have events correctly positioned for dependency feature to draw to their elements\n    onOffsetRows() {\n        this.clearAll();\n        this.doUpdateTimeView();\n    }\n    // Used to pre-calculate row heights\n    calculateRowHeight(resourceRecord) {\n        const\n            { scheduler } = this,\n            rowHeight     = scheduler.getResourceHeight(resourceRecord),\n            eventLayout   = scheduler.getEventLayout(resourceRecord),\n            layoutType    = eventLayout.type,\n            lockLayout    = scheduler.features.eventResize?.lockLayout;\n        if (\n            layoutType === 'stack' &&\n            scheduler.isEngineReady &&\n            !resourceRecord.isSpecialRow &&\n            // Generated parents when TreeGrouping do not have assigned bucket\n            resourceRecord.assigned?.size > 1\n        ) {\n            const\n                {\n                    assignmentStore,\n                    eventStore,\n                    timeAxis\n                }                  = scheduler,\n                {\n                    barMargin,\n                    resourceMarginObject : { total },\n                    contentHeight\n                }                  = scheduler.getResourceLayoutSettings(resourceRecord),\n                // When using an AssignmentStore we will get all events for the resource even if the EventStore is\n                // filtered\n                eventFilter        = (eventStore.isFiltered || assignmentStore.isFiltered) && (eventRecord =>\n                    eventRecord.assignments.some(a => a.resource === resourceRecord.$original && assignmentStore.includes(a))),\n                events             = eventStore\n                    .getEvents({\n                        resourceRecord,\n                        includeOccurrences : scheduler.enableRecurringEvents,\n                        startDate          : timeAxis.startDate,\n                        endDate            : timeAxis.endDate,\n                        filter             : eventFilter\n                    })\n                    .sort(heightEventSorter)\n                    .map(eventRecord => {\n                        const\n                            useCurrent = eventRecord.isBatchUpdating && !(lockLayout && eventRecord.meta?.isResizing),\n                            // Must use Model.get in order to get latest values in case we are inside a batch.\n                            // EventResize changes the endDate using batching to enable a tentative change\n                            // via the batchedUpdate event which is triggered when changing a field in a batch.\n                            // Fall back to accessor if propagation has not populated date fields.\n                            startDate  = useCurrent ? eventRecord.get('startDate') : eventRecord.startDate,\n                            endDate    = useCurrent ? eventRecord.get('endDate') : eventRecord.endDate || startDate;\n                        return {\n                            eventRecord,\n                            resourceRecord,\n                            startMS : startDate.getTime(),\n                            endMS   : endDate.getTime()\n                        };\n                    }),\n                layoutHandler      = scheduler.getEventLayoutHandler(eventLayout),\n                nbrOfBandsRequired = layoutHandler.layoutEventsInBands(events, resourceRecord, true);\n            if (layoutHandler.type === 'layoutFn') {\n                return nbrOfBandsRequired;\n            }\n            return (nbrOfBandsRequired * contentHeight) + ((nbrOfBandsRequired - 1) * barMargin) + total;\n        }\n        return rowHeight;\n    }\n    //endregion\n    //region TimeAxis\n    doUpdateTimeView() {\n        const { scrollable } = this.scheduler.timeAxisSubGrid;\n        // scrollLeft is the DOM's concept which is -ve in RTL mode.\n        // scrollX is always the +ve scroll offset from the origin.\n        // Both may be needed for different calculations.\n        this.updateFromHorizontalScroll(scrollable.x, true);\n    }\n    onTimeAxisViewModelUpdate() {\n        const\n            me            = this,\n            { scheduler } = me;\n        me.clearAll();\n        // If refresh is suspended, update timeView as soon as refresh gets unsuspended\n        if (scheduler.refreshSuspended) {\n            me.detachListeners('renderingSuspend');\n            scheduler.ion({\n                name : 'renderingSuspend',\n                resumeRefresh({ trigger }) {\n                    // This code will try to refresh rows, but resumeRefresh event doesn't guarantee rowManager rows are\n                    // in actual state. e.g. if resources were removed during a suspended refresh rowManager won't get a\n                    // chance to update them until `refresh` event from the project. We can safely update the view only\n                    // if engine in ready (not committing), otherwise we leave refresh a liability of normal project refresh\n                    // logic. Covered by SchedulerRendering.t.js\n                    // https://github.com/bryntum/support/issues/1462\n                    if (scheduler.isEngineReady && trigger) {\n                        me.doUpdateTimeView();\n                    }\n                },\n                thisObj : me,\n                once    : true\n            });\n        }\n        // Call update anyway. If refresh is suspended this call will only update visible date range and will not redraw rows\n        me.doUpdateTimeView();\n    }\n    //endregion\n    //region Dependency connectors\n    /**\n     * Gets displaying item start side\n     *\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @returns {'start'|'end'|'top'|'bottom'} 'start' / 'end' / 'top' / 'bottom'\n     */\n    getConnectorStartSide(eventRecord) {\n        return 'start';\n    }\n    /**\n     * Gets displaying item end side\n     *\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @returns {'start'|'end'|'top'|'bottom'} 'start' / 'end' / 'top' / 'bottom'\n     */\n    getConnectorEndSide(eventRecord) {\n        return 'end';\n    }\n    //endregion\n    //region Scheduler hooks\n    refreshRows(reLayoutEvents) {\n        if (reLayoutEvents) {\n            this.clearAll();\n        }\n    }\n    // Clear events in case they use date as part of displayed info\n    onLocaleChange() {\n        this.clearAll();\n    }\n    // Called when viewport size changes\n    onViewportResize(width, height, oldWidth, oldHeight) {\n        // We don't draw events for all rendered rows, \"refresh\" when height changes to make sure events in previously\n        // invisible rows gets displayed\n        if (height > oldHeight) {\n            this.onRenderDone();\n        }\n    }\n    // Called from EventDrag\n    onDragAbort({ context, dragData }) {\n        // Aborted a drag in a scrolled scheduler, with origin now out of view. Element is no longer needed\n        if (this.resourceStore.indexOf(dragData.record.resource) < this.scheduler.topRow.dataIndex) {\n            context.element.remove();\n        }\n    }\n    // Called from EventSelection\n    toggleCls(assignmentRecord, cls, add = true, useWrapper = false, checkReleased = false) {\n        const\n            element      = this.client.getElementFromAssignmentRecord(assignmentRecord, useWrapper, checkReleased),\n            resourceData = this.resourceMap.get(assignmentRecord.isModel ? assignmentRecord.get('resourceId') : assignmentRecord.resourceId),\n            eventData    = resourceData?.eventsData.find(d => d.eventId === assignmentRecord.eventId);\n        // Update cached config\n        if (eventData) {\n            eventData[useWrapper ? 'wrapperCls' : 'cls'][cls] = add;\n        }\n        // Live update element\n        if (element) {\n            // Update element\n            element.classList.toggle(cls, add);\n            // And its DOM config\n            element.lastDomConfig.className[cls] = add;\n        }\n    }\n    // React to rows being removed, refreshes view without any relayouting needed since layout is cached relative to row\n    onRemoveRows({ rows }) {\n        rows.forEach(row => this.rowMap.delete(row));\n        this.onRenderDone();\n    }\n    // Reset renderer flag before any renderers are called\n    onEarlyScroll() {\n        this.rendererCalled = false;\n    }\n    // If vertical scroll did not cause a renderer to be called we still want to update since we only draw events in\n    // view, \"independent\" from their rows\n    updateFromVerticalScroll() {\n        this.fromScroll = true;\n        if (!this.rendererCalled) {\n            this.onRenderDone();\n        }\n    }\n    // Update header range on horizontal scroll. No need to draw any tasks, Gantt only cares about vertical scroll\n    updateFromHorizontalScroll(scrollX, force) {\n        const\n            me            = this,\n            {\n                scheduler,\n                scrollBuffer\n            }             = me,\n            renderAll     = scrollBuffer === -1,\n            {\n                timeAxisSubGrid,\n                timeAxis,\n                rtl\n            }             = scheduler,\n            { width }     = timeAxisSubGrid,\n            { totalSize } = scheduler.timeAxisViewModel,\n            start         = scrollX,\n            // If there are few pixels left from the right most position then just render all remaining ticks,\n            // there wouldn't be many. It makes end date reachable with more page zoom levels while not having any poor\n            // implications.\n            // 5px to make TimeViewRangePageZoom test stable in puppeteer.\n            returnEnd     = timeAxisSubGrid.scrollable.maxX !== 0 && Math.abs(timeAxisSubGrid.scrollable.maxX) <= Math.round(start) + 5,\n            startDate     = renderAll ? timeAxis.startDate : scheduler.getDateFromCoord({ coord : Math.max(0, start - scrollBuffer), ignoreRTL : true }),\n            endDate       = returnEnd || renderAll ? timeAxis.endDate : (scheduler.getDateFromCoord({ coord : start + width + scrollBuffer, ignoreRTL : true }) || timeAxis.endDate);\n        if (\n            startDate && !scheduler._viewPresetChanging &&\n            // If rendering all, no action needed if scrolling horizontally unless start/end/tick size etc changes\n            (!renderAll || force || (startDate - (me._visibleDateRange?.startDate || 0)) || (endDate - (me._visibleDateRange?.endDate || 0)))\n        ) {\n            me._visibleDateRange = { startDate, endDate, startMS : startDate.getTime(), endMS : endDate.getTime() };\n            me.viewportCoords    = renderAll ? { left : 0, right : totalSize } : rtl\n                // RTL starts all the way to the right (and goes in opposite direction)\n                ? { left : totalSize - scrollX - width + scrollBuffer, right : totalSize - scrollX - scrollBuffer }\n                // LTR all the way to the left\n                : { left : scrollX - scrollBuffer, right : scrollX + width + scrollBuffer };\n            // Update timeaxis header making it display the new dates\n            const range = scheduler.timeView.range = { startDate, endDate };\n            scheduler.internalOnVisibleDateRangeChange(range);\n            // If refresh is suspended, someone else is responsible for updating the UI later\n            if (!scheduler.refreshSuspended && scheduler.rowManager.rows.length) {\n                // Gets here too early in Safari for ResourceHistogram. ResizeObserver triggers a scroll before rows are\n                // rendered first time. Could not track down why, bailing out\n                if (scheduler.rowManager.rows[0].id === null) {\n                    return;\n                }\n                me.fromScroll = true;\n                scheduler.rowManager.rows.forEach(row => me.refreshEventsForResource(row, false, false));\n                me.onRenderDone();\n            }\n        }\n    }\n    // Called from SchedulerEventRendering\n    repaintEventsForResource(resourceRecord) {\n        this.refreshResources([resourceRecord.id]);\n    }\n    onBeforeRowHeightChange() {\n        // Row height is cached per resource, all have to be re-laid out\n        this.clearAll();\n    }\n    //endregion\n    //region Refresh resources\n    refreshResourcesOnDataReady(resourceIds) {\n        resourceIds.forEach(id => this.toDrawOnDataReady.add(id));\n    }\n    /**\n     * Clears resources directly and redraws them on next project refresh\n     * @param {Number[]|String[]} resourceIds\n     * @private\n     */\n    refreshResourcesWhenReady(resourceIds) {\n        this.clearResources(resourceIds);\n        resourceIds.forEach(id => this.toDrawOnProjectRefresh.add(id));\n    }\n    /**\n     * Clears and redraws resources directly. Respects schedulers refresh suspension\n     * @param {Number[]|String[]} ids Resource ids\n     * @param {Boolean} [transition] Use transition or not\n     * @private\n     */\n    refreshResources(ids, transition = true) {\n        const\n            me            = this,\n            { scheduler } = me;\n        me.clearResources(ids);\n        if (!scheduler.refreshSuspended) {\n            const\n                rows   = [],\n                noRows = [];\n            ids.forEach(id => {\n                const row = scheduler.getRowById(id);\n                if (row) {\n                    rows.push(row);\n                }\n                else {\n                    noRows.push(row);\n                }\n            });\n            scheduler.runWithTransition(() => {\n                // Rendering rows populates row heights, but not all resources might have a row in view\n                scheduler.calculateRowHeights(noRows.map(id => this.resourceStore.getById(id)), true);\n                // Render those that do\n                scheduler.rowManager.renderRows(rows);\n            }, transition);\n        }\n    }\n    //endregion\n    //region Stack & pack\n    layoutEventVerticallyStack(bandIndex, eventRecord, resourceRecord) {\n        const\n            {\n                barMargin,\n                resourceMarginObject : { start },\n                contentHeight\n            } = this.scheduler.getResourceLayoutSettings(resourceRecord, eventRecord.parent);\n        return bandIndex === 0\n            ? start\n            : start + bandIndex * contentHeight + bandIndex * barMargin;\n    }\n    layoutEventVerticallyPack(topFraction, heightFraction, eventRecord, resourceRecord) {\n        const\n            {\n                barMargin,\n                resourceMarginObject : { start },\n                contentHeight\n            }         = this.scheduler.getResourceLayoutSettings(resourceRecord, eventRecord.parent),\n            count     = 1 / heightFraction,\n            bandIndex = topFraction * count, // \"y\" within row\n            height    = (contentHeight - ((count - 1) * barMargin)) * heightFraction,\n            top       = start + bandIndex * height + bandIndex * barMargin;\n        return {\n            top, height\n        };\n    }\n    //endregion\n    //region Render\n    /**\n     * Used by event drag features to bring into existence event elements that are outside of the rendered block.\n     * @param {Scheduler.model.TimeSpan} eventRecord The event to render\n     * @param {Scheduler.model.ResourceModel} [resourceRecord] The event to render\n     * @private\n     */\n    addTemporaryDragElement(eventRecord, resourceRecord = eventRecord.resource) {\n        const\n            { scheduler } = this,\n            renderData    = scheduler.generateRenderData(eventRecord, resourceRecord, {\n                timeAxis : true,\n                viewport : true\n            });\n        renderData.absoluteTop = renderData.row\n            ? (renderData.top + renderData.row.top)\n            : scheduler.getResourceEventBox(eventRecord, resourceRecord, true).top;\n        const\n            domConfig   = this.renderEvent(renderData),\n            { dataset } = domConfig;\n        delete domConfig.tabIndex;\n        delete dataset.eventId;\n        delete dataset.resourceId;\n        delete dataset.assignmentId;\n        delete dataset.syncId;\n        dataset.transient = true;\n        domConfig.parent  = this.scheduler.foregroundCanvas;\n        // So that the regular DomSyncing which may happen during scroll does not\n        // sweep up and reuse the temporary element.\n        domConfig.retainElement = true;\n        const result = DomHelper.createElement(domConfig);\n        result.innerElement = result.firstChild;\n        eventRecord.instanceMeta(scheduler).hasTemporaryDragElement = true;\n        return result;\n    }\n    // Earlier start dates are above later tasks\n    // If same start date, longer tasks float to top\n    // If same start + duration, sort by name\n    // Fn can be called with layout date or event records (from EventNavigation)\n    eventSorter(a, b) {\n        if (this.overlappingEventSorter) {\n            return this.overlappingEventSorter(a.eventRecord || a, b.eventRecord || b);\n        }\n        const\n            startA = a.isModel ? a.startDateMS : a.dataStartMS || a.startMS, // dataXX are used if configured with fillTicks\n            endA   = a.isModel ? a.endDateMS : a.dataEndMS || a.endMS,\n            startB = b.isModel ? b.startDateMS : b.dataStartMS || b.startMS,\n            endB   = b.isModel ? b.endDateMS : b.dataEndMS || b.endMS,\n            nameA  = a.isModel ? a.name : a.eventRecord.name,\n            nameB  = b.isModel ? b.name : b.eventRecord.name;\n        return startA - startB || endB - endA || (nameA < nameB ? -1 : nameA == nameB ? 0 : 1);\n    }\n    /**\n     * Converts a start/endDate into a MS value used when rendering the event. If scheduler is configured with\n     * `fillTicks: true` the value returned will be snapped to tick start/end.\n     * @private\n     * @param {Scheduler.model.TimeSpan} eventRecord\n     * @param {String} startDateField\n     * @param {String} endDateField\n     * @param {Boolean} useEventBuffer\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @returns {Object} Object of format { startMS, endMS, durationMS }\n     */\n    calculateMS(eventRecord, startDateField, endDateField, useEventBuffer, resourceRecord) {\n        const\n            me                    = this,\n            { scheduler }         = me,\n            { timeAxisViewModel } = scheduler;\n        let startMS    = getStartEnd(scheduler, eventRecord, false, startDateField, useEventBuffer),\n            endMS      = getStartEnd(scheduler, eventRecord, true, endDateField, useEventBuffer),\n            durationMS = endMS - startMS;\n        if (scheduler.milestoneLayoutMode !== 'default' && durationMS === 0) {\n            const\n                pxPerMinute = timeAxisViewModel.getSingleUnitInPixels('minute'),\n                lengthInPx  = scheduler.getMilestoneLabelWidth(eventRecord, resourceRecord),\n                duration    = lengthInPx * (1 / pxPerMinute);\n            durationMS = duration * 60 * 1000;\n            if (scheduler.milestoneTextPosition === 'always-outside') {\n                // Milestone is offset half a diamond to the left (compensated in CSS with padding) for the layout pass,\n                // to take diamond corner into account\n                const\n                    diamondSize = scheduler.getResourceLayoutSettings(resourceRecord, eventRecord.parent).contentHeight,\n                    diamondMS   = diamondSize * (1 / pxPerMinute) * 60 * 1000;\n                startMS -= diamondMS / 2;\n                endMS           = startMS + durationMS;\n            }\n            else {\n                switch (scheduler.milestoneAlign) {\n                    case 'start':\n                    case 'left':\n                        endMS = startMS + durationMS;\n                        break;\n                    case 'end':\n                    case 'right':\n                        endMS   = startMS;\n                        startMS = endMS - durationMS;\n                        break;\n                    default: // using center as default\n                        endMS   = startMS + durationMS / 2;\n                        startMS = endMS - durationMS;\n                        break;\n                }\n            }\n        }\n        // Normally the event bar element and the event layout use the same timestamps for sizing,\n        // but during resize if we have locked the layout we need them to differ\n        const\n            elementStartMS    = startMS,\n            elementEndMS      = endMS,\n            elementDurationMS = durationMS;\n        // Use initial values for the layout during resize\n        if (eventRecord.meta?.isResizing && scheduler.features.eventResize?.lockLayout) {\n            startMS    = eventRecord.startDate.getTime();\n            endMS      = eventRecord.endDate.getTime();\n            durationMS = elementEndMS - elementStartMS;\n        }\n        return {\n            startMS,\n            endMS,\n            durationMS,\n            elementStartMS,\n            elementEndMS,\n            elementDurationMS\n        };\n    }\n    /**\n     * Returns event render data except actual position information.\n     * @param timeSpan\n     * @param rowRecord\n     * @returns {HorizontalRenderData}\n     * @private\n     */\n    setupRenderData(timeSpan, rowRecord) {\n        const\n            me                  = this,\n            { scheduler }       = me,\n            {\n                timeAxis,\n                timeAxisViewModel\n            }                   = scheduler,\n            {\n                preamble,\n                postamble\n            }                   = timeSpan,\n            useEventBuffer      = me.isProHorizontalRendering && scheduler.features.eventBuffer?.enabled &&\n                (preamble || postamble) && !timeSpan.isMilestone,\n            pxPerMinute         = timeAxisViewModel.getSingleUnitInPixels('minute'),\n            { isBatchUpdating } = timeSpan,\n            startDateField      = useEventBuffer ? 'wrapStartDate' : 'startDate',\n            endDateField        = useEventBuffer ? 'wrapEndDate' : 'endDate',\n            // Must use Model.get in order to get latest values in case we are inside a batch.\n            // EventResize changes the endDate using batching to enable a tentative change\n            // via the batchedUpdate event which is triggered when changing a field in a batch.\n            // Fall back to accessor if propagation has not populated date fields.\n            // Use endDate accessor if duration has not been propagated to create endDate\n            timespanStart       = isBatchUpdating && !useEventBuffer ? timeSpan.get(startDateField) : timeSpan[startDateField],\n            // Allow timespans to be rendered even when they are missing an end date\n            timespanEnd         = isBatchUpdating && !useEventBuffer ? timeSpan.get(endDateField) : timeSpan[endDateField] || timespanStart,\n            viewStartMS         = timeAxis.startMS,\n            viewEndMS           = timeAxis.endMS,\n            // Convert start/end dates to milliseconds, taking fillTicks, lockLayout etc. into account\n            msValues            = me.calculateMS(timeSpan, startDateField, endDateField, useEventBuffer, rowRecord),\n            {\n                startMS,\n                endMS,\n                durationMS\n            }                   = msValues,\n            // These flags have two components because includeOutsideViewport\n            // means that we can be calculating data for events either side of\n            // the TimeAxis.\n            // The start is outside of the view if it's before *or after* the TimeAxis range.\n            // 1 set means the start is before the TimeAxis\n            // 2 set means the start is after the TimeAxis\n            // Either way, a truthy value means that the start is outside of the TimeAxis.\n            startsOutsideView   = startMS < viewStartMS | ((startMS > viewEndMS) << 1),\n            // The end is outside of the view if it's before *or after* the TimeAxis range.\n            // 1 set means the end is after the TimeAxis\n            // 2 set means the end is before the TimeAxis\n            // Either way, a truthy value means that the end is outside the TimeAxis.\n            endsOutsideView     = endMS > viewEndMS | ((endMS <= viewStartMS) << 1),\n            durationMinutes     = durationMS / (1000 * 60),\n            width               = endsOutsideView ? pxPerMinute * durationMinutes : null,\n            row                 = scheduler.getRowById(rowRecord);\n        return {\n            eventRecord : timeSpan,\n            taskRecord  : timeSpan, // Helps with using Gantt projects in Scheduler Pro\n            start       : timespanStart,\n            end         : timespanEnd,\n            rowId       : rowRecord.id,\n            children    : [],\n            startsOutsideView,\n            endsOutsideView,\n            width,\n            row,\n            useEventBuffer,\n            ...msValues\n        };\n    }\n    /**\n     * Populates render data with information about width and horizontal position of the wrap.\n     * @param {HorizontalRenderData} renderData\n     * @returns {Boolean}\n     * @private\n     */\n    fillTimeSpanHorizontalPosition(renderData) {\n        const\n            { elementStartMS : startMS, elementEndMS : endMS, elementDurationMS : durationMS } = renderData,\n            // With delayed calculation there is no guarantee data is normalized, might be missing a crucial component\n            result = startMS != null && endMS != null && this.calculateHorizontalPosition(renderData, startMS, endMS, durationMS);\n        if (result) {\n            Object.assign(renderData, result);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Fills render data with `left` and `width` properties\n     * @param {HorizontalRenderData} renderData\n     * @param {Number} startMS\n     * @param {Number} endMS\n     * @param {Number} durationMS\n     * @returns {{left: number, width: number, clippedStart: boolean, clippedEnd: boolean}|null}\n     * @private\n     */\n    calculateHorizontalPosition(renderData, startMS, endMS, durationMS) {\n        const\n            { scheduler } = this,\n            {\n                timeAxis,\n                timeAxisViewModel\n            }             = scheduler,\n            {\n                startsOutsideView,\n                endsOutsideView,\n                eventRecord\n            }             = renderData,\n            viewStartMS   = timeAxis.startMS,\n            pxPerMinute   = timeAxisViewModel.getSingleUnitInPixels('minute');\n        let\n            width                                        = null,\n            endX                                         = scheduler.getCoordinateFromDate(endMS, {\n                local            : true,\n                respectExclusion : true,\n                isEnd            : true\n            }), startX, clippedStart = false, clippedEnd = false;\n        // If event starts outside of view, estimate where.\n        if (startsOutsideView) {\n            startX = (startMS - viewStartMS) / (1000 * 60) * pxPerMinute;\n            // Flip -ve startX to being to the right of the viewport end\n            if (scheduler.rtl) {\n                startX = timeAxisViewModel.totalSize - startX;\n            }\n        }\n        // Starts in view, calculate exactly\n        else {\n            // If end date is included in time axis but start date is not (when using time axis exclusions), snap start date to next included data\n            startX = scheduler.getCoordinateFromDate(startMS, {\n                local              : true,\n                respectExclusion   : true,\n                isEnd              : false,\n                snapToNextIncluded : endX !== -1\n            });\n            clippedStart = startX === -1;\n        }\n        if (endsOutsideView) {\n            // Estimate where the end is, based on where time axis ends + how much the event overflows\n            const\n                distanceToTimeAxisEnd   = timeAxisViewModel.totalSize - startX,\n                overflowDurationMS      = endMS - timeAxis.endMS,\n                overflowDurationMinutes = overflowDurationMS / (1000 * 60);\n            width = scheduler.rtl\n                ? pxPerMinute * durationMS / (1000 * 60)\n                : distanceToTimeAxisEnd + pxPerMinute * overflowDurationMinutes;\n            // Have to clip the events in Safari when using stickyEvents, it does not support `overflow: clip`\n            if (BrowserHelper.isSafari && scheduler.features.stickyEvents && timeAxis.endMS) {\n                endX = scheduler.getCoordinateFromDate(timeAxis.endMS);\n            }\n            else {\n                // Parentheses needed\n                endX = startX + width * (scheduler.rtl ? -1 : 1);\n            }\n        }\n        else {\n            clippedEnd = endX === -1;\n        }\n        if (clippedEnd && !clippedStart) {\n            // We know where to start but not where to end, snap it (the opposite is already handled by the\n            // snapToNextIncluded flag when calculating startX above)\n            endX = scheduler.getCoordinateFromDate(endMS, {\n                local              : true,\n                respectExclusion   : true,\n                isEnd              : true,\n                snapToNextIncluded : true\n            });\n        }\n        // If the element is very wide there's no point in displaying it all.\n        // Indeed the element may not be displayable at extremely large widths.\n        if (width > MAX_WIDTH) {\n            // The start is before the TimeAxis start\n            if (startsOutsideView === 1) {\n                // Both ends outside - spans TimeAxis\n                if (endsOutsideView === 1) {\n                    startX = -100;\n                    endX   = scheduler.timeAxisColumn.width + 100;\n                }\n                // End is in view\n                else {\n                    startX = endX - MAX_WIDTH;\n                }\n            }\n            // The end is after, but the start is in view\n            else if (endsOutsideView === 1) {\n                endX = startX + MAX_WIDTH;\n            }\n        }\n        if (clippedStart && clippedEnd) {\n            // Both ends excluded, but there might be some part in between that should be displayed...\n            startX = scheduler.getCoordinateFromDate(startMS, {\n                local              : true,\n                respectExclusion   : true,\n                isEnd              : false,\n                snapToNextIncluded : true,\n                max                : endMS\n            });\n            endX = scheduler.getCoordinateFromDate(endMS, {\n                local              : true,\n                respectExclusion   : true,\n                isEnd              : true,\n                snapToNextIncluded : true,\n                min                : startMS\n            });\n            if (startX === endX) {\n                // Raise flag on instance meta to avoid duplicating this logic\n                eventRecord.instanceMeta(scheduler).excluded = true;\n                // Excluded by time axis exclusion rules, render nothing\n                return null;\n            }\n        }\n        return {\n            left  : Math.min(startX, endX),\n            // Use min width 5 for normal events, 0 for milestones (won't have width specified at all in the\n            // end). During drag create a normal event can get 0 duration, in this case we still want it to\n            // get a min width of 5 (6px for wrapper, -1 px for event element\n            width : Math.abs(endX - startX) || (eventRecord.isMilestone && !eventRecord.meta.isDragCreating ? 0 : 6),\n            clippedStart,\n            clippedEnd\n        };\n    }\n    fillTimeSpanVerticalPosition(renderData, rowRecord) {\n        const\n            { scheduler }  = this,\n            { start, end } = renderData,\n            {\n                resourceMarginObject : { start : resourceMarginStart },\n                contentHeight\n            }              = scheduler.getResourceLayoutSettings(rowRecord);\n        // If filling ticks we need to also keep data's MS values, since they are used for sorting timespans\n        if (scheduler.fillTicks) {\n            renderData.dataStartMS = start.getTime();\n            renderData.dataEndMS   = end.getTime();\n        }\n        renderData.top = Math.max(0, resourceMarginStart);\n        if (scheduler.managedEventSizing) {\n            // Timespan height should be at least 1px\n            renderData.height = contentHeight;\n        }\n    }\n    /**\n     * Gets timespan coordinates etc. Relative to containing row. If the timespan is outside of the zone in\n     * which timespans are rendered, that is outside of the TimeAxis, or outside of the vertical zone in which timespans\n     * are rendered, then `undefined` is returned.\n     * @private\n     * @param {Scheduler.model.TimeSpan} timeSpan TimeSpan record\n     * @param {Core.data.Model} rowRecord Row record\n     * @param {Boolean|Object} includeOutside Specify true to get boxes for timespans outside of the rendered zone in both\n     * dimensions. This option is used when calculating dependency lines, and we need to include routes from timespans\n     * which may be outside the rendered zone.\n     * @param {Boolean} includeOutside.timeAxis Pass as `true` to include timespans outside of the TimeAxis's bounds\n     * @param {Boolean} includeOutside.viewport Pass as `true` to include timespans outside of the vertical timespan viewport's bounds.\n     * @returns {{event/task: *, left: number, width: number, start: (Date), end: (Date), startMS: number, endMS: number, startsOutsideView: boolean, endsOutsideView: boolean}}\n     */\n    getTimeSpanRenderData(timeSpan, rowRecord, includeOutside = false) {\n        const data = this.setupRenderData(timeSpan, rowRecord);\n        if (!this.fillTimeSpanHorizontalPosition(data)) {\n            return null;\n        }\n        this.fillTimeSpanVerticalPosition(data, rowRecord);\n        return data;\n    }\n    // Layout a set of events, code shared by normal event render path and nested events\n    layoutEvents(resourceRecord, allEvents, includeOutside = false, parentEventRecord, eventSorter) {\n        const\n            me            = this,\n            { scheduler } = me,\n            { timeAxis }  = scheduler,\n            // Generate layout data\n            eventsData    = allEvents.reduce((result, eventRecord) => {\n                // Only those in time axis (by default)\n                if ((includeOutside || timeAxis.isTimeSpanInAxis(eventRecord))) {\n                    const eventBox = scheduler.generateRenderData(eventRecord, resourceRecord, includeOutside);\n                    // Collect layouts of visible events\n                    if (eventBox) {\n                        result.push(eventBox);\n                    }\n                }\n                return result;\n            }, []);\n        // Ensure the events are rendered in natural order so that navigation works.\n        eventsData.sort(eventSorter ?? me.eventSorter);\n        let rowHeight = scheduler.getAppliedResourceHeight(resourceRecord, parentEventRecord);\n        const\n            // Only events and tasks should be considered during layout (not resource time ranges if any, or events\n            // being drag created when configured with lockLayout)\n            layoutEventData = eventsData.filter(({ eventRecord }) => eventRecord.isEvent && !eventRecord.meta.excludeFromLayout),\n            eventLayout     = scheduler.getEventLayout(resourceRecord, parentEventRecord),\n            layoutHandler   = scheduler.getEventLayoutHandler(eventLayout);\n        if (layoutHandler) {\n            const\n                {\n                    barMargin,\n                    resourceMarginObject : { total },\n                    contentHeight\n                }             = scheduler.getResourceLayoutSettings(resourceRecord, parentEventRecord),\n                bandsRequired = layoutHandler.applyLayout(layoutEventData, resourceRecord) || 1;\n            if (layoutHandler.type === 'layoutFn') {\n                rowHeight = bandsRequired;\n            }\n            else {\n                rowHeight = (bandsRequired * contentHeight) + ((bandsRequired - 1) * barMargin) + total;\n            }\n        }\n        // Apply z-index when event elements might overlap, to keep \"overlap order\" consistent\n        else if (layoutEventData.length > 0) {\n            for (let i = 0; i < layoutEventData.length; i++) {\n                const data = layoutEventData[i];\n                // $event-zindex scss var is 5\n                data.wrapperStyle += `;z-index:${i + 5}`;\n            }\n        }\n        return { rowHeight, eventsData };\n    }\n    // Lay out events within a resource, relative to the resource\n    layoutResourceEvents(resourceRecord, includeOutside = false) {\n        const\n            me             = this,\n            { scheduler }  = me,\n            {\n                eventStore,\n                assignmentStore,\n                timeAxis\n            }              = scheduler,\n            // Events for this resource\n            resourceEvents = eventStore.getEvents({\n                includeOccurrences : scheduler.enableRecurringEvents,\n                resourceRecord,\n                startDate          : timeAxis.startDate,\n                endDate            : timeAxis.endDate,\n                filter             : (assignmentStore.isFiltered || eventStore.isFiltered) && (eventRecord =>\n                    eventRecord.assignments.some(a => a.resource === resourceRecord.$original && assignmentStore.includes(a)))\n            }),\n            // Call a chainable template function on scheduler to allow features to add additional \"events\" to render\n            // Currently used by ResourceTimeRanges, CalendarHighlight & NestedEvents\n            allEvents      = scheduler.getEventsToRender(resourceRecord, resourceEvents) || [];\n        return me.layoutEvents(resourceRecord, allEvents, includeOutside);\n    }\n    // Generates a DOMConfig for an EventRecord\n    renderEvent(data, rowHeight) {\n        const\n            { scheduler }                                     = this,\n            { resourceRecord, assignmentRecord, eventRecord } = data,\n            // Sync using assignment id for events and event id for ResourceTimeRanges. Add eventId for occurrences to make them unique\n            syncId                                            = assignmentRecord\n                // Assignment, might be an occurrence\n                ? this.assignmentStore.getOccurrence(assignmentRecord, eventRecord).id\n                // Something else, probably a ResourceTimeRange\n                : data.eventId,\n            eventElementConfig                                = {\n                className : data.cls,\n                style     : data.style || '',\n                children  : data.children,\n                role      : 'presentation',\n                dataset   : {\n                    // Each feature putting contents in the event wrap should have this to simplify syncing and\n                    // element retrieval after sync\n                    taskFeature : 'event'\n                },\n                syncOptions : {\n                    syncIdField : 'taskBarFeature'\n                }\n            },\n            // Event element config, applied to existing element or used to create a new one below\n            elementConfig                                     = {\n                className : data.wrapperCls,\n                tabIndex  : ('tabIndex' in data) ? data.tabIndex : -1,\n                children  : [\n                    eventElementConfig,\n                    ...data.wrapperChildren\n                ],\n                style : {\n                    top      : data.absoluteTop,\n                    left     : data.left,\n                    // ResourceTimeRanges fill row height, cannot be done earlier than this since row height is not\n                    // known initially\n                    height   : data.fillSize ? rowHeight : data.height,\n                    // DomHelper appends px to dimensions when using numbers.\n                    width    : data.width,\n                    style    : data.wrapperStyle,\n                    fontSize : data.height + 'px'\n                },\n                dataset : {\n                    // assignmentId is set in this function conditionally\n                    resourceId : resourceRecord.id,\n                    eventId    : data.eventId, // Not using eventRecord.id to distinguish between Event and ResourceTimeRange\n                    syncId     : resourceRecord.isLinked ? `${syncId}_${resourceRecord.id}` : syncId\n                },\n                // Will not be part of DOM, but attached to the element\n                elementData   : data,\n                // Dragging etc. flags element as retained, to not reuse/release it during that operation. Events\n                // always use assignments, but ResourceTimeRanges does not\n                retainElement : assignmentRecord?.instanceMeta(scheduler).retainElement || eventRecord.instanceMeta(scheduler).retainElement,\n                // Options for this level of sync, lower levels can have their own\n                syncOptions   : {\n                    syncIdField      : 'taskFeature',\n                    // Remove instead of release when a feature is disabled\n                    releaseThreshold : 0\n                }\n            };\n        // Write back the correct height for elements filling the row, to not derender them later based on wrong height\n        if (data.fillSize) {\n            data.height = rowHeight;\n        }\n        // Some browsers throw warnings on zIndex = ''\n        if (data.zIndex) {\n            elementConfig.zIndex = data.zIndex;\n        }\n        // Do not want to spam dataset with empty prop when not using assignments (ResourceTimeRanges)\n        if (assignmentRecord) {\n            elementConfig.dataset.assignmentId = assignmentRecord.id;\n        }\n        data.elementConfig = elementConfig;\n        scheduler.afterRenderEvent({ renderData : data, rowHeight, domConfig : elementConfig });\n        return elementConfig;\n    }\n    /**\n     * Refresh events for resource record (or Row), clearing its cache and forcing DOM refresh.\n     * @param {Scheduler.model.ResourceModel} recordOrRow Record or row to refresh\n     * @param {Boolean} [force] Specify `false` to prevent clearing cache and forcing DOM refresh\n     * @internal\n     */\n    refreshEventsForResource(recordOrRow, force = true, draw = true) {\n        const\n            me     = this,\n            record = me.scheduler.store.getById(recordOrRow.isRow ? recordOrRow.id : recordOrRow),\n            row    = me.scheduler.rowManager.getRowFor(record);\n        if (force) {\n            me.clearResources([record]);\n        }\n        if (row && record) {\n            me.renderer({ row, record });\n            if (force && draw) {\n                me.onRenderDone();\n            }\n        }\n    }\n    // Returns layout for the current resource. Used by the renderer and exporter\n    getResourceLayout(resourceRecord) {\n        const me = this;\n        // Use cached layout if available\n        let resourceLayout = me.resourceMap.get(resourceRecord.id);\n        if (!resourceLayout || resourceLayout.invalid) {\n            // Previously we would bail out here if engine wasn't ready. Now we instead allow drawing in most cases,\n            // since data can be read and written during commit (previously it could not)\n            if (me.suspended) {\n                return;\n            }\n            resourceLayout = me.layoutResourceEvents(resourceRecord, false);\n            me.resourceMap.set(resourceRecord.id, resourceLayout);\n        }\n        return resourceLayout;\n    }\n    getEventDOMConfigForCurrentView(resourceLayout, row, left, right) {\n        const\n            me                        = this,\n            { bufferSize, scheduler } = me,\n            { labels, eventBuffer }   = scheduler.features,\n            // Left/right labels and event buffer elements require using a buffer to not derender too early\n            usesLabels                = eventBuffer?.enabled || (labels?.enabled && (labels.left || labels.right || labels.before || labels.after)),\n            { eventsData }            = resourceLayout,\n            // When scrolling, layout will be reused and any events that are still in view can reuse their DOM configs\n            reusableDOMConfigs        = me.fromScroll ? me.rowMap.get(row) : null,\n            eventDOMConfigs           = [];\n        let useLeft, useRight;\n        // Only collect configs for those actually in view\n        for (let i = 0; i < eventsData.length; i++) {\n            const layout = eventsData[i];\n            useLeft  = left;\n            useRight = right;\n            // Labels/milestones requires keeping events rendered longer\n            if (usesLabels || layout.width === 0) {\n                useLeft -= bufferSize;\n                useRight += bufferSize;\n            }\n            if ((layout.left + layout.width) >= useLeft && layout.left <= useRight) {\n                layout.absoluteTop = layout.top + row.top;\n                const prevDomConfig = reusableDOMConfigs?.find(config => config.elementData.eventId === layout.eventId &&\n                    config.elementData.resourceId === layout.resourceId);\n                eventDOMConfigs.push(prevDomConfig ?? me.renderEvent(layout, resourceLayout.rowHeight));\n            }\n        }\n        return eventDOMConfigs;\n    }\n    // Called per row in \"view\", collect configs\n    renderer({ row, record : resourceRecord, size = {} }) {\n        const me = this;\n        // Bail out for group headers/footers\n        if (resourceRecord.isSpecialRow) {\n            // Clear any cached layout for row retooled to special row, and bail out\n            me.rowMap.delete(row);\n            return;\n        }\n        const\n            { left, right } = me.viewportCoords,\n            resourceLayout  = me.getResourceLayout(resourceRecord);\n        // Layout is suspended\n        if (!resourceLayout) {\n            return;\n        }\n        // Size row to fit events\n        size.height    = resourceLayout.rowHeight;\n        // Avoid storing our calculated height as the rows max height, to not affect next round of calculations\n        size.transient = true;\n        const eventDOMConfigs = me.getEventDOMConfigForCurrentView(resourceLayout, row, left, right);\n        me.rowMap.set(row, eventDOMConfigs);\n        // Keep track if we need to draw on vertical scroll or not, to not get multiple onRenderDone() calls\n        me.rendererCalled = true;\n    }\n    // Called when the current row rendering \"pass\" is complete, sync collected configs to DOM\n    onRenderDone() {\n        const\n            { scheduler, rowMap, verticalBufferSize } = this,\n            visibleEventDOMConfigs                    = [],\n            bodyTop                                   = scheduler._scrollTop ?? 0,\n            viewTop                                   = bodyTop - verticalBufferSize,\n            viewBottom                                = bodyTop + scheduler._bodyRectangle.height + verticalBufferSize,\n            unbuffered                                = verticalBufferSize < 0,\n            unmanagedSize                             = !scheduler.managedEventSizing;\n        // Event configs are collected when rows are rendered, but we do not want to waste resources on rendering\n        // events far out of view. Especially with many events per row giving large row heights, rows in the RowManagers\n        // buffer might far away -> collect events for rows within viewport + small vertical buffer\n        rowMap.forEach((eventDOMConfigs, row) => {\n            // Render events \"in view\". Export specifies a negative verticalBufferSize to disable it\n            if (unbuffered || (row.bottom > viewTop && row.top < viewBottom)) {\n                for (let i = 0; i < eventDOMConfigs.length; i++) {\n                    const\n                        config = eventDOMConfigs[i],\n                        data   = config.elementData,\n                        {\n                            absoluteTop,\n                            eventRecord\n                        }      = data;\n                    // Conditions under which event bars are included in the DOM:\n                    //   If bufferSize is -ve, meaning render all events.\n                    //   scheduler.managedEventSizing is false.\n                    //   The event is being drag-created or drag-resized\n                    //   The event is within the bounds of the rendered region.\n                    if (unbuffered || unmanagedSize || eventRecord.meta.isDragCreating || eventRecord.meta.isResizing || (absoluteTop + data.height > viewTop && absoluteTop < viewBottom)) {\n                        visibleEventDOMConfigs.push(config);\n                    }\n                }\n            }\n            // We are using cached DomConfigs. When DomSync releases an element, it also flags the config as released.\n            // Next time we pass it that very same config, it says it is released and nothing shows up.\n            //\n            // We are breaching the DomSync contract a bit with the cached approach. DomSync expects new configs on each\n            // call, so to facilitate that we clone the configs shallowly (nothing deep is affected by sync releasing).\n            // That way we can always pass it fresh unreleased configs.\n            for (let i = 0; i < eventDOMConfigs.length; i++) {\n                eventDOMConfigs[i] = { ...eventDOMConfigs[i] };\n            }\n        });\n        this.fromScroll             = false;\n        this.visibleEventDOMConfigs = visibleEventDOMConfigs;\n        DomSync.sync({\n            domConfig : {\n                onlyChildren : true,\n                children     : visibleEventDOMConfigs\n            },\n            targetElement : scheduler.foregroundCanvas,\n            syncIdField   : 'syncId',\n            // Called by DomSync when it creates, releases or reuses elements\n            callback({ action, domConfig, lastDomConfig, targetElement, jsx }) {\n                const\n                    { reactComponent } = scheduler,\n                    // Some actions are considered first a release and then a render (reusing another element).\n                    // This gives clients code a chance to clean up before reusing an element\n                    isRelease          = releaseEventActions[action],\n                    isRender           = renderEventActions[action];\n                !isRelease && scheduler.processEventContent?.({\n                    jsx,\n                    action,\n                    domConfig,\n                    targetElement,\n                    isRelease,\n                    reactComponent\n                });\n                if (action === 'none' || !domConfig?.elementData?.isWrap) {\n                    return;\n                }\n                // Trigger release for events (it might be a proxy element, skip those)\n                if (isRelease && lastDomConfig?.elementData) {\n                    const\n                        { eventRecord, resourceRecord, assignmentRecord } = lastDomConfig.elementData,\n                        event                                             = {\n                            renderData : lastDomConfig.elementData,\n                            element    : targetElement,\n                            eventRecord,\n                            resourceRecord,\n                            assignmentRecord\n                        };\n                    // Process event necessary in the case of release\n                    scheduler.processEventContent?.({\n                        isRelease,\n                        targetElement,\n                        reactComponent,\n                        assignmentRecord\n                    });\n                    // Some browsers do not blur on set to display:none, so releasing the active element\n                    // must *explicitly* move focus outwards to the view.\n                    if (targetElement === DomHelper.getActiveElement(targetElement)) {\n                        scheduler.focusElement.focus();\n                    }\n                    // This event is documented on Scheduler\n                    scheduler.trigger('releaseEvent', event);\n                }\n                if (isRender) {\n                    const\n                        { eventRecord, resourceRecord, assignmentRecord } = domConfig.elementData,\n                        event                                             = {\n                            renderData       : domConfig.elementData,\n                            element          : targetElement,\n                            isReusingElement : action === 'reuseElement',\n                            isRepaint        : action === 'reuseOwnElement',\n                            eventRecord,\n                            resourceRecord,\n                            assignmentRecord\n                        };\n                    // Prevent transitions when reusing some other events element\n                    if (action === 'reuseElement' && scheduler.isAnimating) {\n                        // No assignments for ResourceTimeRanges\n                        DomHelper.addTemporaryClass(targetElement, 'b-reusing-own', 50, scheduler, `b-reusing-own-${(assignmentRecord || eventRecord).id}`);\n                    }\n                    // This event is documented on Scheduler\n                    scheduler.trigger('renderEvent', event);\n                }\n            }\n        });\n    }\n    //endregion\n    //region Cache\n    // Clears cached resource layout\n    clearResources(recordsOrIds) {\n        recordsOrIds = ArrayHelper.asArray(recordsOrIds);\n        const resourceIds = recordsOrIds.map(Model.asId);\n        resourceIds.forEach(resourceId => {\n            // Invalidate resourceLayout, keeping it around in case we need it before next refresh\n            const cached = this.resourceMap.get(resourceId);\n            if (cached) {\n                cached.invalid = true;\n            }\n            const row = this.scheduler.getRowById(resourceId);\n            row && this.rowMap.delete(row);\n        });\n    }\n    clearAll({ clearDom = false, clearLayoutCache = false } = {}) {\n        const\n            me                            = this,\n            { layouts, foregroundCanvas } = me.scheduler;\n        if (clearLayoutCache && layouts) {\n            for (const layout in layouts) {\n                layouts[layout].clearCache();\n            }\n        }\n        // it seems `foregroundCanvas` can be missing at this point\n        // for example if scheduler instance is created w/o of `appendTo` config\n        if (foregroundCanvas && clearDom) {\n            // Start from scratch when replacing the project, to not retain anything in maps or released elements\n            foregroundCanvas.syncIdMap = foregroundCanvas.lastDomConfig = foregroundCanvas.releasedIdMap = null;\n            for (const child of foregroundCanvas.children) {\n                child.lastDomConfig = child.elementData = null;\n            }\n        }\n        me.resourceMap.clear();\n        me.rowMap.clear();\n    }\n    //endregion\n}\nHorizontalRendering._$name = 'HorizontalRendering';", "import PackMixin from './PackMixin.js';\n/**\n * @module Scheduler/eventlayout/VerticalLayout\n */\n/**\n * Assists with event layout in vertical mode, handles `eventLayout: none|pack|mixed`\n * @private\n * @mixes Scheduler/eventlayout/PackMixin\n */\nexport default class VerticalLayout extends PackMixin() {\n    static get defaultConfig() {\n        return {\n            coordProp : 'leftFactor',\n            sizeProp  : 'widthFactor'\n        };\n    }\n    // Try to pack the events to consume as little space as possible\n    applyLayout(events, columnWidth, resourceMarginStart, resourceMarginTotal, barMargin, columnIndex, eventLayout) {\n        const\n            me         = this,\n            layoutType = eventLayout.type;\n        return me.packEventsInBands(events, (tplData, clusterIndex, slot, slotSize) => {\n            // Stretch events to fill available width\n            if (layoutType === 'none') {\n                tplData.width = columnWidth - resourceMarginTotal;\n                tplData.left += resourceMarginStart;\n            }\n            else {\n                // Fractions of resource column\n                tplData.widthFactor = slotSize;\n                const\n                    leftFactor      = tplData.leftFactor = slot.start + (clusterIndex * slotSize),\n                    // Number of \"columns\" in the current slot\n                    packColumnCount = Math.round(1 / slotSize),\n                    // Index among those columns for current event\n                    packColumnIndex = leftFactor / slotSize,\n                    // Width with all bar margins subtracted\n                    availableWidth  = columnWidth - resourceMarginTotal - barMargin * (packColumnCount - 1);\n                // Allowing two events to overlap? Slightly offset the second\n                if (layoutType === 'mixed' && packColumnCount === 2) {\n                    tplData.left += leftFactor * columnWidth / 5 + barMargin;\n                    tplData.width = columnWidth - leftFactor * columnWidth / 5 - barMargin * 2;\n                    tplData.zIndex = 5 + packColumnIndex;\n                }\n                // Pack by default\n                else {\n                    // Fractional width\n                    tplData.width = slotSize * availableWidth;\n                    // Translate to absolute position\n                    tplData.left += leftFactor * availableWidth + resourceMarginStart + barMargin * packColumnIndex;\n                }\n            }\n            tplData.cls['b-sch-event-narrow'] = tplData.width < me.scheduler.narrowEventWidth;\n        });\n    }\n}\nVerticalLayout._$name = 'VerticalLayout';", "import Base from '../../../Core/Base.js';\nimport Delayable from '../../../Core/mixin/Delayable.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport DomSync from '../../../Core/helper/DomSync.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport VerticalLayout from '../../eventlayout/VerticalLayout.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport AttachToProjectMixin from '../../data/mixin/AttachToProjectMixin.js';\n/**\n * @module Scheduler/view/orientation/VerticalRendering\n */\nconst\n    releaseEventActions = {\n        releaseElement : 1, // Not used at all at the moment\n        reuseElement   : 1  // Used by some other element\n    },\n    renderEventActions  = {\n        newElement      : 1,\n        reuseOwnElement : 1,\n        reuseElement    : 1\n    },\n    chronoFields        = {\n        startDate : 1,\n        endDate   : 1,\n        duration  : 1\n    },\n    emptyObject        = Object.freeze({});\n/**\n * Handles event rendering in Schedulers vertical mode. Reacts to project/store changes to keep the UI up to date.\n *\n * @internal\n */\nexport default class VerticalRendering extends Base.mixin(Delayable, AttachToProjectMixin) {\n    //region Config & Init\n    static get properties() {\n        return {\n            eventMap               : new Map(),\n            resourceMap            : new Map(),\n            releasedElements       : {},\n            toDrawOnProjectRefresh : new Set(),\n            resourceBufferSize     : 1\n        };\n    }\n    construct(scheduler) {\n        this.client         = this.scheduler = scheduler;\n        this.verticalLayout = new VerticalLayout({ scheduler });\n        super.construct({});\n    }\n    init() {\n        const\n            me                             = this,\n            { scheduler, resourceColumns } = me;\n        // Resource header/columns\n        resourceColumns.resourceStore = me.resourceStore;\n        resourceColumns.ion({\n            name              : 'resourceColumns',\n            columnWidthChange : 'onResourceColumnWidthChange',\n            thisObj           : me\n        });\n        me.initialized = true;\n        if (scheduler.isPainted) {\n            me.renderer();\n        }\n        resourceColumns.availableWidth = scheduler.timeAxisSubGridElement.offsetWidth;\n    }\n    //endregion\n    //region Elements <-> Records\n    resolveRowRecord(elementOrEvent, xy) {\n        const\n            me            = this,\n            { scheduler } = me,\n            event         = elementOrEvent.nodeType ? null : elementOrEvent,\n            element       = event ? event.target : elementOrEvent,\n            coords        = event ? [event.borderOffsetX, event.borderOffsetY] : xy,\n            // Fix for FF on Linux having text nodes as event.target\n            el            = element.nodeType === Element.TEXT_NODE ? element.parentElement : element,\n            eventElement  = el.closest(scheduler.eventSelector);\n        if (eventElement) {\n            return scheduler.resourceStore.getById(eventElement.dataset.resourceId);\n        }\n        // Need to be inside schedule at least\n        if (!element.closest('.b-sch-timeaxis-cell')) {\n            return null;\n        }\n        if (!coords) {\n            throw new Error(`Vertical mode needs coordinates to resolve this element. Can also be called with a browser\n                event instead of element to extract element and coordinates from`);\n        }\n        if (scheduler.variableColumnWidths || scheduler.resourceStore.isGrouped) {\n            let totalWidth = 0;\n            for (const col of me.resourceStore) {\n                if (!col.isSpecialRow) {\n                    totalWidth += col.columnWidth || me.resourceColumns.columnWidth;\n                }\n                if (totalWidth >= coords[0]) {\n                    return col;\n                }\n            }\n            return null;\n        }\n        const index = Math.floor(coords[0] / me.resourceColumns.columnWidth);\n        return me.allResourceRecords[index];\n    }\n    toggleCls(assignmentRecord, cls, add = true, useWrapper = false) {\n        const eventData = this.eventMap.get(assignmentRecord.eventId)?.[assignmentRecord.resourceId];\n        if (eventData) {\n            eventData.renderData[useWrapper ? 'wrapperCls' : 'cls'][cls] = add;\n            // Element from the map cannot be trusted, might be reused in which case map is not updated to reflect that.\n            // To be safe, retrieve using `getElementFromAssignmentRecord`\n            const element = this.client.getElementFromAssignmentRecord(assignmentRecord, useWrapper);\n            if (element) {\n                element.classList[add ? 'add' : 'remove'](cls);\n            }\n        }\n    }\n    //endregion\n    //region Coordinate <-> Date\n    getDateFromXY(xy, roundingMethod, local, allowOutOfRange = false) {\n        let coord = xy[1];\n        if (!local) {\n            coord = this.translateToScheduleCoordinate(coord);\n        }\n        return this.scheduler.timeAxisViewModel.getDateFromPosition(coord, roundingMethod, allowOutOfRange);\n    }\n    translateToScheduleCoordinate(y) {\n        return y - this.scheduler.timeAxisSubGridElement.getBoundingClientRect().top - globalThis.scrollY;\n    }\n    translateToPageCoordinate(y) {\n        return y + this.scheduler.timeAxisSubGridElement.getBoundingClientRect().top + globalThis.scrollY;\n    }\n    //endregion\n    //region Regions\n    getResourceEventBox(event, resource) {\n        const\n            eventId    = event.id,\n            resourceId = resource.id;\n        let { renderData } = this.eventMap.get(eventId)?.[resourceId] || emptyObject;\n        if (!renderData) {\n            // Never been in view, lay it out\n            this.layoutResourceEvents(this.scheduler.resourceStore.getById(resourceId));\n            // Have another go at getting the layout data\n            renderData = this.eventMap.get(eventId)?.[resourceId]?.renderData;\n        }\n        return renderData\n            ? new Rectangle(renderData.left, renderData.top, renderData.width, renderData.bottom - renderData.top)\n            : null;\n    }\n    getScheduleRegion(resourceRecord, eventRecord, local) {\n        const\n            me            = this,\n            { scheduler } = me,\n            // Only interested in width / height (in \"local\" coordinates)\n            region        = Rectangle.from(scheduler.timeAxisSubGridElement, scheduler.timeAxisSubGridElement);\n        if (resourceRecord) {\n            region.left  = me.allResourceRecords.indexOf(resourceRecord) * scheduler.resourceColumnWidth;\n            region.right = region.left + scheduler.resourceColumnWidth;\n        }\n        const\n            start           = scheduler.timeAxis.startDate,\n            end             = scheduler.timeAxis.endDate,\n            dateConstraints = scheduler.getDateConstraints?.(resourceRecord, eventRecord) || {\n                start,\n                end\n            },\n            startY          = scheduler.getCoordinateFromDate(DateHelper.max(start, dateConstraints.start)),\n            endY            = scheduler.getCoordinateFromDate(DateHelper.min(end, dateConstraints.end));\n        if (!local) {\n            region.top    = me.translateToPageCoordinate(startY);\n            region.bottom = me.translateToPageCoordinate(endY);\n        }\n        else {\n            region.top    = startY;\n            region.bottom = endY;\n        }\n        return region;\n    }\n    getRowRegion(resourceRecord, startDate, endDate) {\n        const\n            me            = this,\n            { scheduler } = me,\n            x             = me.allResourceRecords.indexOf(resourceRecord) * scheduler.resourceColumnWidth,\n            taStart       = scheduler.timeAxis.startDate,\n            taEnd         = scheduler.timeAxis.endDate,\n            start         = startDate ? DateHelper.max(taStart, startDate) : taStart,\n            end           = endDate ? DateHelper.min(taEnd, endDate) : taEnd,\n            startY        = scheduler.getCoordinateFromDate(start),\n            endY          = scheduler.getCoordinateFromDate(end, true, true),\n            y             = Math.min(startY, endY),\n            height        = Math.abs(startY - endY);\n        return new Rectangle(x, y, scheduler.resourceColumnWidth, height);\n    }\n    get visibleDateRange() {\n        const\n            scheduler = this.scheduler,\n            scrollPos = scheduler.scrollable.y,\n            height    = scheduler.scrollable.clientHeight,\n            startDate = scheduler.getDateFromCoordinate(scrollPos) || scheduler.timeAxis.startDate,\n            endDate   = scheduler.getDateFromCoordinate(scrollPos + height) || scheduler.timeAxis.endDate;\n        return {\n            startDate,\n            endDate,\n            startMS : startDate.getTime(),\n            endMS   : endDate.getTime()\n        };\n    }\n    //endregion\n    //region Events\n    // Column width changed, rerender fully\n    onResourceColumnWidthChange({ width, oldWidth }) {\n        const\n            me            = this,\n            { scheduler } = me;\n        // Fix width of column & header\n        me.resourceColumns.width = scheduler.timeAxisColumn.width = me.allResourceRecords.length * width;\n        me.clearAll();\n        // Only transition large changes, otherwise it is janky when dragging slider in demo\n        me.refresh(Math.abs(width - oldWidth) > 30);\n        // Not detected by resizeobserver? Need to call this for virtual scrolling to react to update\n        //        scheduler.callEachSubGrid('refreshFakeScroll');\n        //        scheduler.refreshVirtualScrollbars();\n    }\n    //endregion\n    //region Project\n    attachToProject(project) {\n        super.attachToProject(project);\n        if (project) {\n            project.ion({\n                name    : 'project',\n                refresh : 'onProjectRefresh',\n                thisObj : this\n            });\n        }\n    }\n    onProjectRefresh() {\n        const\n            me                                    = this,\n            { scheduler, toDrawOnProjectRefresh } = me;\n        // Only update the UI immediately if we are visible\n        if (scheduler.isVisible) {\n            if (scheduler.rendered && !scheduler.refreshSuspended) {\n                // Either refresh all rows (on for example dataset)\n                if (me.refreshAllWhenReady) {\n                    me.clearAll();\n                    //scheduler.refreshWithTransition();\n                    me.refresh();\n                    me.refreshAllWhenReady = false;\n                }\n                // Or only affected rows (if any)\n                else if (toDrawOnProjectRefresh.size) {\n                    me.refresh();\n                }\n                toDrawOnProjectRefresh.clear();\n            }\n        }\n        // Otherwise wait till next time we get painted (shown, or a hidden ancestor shown)\n        else {\n            scheduler.whenVisible('refresh', scheduler, [true]);\n        }\n    }\n    //endregion\n    //region EventStore\n    attachToEventStore(eventStore) {\n        super.attachToEventStore(eventStore);\n        this.refreshAllWhenReady = true;\n        if (eventStore) {\n            eventStore.ion({\n                name             : 'eventStore',\n                addConfirmed     : 'onEventStoreAddConfirmed',\n                refreshPreCommit : 'onEventStoreRefresh',\n                thisObj          : this\n            });\n        }\n    }\n    onEventStoreAddConfirmed({ record }) {\n        for (const element of this.client.getElementsFromEventRecord(record)) {\n            element.classList.remove('b-iscreating');\n        }\n    }\n    onEventStoreRefresh({ action }) {\n        if (action === 'batch') {\n            this.refreshAllWhenReady = true;\n        }\n    }\n    onEventStoreChange({ action, records : eventRecords = [], record, replaced, changes, isAssign }) {\n        const\n            me          = this,\n            resourceIds = new Set();\n        eventRecords.forEach(eventRecord => {\n            // Update all resource rows to which this event is assigned *if* the resourceStore\n            // contains that resource (We could have filtered the resourceStore)\n            const renderedEventResources = eventRecord.$linkedResources?.filter(r => me.resourceStore.includes(r));\n            renderedEventResources?.forEach(resourceRecord => resourceIds.add(resourceRecord.id));\n        });\n        switch (action) {\n            // No-ops\n            case 'sort':  // Order in EventStore does not matter, so these actions are no-ops\n            case 'group':\n            case 'move':\n            case 'remove': // Remove is a no-op since assignment will also be removed\n            case 'batch':\n                return;\n            case 'dataset':\n                me.refreshAllResourcesWhenReady();\n                return;\n            case 'add':\n            case 'updateMultiple':\n                // Just refresh below\n                break;\n            case 'replace':\n                // Gather resources from both the old record and the new one\n                replaced.forEach(([, newEvent]) => {\n                    // Old cleared by changed assignment\n                    newEvent.resources.map(resourceRecord => resourceIds.add(resourceRecord.id));\n                });\n                // And clear them\n                me.clearResources(resourceIds);\n                break;\n            case 'removeall':\n            case 'filter':\n                // Clear all when filtering for simplicity. If that turns out to give bad performance, one would need to\n                // figure out which events was filtered out and only clear their resources.\n                me.clearAll();\n                me.refresh();\n                return;\n            case 'update': {\n                // Check if changes are graph related or not\n                const allChrono = record.$entity\n                    ? !Object.keys(changes).some(name => !record.$entity.getField(name))\n                    : !Object.keys(changes).some(name => !chronoFields[name]);\n                // If any one of these in changes, it will affect visuals\n                let changeCount = 0;\n                if ('startDate' in changes) changeCount++;\n                if ('endDate' in changes) changeCount++;\n                if ('duration' in changes) changeCount++;\n                // Always redraw non chrono changes (name etc)\n                if (!allChrono || changeCount || 'percentDone' in changes || 'inactive' in changes || 'segments' in changes) {\n                    if (me.shouldWaitForInitializeAndEngineReady) {\n                        me.refreshResourcesWhenReady(resourceIds);\n                    }\n                    else {\n                        me.clearResources(resourceIds);\n                        me.refresh();\n                    }\n                }\n                return;\n            }\n        }\n        me.refreshResourcesWhenReady(resourceIds);\n    }\n    //endregion\n    //region ResourceStore\n    attachToResourceStore(resourceStore) {\n        const me = this;\n        super.attachToResourceStore(resourceStore);\n        me.refreshAllWhenReady = true;\n        if (me.resourceColumns) {\n            me.resourceColumns.resourceStore = resourceStore;\n        }\n        resourceStore.ion({\n            name             : 'resourceStore',\n            changePreCommit  : 'onResourceStoreChange',\n            refreshPreCommit : 'onResourceStoreRefresh',\n            // In vertical, resource store is not the row store but should toggle the load mask\n            load             : () => me.scheduler.unmaskBody(),\n            thisObj          : me,\n            prio             : 1 // Call before others to clear cache before redraw\n        });\n        if (me.initialized && me.scheduler.isPainted) {\n            // Invalidate resource range and events\n            me.firstResource = me.lastResource = null;\n            me.clearAll();\n            me.renderer();\n        }\n    }\n    onResourceStoreChange({ source : resourceStore, action, records = [], record, replaced, changes }) {\n        const\n            me              = this,\n            // records for add, record for update, replaced [[old, new]] for replace\n            resourceRecords = replaced ? replaced.map(r => r[1]) : records,\n            resourceIds     = new Set(resourceRecords.map(resourceRecord => resourceRecord.id));\n        // Invalidate resource range\n        me.firstResource                  = me.lastResource = null;\n        resourceStore._allResourceRecords = null;\n        const { allResourceRecords } = resourceStore;\n        // Operation that did not invalidate engine, refresh directly\n        if (me.scheduler.isEngineReady) {\n            switch (action) {\n                case 'update':\n                    if (changes?.id) {\n                        me.clearResources([changes.id.oldValue, changes.id.value]);\n                    }\n                    else {\n                        me.clearResources([record.id]);\n                    }\n                    // Only the invalidation above needed\n                    break;\n                case 'filter':\n                    // All filtered out resources needs clearing and so does those not filtered out since they might have\n                    // moved horizontally when others hide\n                    me.clearAll();\n                    break;\n            }\n            // Changing a column width means columns after that will have to be recalculated\n            // so clear all cached layouts.\n            if (changes && ('columnWidth' in changes)) {\n                me.clearAll();\n            }\n            me.refresh(true);\n        }\n        // Operation that did invalidate project, update on project refresh\n        else {\n            switch (action) {\n                case 'dataset':\n                case 'remove': // Cannot tell from which index it was removed\n                case 'removeall':\n                    me.refreshAllResourcesWhenReady();\n                    return;\n                case 'replace':\n                case 'add': {\n                    if (!resourceStore.isGrouped) {\n                        // Make sure all existing events following added resources are offset correctly\n                        const\n                            firstIndex = resourceRecords.reduce(\n                                (index, record) => Math.min(index, allResourceRecords.indexOf(record)),\n                                allResourceRecords.length\n                            );\n                        for (let i = firstIndex; i < allResourceRecords.length; i++) {\n                            resourceIds.add(allResourceRecords[i].id);\n                        }\n                    }\n                }\n            }\n            me.refreshResourcesWhenReady(resourceIds);\n        }\n    }\n    onResourceStoreRefresh({ action }) {\n        const me = this;\n        if (action === 'sort' || action === 'group') {\n            // Invalidate resource range & cache\n            me.firstResource = me.lastResource = me.resourceStore._allResourceRecords = null;\n            me.clearAll();\n            me.refresh();\n        }\n    }\n    //endregion\n    //region AssignmentStore\n    attachToAssignmentStore(assignmentStore) {\n        super.attachToAssignmentStore(assignmentStore);\n        this.refreshAllWhenReady = true;\n        if (assignmentStore) {\n            assignmentStore.ion({\n                name             : 'assignmentStore',\n                changePreCommit  : 'onAssignmentStoreChange',\n                refreshPreCommit : 'onAssignmentStoreRefresh',\n                thisObj          : this\n            });\n        }\n    }\n    onAssignmentStoreChange({ action, records : assignmentRecords = [], replaced, changes }) {\n        const\n            me          = this,\n            resourceIds = new Set(assignmentRecords.map(assignmentRecord => assignmentRecord.resourceId));\n        // Operation that did not invalidate engine, refresh directly\n        if (me.scheduler.isEngineReady) {\n            switch (action) {\n                case 'remove':\n                    me.clearResources(resourceIds);\n                    break;\n                case 'filter':\n                    me.clearAll();\n                    break;\n                case 'update': {\n                    // When reassigning, clear old resource also\n                    if ('resourceId' in changes) {\n                        resourceIds.add(changes.resourceId.oldValue);\n                    }\n                    // Ignore engine resolving resourceId -> resource, eventId -> event\n                    if (!Object.keys(changes).filter(field => field !== 'resource' && field !== 'event').length) {\n                        return;\n                    }\n                    me.clearResources(resourceIds);\n                }\n            }\n            me.refresh(true);\n        }\n        // Operation that did invalidate project, update on project refresh\n        else {\n            if (changes && 'resourceId' in changes) {\n                resourceIds.add(changes.resourceId.oldValue);\n            }\n            switch (action) {\n                case 'removeall':\n                    me.refreshAllResourcesWhenReady();\n                    return;\n                case 'replace':\n                    // Gather resources from both the old record and the new one\n                    replaced.forEach(([oldAssignment, newAssignment]) => {\n                        resourceIds.add(oldAssignment.resourceId);\n                        resourceIds.add(newAssignment.resourceId);\n                    });\n            }\n            me.refreshResourcesWhenReady(resourceIds);\n        }\n    }\n    onAssignmentStoreRefresh({ action, records }) {\n        if (action === 'batch') {\n            this.clearAll();\n            this.refreshAllResourcesWhenReady();\n        }\n    }\n    //endregion\n    //region View hooks\n    refreshRows(reLayoutEvents) {\n        if (reLayoutEvents) {\n            this.clearAll();\n            this.scheduler.refreshFromRerender = false;\n        }\n    }\n    // Called from SchedulerEventRendering\n    repaintEventsForResource(resourceRecord) {\n        this.renderResource(resourceRecord);\n    }\n    updateFromHorizontalScroll(scrollX) {\n        if (scrollX !== this.prevScrollX) {\n            this.renderer();\n            this.prevScrollX = scrollX;\n        }\n    }\n    updateFromVerticalScroll() {\n        this.renderer();\n    }\n    scrollResourceIntoView(resourceRecord, options) {\n        const\n            { scheduler } = this,\n            x             = this.allResourceRecords.indexOf(resourceRecord) * scheduler.resourceColumnWidth;\n        return scheduler.scrollHorizontallyTo(x, options);\n    }\n    get allResourceRecords() {\n        return this.scheduler.resourceStore.allResourceRecords;\n    }\n    // Called when viewport size changes\n    onViewportResize(width) {\n        this.resourceColumns.availableWidth = width;\n        this.renderer();\n    }\n    get resourceColumns() {\n        return this.scheduler.timeAxisColumn?.resourceColumns;\n    }\n    // Clear events in case they use date as part of displayed info\n    onLocaleChange() {\n        this.clearAll();\n    }\n    // No need to do anything special\n    onDragAbort() {}\n    onBeforeRowHeightChange() {}\n    onTimeAxisViewModelUpdate() {}\n    updateElementId() {}\n    releaseTimeSpanDiv() {}\n    //endregion\n    //region Dependency connectors\n    /**\n     * Gets displaying item start side\n     *\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @returns {'top'|'left'|'bottom'|'right'} 'left' / 'right' / 'top' / 'bottom'\n     */\n    getConnectorStartSide(eventRecord) {\n        return 'top';\n    }\n    /**\n     * Gets displaying item end side\n     *\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @returns {'top'|'left'|'bottom'|'right'} 'left' / 'right' / 'top' / 'bottom'\n     */\n    getConnectorEndSide(eventRecord) {\n        return 'bottom';\n    }\n    //endregion\n    //region Refresh resources\n    /**\n     * Clears resources directly and redraws them on next project refresh\n     * @param {Number[]|String[]} resourceIds\n     * @private\n     */\n    refreshResourcesWhenReady(resourceIds) {\n        this.clearResources(resourceIds);\n        resourceIds.forEach(id => this.toDrawOnProjectRefresh.add(id));\n    }\n    /**\n     * Clears all resources directly and redraws them on next project refresh\n     * @private\n     */\n    refreshAllResourcesWhenReady() {\n        this.clearAll();\n        this.refreshAllWhenReady = true;\n    }\n    //region Rendering\n    // Resources in view + buffer\n    get resourceRange() {\n        return this.getResourceRange(true);\n    }\n    // Resources strictly in view\n    get visibleResources() {\n        const { first, last } = this.getResourceRange();\n        return {\n            first : this.allResourceRecords[first],\n            last  : this.allResourceRecords[last]\n        };\n    }\n    getResourceRange(withBuffer) {\n        const\n            {\n                scheduler,\n                resourceStore\n            }                  = this,\n            {\n                resourceColumnWidth,\n                scrollX\n            }                  = scheduler,\n            {\n                scrollWidth\n            }                  = scheduler.timeAxisSubGrid.scrollable,\n            resourceBufferSize = withBuffer ? this.resourceBufferSize : 0,\n            viewportStart      = scrollX - resourceBufferSize,\n            viewportEnd        = scrollX + scrollWidth + resourceBufferSize;\n        if (!resourceStore?.count) {\n            return { first : -1, last : -1 };\n        }\n        // Some resources define their own width\n        if (scheduler.variableColumnWidths) {\n            let first, last = 0, start, end = 0;\n            this.allResourceRecords.forEach((resource, i) => {\n                resource.instanceMeta(scheduler).insetStart = start = end;\n                end                                         = start + resource.columnWidth;\n                if (start > viewportEnd) {\n                    return false;\n                }\n                if (end > viewportStart && first == null) {\n                    first = i;\n                }\n                else if (start < viewportEnd) {\n                    last = i;\n                }\n            });\n            return { first, last };\n        }\n        // We are using fixed column widths\n        else {\n            return {\n                first : Math.max(Math.floor(scrollX / resourceColumnWidth) - resourceBufferSize, 0),\n                last  : Math.min(\n                    Math.floor((scrollX + scheduler.timeAxisSubGrid.width) / resourceColumnWidth) + resourceBufferSize,\n                    this.allResourceRecords.length - 1\n                )\n            };\n        }\n    }\n    // Dates in view + buffer\n    get dateRange() {\n        const\n            { scheduler } = this;\n        let bottomDate = scheduler.getDateFromCoordinate(Math.min(\n            scheduler.scrollTop + scheduler.bodyHeight + scheduler.tickSize - 1,\n            (scheduler.virtualScrollHeight || scheduler.scrollable.scrollHeight) - 1)\n        );\n        // Might end up below time axis (out of ticks)\n        if (!bottomDate) {\n            bottomDate = scheduler.timeAxis.last.endDate;\n        }\n        let topDate = scheduler.getDateFromCoordinate(Math.max(scheduler.scrollTop - scheduler.tickSize, 0));\n        // Might end up above time axis when reconfiguring (since this happens as part of rendering)\n        if (!topDate) {\n            topDate    = scheduler.timeAxis.first.startDate;\n            bottomDate = scheduler.getDateFromCoordinate(scheduler.bodyHeight + scheduler.tickSize - 1);\n        }\n        return {\n            topDate,\n            bottomDate\n        };\n    }\n    getTimeSpanRenderData(eventRecord, resourceRecord, includeOutside = false) {\n        const\n            me             = this,\n            {\n                scheduler\n            }              = me,\n            {\n                preamble,\n                postamble\n            }              = eventRecord,\n            {\n                variableColumnWidths\n            }              = scheduler,\n            useEventBuffer = scheduler.features.eventBuffer?.enabled && me.isProVerticalRendering &&\n                (preamble || postamble) && !eventRecord.isMilestone,\n            startDateField = useEventBuffer ? 'wrapStartDate' : 'startDate',\n            endDateField   = useEventBuffer ? 'wrapEndDate' : 'endDate',\n            // Must use Model.get in order to get latest values in case we are inside a batch.\n            // EventResize changes the endDate using batching to enable a tentative change\n            // via the batchedUpdate event which is triggered when changing a field in a batch.\n            // Fall back to accessor if propagation has not populated date fields.\n            startDate      = eventRecord.isBatchUpdating && eventRecord.hasBatchedChange(startDateField) && !useEventBuffer\n                ? eventRecord.get(startDateField) : eventRecord[startDateField],\n            endDate        = eventRecord.isBatchUpdating && eventRecord.hasBatchedChange(endDateField) && !useEventBuffer\n                ? eventRecord.get(endDateField) : eventRecord[endDateField],\n            {\n                resourceMarginObject : { total }\n            }              = scheduler.getResourceLayoutSettings(resourceRecord),\n            top            = scheduler.getCoordinateFromDate(startDate),\n            instanceMeta   = resourceRecord.instanceMeta(scheduler),\n            // Preliminary values for left & width, used for proxy. Will be changed on layout.\n            // The property \"left\" is utilized based on Scheduler's rtl setting.\n            // If RTL, then it's used as the \"right\" style position.\n            left           = variableColumnWidths ? instanceMeta.insetStart : me.allResourceRecords.indexOf(resourceRecord) * scheduler.resourceColumnWidth,\n            resourceWidth  = scheduler.getResourceWidth(resourceRecord),\n            width          = resourceWidth - total,\n            startDateMS    = startDate.getTime(),\n            endDateMS      = endDate.getTime();\n        let bottom = scheduler.getCoordinateFromDate(endDate),\n            height = bottom - top;\n        // Below, estimate height\n        if (bottom === -1) {\n            height = Math.round((endDateMS - startDateMS) * scheduler.timeAxisViewModel.getSingleUnitInPixels('millisecond'));\n            bottom = top + height;\n        }\n        return {\n            eventRecord,\n            resourceRecord,\n            left,\n            top,\n            bottom,\n            resourceWidth,\n            width,\n            height,\n            startDate,\n            endDate,\n            startDateMS,\n            endDateMS,\n            useEventBuffer,\n            children : [],\n            start   : startDate,\n            end     : endDate,\n            startMS : startDateMS,\n            endMS   : endDateMS\n        };\n    }\n    // Earlier start dates are above later tasks\n    // If same start date, longer tasks float to top\n    // If same start + duration, sort by name\n    eventSorter(a, b) {\n        const\n            startA = a.dataStartMs || a.startDateMS, // dataXX are used if configured with fillTicks\n            endA   = a.dataEndMs || a.endDateMS,\n            startB = b.dataStartMs || b.startDateMS,\n            endB   = b.dataEndMs || b.endDateMS,\n            nameA  = a.isModel ? a.name : a.eventRecord.name,\n            nameB  = b.isModel ? b.name : b.eventRecord.name;\n        return startA - startB || endB - endA || (nameA < nameB ? -1 : nameA == nameB ? 0 : 1);\n    }\n    layoutEvents(resourceRecord, allEvents, includeOutside = false, parentEventRecord, eventSorter) {\n        const\n            me                        = this,\n            { scheduler }             = me,\n            {\n                variableColumnWidths\n            }                         = scheduler,\n            { id : resourceId }       = resourceRecord,\n            instanceMeta              = resourceRecord.instanceMeta(scheduler),\n            cacheKey                  = parentEventRecord ? `${resourceId}-${parentEventRecord.id}` : resourceId,\n            // Cache per resource\n            cache                     = me.resourceMap.set(cacheKey, {}).get(cacheKey),\n            // Resource \"column\"\n            resourceIndex             = me.allResourceRecords.indexOf(resourceRecord),\n            {\n                barMargin,\n                resourceMarginObject : { start, total }\n            }                         = scheduler.getResourceLayoutSettings(resourceRecord, parentEventRecord);\n        const layoutData = allEvents.reduce((toLayout, eventRecord) => {\n            if (eventRecord.isScheduled) {\n                const\n                    renderData     = scheduler.generateRenderData(eventRecord, resourceRecord, false),\n                    // Elements will be appended to eventData during syncing\n                    eventData      = { renderData },\n                    eventResources = ObjectHelper.getMapPath(me.eventMap, renderData.eventId, {});\n                // Cache per event, { e1 : { r1 : { xxx }, r2 : ... }, e2 : ... }\n                // Uses renderData.eventId in favor of eventRecord.id to work with ResourceTimeRanges\n                eventResources[resourceId] = eventData;\n                // Cache per resource\n                cache[renderData.eventId] = eventData;\n                // Position ResourceTimeRanges directly, they do not affect the layout of others\n                if (renderData.fillSize) {\n                    // The property \"left\" is utilized based on Scheduler's rtl setting.\n                    // If RTL, then it's used as the \"right\" style position.\n                    renderData.left = variableColumnWidths ? instanceMeta.insetStart : resourceIndex * scheduler.resourceColumnWidth;\n                    renderData.width = scheduler.getResourceWidth(resourceRecord);\n                }\n                // Anything not flagged with `fillSize` should take part in layout\n                else {\n                    toLayout.push(renderData);\n                }\n            }\n            return toLayout;\n        }, []);\n        // Ensure the events are rendered in natural order so that navigation works.\n        layoutData.sort(eventSorter ?? me.eventSorter);\n        // Apply per resource event layout (pack, overlap or mixed)\n        me.verticalLayout.applyLayout(\n            layoutData,\n            scheduler.getResourceWidth(resourceRecord, parentEventRecord),\n            start,\n            total,\n            barMargin,\n            resourceIndex,\n            scheduler.getEventLayout(resourceRecord, parentEventRecord)\n        );\n        return cache;\n    }\n    // Calculate the layout for all events assigned to a resource. Since we are never stacking, the layout of one\n    // resource will never affect the others\n    layoutResourceEvents(resourceRecord) {\n        const\n            me                  = this,\n            { scheduler }       = me,\n            // Used in loop, reduce access time a wee bit\n            {\n                assignmentStore,\n                eventStore,\n                timeAxis\n            }                   = scheduler;\n        // Events for the resource, minus those that are filtered out by filtering assignments and events\n        let events = eventStore.getEvents({\n            includeOccurrences : scheduler.enableRecurringEvents,\n            resourceRecord,\n            startDate          : timeAxis.startDate,\n            endDate            : timeAxis.endDate,\n            filter             : (assignmentStore.isFiltered || eventStore.isFiltered) && (eventRecord =>\n                eventRecord.assignments.some(a => a.resource === resourceRecord && assignmentStore.includes(a)))\n        });\n        // Hook for features to inject additional timespans to render\n        events = scheduler.getEventsToRender(resourceRecord, events);\n        return me.layoutEvents(resourceRecord, events);\n    }\n    /**\n     * Used by event drag features to bring into existence event elements that are outside of the rendered block.\n     * @param {Scheduler.model.TimeSpan} eventRecord The event to render\n     * @private\n     */\n    addTemporaryDragElement(eventRecord) {\n        const\n            { scheduler } = this,\n            renderData    = scheduler.generateRenderData(\n                eventRecord,\n                eventRecord.resource,\n                { timeAxis : true, viewport : true }\n            );\n        renderData.top = renderData.row\n            ? (renderData.top + renderData.row.top)\n            : scheduler.getResourceEventBox(eventRecord, eventRecord.resource, true).top;\n        const\n            domConfig   = this.renderEvent({ renderData }),\n            { dataset } = domConfig;\n        delete domConfig.tabIndex;\n        delete dataset.eventId;\n        delete dataset.resourceId;\n        delete dataset.assignmentId;\n        delete dataset.syncId;\n        dataset.transient = true;\n        domConfig.parent  = this.scheduler.foregroundCanvas;\n        // So that the regular DomSyncing which may happen during scroll does not\n        // sweep up and reuse the temporary element.\n        domConfig.retainElement = true;\n        const result = DomHelper.createElement(domConfig);\n        result.innerElement = result.firstChild;\n        eventRecord.instanceMeta(scheduler).hasTemporaryDragElement = true;\n        return result;\n    }\n    // To update an event, first release its element and then render it again.\n    // The element will be reused and updated. Keeps code simpler\n    renderEvent(eventData) {\n        // No point in rendering event that already has an element\n        const\n            { scheduler } = this,\n            data          = eventData.renderData,\n            {\n                resourceRecord,\n                assignmentRecord,\n                eventRecord\n            }             = data,\n            // Event element config, applied to existing element or used to create a new one below\n            elementConfig = {\n                className : data.wrapperCls,\n                tabIndex  : -1,\n                children  : [\n                    {\n                        role      : 'presentation',\n                        className : data.cls,\n                        style     : (data.internalStyle || '') + (data.style || ''),\n                        children  : data.children,\n                        dataset   : {\n                            // Each feature putting contents in the event wrap should have this to simplify syncing and\n                            // element retrieval after sync\n                            taskFeature : 'event'\n                        },\n                        syncOptions : {\n                            syncIdField : 'taskBarFeature'\n                        }\n                    },\n                    ...data.wrapperChildren\n                ],\n                style : {\n                    top                                : data.top,\n                    [scheduler.rtl ? 'right' : 'left'] : data.left,\n                    // DomHelper appends px to dimensions when using numbers\n                    height                             : eventRecord.isMilestone ? '1em' : data.height,\n                    width                              : data.width,\n                    style                              : data.wrapperStyle || '',\n                    fontSize                           : eventRecord.isMilestone ? Math.min(data.width, 40) : null\n                },\n                dataset : {\n                    // assignmentId is set in this function conditionally\n                    resourceId : resourceRecord.id,\n                    eventId    : data.eventId, // Not using eventRecord.id to distinguish between Event and ResourceTimeRange\n                    // Sync using assignment id for events and event id for ResourceTimeRanges\n                    syncId     : assignmentRecord ? this.assignmentStore.getOccurrence(assignmentRecord, eventRecord).id : data.eventId\n                },\n                // Will not be part of DOM, but attached to the element\n                elementData   : eventData,\n                // Dragging etc. flags element as retained, to not reuse/release it during that operation. Events\n                // always use assignments, but ResourceTimeRanges does not\n                retainElement : (assignmentRecord || eventRecord).instanceMeta(this.scheduler).retainElement,\n                // Options for this level of sync, lower levels can have their own\n                syncOptions   : {\n                    syncIdField      : 'taskFeature',\n                    // Remove instead of release when a feature is disabled\n                    releaseThreshold : 0\n                }\n            };\n        elementConfig.className['b-sch-vertical'] = 1;\n        // Some browsers throw warnings on zIndex = ''\n        if (data.zIndex) {\n            elementConfig.zIndex = data.zIndex;\n        }\n        // Do not want to spam dataset with empty prop when not using assignments (ResourceTimeRanges)\n        if (assignmentRecord) {\n            elementConfig.dataset.assignmentId = assignmentRecord.id;\n        }\n        // Allows access to the used config later, for example to retrieve element\n        data.elementConfig = eventData.elementConfig = elementConfig;\n        scheduler.afterRenderEvent({ renderData : data, domConfig : elementConfig });\n        return elementConfig;\n    }\n    renderResource(resourceRecord) {\n        const\n            me                          = this,\n            // Date at top and bottom for determining which events to include\n            { topDateMS, bottomDateMS } = me,\n            // Will hold element configs\n            eventDOMConfigs             = [];\n        let resourceEntry = me.resourceMap.get(resourceRecord.id);\n        // Layout all events for the resource unless already done\n        if (!resourceEntry) {\n            resourceEntry = me.layoutResourceEvents(resourceRecord);\n        }\n        // Iterate over all events for the resource\n        for (const eventId in resourceEntry) {\n            const\n                eventData                               = resourceEntry[eventId],\n                { endDateMS, startDateMS, eventRecord } = eventData.renderData;\n            if (\n                // Only collect configs for those actually in view\n                endDateMS >= topDateMS && startDateMS <= bottomDateMS &&\n                // And not being dragged, those have a temporary element already\n                !eventRecord.instanceMeta(me.scheduler).hasTemporaryDragElement\n            ) {\n                // Reuse DomConfig if available, otherwise render event to create one\n                const domConfig = eventData.elementConfig?.className !== 'b-released' && eventData.elementConfig || me.renderEvent(eventData);\n                eventDOMConfigs.push(domConfig);\n            }\n        }\n        return eventDOMConfigs;\n    }\n    isEventElement(domConfig) {\n        const className = domConfig && domConfig.className;\n        return className && className[this.scheduler.eventCls + '-wrap'];\n    }\n    get shouldWaitForInitializeAndEngineReady() {\n        return !this.initialized || (!this.scheduler.isEngineReady && !this.scheduler.isCreating);\n    }\n    // Single cell so only one call to this renderer, determine which events are in view and draw them.\n    // Drawing on scroll is triggered by `updateFromVerticalScroll()` and `updateFromHorizontalScroll()`\n    renderer() {\n        const\n            me                                           = this,\n            { scheduler }                                = me,\n            // Determine resource range to draw events for\n            { first : firstResource, last : lastResource } = me.resourceRange,\n            // Date at top and bottom for determining which events to include\n            { topDate, bottomDate }                        = me.dateRange,\n            syncConfigs                                    = [],\n            featureDomConfigs                              = [];\n        // If scheduler is creating a new event, the render needs to be synchronous, so\n        // we cannot wait for the engine to normalize - the new event will have correct data set.\n        if (me.shouldWaitForInitializeAndEngineReady) {\n            return;\n        }\n        // Update current time range, reflecting the change on the vertical time axis header\n        if (!DateHelper.isEqual(topDate, me.topDate) || !DateHelper.isEqual(bottomDate, me.bottomDate)) {\n            // Calculated values used by `renderResource()`\n            me.topDate      = topDate;\n            me.bottomDate   = bottomDate;\n            me.topDateMS    = topDate.getTime();\n            me.bottomDateMS = bottomDate.getTime();\n            const range = me.timeView.range = { startDate : topDate, endDate : bottomDate };\n            scheduler.internalOnVisibleDateRangeChange(range);\n        }\n        if (firstResource !== -1 && lastResource !== -1) {\n            // Collect all events for resources in view\n            for (let i = firstResource; i <= lastResource; i++) {\n                syncConfigs.push.apply(syncConfigs, me.renderResource(me.allResourceRecords[i]));\n            }\n        }\n        scheduler.getForegroundDomConfigs(featureDomConfigs);\n        syncConfigs.push.apply(syncConfigs, featureDomConfigs);\n        DomSync.sync({\n            domConfig : {\n                onlyChildren : true,\n                children     : syncConfigs\n            },\n            targetElement : scheduler.foregroundCanvas,\n            syncIdField   : 'syncId',\n            // Called by DomHelper when it creates, releases or reuses elements\n            callback({ action, domConfig, lastDomConfig, targetElement, jsx }) {\n                const { reactComponent } = scheduler;\n                // If element is an event wrap, trigger appropriate events\n                if (me.isEventElement(domConfig) || jsx || domConfig?.elementData?.jsx) {\n                    const\n                        // Some actions are considered first a release and then a render (reusing another element).\n                        // This gives clients code a chance to clean up before reusing an element\n                        isRelease = releaseEventActions[action],\n                        isRender  = renderEventActions[action];\n                    if (scheduler.processEventContent?.({\n                        action,\n                        domConfig,\n                        isRelease : false,\n                        targetElement,\n                        reactComponent,\n                        jsx\n                    })) return;\n                    // If we are reusing an element that was previously released we should not trigger again\n                    if (isRelease && me.isEventElement(lastDomConfig) && !lastDomConfig.isReleased) {\n                        const\n                            data  = lastDomConfig.elementData.renderData,\n                            event = {\n                                renderData       : data,\n                                assignmentRecord : data.assignmentRecord,\n                                eventRecord      : data.eventRecord,\n                                resourceRecord   : data.resourceRecord,\n                                element          : targetElement\n                            };\n                        // Release any portal in React event content\n                        scheduler.processEventContent?.({\n                            isRelease,\n                            targetElement,\n                            reactComponent,\n                            assignmentRecord : data.assignmentRecord\n                        });\n                        // Some browsers do not blur on set to display:none, so releasing the active element\n                        // must *explicitly* move focus outwards to the view.\n                        if (targetElement === DomHelper.getActiveElement(targetElement)) {\n                            scheduler.focusElement.focus();\n                        }\n                        // This event is documented on Scheduler\n                        scheduler.trigger('releaseEvent', event);\n                    }\n                    if (isRender) {\n                        const\n                            data  = domConfig.elementData.renderData,\n                            event = {\n                                renderData       : data,\n                                assignmentRecord : data.assignmentRecord,\n                                eventRecord      : data.eventRecord,\n                                resourceRecord   : data.resourceRecord,\n                                element          : targetElement,\n                                isReusingElement : action === 'reuseElement',\n                                isRepaint        : action === 'reuseOwnElement'\n                            };\n                        event.reusingElement = action === 'reuseElement';\n                        // This event is documented on Scheduler\n                        scheduler.trigger('renderEvent', event);\n                    }\n                }\n            }\n        });\n        // Change in displayed resources?\n        if (me.firstResource !== firstResource || me.lastResource !== lastResource) {\n            // Update header to match\n            const range = me.resourceColumns.visibleResources = { firstResource, lastResource };\n            // Store which resources are currently in view\n            me.firstResource = firstResource;\n            me.lastResource  = lastResource;\n            scheduler.onVisibleResourceRangeChange(range);\n            scheduler.trigger('resourceRangeChange', range);\n        }\n    }\n    refresh(transition) {\n        this.scheduler.runWithTransition(() => this.renderer(), transition);\n    }\n    // To match horizontals API, used from EventDrag\n    refreshResources(resourceIds) {\n        this.clearResources(resourceIds);\n        this.refresh();\n    }\n    // To match horizontals API, used from EventDrag\n    refreshEventsForResource(recordOrRow, force = true, draw = true) {\n        this.refreshResources([recordOrRow.id]);\n    }\n    onRenderDone() {\n    }\n    //endregion\n    //region Other\n    get timeView() {\n        return this.scheduler.timeView;\n    }\n    //endregion\n    //region Cache\n    // Clears cached resource layout\n    clearResources(resourceIds) {\n        const { resourceMap, eventMap } = this;\n        resourceIds.forEach(resourceId => {\n            if (resourceMap.has(resourceId)) {\n                // The *keys* of an Object are strings, so we must iterate the values\n                // and use the original eventId to look up in the Map which preserves key type.\n                Object.values(resourceMap.get(resourceId)).forEach(({ renderData : { eventId } }) => {\n                    delete eventMap.get(eventId)[resourceId];\n                });\n                resourceMap.delete(resourceId);\n            }\n        });\n    }\n    clearAll() {\n        this.resourceMap.clear();\n        this.eventMap.clear();\n    }\n    //endregion\n}\nVerticalRendering._$name = 'VerticalRendering';", "import Widget from '../../Core/widget/Widget.js';\nimport DomSync from '../../Core/helper/DomSync.js';\n/**\n * @module Scheduler/view/TimeAxisBase\n */\nfunction isLastLevel(level, levels) {\n    return level === levels.length - 1;\n}\nfunction isLastCell(level, cell) {\n    return cell === level.cells[level.cells.length - 1];\n}\n/**\n * Base class for HorizontalTimeAxis and VerticalTimeAxis. Contains shared functionality to only render ticks in view,\n * should not be used directly.\n *\n * @extends Core/widget/Widget\n * @private\n * @abstract\n */\nexport default class TimeAxisBase extends Widget {\n    static $name = 'TimeAxisBase';\n    //region Config\n    static configurable = {\n        /**\n         * The minimum width for a bottom row header cell to be considered 'compact', which adds a special CSS class\n         * to the row (for special styling). Copied from Scheduler/Gantt.\n         * @config {Number}\n         * @default\n         */\n        compactCellWidthThreshold : 15,\n        // TimeAxisViewModel\n        model : null,\n        cls : null,\n        /**\n         * Style property to use as cell size. Either width or height depending on orientation\n         * @config {'width'|'height'}\n         * @private\n         */\n        sizeProperty : null,\n        /**\n         * Style property to use as cells position. Either left or top depending on orientation\n         * @config {'left'|'top'}\n         * @private\n         */\n        positionProperty : null\n    };\n    startDate = null;\n    endDate   = null;\n    levels    = [];\n    size      = null;\n    // Set visible date range\n    set range({ startDate, endDate }) {\n        const me = this;\n        // Only process a change\n        if (me.startDate - startDate || me.endDate - endDate) {\n            const { client } = me;\n            me.startDate = startDate;\n            me.endDate = endDate;\n            // Avoid refreshing if time axis view is not visible\n            if ((me.sizeProperty === 'width' && client?.hideHeaders) ||\n                (me.sizeProperty === 'height' && client?.verticalTimeAxisColumn?.hidden)) {\n                return;\n            }\n            me.refresh();\n        }\n    }\n    //endregion\n    //region Html & rendering\n    // Generates element configs for all levels defined by the current ViewPreset\n    buildCells(start = this.startDate, end = this.endDate) {\n        const\n            me                   = this,\n            { sizeProperty }     = me,\n            {\n                stickyHeaders,\n                isVertical\n            }                    = me.client || {},\n            featureHeaderConfigs = [],\n            { length }           = me.levels;\n        const cellConfigs = me.levels.map((level, i) => {\n            const stickyHeader = stickyHeaders && (isVertical || i < length - 1);\n            return {\n                className : {\n                    'b-sch-header-row'                     : 1,\n                    [`b-sch-header-row-${level.position}`] : 1,\n                    'b-sch-header-row-main'                : i === me.model.viewPreset.mainHeaderLevel,\n                    'b-lowest'                             : isLastLevel(i, me.levels),\n                    'b-sticky-header'                      : stickyHeader\n                },\n                syncOptions : {\n                    // Keep a maximum of 5 released cells. Might be fine with fewer since ticks are fixed width.\n                    // Prevents an unnecessary amount of cells from sticking around when switching from narrow to\n                    // wide tickSizes\n                    releaseThreshold : 5,\n                    syncIdField      : 'tickIndex'\n                },\n                dataset : {\n                    headerFeature  : `headerRow${i}`,\n                    headerPosition : level.position\n                },\n                // Only include cells in view\n                children : level.cells?.filter(cell => cell.start < end && cell.end > start).map((cell, j) => ({\n                    role      : 'presentation',\n                    className : {\n                        'b-sch-header-timeaxis-cell' : 1,\n                        [cell.headerCellCls]         : cell.headerCellCls,\n                        [`b-align-${cell.align}`]    : cell.align,\n                        'b-last'                     : isLastCell(level, cell)\n                    },\n                    dataset : {\n                        tickIndex : cell.index,\n                        // Used in export tests to resolve dates from tick elements\n                        ...globalThis.DEBUG && { date : cell.start.getTime() }\n                    },\n                    style : {\n                        // DomHelper appends px to numeric dimensions\n                        [me.positionProperty]   : cell.coord,\n                        [sizeProperty]          : cell.width,\n                        [`min-${sizeProperty}`] : cell.width\n                    },\n                    children : [\n                        {\n                            tag       : 'span',\n                            role      : 'presentation',\n                            className : {\n                                'b-sch-header-text' : 1,\n                                'b-sticky-header'   : stickyHeader\n                            },\n                            html : cell.value\n                        }\n                    ]\n                }))\n            };\n        });\n        // When tested in isolation there is no client\n        me.client?.getHeaderDomConfigs(featureHeaderConfigs);\n        cellConfigs.push(...featureHeaderConfigs);\n        // noinspection JSSuspiciousNameCombination\n        return {\n            onlyChildren : true,\n            syncOptions  : {\n                // Do not keep entire levels no longer used, for example after switching view preset\n                releaseThreshold : 0\n            },\n            children : cellConfigs\n        };\n    }\n    render(targetElement) {\n        super.render(targetElement);\n        this.refresh(true);\n    }\n    /**\n     * Refresh the UI\n     * @param {Boolean} [rebuild] Specify `true` to force a rebuild of the underlying header level definitions\n     */\n    refresh(rebuild = !this.levels.length) {\n        const\n            me               = this,\n            { columnConfig } = me.model,\n            { levels }       = me,\n            oldLevelsCount   = levels.length;\n        if (rebuild) {\n            levels.length = 0;\n            columnConfig.forEach((cells, position) => levels[position] = {\n                position,\n                cells\n            });\n            me.size = levels[0].cells.reduce((sum, cell) => sum + cell.width, 0);\n            const { parentElement } = me.element;\n            // Don't mutate a classList unless necessary. Browsers invalidate the style.\n            if (parentElement && (levels.length !== oldLevelsCount || rebuild)) {\n                parentElement.classList.remove(`b-sch-timeaxiscolumn-levels-${oldLevelsCount}`);\n                parentElement.classList.add(`b-sch-timeaxiscolumn-levels-${levels.length}`);\n            }\n        }\n        if (!me.startDate || !me.endDate) {\n            return;\n        }\n        // Boil down levels to only show what is in view\n        DomSync.sync({\n            domConfig     : me.buildCells(),\n            targetElement : me.element,\n            syncIdField   : 'headerFeature'\n        });\n        me.trigger('refresh');\n    }\n    //endregion\n    // Our widget class doesn't include \"base\".\n    get widgetClass() {\n        return 'b-timeaxis';\n    }\n}\nTimeAxisBase._$name = 'TimeAxisBase';", "import TimeAxisBase from './TimeAxisBase.js';\n/**\n * @module Scheduler/view/HorizontalTimeAxis\n */\n/**\n * A visual horizontal representation of the time axis described in the\n * {@link Scheduler.preset.ViewPreset#field-headers} field.\n * Normally you should not interact with this class directly.\n *\n * @extends Scheduler/view/TimeAxisBase\n * @private\n */\nexport default class HorizontalTimeAxis extends TimeAxisBase {\n    //region Config\n    static $name = 'HorizontalTimeAxis';\n    static type = 'horizontaltimeaxis';\n    static configurable = {\n        model        : null,\n        sizeProperty : 'width'\n    };\n    //endregion\n    get positionProperty() {\n        return this.owner?.rtl ? 'right' : 'left';\n    }\n    get width() {\n        return this.size;\n    }\n    onModelUpdate() {\n        // Force rebuild when availableSpace has changed, to recalculate width and maybe apply compact styling\n        if (!this.owner?.hideHeaders && this.model.availableSpace > 0 && this.model.availableSpace !== this.width) {\n            this.refresh(true);\n        }\n    }\n    updateModel(timeAxisViewModel) {\n        this.detachListeners('tavm');\n        timeAxisViewModel?.ion({\n            name    : 'tavm',\n            update  : 'onModelUpdate',\n            thisObj : this\n        });\n    }\n}\nHorizontalTimeAxis._$name = 'HorizontalTimeAxis';", "import Widget from '../../Core/widget/Widget.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport DomClassList from '../../Core/helper/util/DomClassList.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport AvatarRendering from '../../Core/widget/util/AvatarRendering.js';\n/**\n * @module Scheduler/view/ResourceHeader\n */\n/**\n * Header widget that renders resource column headers and acts as the interaction point for resource columns in vertical\n * mode. Note that it uses virtual rendering and element reusage to gain performance, only headers in view are available\n * in DOM. Because of this you should avoid direct element manipulation, any such changes can be discarded at any time.\n *\n * By default, it displays resources `name` and also applies its `iconCls` if any, like this:\n *\n * ```html\n * <i class=\"iconCls\">name</i>\n * ```\n *\n * If Scheduler is configured with a {@link Scheduler.view.Scheduler#config-resourceImagePath} the\n * header will render miniatures for the resources, using {@link Scheduler.model.ResourceModel#field-imageUrl}\n * or {@link Scheduler.model.ResourceModel#field-image} with fallback to\n * {@link Scheduler.model.ResourceModel#field-name} + {@link Scheduler.view.Scheduler#config-resourceImageExtension}\n * for unset values.\n *\n * The contents and styling of the resource cells in the header can be customized using {@link #config-headerRenderer}:\n *\n * ```javascript\n * new Scheduler({\n *     mode            : 'vertical',\n *     resourceColumns : {\n *         headerRenderer : ({ resourceRecord }) => `Hello ${resourceRecord.name}`\n *     }\n * }\n *```\n *\n * The width of the resource columns is determined by the {@link #config-columnWidth} config.\n *\n * @extends Core/widget/Widget\n */\nexport default class ResourceHeader extends Widget {\n    //region Config\n    static $name = 'ResourceHeader';\n    static type = 'resourceheader';\n    static configurable = {\n        /**\n         * Resource store used to render resource headers. Assigned from Scheduler.\n         * @config {Scheduler.data.ResourceStore}\n         * @private\n         */\n        resourceStore : null,\n        /**\n         * Custom header renderer function. Can be used to manipulate the element config used to create the element\n         * for the header:\n         *\n         * ```javascript\n         * new Scheduler({\n         *   resourceColumns : {\n         *     headerRenderer({ elementConfig, resourceRecord }) {\n         *       elementConfig.dataset.myExtraData = 'extra';\n         *       elementConfig.style.fontWeight = 'bold';\n         *     }\n         *   }\n         * });\n         * ```\n         *\n         * See {@link DomConfig} for more information.\n         * Please take care to not break the default configs :)\n         *\n         * Or as a template by returning HTML from the function:\n         *\n         * ```javascript\n         * new Scheduler({\n         *   resourceColumns : {\n         *     headerRenderer : ({ resourceRecord }) => `\n         *       <div class=\"my-custom-template\">\n         *       ${resourceRecord.firstName} {resourceRecord.surname}\n         *       </div>\n         *     `\n         *   }\n         * });\n         * ```\n         *\n         * NOTE: When using `headerRenderer` no default internal markup is applied to the resource header cell,\n         * `iconCls` and {@link Scheduler.model.ResourceModel#field-imageUrl} or {@link Scheduler.model.ResourceModel#field-image}\n         * will have no effect unless you supply custom markup for them.\n         *\n         * @config {Function}\n         * @param {Object} params Object containing the params below\n         * @param {Scheduler.model.ResourceModel} params.resourceRecord Resource whose header is being rendered\n         * @param {DomConfig} params.elementConfig A config object used to create the element for the resource\n         * @returns {void}\n         */\n        headerRenderer : null,\n        /**\n         * Set to `false` to render just the resource name, `true` to render an avatar (or initials if no image exists)\n         * @config {Boolean}\n         * @default true\n         */\n        showAvatars : {\n            value : true,\n            $config : 'nullify'\n        },\n        /**\n         * Assign to toggle resource columns **fill* mode. `true` means they will stretch (grow) to fill viewport, `false`\n         * that they will respect their configured `columnWidth`.\n         *\n         * This is ignored if *any* resources are loaded with {@link Scheduler.model.ResourceModel#field-columnWidth}.\n         * @member {Boolean} fillWidth\n         */\n        /**\n         * Automatically resize resource columns to **fill** available width. Set to `false` to always respect the\n         * configured `columnWidth`.\n         *\n         * This is ignored if *any* resources are loaded with {@link Scheduler.model.ResourceModel#field-columnWidth}.\n         * @config {Boolean}\n         * @default\n         */\n        fillWidth : true,\n        /**\n         * Assign to toggle resource columns **fit* mode. `true` means they will grow or shrink to always fit viewport,\n         * `false` that they will respect their configured `columnWidth`.\n         *\n         * This is ignored if *any* resources are loaded with {@link Scheduler.model.ResourceModel#field-columnWidth}.\n         * @member {Boolean} fitWidth\n         */\n        /**\n         * Automatically resize resource columns to always **fit** available width.\n         *\n         * This is ignored if *any* resources are loaded with {@link Scheduler.model.ResourceModel#field-columnWidth}.\n         * @config {Boolean}\n         * @default\n         */\n        fitWidth : false,\n        /**\n         * Width for each resource column.\n         *\n         * This is used for resources which are not are loaded with a {@link Scheduler.model.ResourceModel#field-columnWidth}.\n         * @config {Number}\n         */\n        columnWidth : 150,\n        // Copied from Scheduler#resourceImagePath on creation in TimeAxisColumn.js\n        imagePath : null,\n        // Copied from Scheduler#resourceImageExtension on creation in TimeAxisColumn.js\n        imageExtension : null,\n        // Copied from Scheduler#defaultResourceImageName on creation in TimeAxisColumn.js\n        defaultImageName : null,\n        availableWidth : null\n    };\n    /**\n     * An index of the first visible resource in vertical mode\n     * @property {Number}\n     * @readonly\n     * @private\n     */\n    firstResource = -1;\n    /**\n     * An index of the last visible resource in vertical mode\n     * @property {Number}\n     * @readonly\n     * @private\n     */\n    lastResource  = -1;\n    //endregion\n    //region Init\n    construct(config) {\n        const me = this;\n        // Inject this into owning Scheduler early because code further down\n        // can call code which uses scheduler.resourceColumns.\n        config.scheduler._resourceColumns = me;\n        super.construct(config);\n        if (me.imagePath != null) {\n            // Need to increase height a bit when displaying images\n            me.element.classList.add('b-has-images');\n        }\n        EventHelper.on({\n            element     : me.element,\n            delegate    : '.b-resourceheader-cell',\n            capture     : true,\n            click       : 'onResourceMouseEvent',\n            dblclick    : 'onResourceMouseEvent',\n            contextmenu : 'onResourceMouseEvent',\n            thisObj     : me\n        });\n    }\n    changeShowAvatars(show) {\n        this.avatarRendering?.destroy();\n        if (show) {\n            this.avatarRendering = new AvatarRendering({\n                element : this.element\n            });\n        }\n        return show;\n    }\n    updateShowAvatars() {\n        if (!this.isConfiguring) {\n            this.refresh();\n        }\n    }\n    //endregion\n    //region ResourceStore\n    updateResourceStore(store) {\n        const me = this;\n        me.detachListeners('resourceStore');\n        if (store) {\n            store.ion({\n                name            : 'resourceStore',\n                changePreCommit : 'onResourceStoreDataChange',\n                thisObj         : me\n            });\n            // Already have data? Update width etc\n            if (store.count) {\n                me.onResourceStoreDataChange({});\n            }\n        }\n    }\n    // Redraw resource headers on any data change\n    onResourceStoreDataChange({ action }) {\n        const me    = this;\n        // These must be ingested before we assess the source of column widths\n        // so that they can be cleared *after* their values have been cached.\n        me.getConfig('fillWidth');\n        me.getConfig('fitWidth');\n        me.updateWidthCache();\n        const\n            {\n                element\n            }     = me,\n            width = me.totalWidth;\n        // If we have some defined columnWidths in the resourceStore\n        // we must then bypass configured fitWidth and fillWidth behaviour.\n        if (me.scheduler.variableColumnWidths) {\n            me._fillWidth = me._fitWidth = false;\n        }\n        else {\n            me._fillWidth = me.configuredFillWidth;\n            me._fitWidth = me.configuredFitWidth;\n        }\n        if (width !== me.width) {\n            DomHelper.setLength(element, 'width', width);\n            // During setup, silently set the width. It will then render correctly. After setup, let the world know...\n            me.column.set('width', width, me.column.grid.isConfiguring);\n        }\n        if (action === 'removeall') {\n            // Keep nothing\n            element.innerHTML = '';\n        }\n        if (action === 'remove' || action === 'add' || action === 'filter' || me.fitWidth || me.fillWidth) {\n            me.refreshWidths();\n        }\n        me.column.grid.toggleEmptyText();\n    }\n    get totalWidth() {\n        return this.updateWidthCache();\n    }\n    updateWidthCache() {\n        let result          = 0;\n        const { scheduler } = this;\n        // Flag so that VerticalRendering#getResourceRange knows\n        // whether to use fast or slow mode to ascertain visible columns.\n        scheduler.variableColumnWidths = false;\n        scheduler.resourceStore.forEach(resource => {\n            // Set the start position for each resource with respect to the widths\n            resource.instanceMeta(scheduler).insetStart = result;\n            resource.instanceMeta(scheduler).insetEnd   = result + (resource.columnWidth || scheduler.resourceColumnWidth);\n            if (resource.columnWidth == null) {\n                result += scheduler.resourceColumnWidth;\n            }\n            else {\n                result += resource.columnWidth;\n                scheduler.variableColumnWidths = true;\n            }\n        });\n        return result;\n    }\n    //endregion\n    //region Properties\n    changeColumnWidth(columnWidth) {\n        // Cache configured value, because if *all* resources have their own columnWidths\n        // the property will be nulled, but if we ever recieve a new resource with no\n        // columnWidth, or a columnWidth is nulled, we then have to fall back to using this.\n        if (!this.refreshingWidths) {\n            this.configuredColumnWidth = columnWidth;\n        }\n        return columnWidth;\n    }\n    updateColumnWidth(width, oldWidth) {\n        const me = this;\n        // Flag set in refreshWidths, do not want to create a loop\n        if (!me.refreshingWidths) {\n            me.refreshWidths();\n        }\n        if (!me.isConfiguring) {\n            // If resources are grouped, I need to refresh manually the cached width of resource header columns\n            if (me.resourceStore.isGrouped) {\n                me.updateWidthCache();\n            }\n            me.refresh();\n            // Cannot trigger with requested width, might have changed because of fit/fill\n            me.trigger('columnWidthChange', { width, oldWidth });\n        }\n    }\n    changeFillWidth(fillWidth) {\n        return this.configuredFillWidth = fillWidth;\n    }\n    updateFillWidth() {\n        if (!this.isConfiguring) {\n            this.refreshWidths();\n        }\n    }\n    changeFitWidth(fitWidth) {\n        return this.configuredFitWidth = fitWidth;\n    }\n    updateFitWidth() {\n        if (!this.isConfiguring) {\n            this.refreshWidths();\n        }\n    }\n    getImageURL(imageName) {\n        return StringHelper.joinPaths([this.imagePath || '', imageName || '']);\n    }\n    updateImagePath() {\n        if (!this.isConfiguring) {\n            this.refresh();\n        }\n    }\n    //endregion\n    //region Fit to width\n    updateAvailableWidth(width) {\n        this.refreshWidths();\n    }\n    // Updates the column widths according to fill and fit settings\n    refreshWidths() {\n        const\n            me    = this,\n            {\n                availableWidth,\n                configuredColumnWidth\n            }     = me,\n            count = me.resourceStore?.count;\n        // Bail out if availableWidth not yet set or resource store not assigned/loaded\n        // or column widths are defined in the resources.\n        if (!availableWidth || !count || me.scheduler.variableColumnWidths) {\n            return;\n        }\n        me.refreshingWidths = true;\n        const\n            // Fit width if configured to do so or if configured to fill and used width is less than available width\n            fit           = me.fitWidth || me.fillWidth && configuredColumnWidth * count < availableWidth,\n            useWidth      = fit ? Math.floor(availableWidth / count) : configuredColumnWidth,\n            shouldAnimate = me.column.grid.enableEventAnimations && Math.abs(me._columnWidth - useWidth) > 30;\n        DomHelper.addTemporaryClass(me.element, 'b-animating', shouldAnimate ? 300 : 0, me);\n        me.columnWidth = useWidth;\n        me.refreshingWidths = false;\n    }\n    //endregion\n    //region Rendering\n    // Visual resource range, set by VerticalRendering + its buffer\n    set visibleResources({ firstResource, lastResource }) {\n        this.firstResource = firstResource;\n        this.lastResource = lastResource;\n        this.updateWidthCache();\n        this.refresh();\n    }\n    /**\n     * Refreshes the visible headers\n     */\n    refresh() {\n        const\n            me         = this,\n            {\n                firstResource,\n                scheduler,\n                resourceStore,\n                lastResource\n            }          = me,\n            {\n                variableColumnWidths\n            }          = scheduler,\n            groupField = resourceStore.isGrouped && resourceStore.groupers[0].field,\n            configs    = [];\n        me.element.classList.toggle('b-grouped', Boolean(groupField));\n        if (!me.column.grid.isConfiguring && firstResource > -1 && lastResource > -1 && lastResource < resourceStore.count) {\n            let currentGroup;\n            // Gather element configs for resource headers in view\n            for (let i = firstResource; i <= lastResource; i++) {\n                const\n                    resourceRecord = resourceStore.allResourceRecords[i],\n                    groupRecord    = resourceRecord.groupParent?.get(resourceStore.id),\n                    groupChildren  = groupRecord?.groupChildren;\n                if (groupField && groupRecord.id !== currentGroup?.dataset.resourceId) {\n                    const\n                        groupLeft  = groupChildren[0].instanceMeta(scheduler).insetStart,\n                        groupWidth = groupChildren[groupChildren.length - 1].instanceMeta(scheduler).insetEnd - groupLeft;\n                    currentGroup = {\n                        className : 'b-resourceheader-group-cell',\n                        dataset   : {\n                            resourceId : groupRecord.id\n                        },\n                        style : {\n                            left  : groupLeft,\n                            width : groupWidth\n                        },\n                        children : [\n                            {\n                                tag  : 'span',\n                                html : StringHelper.encodeHtml(groupChildren[0][groupField])\n                            },\n                            {\n                                className : 'b-resourceheader-group-children',\n                                children  : []\n                            }\n                        ]\n                    };\n                    configs.push(currentGroup);\n                }\n                const\n                    instanceMeta  = resourceRecord.instanceMeta(scheduler),\n                    // Possible variable column width taken from the resources, fallback to scheduler's default\n                    width         = resourceRecord.columnWidth || me.columnWidth,\n                    position      = groupField ? instanceMeta.insetStart - currentGroup.style.left //groupChildren[0].instanceMeta(scheduler).insetStart\n                        : variableColumnWidths ? instanceMeta.insetStart : i * me.columnWidth,\n                    elementConfig = {\n                        // Might look like overkill to use DomClassList here, but can be used in headerRenderer\n                        className : new DomClassList({\n                            'b-resourceheader-cell' : 1\n                        }),\n                        dataset : {\n                            resourceId : resourceRecord.id\n                        },\n                        style : {\n                            [scheduler.rtl ? 'right' : 'left'] : position,\n                            width\n                        },\n                        children : []\n                    };\n                // Let a configured headerRenderer have a go at it before applying\n                if (me.headerRenderer) {\n                    const value = me.headerRenderer({ elementConfig, resourceRecord });\n                    if (value) {\n                        if (typeof value === 'string') {\n                            elementConfig.html = value;\n                        }\n                        else if (typeof value === 'object') {\n                            elementConfig.children = [value];\n                        }\n                    }\n                }\n                // No headerRenderer, apply default markup\n                else {\n                    let imageUrl;\n                    if (resourceRecord.imageUrl) {\n                        imageUrl = resourceRecord.imageUrl;\n                    }\n                    else {\n                        if (me.imagePath != null) {\n                            if (resourceRecord.image !== false) {\n                                const imageName = resourceRecord.image ||\n                                    resourceRecord.name?.toLowerCase() + me.imageExtension;\n                                imageUrl = me.getImageURL(imageName);\n                            }\n                        }\n                    }\n                    // By default showing resource name and optionally avatar\n                    elementConfig.children.push(\n                        me.showAvatars && me.avatarRendering.getResourceAvatar({\n                            resourceRecord,\n                            initials        : resourceRecord.initials,\n                            color           : resourceRecord.eventColor,\n                            iconCls         : resourceRecord.iconCls,\n                            defaultImageUrl : me.defaultImageName && me.getImageURL(me.defaultImageName),\n                            imageUrl\n                        }),\n                        {\n                            tag       : 'span',\n                            className : 'b-resource-name',\n                            html      : StringHelper.encodeHtml(resourceRecord.name)\n                        }\n                    );\n                }\n                if (groupField) {\n                    currentGroup.children[1].children.push(elementConfig);\n                }\n                else {\n                    configs.push(elementConfig);\n                }\n            }\n        }\n        // Sync changes to the header\n        DomSync.sync({\n            domConfig : {\n                onlyChildren : true,\n                children     : configs\n            },\n            targetElement : me.element,\n            syncIdField   : 'resourceId',\n            callback : ({ jsx, targetElement, domConfig }) => {\n                // Handle the React (JSX) returned from the headerRenderer\n                scheduler.processResourceHeader?.({ jsx, targetElement, domConfig });\n            }\n        });\n    }\n    //endregion\n    onResourceMouseEvent(event) {\n        const\n            resourceCell   = event.target.closest('.b-resourceheader-cell'),\n            resourceRecord = this.resourceStore.getById(resourceCell.dataset.resourceId);\n        this.trigger('resourceHeader' + StringHelper.capitalize(event.type), {\n            resourceRecord,\n            event\n        });\n    }\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    // It extracts the current configs for the header, removing irrelevant ones\n    getCurrentConfig(options) {\n        const result = super.getCurrentConfig(options);\n        // Assigned from Scheduler\n        delete result.resourceStore;\n        delete result.column;\n        delete result.type;\n        return result;\n    }\n}\nResourceHeader._$name = 'ResourceHeader';", "import WidgetColumn from '../../Grid/column/WidgetColumn.js';\nimport ColumnStore from '../../Grid/data/ColumnStore.js';\nimport Events from '../../Core/mixin/Events.js';\nimport HorizontalTimeAxis from '../view/HorizontalTimeAxis.js';\nimport ResourceHeader from '../view/ResourceHeader.js';\n/**\n * @module Scheduler/column/TimeAxisColumn\n */\n/**\n * A column containing the timeline \"viewport\", in which events, dependencies etc. are drawn.\n * Normally you do not need to interact with or create this column, it is handled by Scheduler.\n *\n * If you wish to output custom contents inside the time axis row cells, you can provide your custom column configuration\n * using the {@link #config-renderer} like so:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *    appendTo         : document.body\n *    columns          : [\n *       { text : 'Name', field : 'name', width : 130 },\n *       {\n *           type : 'timeAxis',\n *           renderer({ record, cellElement }) {\n *               return '<div class=\"cool-chart\"></div>';\n *           }\n *       }\n *    ]\n * });\n * ```\n *\n * @extends Grid/column/WidgetColumn\n * @column\n */\nexport default class TimeAxisColumn extends Events(WidgetColumn) {\n    //region Config\n    headerHoverable = false;\n    static $name = 'TimeAxisColumn';\n    static get fields() {\n        return [\n            // Exclude some irrelevant fields from getCurrentConfig()\n            { name : 'locked', persist : false },\n            { name : 'flex', persist : false },\n            { name : 'width', persist : false },\n            { name : 'cellCls', persist : false },\n            { name : 'field', persist : false },\n            'mode'\n        ];\n    }\n    static get defaults() {\n        return {\n            /**\n             * Set to false to prevent this column header from being dragged.\n             * @config {Boolean} draggable\n             * @category Interaction\n             * @default false\n             */\n            draggable : false,\n            /**\n             * Set to false to prevent grouping by this column.\n             * @config {Boolean} groupable\n             * @category Interaction\n             * @default false\n             */\n            groupable : false,\n            /**\n             * Allow column visibility to be toggled through UI.\n             * @config {Boolean} hideable\n             * @default false\n             * @category Interaction\n             */\n            hideable : false,\n            /**\n             * Show column picker for the column.\n             * @config {Boolean} showColumnPicker\n             * @default false\n             * @category Menu\n             */\n            showColumnPicker : false,\n            /**\n             * Allow filtering data in the column (if Filter feature is enabled)\n             * @config {Boolean} filterable\n             * @default false\n             * @category Interaction\n             */\n            filterable : false,\n            /**\n             * Allow sorting of data in the column\n             * @config {Boolean} sortable\n             * @category Interaction\n             * @default false\n             */\n            sortable : false,\n            /**\n             * Set to `false` to prevent the column from being drag-resized when the ColumnResize plugin is enabled.\n             * @config {Boolean} resizable\n             * @default false\n             * @category Interaction\n             */\n            resizable : false,\n            /**\n             * Allow searching in the column (respected by QuickFind and Search features)\n             * @config {Boolean} searchable\n             * @default false\n             * @category Interaction\n             */\n            searchable : false,\n            /**\n             * @config {String} editor\n             * @hide\n             */\n            editor : false,\n            /**\n             * Set to `true` to show a context menu on the cell elements in this column\n             * @config {Boolean} enableCellContextMenu\n             * @default false\n             * @category Menu\n             */\n            enableCellContextMenu : false,\n            /**\n             * @config {Function|Boolean} tooltipRenderer\n             * @hide\n             */\n            tooltipRenderer : false,\n            /**\n             * CSS class added to the header of this column\n             * @config {String} cls\n             * @category Rendering\n             * @default 'b-sch-timeaxiscolumn'\n             */\n            cls : 'b-sch-timeaxiscolumn',\n            // needs to have width specified, flex-basis messes measurements up\n            needWidth : true,\n            mode       : null,\n            region     : 'normal',\n            exportable : false,\n            htmlEncode : false\n        };\n    }\n    static get type() {\n        return 'timeAxis';\n    }\n    //region Init\n    construct(config) {\n        const me = this;\n        super.construct(...arguments);\n        me.thisObj = me;\n        // Inject the reference to this column as early as possible\n        me.grid._timeAxisColumn = me;\n        me.timeAxisViewModel = me.grid.timeAxisViewModel;\n        // A bit hacky, because mode is a field and not a config\n        // eslint-disable-next-line no-self-assign\n        me.mode = me.mode;\n        me.grid.ion({\n            paint   : 'onTimelinePaint',\n            thisObj : me,\n            once    : true\n        });\n    }\n    static get autoExposeFields() {\n        return true;\n    }\n    // endregion\n    doDestroy() {\n        this.resourceColumns?.destroy();\n        this.timeAxisView?.destroy();\n        super.doDestroy();\n    }\n    set mode(mode) {\n        const\n            me       = this,\n            { grid } = me;\n        me.set('mode', mode);\n        // In horizontal mode this column has a time axis header on top, with timeline ticks\n        if (mode === 'horizontal') {\n            me.timeAxisView = new HorizontalTimeAxis({\n                model                     : me.timeAxisViewModel,\n                compactCellWidthThreshold : me.compactCellWidthThreshold,\n                owner                     : grid,\n                client                    : grid\n            });\n        }\n        // In vertical mode, it instead displays resources at top\n        else if (mode === 'vertical') {\n            me.resourceColumns = ResourceHeader.new({\n                column           : me,\n                scheduler        : grid,\n                resourceStore    : grid.resourceStore,\n                imagePath        : grid.resourceImagePath,\n                imageExtension   : grid.resourceImageExtension,\n                defaultImageName : grid.defaultResourceImageName\n            }, grid.resourceColumns || {});\n            me.relayEvents(me.resourceColumns, [\n                'resourceheaderclick',\n                'resourceheaderdblclick',\n                'resourceheadercontextmenu'\n            ]);\n        }\n    }\n    get mode() {\n        return this.get('mode');\n    }\n    //region Events\n    onViewModelUpdate({ source : viewModel }) {\n        const me = this;\n        if (me.grid.timeAxisSubGrid.collapsed) {\n            return;\n        }\n        if (me.mode === 'horizontal') {\n            // render the time axis view into the column header element\n            me.refreshHeader(true);\n            me.width = viewModel.totalSize;\n            me.grid.refresh();\n            // When width is set above, that ends up on a columnsResized listener, but the refreshing of the fake\n            // scrollers to accommodate the new width is not done in this timeframe, so the upcoming centering related\n            // to preset change cannot work. So we have to refresh the fake scrollers now\n            me.subGrid.refreshFakeScroll();\n        }\n        else if (me.mode === 'vertical') {\n            // Refresh to rerender cells, in the process updating the vertical timeaxis to reflect view model changes\n            me.grid.refreshRows();\n        }\n    }\n    // Called on paint. SubGrid has its width so this is the earliest time to configure the TimeAxisViewModel with\n    // correct width\n    onTimelinePaint({ firstPaint }) {\n        const me = this;\n        if (!me.subGrid.insertRowsBefore) {\n            return;\n        }\n        if (firstPaint) {\n            me.subGridElement.classList.add('b-timeline-subgrid');\n            if (me.mode === 'vertical') {\n                me.refreshHeader();\n                // The above operation can cause height change.\n                me.grid?.onHeightChange();\n            }\n        }\n    }\n    //endregion\n    //region Rendering\n    /**\n     * Refreshes the columns header contents (which is either a HorizontalTimeAxis or a ResourceHeader). Useful if you\n     * have rendered some extra meta data that depends on external data such as the EventStore or ResourceStore.\n     */\n    refreshHeader(internal) {\n        const\n            me          = this,\n            { element } = me;\n        if (element) {\n            if (me.mode === 'horizontal') {\n                // Force timeAxisViewModel to regenerate its column config, which calls header renderers etc.\n                !internal && me.timeAxisViewModel.update(undefined, undefined, true);\n                if (!me.timeAxisView.rendered) {\n                    // Do not need the normal header markup\n                    element.innerHTML = '';\n                    me.timeAxisView.render(element);\n                }\n                else {\n                    // Force rebuild of cells in case external data has changed (cheap since it still syncs to DOM)\n                    me.timeAxisView.refresh(true);\n                }\n            }\n            else if (me.mode === 'vertical') {\n                if (!me.resourceColumns.currentElement) {\n                    // Do not need the normal header markup\n                    element.innerHTML = '';\n                    me.resourceColumns.render(element);\n                }\n                else {\n                    me.resourceColumns.refresh();\n                }\n                // Vertical's resourceColumns is redrawn with the events, no need here\n            }\n        }\n    }\n    internalRenderer(renderData) {\n        const { grid } = this;\n        // No drawing of events before engines initial commit\n        if (grid.project.isInitialCommitPerformed || grid.project.isDelayingCalculation) {\n            grid.currentOrientation.renderer(renderData);\n            return super.internalRenderer(renderData);\n        }\n        return '';\n    }\n    //endregion\n    get timeAxisViewModel() {\n        return this._timeAxisViewModel;\n    }\n    set timeAxisViewModel(timeAxisViewModel) {\n        const me = this;\n        me.detachListeners('tavm');\n        timeAxisViewModel?.ion({\n            name    : 'tavm',\n            update  : 'onViewModelUpdate',\n            prio    : -10000,\n            thisObj : me\n        });\n        me._timeAxisViewModel = timeAxisViewModel;\n        if (me.timeAxisView) {\n            me.timeAxisView.model = timeAxisViewModel;\n        }\n    }\n    // Width of the time axis column is solely determined by the zoom level. We should not keep it part of the state\n    // otherwise restoring the state might break the normal zooming process.\n    // Covered by SchedulerState.t\n    // https://github.com/bryntum/support/issues/5545\n    getState() {\n        const state = super.getState();\n        delete state.width;\n        delete state.flex;\n        return state;\n    }\n}\nColumnStore.registerColumnType(TimeAxisColumn);\nTimeAxisColumn._$name = 'TimeAxisColumn';", "import TimeAxisBase from './TimeAxisBase.js';\n/**\n * @module Scheduler/view/VerticalTimeAxis\n */\n/**\n * Widget that renders a vertical time axis. Only renders ticks in view. Used in vertical mode.\n * @extends Core/widget/Widget\n * @private\n */\nexport default class VerticalTimeAxis extends TimeAxisBase {\n    static get $name() {\n        return 'VerticalTimeAxis';\n    }\n    static get configurable() {\n        return {\n            cls : 'b-verticaltimeaxis',\n            sizeProperty : 'height',\n            positionProperty : 'top',\n            wrapText : true\n        };\n    }\n    // All cells overlayed in the same space.\n    // For future use.\n    buildHorizontalCells() {\n        const\n            me                   = this,\n            { client }           = me,\n            stickyHeaders        = client?.stickyHeaders,\n            featureHeaderConfigs = [],\n            cellConfigs          = me.levels.reduce((result, level, i) => {\n                if (level.cells) {\n                    result.push(...level.cells?.filter(cell => cell.start < me.endDate && cell.end > me.startDate).map((cell, j, cells) => ({\n                        role      : 'presentation',\n                        className : {\n                            'b-sch-header-timeaxis-cell' : 1,\n                            [cell.headerCellCls]         : cell.headerCellCls,\n                            [`b-align-${cell.align}`]    : cell.align,\n                            'b-last'                     : j === cells.length - 1,\n                            'b-lowest'                   : i === me.levels.length - 1\n                        },\n                        dataset : {\n                            tickIndex      : cell.index,\n                            cellId         : `${i}-${cell.index}`,\n                            headerPosition : i,\n                            // Used in export tests to resolve dates from tick elements\n                            ...globalThis.DEBUG && { date : cell.start.getTime() }\n                        },\n                        style : {\n                            // DomHelper appends px to numeric dimensions\n                            top       : cell.coord,\n                            height    : cell.width,\n                            minHeight : cell.width\n                        },\n                        children : [\n                            {\n                                role      : 'presentation',\n                                className : {\n                                    'b-sch-header-text' : 1,\n                                    'b-sticky-header'   : stickyHeaders\n                                },\n                                html : cell.value\n                            }\n                        ]\n                    })));\n                }\n                return result;\n            }, []);\n        // When tested in isolation there is no client\n        client?.getHeaderDomConfigs(featureHeaderConfigs);\n        cellConfigs.push(...featureHeaderConfigs);\n        // noinspection JSSuspiciousNameCombination\n        return {\n            className : me.widgetClassList,\n            dataset   : {\n                headerFeature  : `headerRow0`,\n                headerPosition : 0\n            },\n            syncOptions : {\n                // Keep a maximum of 5 released cells. Might be fine with fewer since ticks are fixed width.\n                // Prevents an unnecessary amount of cells from sticking around when switching from narrow to\n                // wide tickSizes\n                releaseThreshold : 5,\n                syncIdField      : 'cellId'\n            },\n            children : cellConfigs\n        };\n    }\n    get height() {\n        return this.size;\n    }\n}\nVerticalTimeAxis._$name = 'VerticalTimeAxis';", "import Column from '../../Grid/column/Column.js';\nimport ColumnStore from '../../Grid/data/ColumnStore.js';\nimport VerticalTimeAxis from '../view/VerticalTimeAxis.js';\n/**\n * @module Scheduler/column/VerticalTimeAxisColumn\n */\n/**\n * A special column containing the time axis labels when the Scheduler is used in vertical mode. You can configure,\n * it using the {@link Scheduler.view.Scheduler#config-verticalTimeAxisColumn} config object.\n *\n * **Note**: this column is sized by flexing to consume full width of its containing {@link Grid.view.SubGrid}. To\n * change width of this column, instead size the subgrid like so:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     mode           : 'vertical',\n *     subGridConfigs : {\n *         locked : {\n *             width : 300\n *         }\n *     }\n * });\n * ```\n *\n * @extends Grid/column/Column\n */\nexport default class VerticalTimeAxisColumn extends Column {\n    static $name = 'VerticalTimeAxisColumn';\n    static get type() {\n        return 'verticalTimeAxis';\n    }\n    static get defaults() {\n        return {\n            /**\n             * @hideconfigs autoWidth, autoHeight\n             */\n            /**\n             * Set to false to prevent this column header from being dragged.\n             * @config {Boolean} draggable\n             * @category Interaction\n             * @default false\n             * @hide\n             */\n            draggable : false,\n            /**\n             * Set to false to prevent grouping by this column.\n             * @config {Boolean} groupable\n             * @category Interaction\n             * @default false\n             * @hide\n             */\n            groupable : false,\n            /**\n             * Allow column visibility to be toggled through UI.\n             * @config {Boolean} hideable\n             * @default false\n             * @category Interaction\n             * @hide\n             */\n            hideable : false,\n            /**\n             * Show column picker for the column.\n             * @config {Boolean} showColumnPicker\n             * @default false\n             * @category Menu\n             * @hide\n             */\n            showColumnPicker : false,\n            /**\n             * Allow filtering data in the column (if Filter feature is enabled)\n             * @config {Boolean} filterable\n             * @default false\n             * @category Interaction\n             * @hide\n             */\n            filterable : false,\n            /**\n             * Allow sorting of data in the column\n             * @config {Boolean} sortable\n             * @category Interaction\n             * @default false\n             * @hide\n             */\n            sortable : false,\n            // /**\n            //  * Set to `false` to prevent the column from being drag-resized when the ColumnResize plugin is enabled.\n            //  * @config {Boolean} resizable\n            //  * @default false\n            //  * @category Interaction\n            //  * @hide\n            //  */\n            // resizable : false,\n            /**\n             * Allow searching in the column (respected by QuickFind and Search features)\n             * @config {Boolean} searchable\n             * @default false\n             * @category Interaction\n             * @hide\n             */\n            searchable : false,\n            /**\n             * Specifies if this column should be editable, and define which editor to use for editing cells in the column (if CellEdit feature is enabled)\n             * @config {String} editor\n             * @default false\n             * @category Interaction\n             * @hide\n             */\n            editor : false,\n            /**\n             * Set to `true` to show a context menu on the cell elements in this column\n             * @config {Boolean} enableCellContextMenu\n             * @default false\n             * @category Menu\n             * @hide\n             */\n            enableCellContextMenu : false,\n            /**\n             * @config {Function|Boolean} tooltipRenderer\n             * @hide\n             */\n            tooltipRenderer : false,\n            /**\n             * Column minimal width. If value is Number then minimal width is in pixels\n             * @config {Number|String} minWidth\n             * @default 0\n             * @category Layout\n             */\n            minWidth : 0,\n            resizable : false,\n            cellCls : 'b-verticaltimeaxiscolumn',\n            locked  : true,\n            flex : 1,\n            alwaysClearCell : false\n        };\n    }\n    get isFocusable() {\n        return false;\n    }\n    construct(data) {\n        super.construct(...arguments);\n        this.view = new VerticalTimeAxis({\n            model  : this.grid.timeAxisViewModel,\n            client : this.grid\n        });\n    }\n    renderer({ cellElement, size }) {\n        this.view.render(cellElement);\n        size.height = this.view.height;\n    }\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    // It extracts the current configs (fields) for the column, removing irrelevant ones\n    getCurrentConfig(options) {\n        const result = super.getCurrentConfig(options);\n        // Remove irrelevant configs\n        delete result.id;\n        delete result.region;\n        delete result.type;\n        delete result.field;\n        delete result.ariaLabel;\n        delete result.cellAriaLabel;\n        return result;\n    }\n}\nColumnStore.registerColumnType(VerticalTimeAxisColumn);\nVerticalTimeAxisColumn._$name = 'VerticalTimeAxisColumn';", "/**\n * @module Scheduler/view/mixin/CurrentConfig\n */\nconst\n    stores = [\n        'eventStore',\n        'taskStore',\n        'assignmentStore',\n        'resourceStore',\n        'dependencyStore',\n        'timeRangeStore',\n        'resourceTimeRangeStore'\n    ],\n    inlineProperties = [\n        'events',\n        'tasks',\n        'resources',\n        'assignments',\n        'dependencies',\n        'timeRanges',\n        'resourceTimeRanges'\n    ];\n/**\n * Mixin that makes sure inline data & crud manager data are removed from current config for products using a project.\n * The data is instead inlined in the project (by ProjectModel.js)\n *\n * @mixin\n * @private\n */\nexport default Target => class CurrentConfig extends Target {\n    static get $name() {\n        return 'CurrentConfig';\n    }\n    preProcessCurrentConfigs(configs) {\n        // Remove inline data on the component\n        for (const prop of inlineProperties) {\n            delete configs[prop];\n        }\n        super.preProcessCurrentConfigs(configs);\n    }\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    getCurrentConfig(options) {\n        const\n            project = this.project.getCurrentConfig(options),\n            result = super.getCurrentConfig(options);\n        // Force project with inline data\n        if (project) {\n            result.project = project;\n            const { crudManager } = result;\n            // Transfer crud store configs to project (mainly fields)\n            if (crudManager) {\n                for (const store of stores) {\n                    if (crudManager[store]) {\n                        project[store] = crudManager[store];\n                    }\n                }\n            }\n            if (Object.keys(project).length === 0) {\n                delete result.project;\n            }\n        }\n        // Store (resource store) data is included in project\n        delete result.data;\n        // Remove CrudManager, since data will be placed inline\n        delete result.crudManager;\n        return result;\n    }\n    get widgetClass() {}\n};\n", "import TimelineBase from './TimelineBase.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport CrudManager from '../data/CrudManager.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport '../localization/En.js';\nimport CurrentConfig from './mixin/CurrentConfig.js';\nimport Describable from './mixin/Describable.js';\nimport SchedulerDom from './mixin/SchedulerDom.js';\nimport SchedulerDomEvents from './mixin/SchedulerDomEvents.js';\nimport SchedulerEventRendering from './mixin/SchedulerEventRendering.js';\nimport SchedulerStores from './mixin/SchedulerStores.js';\nimport SchedulerScroll from './mixin/SchedulerScroll.js';\nimport SchedulerRegions from './mixin/SchedulerRegions.js';\nimport SchedulerState from './mixin/SchedulerState.js';\nimport EventSelection from './mixin/EventSelection.js';\nimport EventNavigation from './mixin/EventNavigation.js';\nimport TransactionalFeatureMixin from './mixin/TransactionalFeatureMixin.js';\nimport CrudManagerView from '../crud/mixin/CrudManagerView.js';\nimport HorizontalRendering from './orientation/HorizontalRendering.js';\nimport VerticalRendering from './orientation/VerticalRendering.js';\nimport '../column/TimeAxisColumn.js';\nimport '../column/VerticalTimeAxisColumn.js';\n// Should always be present in Scheduler\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\n/**\n * @module Scheduler/view/SchedulerBase\n */\nconst\n    descriptionFormats = {\n        month : 'MMMM, YYYY',\n        week  : ['MMMM YYYY (Wp)', 'S{MMM} - E{MMM YYYY} (S{Wp})'],\n        day   : 'MMMM D, YYYY'\n    };\n/**\n * A thin base class for {@link Scheduler.view.Scheduler}. Does not include any features by default, allowing smaller\n * custom-built bundles if used in place of {@link Scheduler.view.Scheduler}.\n *\n * **NOTE:** In most scenarios you do probably want to use Scheduler instead of SchedulerBase.\n *\n * @mixes Scheduler/view/mixin/Describable\n * @mixes Scheduler/view/mixin/EventNavigation\n * @mixes Scheduler/view/mixin/EventSelection\n * @mixes Scheduler/view/mixin/SchedulerDom\n * @mixes Scheduler/view/mixin/SchedulerDomEvents\n * @mixes Scheduler/view/mixin/SchedulerEventRendering\n * @mixes Scheduler/view/mixin/SchedulerRegions\n * @mixes Scheduler/view/mixin/SchedulerScroll\n * @mixes Scheduler/view/mixin/SchedulerState\n * @mixes Scheduler/view/mixin/SchedulerStores\n * @mixes Scheduler/view/mixin/TimelineDateMapper\n * @mixes Scheduler/view/mixin/TimelineDomEvents\n * @mixes Scheduler/view/mixin/TimelineEventRendering\n * @mixes Scheduler/view/mixin/TimelineScroll\n * @mixes Scheduler/view/mixin/TimelineViewPresets\n * @mixes Scheduler/view/mixin/TimelineZoomable\n * @mixes Scheduler/view/mixin/TransactionalFeatureMixin\n * @mixes Scheduler/crud/mixin/CrudManagerView\n * @mixes Scheduler/data/mixin/ProjectConsumer\n *\n * @features Scheduler/feature/ColumnLines\n * @features Scheduler/feature/Dependencies\n * @features Scheduler/feature/DependencyEdit\n * @features Scheduler/feature/EventCopyPaste\n * @features Scheduler/feature/EventDrag\n * @features Scheduler/feature/EventDragCreate\n * @features Scheduler/feature/EventDragSelect\n * @features Scheduler/feature/EventEdit\n * @features Scheduler/feature/EventFilter\n * @features Scheduler/feature/EventMenu\n * @features Scheduler/feature/EventNonWorkingTime\n * @features Scheduler/feature/EventResize\n * @features Scheduler/feature/EventTooltip\n * @features Scheduler/feature/GroupSummary\n * @features Scheduler/feature/HeaderZoom\n * @features Scheduler/feature/Labels\n * @features Scheduler/feature/NonWorkingTime\n * @features Scheduler/feature/Pan\n * @features Scheduler/feature/ResourceMenu\n * @features Scheduler/feature/ResourceTimeRanges\n * @features Scheduler/feature/RowReorder\n * @features Scheduler/feature/RowResize\n * @features Scheduler/feature/ScheduleContext\n * @features Scheduler/feature/ScheduleMenu\n * @features Scheduler/feature/ScheduleTooltip\n * @features Scheduler/feature/SimpleEventEdit\n * @features Scheduler/feature/Split\n * @features Scheduler/feature/StickyEvents\n * @features Scheduler/feature/Summary\n * @features Scheduler/feature/TimeAxisHeaderMenu\n * @features Scheduler/feature/TimeRanges\n * @features Scheduler/feature/TimeSelection\n *\n * @features Scheduler/feature/experimental/ExcelExporter\n *\n * @features Scheduler/feature/export/PdfExport\n * @features Scheduler/feature/export/Print\n *\n * @extends Scheduler/view/TimelineBase\n * @widget\n */\nexport default class SchedulerBase extends TimelineBase.mixin(\n    CrudManagerView,\n    Describable,\n    SchedulerDom,\n    SchedulerDomEvents,\n    SchedulerStores,\n    SchedulerScroll,\n    SchedulerState,\n    SchedulerEventRendering,\n    SchedulerRegions,\n    EventSelection,\n    EventNavigation,\n    CurrentConfig,\n    TransactionalFeatureMixin\n) {\n    //region Config\n    static $name = 'SchedulerBase';\n    // Factoryable type name\n    static type = 'schedulerbase';\n    static configurable = {\n        /**\n         * Get/set the scheduler's read-only state. When set to `true`, any UIs for modifying data are disabled.\n         * @member {Boolean} readOnly\n         * @category Misc\n         */\n        /**\n         * Configure as `true` to make the scheduler read-only, by disabling any UIs for modifying data.\n         *\n         * __Note that checks MUST always also be applied at the server side.__\n         * @config {Boolean} readOnly\n         * @default false\n         * @category Misc\n         */\n        /**\n         * The date to display when used as a component of a Calendar.\n         *\n         * This is required by the Calendar Mode Interface.\n         *\n         * @config {Date}\n         * @category Calendar integration\n         */\n        date : {\n            value : null,\n            $config : {\n                equal : 'date'\n            }\n        },\n        /**\n         * Unit used to control how large steps to take when clicking the previous and next buttons in the Calendar\n         * UI. Only applies when used as a component of a Calendar.\n         *\n         * Suitable units depend on configured {@link #config-range}, a smaller or equal unit is recommended.\n         *\n         * @config {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'}\n         * @default\n         * @category Calendar integration\n         */\n        stepUnit : 'week',\n        /**\n         * Unit used to set the length of the time axis when used as a component of a Calendar. Suitable units are\n         * `'month'`, `'week'` and `'day'`.\n         *\n         * @config {'day'|'week'|'month'}\n         * @category Calendar integration\n         * @default\n         */\n        range : 'week',\n        /**\n         * When the scheduler is used in a Calendar, this function provides the textual description for the\n         * Calendar's toolbar.\n         *\n         * ```javascript\n         *  descriptionRenderer : scheduler => {\n         *      const\n         *          count = scheduler.eventStore.records.filter(\n         *              eventRec => DateHelper.intersectSpans(\n         *                  scheduler.startDate, scheduler.endDate,\n         *                  eventRec.startDate, eventRec.endDate)).length,\n         *          startDate = DateHelper.format(scheduler.startDate, 'DD/MM/YYY'),\n         *          endData = DateHelper.format(scheduler.endDate, 'DD/MM/YYY');\n         *\n         *      return `${startDate} - ${endData}, ${count} event${count === 1 ? '' : 's'}`;\n         *  }\n         * ```\n         * @config {Function}\n         * @param {Scheduler.view.SchedulerBase} view The active view.\n         * @returns {String}\n         * @category Calendar integration\n         */\n        /**\n         * A method allowing you to define date boundaries that will constrain resize, create and drag drop\n         * operations. The method will be called with the Resource record, and the Event record.\n         *\n         * ```javascript\n         *  new Scheduler({\n         *      getDateConstraints(resourceRecord, eventRecord) {\n         *          // Assuming you have added these extra fields to your own EventModel subclass\n         *          const { minStartDate, maxEndDate } = eventRecord;\n         *\n         *          return {\n         *              start : minStartDate,\n         *              end   : maxEndDate\n         *          };\n         *      }\n         *  });\n         * ```\n         * @param {Scheduler.model.ResourceModel} [resourceRecord] The resource record\n         * @param {Scheduler.model.EventModel} [eventRecord] The event record\n         * @returns {Object} Constraining object containing `start` and `end` constraints. Omitting either\n         * will mean that end is not constrained. So you can prevent a resize or move from moving *before*\n         * a certain time while not constraining the end date.\n         * @returns {Date} [return.start] Start date\n         * @returns {Date} [return.end] End date\n         * @config {Function}\n         * @category Scheduled events\n         */\n        getDateConstraints : null,\n        /**\n         * The time axis column config for vertical {@link Scheduler.view.SchedulerBase#config-mode}.\n         *\n         * Object with {@link Scheduler.column.VerticalTimeAxisColumn} configuration.\n         *\n         * This object will be used to configure the vertical time axis column instance.\n         *\n         * The config allows configuring the `VerticalTimeAxisColumn` instance used in vertical mode with any Column options that apply to it.\n         *\n         * Example:\n         *\n         * ```javascript\n         * new Scheduler({\n         *     mode     : 'vertical',\n         *     features : {\n         *         filterBar : true\n         *     },\n         *     verticalTimeAxisColumn : {\n         *         text  : 'Filter by event name',\n         *         width : 180,\n         *         filterable : {\n         *             // add a filter field to the vertical column access header\n         *             filterField : {\n         *                 type        : 'text',\n         *                 placeholder : 'Type to search',\n         *                 onChange    : ({ value }) => {\n         *                     // filter event by name converting to lowerCase to be equal comparison\n         *                     scheduler.eventStore.filter({\n         *                         filters : event => event.name.toLowerCase().includes(value.toLowerCase()),\n         *                         replace : true\n         *                     });\n         *                 }\n         *             }\n         *         }\n         *     },\n         *     ...\n         * });\n         * ```\n         *\n         * @config {VerticalTimeAxisColumnConfig}\n         * @category Time axis\n         */\n        verticalTimeAxisColumn : {},\n        /**\n         * See {@link Scheduler.view.Scheduler#keyboard-shortcuts Keyboard shortcuts} for details\n         * @config {Object<String,String>} keyMap\n         * @category Common\n         */\n        /**\n         * If true, a new event will be created when user double-clicks on a time axis cell (if scheduler is not in\n         * read only mode).\n         *\n         * The duration / durationUnit of the new event will be 1 time axis tick (default), or it can be read from\n         * the {@link Scheduler.model.EventModel#field-duration} and\n         * {@link Scheduler.model.EventModel#field-durationUnit} fields.\n         *\n         * Set to `false` to not create events on double click.\n         * @config {Boolean|Object} createEventOnDblClick\n         * @param {Boolean} [createEventOnDblClick.useEventModelDefaults] set to `true` to set default duration\n         * based on the defaults specified by the {@link Scheduler.model.EventModel#field-duration} and\n         * {@link Scheduler.model.EventModel#field-durationUnit} fields.\n         * @default\n         * @category Scheduled events\n         */\n        createEventOnDblClick : true,\n        /**\n             * Number of pixels to horizontally extend the visible render zone by, controlling the events that will be\n             * rendered. You can use this to increase or reduce the amount of event rendering happening when scrolling\n             * along a horizontal time axis. This can be useful if you render huge amount of events.\n             *\n             * To force the scheduler to render all events within the TimeAxis start & end dates, set this to -1.\n             * The initial render will take slightly longer but no extra event rendering will take place when scrolling.\n             *\n             * NOTE: This is an experimental API which might change in future releases.\n             * @config {Number}\n             * @default\n             * @internal\n             * @category Experimental\n             */\n        scrollBuffer : 0,\n        // A CSS class identifying areas where events can be scheduled using drag-create, double click etc.\n        schedulableAreaSelector : '.b-sch-timeaxis-cell',\n        scheduledEventName      : 'event',\n        sortFeatureStore        : 'resourceStore',\n        /**\n         * If set to `true` this will show a color field in the {@link Scheduler.feature.EventEdit} editor and also a\n         * picker in the {@link Scheduler.feature.EventMenu}. Both enables the user to choose a color which will be\n         * applied to the event bar's background. See EventModel's\n         * {@link Scheduler.model.mixin.EventModelMixin#field-eventColor} config.\n         * config.\n         * @config {Boolean}\n         * @default false\n         * @category Misc\n         */\n        showEventColorPickers : null,\n        /**\n         * By default, scrolling the schedule will update the {@link #property-timelineContext} to reflect the new\n         * currently hovered context. When displaying a large number of events on screen at the same time, this will\n         * have a slight impact on scrolling performance. In such scenarios, opt out of this behavior by setting\n         * this config to `false`.\n         * @default\n         * @prp {Boolean}\n         * @category Misc\n         */\n        updateTimelineContextOnScroll : true\n    };\n    static get defaultConfig() {\n        return {\n            /**\n             * Scheduler mode. Supported values: horizontal, vertical\n             * @config {'horizontal'|'vertical'} mode\n             * @default\n             * @category Common\n             */\n            mode : 'horizontal',\n            /**\n             * CSS class to add to rendered events\n             * @config {String}\n             * @category CSS\n             * @private\n             * @default\n             */\n            eventCls : 'b-sch-event',\n            /**\n             * CSS class to add to cells in the timeaxis column\n             * @config {String}\n             * @category CSS\n             * @private\n             * @default\n             */\n            timeCellCls : 'b-sch-timeaxis-cell',\n            /**\n             * A CSS class to apply to each event in the view on mouseover (defaults to 'b-sch-event-hover').\n             * @config {String}\n             * @default\n             * @category CSS\n             * @private\n             */\n            overScheduledEventClass : 'b-sch-event-hover',\n            /**\n             * Set to `false` if you don't want to allow events overlapping times for any one resource (defaults to `true`).\n             * <div class=\"note\">Note that toggling this at runtime won't affect already overlapping events.</div>\n             *\n             * @prp {Boolean}\n             * @default\n             * @category Scheduled events\n             */\n            allowOverlap : true,\n            /**\n             * The height in pixels of Scheduler rows.\n             * @config {Number}\n             * @default\n             * @category Common\n             */\n            rowHeight : 60,\n            /**\n             * Scheduler overrides Grids default implementation of {@link Grid.view.GridBase#config-getRowHeight} to\n             * pre-calculate row heights based on events in the rows.\n             *\n             * The amount of rows that are pre-calculated is limited for performance reasons. The limit is configurable\n             * by specifying the {@link Scheduler.view.SchedulerBase#config-preCalculateHeightLimit} config.\n             *\n             * The results of the calculation are cached internally.\n             *\n             * @config {Function} getRowHeight\n             * @param {Scheduler.model.ResourceModel} getRowHeight.record Resource record to determine row height for\n             * @returns {Number} Desired row height\n             * @category Layout\n             */\n            /**\n             * Maximum number of resources for which height is pre-calculated. If you have many events per\n             * resource you might want to lower this number to gain some initial rendering performance.\n             *\n             * Specify a falsy value to opt out of row height pre-calculation.\n             *\n             * @config {Number}\n             * @default\n             * @category Layout\n             */\n            preCalculateHeightLimit : 10000,\n            crudManagerClass : CrudManager,\n            testConfig : {\n                loadMaskError : {\n                    autoClose : 10,\n                    showDelay : 0\n                }\n            }\n        };\n    }\n    timeCellSelector          = '.b-sch-timeaxis-cell';\n    resourceTimeRangeSelector = '.b-sch-resourcetimerange';\n    //endregion\n    //region Store & model docs\n    // Documented here instead of in SchedulerStores since SchedulerPro uses different types\n    // Configs\n    /**\n     * Inline events, will be loaded into an internally created EventStore.\n     * @config {Scheduler.model.EventModel[]|Scheduler.model.EventModelConfig[]} events\n     * @category Data\n     */\n    /**\n     * The {@link Scheduler.data.EventStore} holding the events to be rendered into the scheduler (required).\n     * @config {Scheduler.data.EventStore|Scheduler.data.EventStoreConfig} eventStore\n     * @category Data\n     */\n    /**\n     * Inline resources, will be loaded into an internally created ResourceStore.\n     * @config {Scheduler.model.ResourceModel[]|Scheduler.model.ResourceModelConfig[]} resources\n     * @category Data\n     */\n    /**\n     * The {@link Scheduler.data.ResourceStore} holding the resources to be rendered into the scheduler (required).\n     * @config {Scheduler.data.ResourceStore|Scheduler.data.ResourceStoreConfig} resourceStore\n     * @category Data\n     */\n    /**\n     * Inline assignments, will be loaded into an internally created AssignmentStore.\n     * @config {Scheduler.model.AssignmentModel[]|Object[]} assignments\n     * @category Data\n     */\n    /**\n     * The optional {@link Scheduler.data.AssignmentStore}, holding assignments between resources and events.\n     * Required for multi assignments.\n     * @config {Scheduler.data.AssignmentStore|Scheduler.data.AssignmentStoreConfig} assignmentStore\n     * @category Data\n     */\n    /**\n     * Inline dependencies, will be loaded into an internally created DependencyStore.\n     * @config {Scheduler.model.DependencyModel[]|Scheduler.model.DependencyModelConfig[]} dependencies\n     * @category Data\n     */\n    /**\n     * The optional {@link Scheduler.data.DependencyStore}.\n     * @config {Scheduler.data.DependencyStore|Scheduler.model.DependencyStoreConfig} dependencyStore\n     * @category Data\n     */\n    // Properties\n    /**\n     * Get/set events, applies to the backing project's EventStore.\n     * @member {Scheduler.model.EventModel[]} events\n     * @accepts {Scheduler.model.EventModel[]|Scheduler.model.EventModelConfig[]}\n     * @category Data\n     */\n    /**\n     * Get/set the event store instance of the backing project.\n     * @member {Scheduler.data.EventStore} eventStore\n     * @category Data\n     */\n    /**\n     * Get/set resources, applies to the backing project's ResourceStore.\n     * @member {Scheduler.model.ResourceModel[]} resources\n     * @accepts {Scheduler.model.ResourceModel[]|Scheduler.model.ResourceModelConfig[]}\n     * @category Data\n     */\n    /**\n     * Get/set the resource store instance of the backing project\n     * @member {Scheduler.data.ResourceStore} resourceStore\n     * @category Data\n     */\n    /**\n     * Get/set assignments, applies to the backing project's AssignmentStore.\n     * @member {Scheduler.model.AssignmentModel[]} assignments\n     * @accepts {Scheduler.model.AssignmentModel[]|Object[]}\n     * @category Data\n     */\n    /**\n     * Get/set the event store instance of the backing project.\n     * @member {Scheduler.data.AssignmentStore} assignmentStore\n     * @category Data\n     */\n    /**\n     * Get/set dependencies, applies to the backing projects DependencyStore.\n     * @member {Scheduler.model.DependencyModel[]} dependencies\n     * @accepts {Scheduler.model.DependencyModel[]|Scheduler.model.DependencyModelConfig[]}\n     * @category Data\n     */\n    /**\n     * Get/set the dependencies store instance of the backing project.\n     * @member {Scheduler.data.DependencyStore} dependencyStore\n     * @category Data\n     */\n    //endregion\n    //region Events\n    /**\n     * Fired after rendering an event, when its element is available in DOM.\n     * @event renderEvent\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord The event record\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord The assignment record\n     * @param {Object} renderData An object containing details about the event rendering, see\n     *   {@link Scheduler.view.mixin.SchedulerEventRendering#config-eventRenderer} for details\n     * @param {Boolean} isRepaint `true` if this render is a repaint of the event, updating its existing element\n     * @param {Boolean} isReusingElement `true` if this render lead to the event reusing a released events element\n     * @param {HTMLElement} element The event bar element\n     */\n    /**\n     * Fired after releasing an event, useful to cleanup of custom content added on `renderEvent` or in `eventRenderer`.\n     * @event releaseEvent\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord The event record\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord The assignment record\n     * @param {Object} renderData An object containing details about the event rendering\n     * @param {HTMLElement} element The event bar element\n     */\n    /**\n     * Fired when clicking a resource header cell\n     * @event resourceHeaderClick\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {Event} event The event\n     */\n    /**\n     * Fired when double clicking a resource header cell\n     * @event resourceHeaderDblclick\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {Event} event The event\n     */\n    /**\n     * Fired when activating context menu on a resource header cell\n     * @event resourceHeaderContextmenu\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {Event} event The event\n     */\n    /**\n     * Triggered when a keydown event is observed if there are selected events.\n     * @event eventKeyDown\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel[]} eventRecords The selected event records\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords The selected assignment records\n     * @param {KeyboardEvent} event Browser event\n     */\n    /**\n     * Triggered when a keyup event is observed if there are selected events.\n     * @event eventKeyUp\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel[]} eventRecords The selected event records\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords The selected assignment records\n     * @param {KeyboardEvent} event Browser event\n     */\n    //endregion\n    //region Functions injected by features\n    // For documentation & typings purposes\n    /**\n     * Opens an editor UI to edit the passed event.\n     *\n     * *NOTE: Only available when the {@link Scheduler/feature/EventEdit EventEdit} feature is enabled.*\n     *\n     * @function editEvent\n     * @param {Scheduler.model.EventModel} eventRecord Event to edit\n     * @param {Scheduler.model.ResourceModel} [resourceRecord] The Resource record for the event.\n     * This parameter is needed if the event is newly created for a resource and has not been assigned, or when using\n     * multi assignment.\n     * @param {HTMLElement} [element] Element to anchor editor to (defaults to events element)\n     * @category Feature shortcuts\n     */\n    /**\n     * Returns the dependency record for a DOM element\n     *\n     * *NOTE: Only available when the {@link Scheduler/feature/Dependencies Dependencies} feature is enabled.*\n     *\n     * @function resolveDependencyRecord\n     * @param {HTMLElement} element The dependency line element\n     * @returns {Scheduler.model.DependencyModel} The dependency record\n     * @category Feature shortcuts\n     */\n    //endregion\n    //region Init\n    afterConstruct() {\n        const me = this;\n        super.afterConstruct();\n        me.ion({ scroll : 'onVerticalScroll', thisObj : me });\n        if (me.createEventOnDblClick) {\n            me.ion({ scheduledblclick : me.onTimeAxisCellDblClick });\n        }\n    }\n    //endregion\n    //region Overrides\n    onPaintOverride() {\n        // Internal procedure used for paint method overrides\n        // Not used in onInternalPaint() because it may be chained on instance and Override won't be applied\n    }\n    //endregion\n    //region Config getters/setters\n    // Placeholder getter/setter for mixins, please make any changes needed to SchedulerStores#store instead\n    get store() {\n        return super.store;\n    }\n    set store(store) {\n        super.store = store;\n    }\n    /**\n     * Returns an object defining the range of visible resources\n     * @property {Object}\n     * @property {Scheduler.model.ResourceModel} visibleResources.first First visible resource\n     * @property {Scheduler.model.ResourceModel} visibleResources.last Last visible resource\n     * @readonly\n     * @category Resources\n     */\n    get visibleResources() {\n        const me = this;\n        if (me.isVertical) {\n            return me.currentOrientation.visibleResources;\n        }\n        return {\n            first : me.store.getById(me.firstVisibleRow?.id),\n            last  : me.store.getById(me.lastVisibleRow?.id)\n        };\n    }\n    //endregion\n    //region Event handlers\n    onLocaleChange() {\n        this.currentOrientation.onLocaleChange();\n        super.onLocaleChange();\n    }\n    onTimeAxisCellDblClick({ date : startDate, resourceRecord, row }) {\n        this.createEvent(startDate, resourceRecord, row);\n    }\n    onVerticalScroll({ scrollTop }) {\n        this.currentOrientation.updateFromVerticalScroll(scrollTop);\n    }\n    /**\n     * Called when new event is created.\n     * \u0421an be overridden to supply default record values etc.\n     * @param {Scheduler.model.EventModel} eventRecord Newly created event\n     * @category Scheduled events\n     */\n    onEventCreated(eventRecord) {}\n    //endregion\n    //region Mode\n    /**\n     * Checks if scheduler is in horizontal mode\n     * @returns {Boolean}\n     * @readonly\n     * @category Common\n     * @private\n     */\n    get isHorizontal() {\n        return this.mode === 'horizontal';\n    }\n    /**\n     * Checks if scheduler is in vertical mode\n     * @returns {Boolean}\n     * @readonly\n     * @category Common\n     * @private\n     */\n    get isVertical() {\n        return this.mode === 'vertical';\n    }\n    /**\n     * Get mode (horizontal/vertical)\n     * @property {'horizontal'|'vertical'}\n     * @readonly\n     * @category Common\n     */\n    get mode() {\n        return this._mode;\n    }\n    set mode(mode) {\n        const me = this;\n        me._mode = mode;\n        if (!me[mode]) {\n            me.element.classList.add(`b-sch-${mode}`);\n            if (mode === 'horizontal') {\n                me.horizontal = new HorizontalRendering(me);\n                if (me.isPainted) {\n                    me.horizontal.init();\n                }\n            }\n            else if (mode === 'vertical') {\n                me.vertical = new VerticalRendering(me);\n                if (me.rendered) {\n                    me.vertical.init();\n                }\n            }\n        }\n    }\n    get currentOrientation() {\n        return this[this.mode];\n    }\n    //endregion\n    //region Dom event dummies\n    // this is ugly, but needed since super cannot be called from SchedulerDomEvents mixin...\n    onElementKeyDown(event) {\n        return super.onElementKeyDown(event);\n    }\n    onElementKeyUp(event) {\n        return super.onElementKeyUp(event);\n    }\n    onElementMouseOver(event) {\n        return super.onElementMouseOver(event);\n    }\n    onElementMouseOut(event) {\n        return super.onElementMouseOut(event);\n    }\n    //endregion\n    //region Feature hooks\n    // Called for each event during drop\n    processEventDrop() {}\n    processCrossSchedulerEventDrop() {}\n    // Called before event drag starts\n    beforeEventDragStart() {}\n    // Called after event drag starts\n    afterEventDragStart() {}\n    // Called after aborting a drag\n    afterEventDragAbortFinalized() {}\n    // Called during event drag validation\n    checkEventDragValidity() {}\n    // Called after event resizing starts\n    afterEventResizeStart() {}\n    // Called after generating a DomConfig for an event\n    afterRenderEvent() {}\n    //endregion\n    //region Scheduler specific date mapping functions\n    get hasEventEditor() {\n        return Boolean(this.eventEditingFeature);\n    }\n    get eventEditingFeature() {\n        const {\n            eventEdit,\n            taskEdit,\n            simpleEventEdit\n        } = this.features;\n        return eventEdit?.enabled\n            ? eventEdit\n            : taskEdit?.enabled\n                ? taskEdit\n                : simpleEventEdit?.enabled ? simpleEventEdit : null;\n    }\n    // Method is chained by event editing features. Ensure that the event is in the store.\n    editEvent(eventRecord, resourceRecord, element) {\n        const\n            me = this,\n            {\n                eventStore,\n                assignmentStore\n            } = me;\n        // Abort the chain if no event editing features available\n        if (!me.hasEventEditor) {\n            return false;\n        }\n        if (eventRecord.eventStore !== eventStore) {\n            const\n                { enableEventAnimations } = me,\n                resourceRecords           = [];\n            // It's only a provisional event because we are going to edit it which will\n            // allow an opportunity to cancel the add (by removing it).\n            eventRecord.isCreating = true;\n            let assignmentRecords = [];\n            if (resourceRecord) {\n                resourceRecords.push(resourceRecord);\n                assignmentRecords = assignmentStore.assignEventToResource(eventRecord, resourceRecord);\n            }\n            // Vetoable beforeEventAdd allows cancel of this operation\n            if (me.trigger('beforeEventAdd', { eventRecord, resourceRecords, assignmentRecords }) === false) {\n                // Remove any assignment created above, to leave store as it was\n                assignmentStore?.remove(assignmentRecords);\n                return false;\n            }\n            me.enableEventAnimations = false;\n            eventStore.add(eventRecord);\n            me.project.commitAsync().then(() => me.enableEventAnimations = enableEventAnimations);\n            // Element must be created synchronously, not after the project's normalizing delays.\n            me.refreshRows();\n        }\n    }\n    /**\n     * Creates an event on the specified date (and scrolls it into view), for the specified resource which conforms to\n     * this scheduler's {@link #config-createEventOnDblClick} setting.\n     *\n     * NOTE: If the scheduler is readonly, or resource type is invalid (group header), or if `allowOverlap` is `false`\n     * and slot is already occupied - no event is created.\n     *\n     * This method may be called programmatically by application code if the `createEventOnDblClick` setting\n     * is `false`, in which case the default values for `createEventOnDblClick` will be used.\n     *\n     * If the {@link Scheduler.feature.EventEdit} feature is active, the new event\n     * will be displayed in the event editor.\n     * @param {Date} date The date to add the event at.\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource to create the event for.\n     * @category Scheduled events\n     */\n    async createEvent(startDate, resourceRecord) {\n        const\n            me                    = this,\n            {\n                enableEventAnimations,\n                eventStore,\n                assignmentStore,\n                hasEventEditor\n            }                     = me,\n            resourceRecords       = [resourceRecord],\n            useEventModelDefaults = me.createEventOnDblClick.useEventModelDefaults,\n            defaultDuration       = useEventModelDefaults ? eventStore.modelClass.defaultValues.duration : 1,\n            defaultDurationUnit   = useEventModelDefaults ? eventStore.modelClass.defaultValues.durationUnit : me.timeAxis.unit,\n            eventRecord           = eventStore.createRecord({\n                startDate,\n                endDate      : DateHelper.add(startDate, defaultDuration, defaultDurationUnit),\n                duration     : defaultDuration,\n                durationUnit : defaultDurationUnit,\n                name         : me.L('L{Object.newEvent}')\n            });\n        if (me.readOnly || resourceRecord.isSpecialRow || resourceRecord.readOnly || (!me.allowOverlap && !me.isDateRangeAvailable(\n            eventRecord.startDate,\n            eventRecord.endDate,\n            null,\n            resourceRecord\n        ))) {\n            return;\n        }\n        me.eventEditingFeature?.captureStm(true);\n        // It's only a provisional event if there is an event edit feature available to\n        // cancel the add (by removing it). Otherwise it's a definite event creation.\n        eventRecord.isCreating = hasEventEditor;\n        me.onEventCreated(eventRecord);\n        const assignmentRecords = assignmentStore?.assignEventToResource(eventRecord, resourceRecord);\n        /**\n         * Fires before an event is added. Can be triggered by schedule double click or drag create action.\n         * @event beforeEventAdd\n         * @param {Scheduler.view.Scheduler} source The Scheduler instance\n         * @param {Scheduler.model.EventModel} eventRecord The record about to be added\n         * @param {Scheduler.model.ResourceModel[]} resourceRecords Resources that the record is assigned to\n         * @param {Scheduler.model.AssignmentModel[]} assignmentRecords The assignment records\n         * @preventable\n         */\n        if (me.trigger('beforeEventAdd', { eventRecord, resourceRecords, assignmentRecords }) === false) {\n            // Remove any assignment created above, to leave store as it was\n            assignmentStore?.remove(assignmentRecords);\n            me.eventEditingFeature?.freeStm(false);\n            return;\n        }\n        me.enableEventAnimations = false;\n        eventStore.add(eventRecord);\n        me.project.commitAsync().then(() => me.enableEventAnimations = enableEventAnimations);\n        // Element must be created synchronously, not after the project's normalizing delays.\n        // Overrides the check for isEngineReady in VerticalRendering so that the newly added record\n        // will be rendered when we call refreshRows.\n        me.isCreating = true;\n        me.refreshRows();\n        me.isCreating = false;\n        await me.scrollEventIntoView(eventRecord);\n        /**\n         * Fired when a double click or drag gesture has created a new event and added it to the event store.\n         * @event eventAutoCreated\n         * @param {Scheduler.view.Scheduler} source This Scheduler.\n         * @param {Scheduler.model.EventModel} eventRecord The new event record.\n         * @param {Scheduler.model.ResourceModel} resourceRecord The resource assigned to the new event.\n         */\n        me.trigger('eventAutoCreated', {\n            eventRecord,\n            resourceRecord\n        });\n        if (hasEventEditor) {\n            me.editEvent(eventRecord, resourceRecord, me.getEventElement(eventRecord));\n        }\n    }\n    /**\n     * Checks if a date range is allocated or not for a given resource.\n     * @param {Date} start The start date\n     * @param {Date} end The end date\n     * @param {Scheduler.model.EventModel|null} excludeEvent An event to exclude from the check (or null)\n     * @param {Scheduler.model.ResourceModel} resource The resource\n     * @returns {Boolean} True if the timespan is available for the resource\n     * @category Dates\n     */\n    isDateRangeAvailable(start, end, excludeEvent, resource) {\n        return this.eventStore.isDateRangeAvailable(start, end, excludeEvent, resource);\n    }\n    //endregion\n    /**\n     * Suspends UI refresh on store operations.\n     *\n     * Multiple calls to `suspendRefresh` stack up, and will require an equal number of `resumeRefresh` calls to\n     * actually resume UI refresh.\n     *\n     * @function suspendRefresh\n     * @category Rendering\n     */\n    /**\n     * Resumes UI refresh on store operations.\n     *\n     * Multiple calls to `suspendRefresh` stack up, and will require an equal number of `resumeRefresh` calls to\n     * actually resume UI refresh.\n     *\n     * Specify `true` as the first param to trigger a refresh if this call unblocked the refresh suspension.\n     * If the underlying project is calculating changes, the refresh will be postponed until it is done.\n     *\n     * @param {Boolean} [trigger] `true` to trigger a refresh, if this resume unblocks suspension\n     * @privateparam {Boolean} [useTransitions] `false` to block transitions\n     * @category Rendering\n     */\n    async resumeRefresh(trigger = VersionHelper.checkVersion('core', '6.0', '>='), useTransitions = true) {\n        super.resumeRefresh(false);\n        const me = this;\n        if (!me.refreshSuspended && trigger) {\n            // Do not refresh until project is in a valid state\n            if (!me.isEngineReady) {\n                // Refresh will happen because of the commit, bail out of this one after forcing rendering to consider\n                // next one a full refresh\n                me.currentOrientation.refreshAllWhenReady = true;\n                return me.project.commitAsync();\n            }\n            // View could've been destroyed while we waited for engine\n            if (!me.isDestroyed) {\n                // If it already is, refresh now\n                if (useTransitions) {\n                    me.refreshWithTransition();\n                }\n                else {\n                    me.refresh();\n                }\n            }\n        }\n    }\n    //region Appearance\n    // Overrides grid to take crudManager loading into account\n    toggleEmptyText() {\n        const\n            me = this;\n        if (me.bodyContainer) {\n            DomHelper.toggleClasses(me.bodyContainer, 'b-grid-empty', !(me.resourceStore.count > 0 || me.crudManager?.isLoading));\n        }\n    }\n    // Overrides Grids base implementation to return a correctly calculated height for the row. Also stores it in\n    // RowManagers height map, which is used to calculate total height etc.\n    getRowHeight(resourceRecord) {\n        if (this.isHorizontal) {\n            const height = this.currentOrientation.calculateRowHeight(resourceRecord);\n            this.rowManager.storeKnownHeight(resourceRecord.id, height);\n            return height;\n        }\n    }\n    // Calculates the height for specified rows. Call when changes potentially makes its height invalid\n    calculateRowHeights(resourceRecords, silent = false) {\n        const { store } = this;\n        for (const resourceRecord of resourceRecords) {\n            // Array allowed to have nulls in it for easier code when calling this fn\n            // Also ignore records not in the flat part of the store (collapsed away resources)\n            if (resourceRecord && store.isAvailable(resourceRecord)) {\n                this.getRowHeight(resourceRecord);\n            }\n        }\n        if (!silent) {\n            this.rowManager.estimateTotalHeight(true);\n        }\n    }\n    // Calculate heights for all rows (up to the preCalculateHeightLimit)\n    calculateAllRowHeights(silent = false) {\n        const\n            { store, rowManager } = this,\n            count                 = Math.min(store.count, this.preCalculateHeightLimit);\n        // Allow opt out by specifying falsy value.\n        if (count) {\n            rowManager.clearKnownHeights();\n            for (let i = 0; i < count; i++) {\n                // This will both calculate and store the height\n                this.getRowHeight(store.getAt(i));\n            }\n            // Make sure height is reflected on scroller etc.\n            if (!silent) {\n                rowManager.estimateTotalHeight(true);\n            }\n        }\n    }\n    //endregion\n    //region Calendar Mode Interface\n    // These are all internal and match up w/CalendarMixin\n    /**\n     * Returns the date or ranges of included dates as an array. If only the {@link #config-startDate} is significant,\n     * the array will have that date as its only element. Otherwise, a range of dates is returned as a two-element\n     * array with `[0]` is the {@link #config-startDate} and `[1]` is the {@link #property-lastDate}.\n     * @member {Date[]}\n     * @internal\n     */\n    get dateBounds() {\n        const\n            me  = this,\n            ret = [me.startDate];\n        if (me.range === 'week') {\n            ret.push(me.lastDate);\n        }\n        return ret;\n    }\n    get defaultDescriptionFormat() {\n        return descriptionFormats[this.range];\n    }\n    /**\n     * The last day that is included in the date range. This is different than {@link #config-endDate} since that date\n     * is not inclusive. For example, an `endDate` of 2022-07-21 00:00:00 indicates that the time range ends at that\n     * time, and so 2022-07-21 is _not_ in the range. In this example, `lastDate` would be 2022-07-20 since that is the\n     * last day included in the range.\n     * @member {Date}\n     * @internal\n     */\n    get lastDate() {\n        const lastDate = this.endDate;\n        // endDate is \"exclusive\" because it means 00:00:00 of that day, so subtract 1\n        // to keep description consistent with human expectations.\n        return lastDate && DateHelper.add(lastDate, -1, 'day');\n    }\n    getEventRecord(target) {\n        target = DomHelper.getEventElement(target);\n        return this.resolveEventRecord(target);\n    }\n    getResourceRecord(domEvent) {\n        return this.resolveResourceRecord(domEvent);\n    }\n    getEventElement(eventRecord) {\n        return this.getElementFromEventRecord(eventRecord);\n    }\n    changeRange(unit) {\n        return DateHelper.normalizeUnit(unit);\n    }\n    updateRange(unit) {\n        if (!this.isConfiguring) {\n            const\n                currentDate = this.date,\n                newDate     = this.date = DateHelper.startOf(currentDate, unit);\n            // Force a span update if changing the range did not change the date\n            if (currentDate.getTime() === newDate.getTime()) {\n                this.updateDate(newDate);\n            }\n        }\n    }\n    changeStepUnit(unit) {\n        return DateHelper.normalizeUnit(unit);\n    }\n    updateDate(newDate) {\n        const\n            me    = this,\n            start = DateHelper.startOf(newDate, me.range);\n        me.setTimeSpan(start, DateHelper.add(start, 1, me.range));\n        // Cant always use newDate here in case timeAxis is filtered\n        me.visibleDate = {\n            date    : DateHelper.max(newDate, me.timeAxis.startDate),\n            block   : 'start',\n            animate : true\n        };\n        me.trigger('descriptionChange');\n    }\n    updateScrollBuffer(value) {\n        if (!this.isConfiguring) {\n            this.currentOrientation.scrollBuffer = value;\n        }\n    }\n    previous() {\n        this.date = DateHelper.add(this.date, -1, this.stepUnit);\n    }\n    next() {\n        this.date = DateHelper.add(this.date, 1, this.stepUnit);\n    }\n    //endregion\n    /**\n     * Assigns and schedules an unassigned event record (+ adds it to this Scheduler's event store unless already in it).\n     * @param {Object} config The config containing data about the event record to schedule\n     * @param {Date} config.startDate The start date\n     * @param {Scheduler.model.EventModel|EventModelConfig} config.eventRecord Event (or data for it) to assign and schedule\n     * @param {Scheduler.model.EventModel} [config.parentEventRecord] Parent event to add the event to (to nest it),\n     * only applies when using the NestedEvents feature\n     * @param {Scheduler.model.ResourceModel} config.resourceRecord Resource to assign the event to\n     * @param {HTMLElement} [config.element] The element if you are dragging an element from outside the scheduler\n     * @category Scheduled events\n     */\n    async scheduleEvent({ startDate, eventRecord, resourceRecord, element }) {\n        const me = this;\n        // NestedEvents has an override for this function to handle parentEventRecord\n        if (!me.eventStore.includes(eventRecord)) {\n            [eventRecord] = me.eventStore.add(eventRecord);\n        }\n        eventRecord.startDate = startDate;\n        eventRecord.assign(resourceRecord);\n        if (element) {\n            const eventRect = Rectangle.from(element, me.foregroundCanvas);\n            // Clear translate styles used by DragHelper\n            DomHelper.setTranslateXY(element, 0, 0);\n            DomHelper.setTopLeft(element, eventRect.y, eventRect.x);\n            DomSync.addChild(me.foregroundCanvas, element, eventRecord.assignments[0].id);\n        }\n        await me.project.commitAsync();\n    }\n}\n// Register this widget type with its Factory\nSchedulerBase.initClass();\n// Scheduler version is specified in TimelineBase because Gantt extends it\nSchedulerBase._$name = 'SchedulerBase';", "import ColorPicker from '../../Core/widget/ColorPicker.js';\nimport SchedulerBase from '../view/SchedulerBase.js';\n/**\n * @module Scheduler/widget/EventColorPicker\n */\n/**\n * A color picker that displays a list of available event colors which the user can select by using mouse or keyboard.\n * See Schedulers {@link Scheduler.view.mixin.TimelineEventRendering#config-eventColor eventColor config} for default\n * available colors.\n *\n * {@inlineexample Scheduler/widget/EventColorPicker.js}\n *\n * ```javascript\n * new EventColorPicker({\n *    appendTo : 'container',\n *    width    : '10em',\n *    onColorSelected() {\n *        console.log(...arguments);\n *    }\n * });\n * ```\n *\n * @classtype colorpicker\n * @extends Core/widget/ColorPicker\n */\nexport default class EventColorPicker extends ColorPicker {\n    static $name = 'EventColorPicker';\n    static type = 'eventcolorpicker';\n    static configurable = {\n        colorClasses : SchedulerBase.eventColors,\n        colorClassPrefix : 'b-sch-',\n        /**\n         * @hideconfigs colors\n         */\n        colors : null,\n        /**\n         * Provide a {@link Scheduler.model.EventModel} instance to update it's\n         * {@link Scheduler.model.mixin.EventModelMixin#field-eventColor} field\n         * @config {Scheduler.model.EventModel}\n         */\n        record : null\n    };\n    colorSelected({ color }) {\n        if (this.record) {\n            this.record.eventColor = color;\n        }\n    }\n}\nEventColorPicker.initClass();\nEventColorPicker._$name = 'EventColorPicker';", "import Base from '../../Core/Base.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport BrowserHelper from '../../Core/helper/BrowserHelper.js';\n/**\n * @module Scheduler/tooltip/ClockTemplate\n */\n/**\n * A template showing a clock, it consumes an object containing a date and a text\n * @private\n */\nexport default class ClockTemplate extends Base {\n    static get defaultConfig() {\n        return {\n            minuteHeight : 8,\n            minuteTop    : 2,\n            hourHeight   : 8,\n            hourTop      : 2,\n            handLeft     : 10,\n            div          : document.createElement('div'),\n            scheduler    : null, // may be passed to the constructor if needed\n            // `b-sch-clock-day` for calendar icon\n            // `b-sch-clock-hour` for clock icon\n            template(data) {\n                return `<div class=\"b-sch-clockwrap b-sch-clock-${data.mode || this.mode} ${data.cls || ''}\">\n                    <div class=\"b-sch-clock\">\n                        <div class=\"b-sch-hour-indicator\">${DateHelper.format(data.date, 'MMM')}</div>\n                        <div class=\"b-sch-minute-indicator\">${DateHelper.format(data.date, 'D')}</div>\n                        <div class=\"b-sch-clock-dot\"></div>\n                    </div>\n                    <span class=\"b-sch-clock-text\">${StringHelper.encodeHtml(data.text)}</span>\n                </div>`;\n            }\n        };\n    }\n    generateContent(data) {\n        return this.div.innerHTML = this.template(data);\n    }\n    updateDateIndicator(el, date) {\n        const\n            hourIndicatorEl   = el?.querySelector('.b-sch-hour-indicator'),\n            minuteIndicatorEl = el?.querySelector('.b-sch-minute-indicator');\n        if (date && hourIndicatorEl && minuteIndicatorEl && BrowserHelper.isBrowserEnv) {\n            if (this.mode === 'hour') {\n                hourIndicatorEl.style.transform   = `rotate(${(date.getHours() % 12) * 30}deg)`;\n                minuteIndicatorEl.style.transform = `rotate(${date.getMinutes() * 6}deg)`;\n            }\n            else {\n                hourIndicatorEl.style.transform   = 'none';\n                minuteIndicatorEl.style.transform = 'none';\n            }\n        }\n    }\n    set mode(mode) {\n        this._mode = mode;\n    }\n    // `day` mode for calendar icon\n    // `hour` mode for clock icon\n    get mode() {\n        if (this._mode) {\n            return this._mode;\n        }\n        const\n            unitLessThanDay        = DateHelper.compareUnits(this.scheduler.timeAxisViewModel.timeResolution.unit, 'day') < 0,\n            formatContainsHourInfo = DateHelper.formatContainsHourInfo(this.scheduler.displayDateFormat);\n        return unitLessThanDay && formatContainsHourInfo ? 'hour' : 'day';\n    }\n    set template(template) {\n        this._template = template;\n    }\n    /**\n     * Get the clock template, which accepts an object of format { date, text }\n     * @property {Function}\n     * @param {*} Format object\n     * @returns {String}\n     */\n    get template() {\n        return this._template;\n    }\n}\nClockTemplate._$name = 'ClockTemplate';", "import Base from '../../../Core/Base.js';\n/**\n * @module Scheduler/feature/mixin/TaskEditStm\n */\n/**\n * Mixin adding STM transactable behavior to TaskEdit feature.\n *\n * @mixin\n */\nexport default Target => class TaskEditStm extends (Target || Base) {\n    static get $name() {\n        return 'TaskEditStm';\n    }\n    getStmCapture() {\n        return {\n            stmInitiallyAutoRecord : this.stmInitiallyAutoRecord,\n            stmInitiallyDisabled   : this.stmInitiallyDisabled,\n            // this flag indicates whether the STM capture has been transferred to\n            // another feature, which will be responsible for finalizing the STM transaction\n            // (otherwise we'll do it ourselves)\n            transferred            : false\n        };\n    }\n    applyStmCapture(stmCapture) {\n        this.stmInitiallyAutoRecord = stmCapture.stmInitiallyAutoRecord;\n        this.stmInitiallyDisabled = stmCapture.stmInitiallyDisabled;\n    }\n    captureStm(startTransaction = false) {\n        const\n            me      = this,\n            project = me.project,\n            stm     = project.getStm();\n        if (me.hasStmCapture) {\n            return;\n        }\n        me.hasStmCapture = true;\n        me.stmInitiallyDisabled = stm.disabled;\n        me.stmInitiallyAutoRecord = stm.autoRecord;\n        if (me.stmInitiallyDisabled) {\n            stm.enable();\n            // it seems this branch has never been exercised by tests\n            // but the intention is to stop the auto-recording while\n            // task editor is active (all editing is one manual transaction)\n            stm.autoRecord = false;\n        }\n        else {\n            if (me.stmInitiallyAutoRecord) {\n                stm.autoRecord = false;\n            }\n            if (stm.isRecording) {\n                stm.stopTransaction();\n            }\n        }\n        if (startTransaction) {\n            this.startStmTransaction();\n        }\n    }\n    startStmTransaction() {\n        this.project.getStm().startTransaction();\n    }\n    commitStmTransaction() {\n        const\n            me  = this,\n            stm = me.project.getStm();\n        if (!me.hasStmCapture) {\n            throw new Error('Does not have STM capture, no transaction to commit');\n        }\n        if (stm.enabled) {\n            stm.stopTransaction();\n            if (me.stmInitiallyDisabled) {\n                stm.resetQueue();\n            }\n        }\n    }\n    async rejectStmTransaction() {\n        const\n            stm        = this.project.getStm(),\n            { client } = this;\n        if (!this.hasStmCapture) {\n            throw new Error('Does not have STM capture, no transaction to reject');\n        }\n        if (stm.enabled) {\n            if (stm.transaction?.length) {\n                client.suspendRefresh();\n                stm.rejectTransaction();\n                await client.resumeRefresh(true);\n            }\n            else {\n                stm.stopTransaction();\n            }\n        }\n    }\n    enableStm() {\n        this.project.getStm().enable();\n    }\n    disableStm() {\n        this.project.getStm().disable();\n    }\n    async freeStm(commitOrReject = null) {\n        const\n            me  = this,\n            stm = me.project.getStm(),\n            {\n                stmInitiallyDisabled,\n                stmInitiallyAutoRecord\n            } = me;\n        if (!me.hasStmCapture) {\n            return;\n        }\n        let promise;\n        me.rejectingStmTransaction = true;\n        if (commitOrReject === true) {\n            promise = me.commitStmTransaction();\n        }\n        else if (commitOrReject === false) {\n            // Note - we don't wait for async to complete here\n            promise = me.rejectStmTransaction();\n        }\n        await promise;\n        if (!stm.isDestroying) {\n            stm.disabled = stmInitiallyDisabled;\n            stm.autoRecord = stmInitiallyAutoRecord;\n        }\n        if (!me.isDestroying) {\n            me.rejectingStmTransaction = true;\n            me.hasStmCapture = false;\n        }\n    };\n};\n", "import ContextMenuBase from '../../../Core/feature/base/ContextMenuBase.js';\n/**\n * @module Scheduler/feature/base/TimeSpanMenuBase\n */\n/**\n * Abstract base class used by other context menu features which show the context menu for TimeAxis.\n * Using this class you can make sure the menu expects the target to disappear,\n * since it can be scroll out of the scheduling zone.\n *\n * Features that extend this class are:\n *  * {@link Scheduler/feature/EventMenu};\n *  * {@link Scheduler/feature/ScheduleMenu};\n *  * {@link Scheduler/feature/TimeAxisHeaderMenu};\n *\n * @extends Core/feature/base/ContextMenuBase\n * @abstract\n */\nexport default class TimeSpanMenuBase extends ContextMenuBase {\n}\nTimeSpanMenuBase._$name = 'TimeSpanMenuBase';", "import Combo from '../../../../Core/widget/Combo.js';\n/**\n * @module Scheduler/view/recurrence/field/RecurrenceFrequencyCombo\n */\n/**\n * A combobox field allowing to pick frequency in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.\n *\n * @extends Core/widget/Combo\n * @classtype recurrencefrequencycombo\n */\nexport default class RecurrenceFrequencyCombo extends Combo {\n    static $name = 'RecurrenceFrequencyCombo';\n    // Factoryable type name\n    static type = 'recurrencefrequencycombo';\n    static configurable = {\n        editable              : false,\n        displayField          : 'text',\n        valueField            : 'value',\n        localizeDisplayFields : true,\n        addNone               : false\n    };\n    buildItems() {\n        return [\n            ...(this.addNone ? [{ text : 'L{None}', value : 'NONE' }] : []),\n            { value : 'DAILY',   text : 'L{Daily}' },\n            { value : 'WEEKLY',  text : 'L{Weekly}' },\n            { value : 'MONTHLY', text : 'L{Monthly}' },\n            { value : 'YEARLY',  text : 'L{Yearly}' }\n        ];\n    }\n};\n// Register this widget type with its Factory\nRecurrenceFrequencyCombo.initClass();\nRecurrenceFrequencyCombo._$name = 'RecurrenceFrequencyCombo';", "import DateHelper from '../../../../Core/helper/DateHelper.js';\nimport Combo from '../../../../Core/widget/Combo.js';\nimport RecurrenceDayRuleEncoder from '../../../data/util/recurrence/RecurrenceDayRuleEncoder.js';\n/**\n * @module Scheduler/view/recurrence/field/RecurrenceDaysCombo\n */\n/**\n * A combobox field allowing to pick days for the `Monthly` and `Yearly` mode in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.\n *\n * @extends Core/widget/Combo\n * @classtype recurrencedayscombo\n */\nexport default class RecurrenceDaysCombo extends Combo {\n    static get $name() {\n        return 'RecurrenceDaysCombo';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'recurrencedayscombo';\n    }\n    static get defaultConfig() {\n        const\n            allDaysValueAsArray = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'],\n            allDaysValue        = allDaysValueAsArray.join(',');\n        return {\n            allDaysValue,\n            editable            : false,\n            defaultValue        : allDaysValue,\n            workingDaysValue    : allDaysValueAsArray.filter((day, index) => !DateHelper.nonWorkingDays[index]).join(','),\n            nonWorkingDaysValue : allDaysValueAsArray.filter((day, index) => DateHelper.nonWorkingDays[index]).join(','),\n            splitCls            : 'b-recurrencedays-split',\n            displayField        : 'text',\n            valueField          : 'value'\n        };\n    }\n    buildItems() {\n        const me = this;\n        me._weekDays = null;\n        return me.weekDays.concat([\n            { value : me.allDaysValue,        text : me.L('L{day}'), cls : me.splitCls },\n            { value : me.workingDaysValue,    text : me.L('L{weekday}') },\n            { value : me.nonWorkingDaysValue, text : me.L('L{weekend day}') }\n        ]);\n    }\n    get weekDays() {\n        const me = this;\n        if (!me._weekDays) {\n            const weekStartDay = DateHelper.weekStartDay;\n            const dayNames = DateHelper.getDayNames().map((text, index) => ({ text, value : RecurrenceDayRuleEncoder.encodeDay(index) }));\n            // we should start week w/ weekStartDay\n            me._weekDays = dayNames.slice(weekStartDay).concat(dayNames.slice(0, weekStartDay));\n        }\n        return me._weekDays;\n    }\n    set value(value) {\n        const me = this;\n        if (value && Array.isArray(value)) {\n            value = value.join(',');\n        }\n        // if the value has no matching option in the store we need to use default value\n        if (!value || !me.store.findRecord('value', value)) {\n            value = me.defaultValue;\n        }\n        super.value = value;\n    }\n    get value() {\n        let value = super.value;\n        if (value && Array.isArray(value)) {\n            value = value.join(',');\n        }\n        return value;\n    }\n}\n// Register this widget type with its Factory\nRecurrenceDaysCombo.initClass();\nRecurrenceDaysCombo._$name = 'RecurrenceDaysCombo';", "import DateHelper from '../../../../Core/helper/DateHelper.js';\nimport ButtonGroup from '../../../../Core/widget/ButtonGroup.js';\nimport RecurrenceDayRuleEncoder from '../../../data/util/recurrence/RecurrenceDayRuleEncoder.js';\n/**\n * @module Scheduler/view/recurrence/field/RecurrenceDaysButtonGroup\n */\n/**\n * A segmented button field allowing to pick days for the \"Weekly\" mode in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.\n *\n * {@inlineexample Scheduler/view/RecurrenceDaysButtonGroup.js}\n *\n * @extends Core/widget/ButtonGroup\n */\nexport default class RecurrenceDaysButtonGroup extends ButtonGroup {\n    static get $name() {\n        return 'RecurrenceDaysButtonGroup';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'recurrencedaysbuttongroup';\n    }\n    static get defaultConfig() {\n        return {\n            defaults : {\n                cls        : 'b-raised',\n                toggleable : true\n            }\n        };\n    }\n    construct(config = {}) {\n        const me = this;\n        config.columns = 7;\n        config.items   = me.buildItems();\n        super.construct(config);\n    }\n    updateItemText(item) {\n        const day = RecurrenceDayRuleEncoder.decodeDay(item.value)[0];\n        item.text = DateHelper.getDayName(day).substring(0, 3);\n    }\n    buildItems() {\n        const me = this;\n        if (!me.__items) {\n            const weekStartDay = DateHelper.weekStartDay;\n            const dayNames = DateHelper.getDayNames().map((text, index) => ({\n                text  : text.substring(0, 3),\n                value : RecurrenceDayRuleEncoder.encodeDay(index)\n            }));\n            // we should start week w/ weekStartDay\n            me.__items = dayNames.slice(weekStartDay).concat(dayNames.slice(0, weekStartDay));\n        }\n        return me.__items;\n    }\n    set value(value) {\n        if (value && Array.isArray(value)) {\n            value = value.join(',');\n        }\n        super.value = value;\n    }\n    get value() {\n        let value = super.value;\n        if (value && Array.isArray(value)) {\n            value = value.join(',');\n        }\n        return value;\n    }\n    onLocaleChange() {\n        // update button texts on locale switch\n        this.items.forEach(this.updateItemText, this);\n    }\n    updateLocalization() {\n        this.onLocaleChange();\n        super.updateLocalization();\n    }\n    get widgetClassList() {\n        const classList = super.widgetClassList;\n        // to look more like a real field\n        classList.push('b-field');\n        return classList;\n    }\n};\n// Register this widget type with its Factory\nRecurrenceDaysButtonGroup.initClass();\nRecurrenceDaysButtonGroup._$name = 'RecurrenceDaysButtonGroup';", "import ButtonGroup from '../../../../Core/widget/ButtonGroup.js';\n/**\n * A segmented button field allowing to pick month days for the `Monthly` mode in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.\n *\n * @extends Core/widget/ButtonGroup\n */\nexport default class RecurrenceMonthDaysButtonGroup extends ButtonGroup {\n    static get $name() {\n        return 'RecurrenceMonthDaysButtonGroup';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'recurrencemonthdaysbuttongroup';\n    }\n    static get defaultConfig() {\n        return {\n            defaults : {\n                toggleable : true,\n                cls        : 'b-raised'\n            }\n        };\n    }\n    get minValue() {\n        return 1;\n    }\n    get maxValue() {\n        return 31;\n    }\n    construct(config = {}) {\n        const me = this;\n        config.columns = 7;\n        config.items   = me.buildItems();\n        super.construct(config);\n    }\n    buildItems() {\n        const\n            me    = this,\n            items = [];\n        for (let value = me.minValue; value <= me.maxValue; value++) {\n            // button config\n            items.push({\n                text : value + '',\n                value\n            });\n        }\n        return items;\n    }\n    get widgetClassList() {\n        const classList = super.widgetClassList;\n        // to look more like a real field\n        classList.push('b-field');\n        return classList;\n    }\n};\n// Register this widget type with its Factory\nRecurrenceMonthDaysButtonGroup.initClass();\nRecurrenceMonthDaysButtonGroup._$name = 'RecurrenceMonthDaysButtonGroup';", "import DateHelper from '../../../../Core/helper/DateHelper.js';\nimport ButtonGroup from '../../../../Core/widget/ButtonGroup.js';\n/**\n * A segmented button field allowing to pick months for the `Yearly` mode in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.\n *\n * @extends Core/widget/ButtonGroup\n */\nexport default class RecurrenceMonthsButtonGroup extends ButtonGroup {\n    static get $name() {\n        return 'RecurrenceMonthsButtonGroup';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'recurrencemonthsbuttongroup';\n    }\n    static get defaultConfig() {\n        return {\n            defaults : {\n                toggleable : true,\n                cls        : 'b-raised'\n            }\n        };\n    }\n    construct(config = {}) {\n        const me = this;\n        config.columns = 4;\n        config.items   = me.buildItems();\n        super.construct(config);\n    }\n    buildItems() {\n        return DateHelper.getMonthNames().map((item, index) => ({\n            text  : item.substring(0, 3),\n            value : index + 1 // 1-based\n        }));\n    }\n    updateItemText(item) {\n        item.text = DateHelper.getMonthName(item.value - 1).substring(0, 3);\n    }\n    onLocaleChange() {\n        // update button texts on locale switch\n        this.items.forEach(this.updateItemText, this);\n    }\n    updateLocalization() {\n        this.onLocaleChange();\n        super.updateLocalization();\n    }\n    get widgetClassList() {\n        const classList = super.widgetClassList;\n        // to look more like a real field\n        classList.push('b-field');\n        return classList;\n    }\n};\n// Register this widget type with its Factory\nRecurrenceMonthsButtonGroup.initClass();\nRecurrenceMonthsButtonGroup._$name = 'RecurrenceMonthsButtonGroup';", "import Combo from '../../../../Core/widget/Combo.js';\n/**\n * @module Scheduler/view/recurrence/field/RecurrenceStopConditionCombo\n */\n/**\n * A combobox field allowing to choose stop condition for the recurrence in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.\n *\n * @extends Core/widget/Combo\n * @classtype recurrencestopconditioncombo\n */\nexport default class RecurrenceStopConditionCombo extends Combo {\n    static get $name() {\n        return 'RecurrenceStopConditionCombo';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'recurrencestopconditioncombo';\n    }\n    static get defaultConfig() {\n        return {\n            editable     : false,\n            placeholder  : 'Never',\n            displayField : 'text',\n            valueField   : 'value'\n        };\n    }\n    buildItems() {\n        return [\n            { value : 'never', text : this.L('L{Never}') },\n            { value : 'count', text : this.L('L{After}') },\n            { value : 'date',  text : this.L('L{On date}') }\n        ];\n    }\n    set value(value) {\n        // Use 'never' instead of falsy value\n        value = value || 'never';\n        super.value = value;\n    }\n    get value() {\n        return super.value;\n    }\n    get recurrence() {\n        return this._recurrence;\n    }\n    set recurrence(recurrence) {\n        let value = null;\n        if (recurrence.endDate) {\n            value = 'date';\n        }\n        else if (recurrence.count) {\n            value = 'count';\n        }\n        this._recurrence = recurrence;\n        this.value = value;\n    }\n};\n// Register this widget type with its Factory\nRecurrenceStopConditionCombo.initClass();\nRecurrenceStopConditionCombo._$name = 'RecurrenceStopConditionCombo';", "import ArrayHelper from '../../../../Core/helper/ArrayHelper.js';\nimport Combo from '../../../../Core/widget/Combo.js';\n/**\n * @module Scheduler/view/recurrence/field/RecurrencePositionsCombo\n */\n/**\n * A combobox field allowing to specify day positions in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence editor}.\n *\n * @extends Core/widget/Combo\n * @classtype recurrencepositionscombo\n */\nexport default class RecurrencePositionsCombo extends Combo {\n    static get $name() {\n        return 'RecurrencePositionsCombo';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'recurrencepositionscombo';\n    }\n    static get defaultConfig() {\n        return {\n            editable     : false,\n            splitCls     : 'b-sch-recurrencepositions-split',\n            displayField : 'text',\n            valueField   : 'value',\n            defaultValue : 1,\n            maxPosition  : 5\n        };\n    }\n    buildItems() {\n        return this.buildDayNumbers().concat([\n            { value : '-1', text : this.L('L{position-1}'), cls : this.splitCls }\n        ]);\n    }\n    buildDayNumbers() {\n        return ArrayHelper.populate(this.maxPosition, i => (\n            { value : i + 1, text : this.L(`position${i + 1}`) }\n        ));\n    }\n    set value(value) {\n        const me = this;\n        if (value && Array.isArray(value)) {\n            value = value.join(',');\n        }\n        // if the value has no matching option in the store we need to use default value\n        if (!value || !me.store.findRecord('value', value)) {\n            value = me.defaultValue;\n        }\n        super.value = value;\n    }\n    get value() {\n        const value = super.value;\n        return value ? `${value}`.split(',').map(item => parseInt(item, 10)) : [];\n    }\n};\n// Register this widget type with its Factory\nRecurrencePositionsCombo.initClass();\nRecurrencePositionsCombo._$name = 'RecurrencePositionsCombo';", "import RecurrenceDayRuleEncoder from '../../data/util/recurrence/RecurrenceDayRuleEncoder.js';\nimport Panel from '../../../Core/widget/Panel.js';\nimport '../../../Core/widget/Widget.js';\nimport '../../../Core/widget/Button.js';\nimport '../../../Core/widget/Checkbox.js';\nimport '../../../Core/widget/SlideToggle.js';\nimport '../../../Core/widget/DateField.js';\nimport '../../../Core/widget/NumberField.js';\nimport './field/RecurrenceFrequencyCombo.js';\nimport './field/RecurrenceDaysCombo.js';\nimport './field/RecurrenceDaysButtonGroup.js';\nimport './field/RecurrenceMonthDaysButtonGroup.js';\nimport './field/RecurrenceMonthsButtonGroup.js';\nimport './field/RecurrenceStopConditionCombo.js';\nimport './field/RecurrencePositionsCombo.js';\nimport BrowserHelper from '../../../Core/helper/BrowserHelper.js';\n/**\n * @module Scheduler/view/recurrence/RecurrenceEditorPanel\n */\n/**\n * Panel containing fields used to edit a {@link Scheduler.model.RecurrenceModel recurrence model}. Used by\n * {@link Scheduler/view/recurrence/RecurrenceEditor}, and by the recurrence tab in Scheduler Pro's event editor.\n *\n * Not intended to be used separately.\n *\n * @extends Core/widget/Panel\n * @classtype recurrenceeditorpanel\n * @private\n */\nexport default class RecurrenceEditorPanel extends Panel {\n    static $name = 'RecurrenceEditorPanel';\n    static type = 'recurrenceeditorpanel';\n    static configurable = {\n        cls     : 'b-recurrenceeditor',\n        record  : false,\n        addNone : false,\n        items   : {\n            frequencyField : {\n                type     : 'recurrencefrequencycombo',\n                name     : 'frequency',\n                label    : 'L{RecurrenceEditor.Frequency}',\n                weight   : 10,\n                onChange : 'up.onFrequencyFieldChange',\n                addNone  : 'up.addNone'\n            },\n            intervalField : {\n                type     : 'numberfield',\n                weight   : 15,\n                name     : 'interval',\n                label    : 'L{RecurrenceEditor.Every}',\n                min      : 1,\n                required : true\n            },\n            daysButtonField : {\n                type         : 'recurrencedaysbuttongroup',\n                weight       : 20,\n                name         : 'days',\n                forFrequency : 'WEEKLY'\n            },\n            // the radio button enabling \"monthDaysButtonField\" in MONTHLY mode\n            monthDaysRadioField : {\n                type         : 'checkbox',\n                weight       : 30,\n                toggleGroup  : 'radio',\n                forFrequency : 'MONTHLY',\n                label        : 'L{RecurrenceEditor.Each}',\n                checked      : true,\n                onChange     : 'up.onMonthDaysRadioFieldChange'\n            },\n            monthDaysButtonField : {\n                type         : 'recurrencemonthdaysbuttongroup',\n                weight       : 40,\n                name         : 'monthDays',\n                forFrequency : 'MONTHLY'\n            },\n            monthsButtonField : {\n                type         : 'recurrencemonthsbuttongroup',\n                weight       : 50,\n                name         : 'months',\n                forFrequency : 'YEARLY'\n            },\n            // the radio button enabling positions & days combos in MONTHLY & YEARLY modes\n            positionAndDayRadioField : {\n                type         : 'checkbox',\n                weight       : 60,\n                toggleGroup  : 'radio',\n                forFrequency : 'MONTHLY|YEARLY',\n                label        : 'L{RecurrenceEditor.On the}',\n                onChange     : 'up.onPositionAndDayRadioFieldChange'\n            },\n            positionsCombo : {\n                type         : 'recurrencepositionscombo',\n                weight       : 80,\n                name         : 'positions',\n                forFrequency : 'MONTHLY|YEARLY'\n            },\n            daysCombo : {\n                type         : 'recurrencedayscombo',\n                weight       : 90,\n                name         : 'days',\n                forFrequency : 'MONTHLY|YEARLY',\n                flex         : 1\n            },\n            stopRecurrenceField : {\n                type     : 'recurrencestopconditioncombo',\n                weight   : 100,\n                label    : 'L{RecurrenceEditor.End repeat}',\n                onChange : 'up.onStopRecurrenceFieldChange'\n            },\n            countField : {\n                type     : 'numberfield',\n                weight   : 110,\n                name     : 'count',\n                min      : 2,\n                required : true,\n                disabled : true,\n                label    : ' '\n            },\n            endDateField : {\n                type     : 'datefield',\n                weight   : 120,\n                name     : 'endDate',\n                hidden   : true,\n                disabled : true,\n                label    : ' ',\n                required : true\n            }\n        }\n    };\n    setupWidgetConfig(widgetConfig) {\n        // All our inputs must be mutated using triggers and touch gestures on mobile\n        if (BrowserHelper.isMobile && !('editable' in widgetConfig)) {\n            widgetConfig.editable = false;\n        }\n        return super.setupWidgetConfig(...arguments);\n    }\n    updateRecord(record) {\n        super.updateRecord(record);\n        const\n            me = this,\n            {\n                frequencyField,\n                daysButtonField,\n                monthDaysButtonField,\n                monthsButtonField,\n                monthDaysRadioField,\n                positionAndDayRadioField,\n                stopRecurrenceField\n            }  = me.widgetMap;\n        if (record) {\n            const\n                event     = record.timeSpan,\n                startDate = event?.startDate;\n            // some fields default values are calculated based on event \"startDate\" value\n            if (startDate) {\n                // if no \"days\" value provided\n                if (!record.days || !record.days.length) {\n                    daysButtonField.value = [RecurrenceDayRuleEncoder.encodeDay(startDate.getDay())];\n                }\n                // if no \"monthDays\" value provided\n                if (!record.monthDays || !record.monthDays.length) {\n                    monthDaysButtonField.value = startDate.getDate();\n                }\n                // if no \"months\" value provided\n                if (!record.months || !record.months.length) {\n                    monthsButtonField.value = startDate.getMonth() + 1;\n                }\n            }\n            // if the record has both \"days\" & \"positions\" fields set check \"On the\" checkbox\n            if (record.days && record.positions) {\n                positionAndDayRadioField.check();\n                if (!me.isPainted) {\n                    monthDaysRadioField.uncheck();\n                }\n            }\n            else {\n                monthDaysRadioField.check();\n                if (!me.isPainted) {\n                    positionAndDayRadioField.uncheck();\n                }\n            }\n            stopRecurrenceField.recurrence = record;\n        }\n        else {\n            frequencyField.value = 'NONE';\n        }\n    }\n    /**\n     * Updates the provided recurrence model with the contained form data.\n     * If recurrence model is not provided updates the last loaded recurrence model.\n     * @internal\n     */\n    syncEventRecord(recurrence) {\n        // get values relevant to the RecurrenceModel (from enabled fields only)\n        const values = this.getValues((w) => w.name in recurrence && !w.disabled);\n        // Disabled field does not contribute to values, clear manually\n        if (!('endDate' in values)) {\n            values.endDate = null;\n        }\n        if (!('count' in values)) {\n            values.count = null;\n        }\n        recurrence.set(values);\n    }\n    toggleStopFields() {\n        const\n            me                           = this,\n            { countField, endDateField } = me.widgetMap;\n        switch (me.widgetMap.stopRecurrenceField.value) {\n            case 'count' :\n                countField.show();\n                countField.enable();\n                endDateField.hide();\n                endDateField.disable();\n                break;\n            case 'date' :\n                countField.hide();\n                countField.disable();\n                endDateField.show();\n                endDateField.enable();\n                break;\n            default :\n                countField.hide();\n                endDateField.hide();\n                countField.disable();\n                endDateField.disable();\n        }\n    }\n    onMonthDaysRadioFieldChange({ checked }) {\n        const { monthDaysButtonField } = this.widgetMap;\n        monthDaysButtonField.disabled = !checked || !this.isWidgetAvailableForFrequency(monthDaysButtonField);\n    }\n    onPositionAndDayRadioFieldChange({ checked }) {\n        const { daysCombo, positionsCombo } = this.widgetMap;\n        // toggle day & positions combos\n        daysCombo.disabled = positionsCombo.disabled = !checked || !this.isWidgetAvailableForFrequency(daysCombo);\n    }\n    onStopRecurrenceFieldChange() {\n        this.toggleStopFields();\n    }\n    isWidgetAvailableForFrequency(widget, frequency = this.widgetMap.frequencyField.value) {\n        return !widget.forFrequency || widget.forFrequency.includes(frequency);\n    }\n    onFrequencyFieldChange({ value, oldValue, valid }) {\n        const\n            me    = this,\n            items = me.queryAll(w => 'forFrequency' in w),\n            {\n                intervalField,\n                stopRecurrenceField\n            }     = me.widgetMap;\n        if (valid && value) {\n            for (let i = 0; i < items.length; i++) {\n                const item = items[i];\n                if (me.isWidgetAvailableForFrequency(item, value)) {\n                    item.show();\n                    item.enable();\n                }\n                else {\n                    item.hide();\n                    item.disable();\n                }\n            }\n            // Special handling of NONE\n            intervalField.hidden = stopRecurrenceField.hidden = value === 'NONE';\n            if (value !== 'NONE') {\n                intervalField.hint = me.L(`L{RecurrenceEditor.${value}intervalUnit}`);\n            }\n            // When a non-recurring record is loaded, intervalField is set to empty. We want it to default to 1 here\n            // to not look weird (defaults to 1 on the data layer)\n            if (oldValue === 'NONE' && intervalField.value == null) {\n                intervalField.value = 1;\n            }\n            me.toggleFieldsState();\n        }\n    }\n    toggleFieldsState() {\n        const\n            me            = this,\n            { widgetMap } = me;\n        me.onMonthDaysRadioFieldChange({ checked : widgetMap.monthDaysRadioField.checked });\n        me.onPositionAndDayRadioFieldChange({ checked : widgetMap.positionAndDayRadioField.checked });\n        me.onStopRecurrenceFieldChange();\n    }\n    updateLocalization() {\n        // do extra labels translation (not auto-translated yet)\n        const { countField, intervalField, frequencyField } = this.widgetMap;\n        countField.hint = this.L('L{RecurrenceEditor.time(s)}');\n        if (frequencyField.value && frequencyField.value !== 'NONE') {\n            intervalField.hint = this.L(`L{RecurrenceEditor.${frequencyField.value}intervalUnit}`);\n        }\n        super.updateLocalization();\n    }\n}\n// Register this widget type with its Factory\nRecurrenceEditorPanel.initClass();\nRecurrenceEditorPanel._$name = 'RecurrenceEditorPanel';", "import ColorField from '../../Core/widget/ColorField.js';\nimport './EventColorPicker.js';\n/**\n * @module Scheduler/widget/EventColorField\n */\n/**\n * Color field widget for editing the EventModel's {@link Scheduler.model.mixin.EventModelMixin#field-eventColor} field.\n * See Schedulers {@link Scheduler.view.mixin.TimelineEventRendering#config-eventColor eventColor config} for default\n * available colors.\n *\n * What differs this widget from {@link Core.widget.ColorField} is that this uses the\n * {@link Scheduler.widget.EventColorPicker} as its picker. And also that the {@link #config-name} config is set to\n * `eventColor` per default.\n *\n * {@inlineexample Scheduler/widget/EventColorField.js}\n *\n * This widget may be operated using the keyboard. `ArrowDown` opens the color picker, which itself is keyboard\n * navigable.\n *\n * ```javascript\n * let eventColorField = new EventColorField();\n * ```\n *\n * @extends Core/widget/ColorField\n * @classtype eventcolorfield\n * @inputfield\n */\nexport default class EventColorField extends ColorField {\n    static $name = 'EventColorField';\n    static type = 'eventcolorfield';\n    static configurable = {\n        picker : {\n            type : 'eventcolorpicker'\n        },\n        name : 'eventColor'\n    };\n}\nEventColorField.initClass();\nEventColorField._$name = 'EventColorField';", "import GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport TimeSpanMenuBase from './base/TimeSpanMenuBase.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport Objects from '../../Core/helper/util/Objects.js';\nimport '../widget/EventColorPicker.js';\n/**\n * @module Scheduler/feature/EventMenu\n */\n/**\n * Displays a context menu for events. Items are populated by other features and/or application code.\n *\n * {@inlineexample Scheduler/feature/EventMenu.js}\n *\n * ### Default event menu items\n *\n * Here is the list of menu items provided by the feature and populated by the other features:\n *\n * | Reference       | Text           | Weight | Feature                                  | Description                                                       |\n * |-----------------|----------------|--------|------------------------------------------|-------------------------------------------------------------------|\n * | `editEvent`     | Edit event     | 100    | {@link Scheduler/feature/EventEdit}      | Edit in the event editor. Hidden when read-only                   |\n * | `copyEvent`     | Copy event     | 110    | {@link Scheduler/feature/EventCopyPaste} | Copy event or assignment. Hidden when read-only                   |\n * | `cutEvent `     | Cut event      | 120    | {@link Scheduler/feature/EventCopyPaste} | Cut event or assignment. Hidden when read-only                    |\n * | `deleteEvent`   | Delete event   | 200    | *This feature*                           | Remove event. Hidden when read-only                               |\n * | `unassignEvent` | Unassign event | 300    | *This feature*                           | Unassign event. Hidden when read-only, shown for multi-assignment |\n * | `splitEvent`    | Split event    | 650    | *Scheduler Pro only*                     | Split an event into two segments at the mouse position            |\n * | `renameSegment` | Rename segment | 660    | *Scheduler Pro only*                     | Show an inline editor to rename the segment                       |\n * | `eventColor` \u00B9  | Color          | 400    | *This feature*                           | Choose background color for the event bar                         |\n *\n * **\u00B9** Set {@link Scheduler.view.SchedulerBase#config-showEventColorPickers} to `true` to enable this item\n *\n * ### Customizing the menu items\n *\n * The menu items in the Event menu can be customized, existing items can be changed or removed,\n * and new items can be added. This is handled using the `items` config of the feature.\n *\n * Add extra items for all events:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         eventMenu : {\n *             items : {\n *                 extraItem : {\n *                     text : 'Extra',\n *                     icon : 'b-fa b-fa-fw b-fa-flag',\n *                     onItem({eventRecord}) {\n *                         eventRecord.flagged = true;\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Remove existing items:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         eventMenu : {\n *             items : {\n *                 deleteEvent   : false,\n *                 unassignEvent : false\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Customize existing item:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         eventMenu : {\n *             items : {\n *                 deleteEvent : {\n *                     text : 'Delete booking'\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Manipulate existing items for all events or specific events:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         eventMenu : {\n *             // Process items before menu is shown\n *             processItems({eventRecord, items}) {\n *                  // Push an extra item for conferences\n *                  if (eventRecord.type === 'conference') {\n *                      items.showSessionItem = {\n *                          text : 'Show sessions',\n *                          onItem({eventRecord}) {\n *                              // ...\n *                          }\n *                      };\n *                  }\n *\n *                  // Do not show menu for secret events\n *                  if (eventRecord.type === 'secret') {\n *                      return false;\n *                  }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * <div class=\"note\">The `processItems` implementation my be an `async` function which `awaits` a result to\n * mutate the `items` object.</div>\n *\n * Note that the {@link #property-menuContext} is applied to the Menu's `item` event, so your `onItem`\n * handler's single event parameter also contains the following properties:\n *\n * - **source** The {@link Scheduler.view.Scheduler} who's UI was right clicked.\n * - **targetElement** The element right clicked on.\n * - **eventRecord** The {@link Scheduler.model.EventModel event record} clicked on.\n * - **resourceRecord** The {@link Scheduler.model.ResourceModel resource record} clicked on.\n * - **assignmentRecord** The {@link Scheduler.model.AssignmentModel assignment record} clicked on.\n *\n * ## Video guides\n * {@frameworktabs}\n * {@react}\n * [@youtube](https://www.youtube.com/embed/ghWLmifpO_4)\n * {@endreact}\n * {@vue}\n * [@youtube](https://www.youtube.com/embed/HAq12QUBMx8)\n * {@endvue}\n * {@angular}\n * **Coming soon!**\n * {@endangular}\n * {@endframeworktabs}\n *\n * Full information of the menu customization can be found in the \"Customizing the Event menu, the Schedule menu, and the TimeAxisHeader menu\" guide.\n *\n * This feature is **enabled** by default\n *\n * @extends Scheduler/feature/base/TimeSpanMenuBase\n * @demo Scheduler/eventmenu\n * @classtype eventMenu\n * @feature\n */\nexport default class EventMenu extends TimeSpanMenuBase {\n    //region Config\n    static get $name() {\n        return 'EventMenu';\n    }\n    /**\n     * @member {Object} menuContext\n     * An informational object containing contextual information about the last activation\n     * of the context menu. The base properties are listed below.\n     * @property {Event} menuContext.domEvent The initiating event.\n     * @property {Event} menuContext.event DEPRECATED: The initiating event.\n     * @property {Number[]} menuContext.point The client `X` and `Y` position of the initiating event.\n     * @property {HTMLElement} menuContext.targetElement The target to which the menu is being applied.\n     * @property {Object<String,MenuItemConfig>} menuContext.items The context menu **configuration** items.\n     * @property {Core.data.Model[]} menuContext.selection The record selection in the client (Grid, Scheduler, Gantt or Calendar).\n     * @property {Scheduler.model.EventModel} menuContext.eventRecord The event record clicked on.\n     * @property {Scheduler.model.ResourceModel} menuContext.resourceRecord The resource record clicked on.\n     * @property {Scheduler.model.AssignmentModel} menuContext.assignmentRecord The assignment record clicked on.\n     * @readonly\n     */\n    static get configurable() {\n        return {\n            /**\n             * A function called before displaying the menu that allows manipulations of its items.\n             * Returning `false` from this function prevents the menu being shown.\n             *\n             * ```javascript\n             * features         : {\n             *    eventMenu : {\n             *         processItems({ items, eventRecord, assignmentRecord, resourceRecord }) {\n             *             // Add or hide existing items here as needed\n             *             items.myAction = {\n             *                 text   : 'Cool action',\n             *                 icon   : 'b-fa b-fa-fw b-fa-ban',\n             *                 onItem : () => console.log(`Clicked ${eventRecord.name}`),\n             *                 weight : 1000 // Move to end\n             *             };\n             *\n             *            if (!eventRecord.allowDelete) {\n             *                 items.deleteEvent.hidden = true;\n             *             }\n             *         }\n             *     }\n             * },\n             * ```\n             *\n             * @config {Function}\n             * @param {Object} context An object with information about the menu being shown\n             * @param {Scheduler.model.EventModel} context.eventRecord The record representing the current event\n             * @param {Scheduler.model.ResourceModel} context.resourceRecord The record representing the current resource\n             * @param {Scheduler.model.AssignmentModel} context.assignmentRecord The assignment record\n             * @param {Object<String,MenuItemConfig|Boolean>} context.items An object containing the\n             *   {@link Core.widget.MenuItem menu item} configs keyed by their id\n             * @param {Event} context.event The DOM event object that triggered the show\n             * @returns {Boolean|null} Returning `false` from this function prevents the menu being shown\n             * @preventable\n             */\n            processItems : null,\n            type : 'event'\n            /**\n             * This is a preconfigured set of items used to create the default context menu. The default options are\n             * listed at the top of the page.\n             *\n             * To remove existing items, set corresponding keys `null`:\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         eventMenu : {\n             *             items : {\n             *                 deleteEvent   : null,\n             *                 unassignEvent : null\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             *\n             * See the feature config in the above example for details.\n             *\n             * @config {Object<String,MenuItemConfig|Boolean|null>} items\n             */\n        };\n    }\n    static get pluginConfig() {\n        const config = super.pluginConfig;\n        config.chain.push('populateEventMenu');\n        return config;\n    }\n    //endregion\n    //region Events\n    /**\n     * This event fires on the owning Scheduler before the context menu is shown for an event. Allows manipulation of the items\n     * to show in the same way as in `processItems`. Returning `false` from a listener prevents the menu from\n     * being shown.\n     * @event eventMenuBeforeShow\n     * @on-owner\n     * @preventable\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Object<String,MenuItemConfig>} items Menu item configs\n     * @param {Scheduler.model.EventModel} eventRecord Event record for which the menu was triggered\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used\n     * @param {HTMLElement} eventElement\n     * @param {MouseEvent} [event] Pointer event which triggered the context menu (if any)\n     */\n    /**\n     * This event fires on the owning Scheduler when an item is selected in the context menu.\n     * @event eventMenuItem\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Core.widget.MenuItem} item\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used\n     * @param {HTMLElement} eventElement\n     */\n    /**\n     * This event fires on the owning Scheduler after showing the context menu for an event\n     * @event eventMenuShow\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Scheduler.model.EventModel} eventRecord Event record for which the menu was triggered\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used\n     * @param {HTMLElement} eventElement\n     */\n    //endregion\n    get resourceStore() {\n        // In horizontal mode, we use store (might be a display store), in vertical & calendar we use resourceStore\n        return this.client.isHorizontal ? this.client.store : this.client.resourceStore;\n    }\n    getDataFromEvent(event) {\n        const\n            data             = super.getDataFromEvent(event),\n            eventElement     = data.targetElement,\n            { client }       = this,\n            eventRecord      = client.resolveEventRecord(eventElement),\n            // For vertical mode the resource must be resolved from the event\n            resourceRecord   = eventRecord && (client.resolveResourceRecord(eventElement) || this.resourceStore.last)?.$original,\n            assignmentRecord = eventRecord && client.resolveAssignmentRecord(eventElement);\n        return Object.assign(data, {\n            date : client.getDateFromXY([event.pageX, event.pageY], null, false),\n            eventElement,\n            eventRecord,\n            resourceRecord,\n            assignmentRecord\n        });\n    }\n    getTargetElementFromEvent({ target }) {\n        return target.closest(this.client.eventSelector) || target;\n    }\n    shouldShowMenu(eventParams) {\n        return eventParams.eventRecord;\n    }\n    /**\n     * Shows context menu for the provided event. If record is not rendered (outside of time span/filtered)\n     * menu won't appear.\n     * @param {Scheduler.model.EventModel} eventRecord Event record to show menu for.\n     * @param {Object} [options]\n     * @param {HTMLElement} options.targetElement Element to align context menu to.\n     * @param {MouseEvent} options.event Browser event.\n     * If provided menu will be aligned according to clientX/clientY coordinates.\n     * If omitted, context menu will be centered to event element.\n     */\n    showContextMenuFor(eventRecord, { targetElement, event } = {}) {\n        if (this.disabled) {\n            return;\n        }\n        if (!targetElement) {\n            targetElement = this.getElementFromRecord(eventRecord);\n            // If record is not rendered, do nothing\n            if (!targetElement) {\n                return;\n            }\n        }\n        DomHelper.triggerMouseEvent(targetElement, this.triggerEvent);\n    }\n    getElementFromRecord(record) {\n        return this.client.getElementsFromEventRecord(record)[0];\n    }\n    populateEventMenu({ items, eventRecord, assignmentRecord }) {\n        const { client } = this;\n        items.deleteEvent = {\n            disabled : eventRecord.readOnly || assignmentRecord?.readOnly,\n            hidden   : client.readOnly\n        };\n        items.unassignEvent = {\n            disabled : eventRecord.readOnly || assignmentRecord?.readOnly,\n            hidden   : client.readOnly || client.eventStore.usesSingleAssignment\n        };\n        if (client.showEventColorPickers || client.showTaskColorPickers) {\n            items.eventColor = {\n                disabled : eventRecord.readOnly,\n                hidden   : client.readOnly\n            };\n        }\n        else {\n            items.eventColor = {\n                hidden : true\n            };\n        }\n    }\n    populateItemsWithData({ items, eventRecord }) {\n        super.populateItemsWithData(...arguments);\n        const { client } = this;\n        if ((client.showEventColorPickers || (client.isSchedulerPro && client.showTaskColorPickers)) &&\n            items.eventColor?.menu\n        ) {\n            Objects.merge(items.eventColor.menu.colorMenu, {\n                value  : eventRecord.eventColor,\n                record : eventRecord\n            });\n        }\n    }\n    // This generates the fixed, unchanging part of the items and is only called once\n    // to generate the baseItems of the feature.\n    // The dynamic parts which are set by populateEventMenu have this merged into them.\n    changeItems(items) {\n        const { client } = this;\n        return Objects.merge({\n            deleteEvent : {\n                text   : 'L{SchedulerBase.Delete event}',\n                icon   : 'b-icon b-icon-trash',\n                weight : 200,\n                onItem({ menu, eventRecord }) {\n                    // We must synchronously push focus back into the menu's triggering\n                    // event so that our beforeRemove handlers can move focus onwards\n                    // to the closest remaining event.\n                    // Otherwise, the menu's default hide processing on hide will attempt\n                    // to move focus back to the menu's triggering event which will\n                    // by then have been deleted.\n                    const revertTarget = menu.focusInEvent?.relatedTarget;\n                    if (revertTarget) {\n                        revertTarget.focus();\n                        client.navigator.activeItem = revertTarget;\n                    }\n                    client.removeEvents(client.isEventSelected(eventRecord) ? client.selectedEvents : [eventRecord]);\n                }\n            },\n            unassignEvent : {\n                text   : 'L{SchedulerBase.Unassign event}',\n                icon   : 'b-icon b-icon-unassign',\n                weight : 300,\n                onItem({ menu, eventRecord, resourceRecord }) {\n                    // We must synchronously push focus back into the menu's triggering\n                    // event so that our beforeRemove handlers can move focus onwards\n                    // to the closest remaining event.\n                    // Otherwise, the menu's default hide processing on hide will attempt\n                    // to move focus back to the menu's triggering event which will\n                    // by then have been deleted.\n                    const revertTarget = menu.focusInEvent?.relatedTarget;\n                    if (revertTarget) {\n                        revertTarget.focus();\n                        client.navigator.activeItem = revertTarget;\n                    }\n                    if (client.isEventSelected(eventRecord)) {\n                        client.assignmentStore.remove(client.selectedAssignments);\n                    }\n                    else {\n                        eventRecord.unassign(resourceRecord);\n                    }\n                }\n            },\n            eventColor : {\n                text      : 'L{SchedulerBase.color}',\n                icon      : 'b-icon b-icon-palette',\n                separator : true,\n                menu      : {\n                    colorMenu : {\n                        type : 'eventcolorpicker'\n                    }\n                }\n            }\n        }, items);\n    }\n}\nEventMenu.featureClass = '';\nEventMenu._$name = 'EventMenu'; GridFeatureManager.registerFeature(EventMenu, true, 'Scheduler');\nGridFeatureManager.registerFeature(EventMenu, false, 'ResourceHistogram');\n", "import TimeSpanMenuBase from '../../Scheduler/feature/base/TimeSpanMenuBase.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\n/**\n * @module Scheduler/feature/ScheduleMenu\n */\n/**\n * Displays a context menu for empty parts of the schedule. Items are populated in the first place\n * by configurations of this Feature, then by other features and/or application code.\n *\n * ### Default scheduler zone menu items\n *\n * The Scheduler menu feature provides only one item:\n *\n * | Reference              | Text         | Weight | Feature                                  | Description                                                           |\n * |------------------------|--------------|--------|------------------------------------------|-----------------------------------------------------------------------|\n * | `addEvent`             | Add event    | 100    | *This feature*                           | Add new event at the target time and resource. Hidden when read-only  |\n * | `pasteEvent`           | Paste event  | 110    | {@link Scheduler/feature/EventCopyPaste} | Paste event at the target time and resource. Hidden when is read-only |\n * | `splitSchedule`        | Split        | 200    | {@link Scheduler/feature/Split}          | Shows the \"Split schedule\" sub-menu                                   |\n * | \\> `splitHorizontally` | Horizontally | 100    | {@link Scheduler/feature/Split}          | Split horizontally                                                    |\n * | \\> `splitVertically `  | Vertically   | 200    | {@link Scheduler/feature/Split}          | Split vertically                                                      |\n * | \\> `splitBoth`         | Both         | 300    | {@link Scheduler/feature/Split}          | Split both ways                                                       |\n * | `unsplitSchedule`      | Split        | 210    | {@link Scheduler/feature/Split}          | Unsplit a previously split schedule                                   |\n *\n * ### Customizing the menu items\n *\n * The menu items in the Scheduler menu can be customized, existing items can be changed or removed,\n * and new items can be added. This is handled using the `items` config of the feature.\n *\n * Add extra item:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         scheduleMenu : {\n *             items : {\n *                 extraItem : {\n *                     text : 'Extra',\n *                     icon : 'b-fa b-fa-fw b-fa-flag',\n *                     onItem({date, resourceRecord, items}) {\n *                         // Custom date based action\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Remove existing item:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         scheduleMenu : {\n *             items : {\n *                 addEvent : false\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Customize existing item:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         scheduleMenu : {\n *             items : {\n *                 addEvent : {\n *                     text : 'Create new booking'\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Manipulate existing items:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         scheduleMenu : {\n *             // Process items before menu is shown\n *             processItems({date, resourceRecord, items}) {\n *                  // Add an extra item for ancient times\n *                  if (date < new Date(2018, 11, 17)) {\n *                      items.modernize = {\n *                          text : 'Modernize',\n *                          ontItem({date}) {\n *                              // Custom date based action\n *                          }\n *                      };\n *                  }\n *\n *                  // Do not show menu for Sundays\n *                  if (date.getDay() === 0) {\n *                      return false;\n *                  }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * <div class=\"note\">The `processItems` implementation my be an `async` function which `awaits` a result to\n * mutate the `items` object.</div>\n *\n * ## Video guides\n * {@frameworktabs}\n * {@react}\n * [@youtube](https://www.youtube.com/embed/ghWLmifpO_4)\n * {@endreact}\n * {@vue}\n * [@youtube](https://www.youtube.com/embed/HAq12QUBMx8)\n * {@endvue}\n * {@angular}\n * **Coming soon!**\n * {@endangular}\n * {@endframeworktabs}\n *\n * Full information of the menu customization can be found in the \"Customizing the Event menu, the Schedule menu, and the TimeAxisHeader menu\" guide.\n *\n * This feature is **enabled** by default\n *\n * @demo Scheduler/basic\n * @extends Scheduler/feature/base/TimeSpanMenuBase\n * @classtype scheduleMenu\n * @feature\n */\nexport default class ScheduleMenu extends TimeSpanMenuBase {\n    //region Config\n    static get $name() {\n        return 'ScheduleMenu';\n    }\n    static get defaultConfig() {\n        return {\n            type : 'schedule',\n            /**\n             * This is a preconfigured set of items used to create the default context menu.\n             *\n             * The `items` provided by this feature are listed below. These are the predefined property names which you may\n             * configure:\n             *\n             * - `addEvent` Add an event for at the resource and time indicated by the `contextmenu` event.\n             *\n             * To remove existing items, set corresponding keys `null`:\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         scheduleMenu : {\n             *             items : {\n             *                 addEvent : null\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             *\n             * @config {Object<String,MenuItemConfig|Boolean|null>} items\n             */\n            items : null,\n            /**\n             * A function called before displaying the menu that allows manipulations of its items.\n             * Returning `false` from this function prevents the menu being shown.\n             *\n             * ```javascript\n             * features         : {\n             *    scheduleMenu : {\n             *         processItems({ items, date, resourceRecord }) {\n             *            // Add or hide existing items here as needed\n             *            items.myAction = {\n             *                text   : 'Cool action',\n             *                icon   : 'b-fa b-fa-cat',\n             *                onItem : () => console.log(`Clicked on ${resourceRecord.name} at ${date}`),\n             *                weight : 1000 // Move to end\n             *            };\n             *\n             *            if (!resourceRecord.allowAdd) {\n             *                items.addEvent.hidden = true;\n             *            }\n             *        }\n             *    }\n             * },\n             * ```\n             *\n             * @config {Function}\n             * @param {Object} context An object with information about the menu being shown\n             * @param {Scheduler.model.ResourceModel} context.resourceRecord The record representing the current resource\n             * @param {Date} context.date The clicked date\n             * @param {Object<String,MenuItemConfig|Boolean>} context.items An object containing the\n             *   {@link Core.widget.MenuItem menu item} configs keyed by their id\n             * @param {Event} context.event The DOM event object that triggered the show\n             * @returns {Boolean|null} Returning `false` from this function prevents the menu being shown\n             * @preventable\n             */\n            processItems : null\n        };\n    }\n    static get pluginConfig() {\n        const config = super.pluginConfig;\n        config.chain.push('populateScheduleMenu');\n        return config;\n    }\n    //endregion\n    //region Events\n    /**\n     * This event fires on the owning Scheduler or Gantt widget before the context menu is shown for the schedule. Allows manipulation of the items\n     * to show in the same way as in `processItems`. Returning `false` from a listener prevents the menu from\n     * being shown.\n     * @event scheduleMenuBeforeShow\n     * @on-owner\n     * @preventable\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Object<String,MenuItemConfig>} items Menu item configs\n     * @param {Scheduler.model.EventModel} eventRecord Event record for which the menu was triggered\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {Date} date Clicked date, rounded according to viewPreset's settings\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used\n     * @param {HTMLElement} eventElement\n     */\n    /**\n     * This event fires on the owning Scheduler or Gantt widget when an item is selected in the context menu.\n     * @event scheduleMenuItem\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Core.widget.MenuItem} item\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @param {Date} date Clicked date, rounded according to viewPreset's settings\n     * @param {HTMLElement} element\n     */\n    /**\n     * This event fires on the owning Scheduler or Gantt widget after showing the context menu for the schedule.\n     * @event scheduleMenuShow\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Object<String,MenuItemConfig>} items Menu item configs\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @param {Date} date Clicked date, rounded according to viewPreset's settings\n     * @param {HTMLElement} targetElement\n     */\n    //endregion\n    shouldShowMenu(eventParams) {\n        const\n            { client } = this,\n            {\n                targetElement,\n                resourceRecord\n            } = eventParams,\n            isTimeAxisColumn = client.timeAxisSubGridElement.contains(targetElement);\n        return !targetElement.closest(client.eventSelector) && isTimeAxisColumn && !(resourceRecord && resourceRecord.isSpecialRow);\n    }\n    getDataFromEvent(event) {\n        // Process event if it wasn't yet processed\n        if (DomHelper.isDOMEvent(event)) {\n            const\n                { client }     = this,\n                cellData       = client.getCellDataFromEvent?.(event),\n                date           = client.getDateFromDomEvent?.(event, 'floor'),\n                // For vertical mode the resource must be resolved from the event\n                resourceRecord = client.resolveResourceRecord(event) || client.isVertical && client.resourceStore.last;\n            return ObjectHelper.assign(super.getDataFromEvent(event), cellData, { date, resourceRecord });\n        }\n        return event;\n    }\n    populateScheduleMenu({ items, resourceRecord, date }) {\n        const { client } = this;\n        // Menu can work for ResourceHistogram which doesn't have event store\n        if (!client.readOnly && client.eventStore) {\n            items.addEvent = {\n                text     : 'L{SchedulerBase.Add event}',\n                icon     : 'b-icon b-icon-add',\n                disabled : !resourceRecord || resourceRecord.readOnly || !resourceRecord.isWorkingTime(date),\n                weight   : 100,\n                onItem() {\n                    client.createEvent(date, resourceRecord, client.getRowFor(resourceRecord));\n                }\n            };\n        }\n    }\n}\nScheduleMenu.featureClass = '';\nScheduleMenu._$name = 'ScheduleMenu'; GridFeatureManager.registerFeature(ScheduleMenu, true, 'Scheduler');\n"],
  "mappings": "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",
  "names": ["ViewPreset", "Model", "owner", "me", "headers", "parts", "result", "length", "i", "unit", "increment", "multiple", "StringHelper", "IdHelper", "timeResolution", "shiftUnit", "header", "DateHelper", "data", "headerConfig", "columnLinesFor", "mainHeaderLevel", "bottomHeader", "valid", "__publicField", "locale", "days", "months", "interval", "position", "date", "En_default", "LocaleHelper", "PresetStore", "Localizable_default", "Store", "storage", "lhs", "rhs", "leftBottomHeader", "rightBottomHeader", "unitMagnitudes", "id", "args", "presets", "preset", "localePreset", "level", "levelConfig", "localeLevelDateFormat", "options", "presetData", "base", "ObjectHelper", "PresetManager", "value", "start", "end", "cfg", "basePresets", "presetCache", "defaultPresets", "presetAdjustment", "isBase", "baseType", "config", "existingDuplicate", "p", "presetOrId", "pm", "Tick", "TimeSpan", "TimeAxis", "action", "event", "range", "suppressRefresh", "preventThrow", "normalized", "oldConfig", "propName", "viewPresetChanged", "f", "adjusted", "ticks", "count", "startDate", "endDate", "weekStartDay", "startDenominator", "endDenominator", "_a", "resolution", "newStartDate", "newEndDate", "amount", "tries", "fn", "thisObj", "tick", "index", "retVal", "forceAdjust", "relativeToStart", "resolutionUnit", "incr", "relativeTo", "snap", "dt", "day", "startDay", "modifier", "useUnit", "snappedValue", "distanceToWeekStartDay", "toAdd", "nbrMonths", "snappedMonths", "duration", "offset", "snappedDuration", "doCall", "include", "includeUnit", "rule", "from", "to", "stepUnit", "datePart", "axisStartDate", "axisEndDate", "usesExclusion", "intervalEnd", "tickEnd", "isExcluded", "dstDiff", "prev", "_b", "dateMS", "begin", "middle", "tickStart", "startTickIdx", "roundingMethod", "wholeTick", "fraction", "t", "onlyStartEnd", "inclusiveEnd", "axisStart", "axisEnd", "timeSpan", "startMS", "endMS", "startDateMS", "endDateMS", "startTick", "endTick", "iteratorFn", "TimeAxisViewModel", "Events_default", "viewPreset", "timeAxis", "availableSpace", "silent", "forceUpdate", "spaceAvailable", "tickSize", "pos", "headerCells", "durationMs", "respectExclusion", "snapToNextIncluded", "isEnd", "min", "max", "tickChanged", "lengthFactor", "center", "originalHours", "croppedHours", "fractionalHours", "hoursFromCenter", "newHours", "checkDay", "addDays", "fixedCenter", "fractionalDay", "daysFromCenter", "newDay", "allowOutOfRange", "dayWidth", "positionInWeek", "weekStartPosition", "lengthFactorExcl", "hourWidth", "positionInDay", "dayStartPosition", "size", "suppressEvent", "proposedSize", "forceFit", "suppressFit", "timelineUnit", "ratio", "fittingSize", "space", "newTickSize", "useLowestHeader", "getEnd", "linesForLevel", "majorLevel", "levelUnit", "majorUnit", "validMajor", "cells", "l", "headerRowConfig", "align", "headerCellCls", "today", "tickLevel", "createCellContext", "isLast", "isInteriorTick", "cellData", "nextLevel", "r", "tempDate", "TimelineDateMapper_default", "Target", "Base", "x", "coordinate", "local", "ignoreRTL", "xy", "rect", "isHorizontal", "startPos", "endPos", "timeAxisViewModel", "isContinuous", "timelineScroller", "timeAxisOffset", "subGrid", "scrollLeft", "scrollX", "scrollingToCenter", "eventNameMap", "EventHelper", "TimelineDomEvents_default", "schedulerEvents", "BrowserHelper", "eventElement", "timelineContext", "target", "_c", "_d", "_e", "lastPointerEvent", "targetElement", "DomHelper", "pointerEvent", "mouseEvent", "GlobalEvents_default", "context", "oldContext", "domEvent", "cellElement", "DomDataStore", "mouseParams", "tickIndex", "clientY", "type", "isVertical", "foregroundCanvas", "record", "element", "targetCell", "cell", "cellConfig", "contextMenu", "hoveredEvents", "params", "features", "relatedTarget", "eventWrap", "eventInner", "timeSpanRecord", "c1", "c2", "TimelineViewPresets_default", "presetRecord", "presetStore", "oldViewPreset", "lastOpts", "presetChanged", "format", "rtl", "centerDate", "zoomDate", "zoomPosition", "split", "timeAxisCfg", "unitMagnitude", "milliseconds", "targetDate", "viewportSize", "centerCoord", "coord", "TimelineZoomable_default", "e", "ignoreActualWidth", "width", "tickSizeProp", "newPreset", "configuredTickSize", "span", "scrollableViewportSize", "_beforeCollapseState", "eventStore", "needToAdjust", "diffMS", "currLevel", "inc", "msPerPixel", "candidateLevel", "zoomLevel", "levelToZoom", "spanWidth", "unitToZoom", "tickCount", "customWidth", "levels", "currentZoomLevelIndex", "tickWidth", "difference", "zoomContext", "now", "RecurrenceConfirmationPopup", "Popup", "prop", "changeMultipleButton", "changeSingleButton", "cancelButton", "eventRecord", "actionType", "changerFn", "finalizerFn", "firstOccurrence", "occurrence", "isFirst", "RecurringEvents_default", "recurrenceConfirmationPopup", "oldRecurrenceConfirmationPopup", "eventRecords", "assignmentRecords", "as", "recurringEvents", "assignments", "changes", "assignment", "recurringEvent", "callback", "popupOwner", "removeRecord", "shouldFinalize", "recurringEventRecord", "TimelineEventRendering_default", "fillTicks", "margin", "style", "color", "maintainVisibleStart", "defaultScrollOptions", "TimelineScroll_default", "visibleDate", "scrollable", "partner", "setTimeSpanOptions", "TimelineScroller", "centered", "bufferCoef", "leafUnit", "leafIncrement", "topUnit", "topIncrement", "useTop", "snapSize", "snapUnit", "halfSpan", "bufferedTicks", "source", "scrollPos", "clientSize", "requiredSize", "limit", "maxScroll", "newRange", "infiniteScroll", "visibleDateRange", "edgeOffset", "visibleWidth", "direction", "extraScroll", "scrollerViewport", "localCoordinate", "Rectangle", "visibleSpan", "left", "top", "y", "Scroller", "force", "xDelta", "yDelta", "copyProperties", "TimelineState_default", "state", "zoomLevelOptions", "Header", "TimeAxisSubGrid", "SubGrid", "scheduler", "addCls", "height", "oldWidth", "oldHeight", "bodyHeight", "shouldSuspend", "exitTransition", "inRange", "v", "r0", "r1", "isWorkingTime", "d", "wt", "emptyObject", "TimelineBase", "GridBase", "timeZone", "_visibleDateRange", "region", "stickyHeaders", "partneredWith", "currentOrientation", "ResizeMonitor", "firstPaint", "frameCount", "scrollSpeed", "scrollInterval", "timePerFrame", "fps", "scroller", "scrollStart", "startChanged", "endChanged", "totalSize", "oldTickSize", "currentScroll", "visibleStart", "tickSizeChanged", "returnValue", "Collection", "partnerSharedConfig", "configName", "FunctionHelper", "otherScrollable", "ourY", "partners", "columns", "currentStore", "timeAxisColumnIndex", "timeAxisColumnConfig", "isArray", "cols", "col", "was", "timeAxisColumn", "c", "column", "records", "partnerColumn", "partnerChanges", "k", "eventCls", "currentModel", "tavmListeners", "currentTimeAxis", "timeAxisListeners", "hour", "keepDuration", "ta", "mainUnit", "calcEndDate", "diff", "ret", "workingTime", "calcStartDate", "oldAutoAdjust", "oldRect", "newWidth", "partnerSubGrid", "svg", "configs", "forceLayout", "total", "schedulerEl", "fgCanvas", "returnToTop", "reLayoutEvents", "hide", "hideRowHover", "includeSingleAxisMatch", "toTarget", "selectors", "cs", "nbrDecimals", "multiplier", "other", "connected", "initialConnect", "isConfiguring", "field", "VersionHelper", "arrayify", "pickFormat", "formats", "defaultFormat", "Describable_default", "descriptionRenderer", "dateBounds", "dateFormat", "descriptionFormat", "format0", "SchedulerDom_default", "assignmentRecord", "returnWrapper", "checkReleased", "_f", "wrapper", "link", "resourceRecord", "el", "elementOrEvent", "allowReleased", "SchedulerDomEvents_default", "HorizontalLayout", "resource", "events", "HorizontalLayoutStack", "heightRun", "verticalPosition", "eventIndex", "eventRenderData", "group", "isMilestone", "minGap", "closest", "gap", "eventIsMilestone", "rangesIntersect", "range1Start", "range1End", "range2Start", "range2End", "PackMixin_default", "a", "b", "applyClusterFn", "coordProp", "sizeProp", "slot", "firstInCluster", "cluster", "j", "nextSlot", "clusterSize", "slotSize", "inBandSizeProp", "inBandCoordProp", "priorOverlappers", "item", "COORD_PROP", "SIZE_PROP", "overlappers", "e1", "e2", "startIndex", "startEvent", "HorizontalLayoutPack", "SchedulerResourceRendering_default", "row", "parentEventRecord", "resourceMarginObject", "rowHeight", "SchedulerEventRendering_default", "eventLayout", "oldEventLayout", "horizontal", "includeOutside", "renderData", "isEvent", "eventResize", "eventContent", "resizable", "isDirty", "clsListObj", "wrapperClsListObj", "clsList", "DomClassList", "wrapperClsList", "selected", "eventStyle", "eventColor", "hasAnimation", "delayMS", "childContent", "milestoneLabelConfig", "rendererValue", "wrapperCls", "colorProp", "eventData", "name", "old", "classList", "initialAnimation", "mode", "html", "label", "bounds", "alwaysOutside", "engineStoreNames", "ProjectConsumer_default", "_suspendedByRestore", "__privateAdd", "ProjectModel", "project", "oldProject", "projectStoreNames", "projectDataNames", "crudManager", "isCrudManager", "storeName", "dataName", "sharedProject", "store", "projectListeners", "subscriber", "stm", "rawQueue", "__privateSet", "__privateGet", "oldTimeZone", "TimeZoneHelper", "cls", "meta", "projectStores", "storeConfigs", "previousDataName", "listeners", "clsProto", "storeNameCap", "oldStore", "storeProject", "SchedulerStores_default", "isInitialCommit", "isExpand", "ignoreCount", "resourceStore", "resourcesToRepaint", "committingCls", "removingAll", "activeAssignment", "deletingActiveAssignment", "moveTo", "fromEl", "viewport", "fromRect", "fromCenter", "resourceDim", "distanceSort", "d1", "ed1", "d2", "ed2", "rectangle", "vertGap", "horizGap", "timeRanges", "resourceTimeRanges", "resources", "filterFn", "eventsByTick", "SchedulerScroll_default", "eventStart", "eventEnd", "eventIsOutside", "currentTimeSpanRange", "visibleMS", "sign", "AsyncHelper", "resourceRec", "eventRec", "resolve", "rowManager", "initialY", "delta", "counter", "box", "instantScrollOptions", "scrollPromise", "scrollPromise2", "SchedulerRegions_default", "dateConstraints", "includesOutside", "roughly", "SchedulerState_default", "propsToCopy", "EventSelection_default", "selectedCollection", "selection", "deselected", "before", "ArrayHelper", "eventOrAssignment", "preserveSelection", "toRemove", "added", "removed", "updateSelection", "select", "eventAssignHighlightCls", "otherAssignmentRecord", "newAssignments", "selector", "clickedRecord", "highlighted", "dependenciesFeature", "dep", "toWalk", "outgoing", "incoming", "preventDefault", "isArrowKey", "animate100", "EventNavigation_default", "Delayable_default", "navigator", "Navigator", "keyEvent", "firstAssignment", "location", "renderedEvents", "firstResource", "focusEvent", "isGridCellFocus", "navigationEvent", "eventFocus", "destinationCell", "Location", "_focusedCell", "cellSelector", "isDelete", "eventSorter", "resourceEvents", "previousEvent", "rowIdx", "previousAssignment", "nextEvent", "nextAssignment", "targetAssignment", "scrollIntoView", "uiEvent", "skipScrollIntoView", "assignmentEl", "activeItem", "previousActiveItem", "TransactionalFeatureMixin_default", "AttachToProjectMixin_default", "projectHolder", "releaseEventActions", "renderEventActions", "MAX_WIDTH", "heightEventSorter", "chronoFields", "getStartEnd", "useEnd", "fieldName", "useEventBuffer", "hasBatchedChange", "HorizontalRendering", "stretch", "timeAxisSubGridElement", "eventRegion", "taStart", "taEnd", "startX", "endX", "rowRecord", "bottom", "resourceData", "approx", "boxHeight", "rowBox", "absoluteTop", "eventNode", "toDrawOnDataReady", "isCalculated", "toDrawOnProjectRefresh", "assignmentStore", "replaced", "resourceIds", "oldAssignment", "newAssignment", "modified", "isResourceTimeRange", "renderedEventResources", "newEvent", "allChrono", "dateChanges", "eventDragCreate", "layoutType", "lockLayout", "barMargin", "contentHeight", "eventFilter", "useCurrent", "layoutHandler", "nbrOfBandsRequired", "trigger", "dragData", "add", "useWrapper", "rows", "scrollBuffer", "renderAll", "timeAxisSubGrid", "returnEnd", "ids", "transition", "noRows", "bandIndex", "topFraction", "heightFraction", "domConfig", "dataset", "startA", "endA", "startB", "endB", "nameA", "nameB", "startDateField", "endDateField", "durationMS", "pxPerMinute", "diamondSize", "diamondMS", "elementStartMS", "elementEndMS", "elementDurationMS", "preamble", "postamble", "isBatchUpdating", "timespanStart", "timespanEnd", "viewStartMS", "viewEndMS", "msValues", "startsOutsideView", "endsOutsideView", "durationMinutes", "clippedStart", "clippedEnd", "distanceToTimeAxisEnd", "overflowDurationMS", "overflowDurationMinutes", "resourceMarginStart", "allEvents", "eventsData", "eventBox", "layoutEventData", "bandsRequired", "syncId", "eventElementConfig", "elementConfig", "recordOrRow", "draw", "resourceLayout", "right", "bufferSize", "labels", "eventBuffer", "usesLabels", "reusableDOMConfigs", "eventDOMConfigs", "useLeft", "useRight", "layout", "prevDomConfig", "rowMap", "verticalBufferSize", "visibleEventDOMConfigs", "bodyTop", "viewTop", "viewBottom", "unbuffered", "unmanagedSize", "DomSync", "lastDomConfig", "jsx", "reactComponent", "isRelease", "isRender", "recordsOrIds", "resourceId", "cached", "clearDom", "clearLayoutCache", "layouts", "child", "VerticalLayout", "columnWidth", "resourceMarginTotal", "columnIndex", "tplData", "clusterIndex", "leftFactor", "packColumnCount", "packColumnIndex", "availableWidth", "VerticalRendering", "resourceColumns", "coords", "totalWidth", "eventId", "startY", "endY", "isAssign", "changeCount", "resourceRecords", "allResourceRecords", "firstIndex", "first", "last", "withBuffer", "resourceColumnWidth", "scrollWidth", "resourceBufferSize", "viewportStart", "viewportEnd", "bottomDate", "topDate", "variableColumnWidths", "instanceMeta", "resourceWidth", "cacheKey", "cache", "resourceIndex", "layoutData", "toLayout", "eventResources", "topDateMS", "bottomDateMS", "resourceEntry", "className", "lastResource", "syncConfigs", "featureDomConfigs", "resourceMap", "eventMap", "isLastLevel", "isLastCell", "TimeAxisBase", "Widget", "client", "sizeProperty", "featureHeaderConfigs", "cellConfigs", "stickyHeader", "rebuild", "columnConfig", "oldLevelsCount", "sum", "parentElement", "HorizontalTimeAxis", "ResourceHeader", "show", "AvatarRendering", "fillWidth", "fitWidth", "imageName", "configuredColumnWidth", "fit", "useWidth", "shouldAnimate", "groupField", "currentGroup", "groupRecord", "groupChildren", "groupLeft", "groupWidth", "imageUrl", "resourceCell", "TimeAxisColumn", "WidgetColumn", "grid", "viewModel", "internal", "ColumnStore", "VerticalTimeAxis", "VerticalTimeAxisColumn", "Column", "stores", "inlineProperties", "CurrentConfig_default", "descriptionFormats", "SchedulerBase", "CrudManagerView_default", "CrudManager", "scrollTop", "eventEdit", "taskEdit", "simpleEventEdit", "enableEventAnimations", "hasEventEditor", "useEventModelDefaults", "defaultDuration", "defaultDurationUnit", "excludeEvent", "useTransitions", "lastDate", "currentDate", "newDate", "eventRect", "EventColorPicker", "ColorPicker", "ClockTemplate", "hourIndicatorEl", "minuteIndicatorEl", "unitLessThanDay", "formatContainsHourInfo", "template", "TaskEditStm_default", "stmCapture", "startTransaction", "commitOrReject", "stmInitiallyDisabled", "stmInitiallyAutoRecord", "promise", "TimeSpanMenuBase", "ContextMenuBase", "RecurrenceFrequencyCombo", "Combo", "RecurrenceDaysCombo", "allDaysValueAsArray", "allDaysValue", "dayNames", "text", "RecurrenceDayRuleEncoder", "RecurrenceDaysButtonGroup", "ButtonGroup", "RecurrenceMonthDaysButtonGroup", "items", "RecurrenceMonthsButtonGroup", "RecurrenceStopConditionCombo", "recurrence", "RecurrencePositionsCombo", "RecurrenceEditorPanel", "Panel", "widgetConfig", "frequencyField", "daysButtonField", "monthDaysButtonField", "monthsButtonField", "monthDaysRadioField", "positionAndDayRadioField", "stopRecurrenceField", "values", "w", "countField", "checked", "daysCombo", "positionsCombo", "widget", "frequency", "oldValue", "intervalField", "widgetMap", "EventColorField", "ColorField", "EventMenu", "eventParams", "Objects", "menu", "revertTarget", "GridFeatureManager", "ScheduleMenu", "isTimeAxisColumn"]
}
