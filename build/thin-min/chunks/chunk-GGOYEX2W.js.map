{
  "version": 3,
  "sources": ["../../../../Grid/lib/Grid/util/Location.js", "../../../../Grid/lib/Grid/column/Column.js", "../../../../Grid/lib/Grid/data/ColumnStore.js", "../../../../Grid/lib/Grid/column/WidgetColumn.js", "../../../../Grid/lib/Grid/column/CheckColumn.js", "../../../../Grid/lib/Grid/column/RowNumberColumn.js", "../../../../Grid/lib/Grid/feature/base/CopyPasteBase.js", "../../../../Grid/lib/Grid/feature/GridFeatureManager.js", "../../../../Grid/lib/Grid/feature/CellEdit.js", "../../../../Grid/lib/Grid/feature/CellMenu.js", "../../../../Grid/lib/Grid/feature/ColumnDragToolbar.js", "../../../../Grid/lib/Grid/feature/ColumnPicker.js", "../../../../Grid/lib/Grid/feature/ColumnReorder.js", "../../../../Grid/lib/Grid/feature/ColumnResize.js", "../../../../Grid/lib/Grid/widget/GridFieldFilterPicker.js", "../../../../Grid/lib/Grid/widget/GridFieldFilterPickerGroup.js", "../../../../Grid/lib/Grid/feature/Filter.js", "../../../../Grid/lib/Grid/feature/FilterBar.js", "../../../../Grid/lib/Grid/feature/Group.js", "../../../../Grid/lib/Grid/feature/HeaderMenu.js", "../../../../Grid/lib/Grid/feature/RegionResize.js", "../../../../Grid/lib/Grid/feature/Sort.js", "../../../../Grid/lib/Grid/feature/Stripe.js", "../../../../Grid/lib/Grid/row/Row.js", "../../../../Grid/lib/Grid/view/Bar.js", "../../../../Grid/lib/Grid/view/Footer.js", "../../../../Grid/lib/Grid/row/RowManager.js", "../../../../Grid/lib/Grid/view/Header.js", "../../../../Grid/lib/Grid/view/mixin/GridElementEvents.js", "../../../../Grid/lib/Grid/view/mixin/GridFeatures.js", "../../../../Grid/lib/Grid/view/mixin/GridResponsive.js", "../../../../Grid/lib/Grid/view/mixin/GridSelection.js", "../../../../Grid/lib/Grid/view/mixin/GridState.js", "../../../../Grid/lib/Grid/util/SubGridScroller.js", "../../../../Grid/lib/Grid/view/SubGrid.js", "../../../../Grid/lib/Grid/view/mixin/GridSubGrids.js", "../../../../Grid/lib/Grid/util/GridScroller.js", "../../../../Grid/lib/Grid/view/mixin/GridNavigation.js", "../../../../Grid/lib/Grid/localization/En.js", "../../../../Grid/lib/Grid/view/GridBase.js"],
  "sourcesContent": ["import DomHelper from '../../Core/helper/DomHelper.js';\nimport Widget from '../../Core/widget/Widget.js';\n/**\n * @module Grid/util/Location\n */\n/**\n * This class encapsulates a reference to a specific navigable grid location.\n *\n * This encapsulates a grid cell based upon the record and column, but in addition, it could represent\n * an actionable location *within a cell** if the {@link #property-target} is not the grid cell in\n * question.\n *\n * A Location is immutable. That is, once instantiated, the record and column which it references\n * cannot be changed. The {@link #function-move} method returns a new instance.\n *\n * A `Location` that encapsulates a cell within the body of a grid will have the following\n * read-only properties:\n *\n *  - grid        : `Grid` The Grid that owns the Location.\n *  - record      : `Model` The record of the row that owns the Location. (`null` if the header).\n *  - rowIndex    : `Number` The zero-based index of the row that owns the Location. (-1 means the header).\n *  - column      : `Column` The Column that owns the Location.\n *  - columnIndex : `Number` The zero-based index of the column that owns the Location.\n *  - cell        : `HTMLElement` The referenced cell element.\n *  - target      : `HTMLElement` The focusable element. This may be the cell, or a child of the cell.\n *\n * If the location is a column *header*, the `record` will be `null` and the `rowIndex` will be `-1`.\n *\n */\nexport default class Location {\n    /**\n     * The grid which this Location references.\n     * @config {Grid.view.Grid} grid\n     */\n    /**\n     * The record which this Location references. (unless {@link #config-rowIndex} is used to configure)\n     * @config {Core.data.Model} record\n     */\n    /**\n     *\n     * The row index which this Location references. (unless {@link #config-record} is used to configure).\n     *\n     * `-1` means the header row, in which case the {@link #config-record} will be `null`.\n     * @config {Number} rowIndex\n     */\n    /**\n     * The Column which this location references. (unless {@link #config-columnIndex} or {@link #config-columnId} is used to configure)\n     * @config {Grid.column.Column} column\n     */\n    /**\n     * The column id which this location references. (unless {@link #config-column} or {@link #config-columnIndex} is used to configure)\n     * @config {String|Number} columnId\n     */\n    /**\n     * The column index which this location references. (unless {@link #config-column} or {@link #config-columnId} is used to configure)\n     * @config {Number} columnIndex\n     */\n    /**\n     * The field of the column index which this location references. (unless another column identifier is used to configure)\n     * @config {String} field\n     */\n    /**\n     * Initializes a new Location.\n     * @param {LocationConfig|HTMLElement} location A grid location specifier. This may be:\n     *  * An element inside a grid cell or a grid cell.\n     *  * An object identifying a cell location using the following properties:\n     *    * grid\n     *    * record\n     *    * rowIndex\n     *    * column\n     *    * columnIndex\n     * @function constructor\n     */\n    constructor(location) {\n        // Private usage of init means that we can create an un attached Location\n        // The move method does this.\n        if (location) {\n            // They passed us a Location, so they already know where to go.\n            if (location.isLocation) {\n                return location;\n            }\n            // Passed a DOM node.\n            if (location.nodeType === Node.ELEMENT_NODE) {\n                const\n                    grid = Widget.fromElement(location, 'gridbase'),\n                    cell = grid && location.closest(grid.focusableSelector);\n                // We are targeted on, or within a cell.\n                if (cell) {\n                    const { dataset } = cell.parentNode;\n                    this.init({\n                        grid,\n                        // A .b-grid-row will have a data-index\n                        // If it' a column header, we use rowIndex -1\n                        rowIndex : grid.store.includes(dataset.id) ? grid.store.indexOf(dataset.id) : (dataset.index || -1),\n                        columnId : cell.dataset.columnId\n                    });\n                    this.initialTarget = location;\n                }\n            }\n            else {\n                this.init(location);\n            }\n        }\n    }\n    init(config) {\n        const me = this;\n        const\n            grid               = me.grid = config.grid,\n            { store, columns } = grid,\n            { visibleColumns } = columns;\n        // If we have a target. This is usually only for actionable locations.\n        if (config.target) {\n            me.actionTargets = [me._target = config.target];\n        }\n        // Determine our record and rowIndex\n        if (config.record) {\n            me._id = config.record.id;\n        }\n        else if ('id' in config) {\n            me._id = config.id;\n            // Null means that the Location is in the grid header, so rowIndex -1\n            if (config.id == null) {\n                me._rowIndex = -1;\n            }\n        }\n        else {\n            const rowIndex = !isNaN(config.row) ? config.row : !isNaN(config.rowIndex) ? config.rowIndex : NaN;\n            me._rowIndex = Math.max(Math.min(Number(rowIndex), store.count - 1), grid.hideHeaders ? 0 : -1);\n            me._id       = store.getAt(me._rowIndex)?.id;\n        }\n        if (!('_rowIndex' in me)) {\n            me._rowIndex = store.indexOf(me.id);\n        }\n        // Cache value that we use now. We do not hold a reference to a record\n        me.isSpecialRow = me.record?.isSpecialRow;\n        // Determine our column and columnIndex\n        if ('columnId' in config) {\n            me._column = columns.getById(config.columnId);\n        }\n        else if ('field' in config) {\n            me._column = columns.get(config.field);\n        }\n        else {\n            const columnIndex = !isNaN(config.column) ? config.column : !isNaN(config.columnIndex) ? config.columnIndex : NaN;\n            if (!isNaN(columnIndex)) {\n                me._columnIndex = Math.min(Number(columnIndex), visibleColumns.length - 1);\n                me._column      = visibleColumns[me._columnIndex];\n            }\n            // Fall back to using 'column' property either as index or the Column.\n            // If no column property, use column zero.\n            else {\n                me._column = ('column' in config) ? isNaN(config.column) ? config.column : visibleColumns[config.column] : visibleColumns[0];\n            }\n        }\n        if (!('_columnIndex' in me)) {\n            me._columnIndex = visibleColumns.indexOf(me._column);\n        }\n    }\n    // Class identity indicator. Usually added by extending Base, but we don't do that for perf.\n    get isLocation() {\n        return true;\n    }\n    equals(other, shallow = false) {\n        const me = this;\n        return other?.isLocation &&\n            other.grid === me.grid &&\n            (\n                // For a more performant check, use the shallow param\n                shallow ? me.id === other.id && me._column === other._column\n                    : (other.record === me.record && other.column === me.column && other.target === me.target)\n            );\n    }\n    /**\n     * Yields the row index of this location.\n     * @property {Number}\n     * @readonly\n     */\n    get rowIndex() {\n        const\n            { _id }   = this,\n            { store } = this.grid;\n        // Return the up to date row index for our record\n        return store.includes(_id) ? store.indexOf(_id) : Math.min(this._rowIndex, store.count - 1);\n    }\n    /**\n     * Used by GridNavigation.\n     * @private\n     */\n    get visibleRowIndex() {\n        const\n            { rowManager } = this.grid,\n            { rowIndex }   = this;\n        return rowIndex === -1 ? rowIndex : Math.max(Math.min(rowIndex, rowManager.lastFullyVisibleTow.dataIndex), rowManager.firstFullyVisibleTow.dataIndex);\n    }\n    /**\n     * Yields `true` if the cell and row are selectable.\n     *\n     * That is if the record is present in the grid's store and it's not a group summary or group header record.\n     * @property {Boolean}\n     * @readonly\n     */\n    get isSelectable() {\n        return this.grid.store.includes(this._id) && !this.isSpecialRow;\n    }\n    get record() {\n        // -1 means the header row\n        if (this._rowIndex > -1) {\n            const { store } = this.grid;\n            // Location's record no longer in store; fall back to record at same index.\n            if (!store.includes(this._id)) {\n                return store.getAt(this._rowIndex);\n            }\n            return store.getById(this._id);\n        }\n    }\n    get id() {\n        return this._id;\n    }\n    get column() {\n        const { visibleColumns } = this.grid.columns;\n        // Location's column no longer visible; fall back to column at same index.\n        if (!visibleColumns?.includes(this._column)) {\n            return visibleColumns?.[this.columnIndex];\n        }\n        return this._column;\n    }\n    get columnId() {\n        return this.column?.id;\n    }\n    get columnIndex() {\n        return Math.min(this._columnIndex, this.grid.columns.visibleColumns?.length - 1);\n    }\n    /**\n     * Returns a __*new *__ `Location` instance having moved from the current location in the\n     * mode specified.\n     * @param {Number} where Where to move from this Location. May be:\n     *\n     *  - `Location.UP`\n     *  - `Location.NEXT_CELL`\n     *  - `Location.DOWN`\n     *  - `Location.PREV_CELL`\n     *  - `Location.FIRST_COLUMN`\n     *  - `Location.LAST_COLUMN`\n     *  - `Location.FIRST_CELL`\n     *  - `Location.LAST_CELL`\n     *  - `Location.PREV_PAGE`\n     *  - `Location.NEXT_PAGE`\n     * @returns {Grid.util.Location} A Location object encapsulating the target location.\n     */\n    move(where) {\n        const\n            me        = this,\n            {\n                record,\n                column,\n                grid\n            }         = me,\n            { store } = grid,\n            columns   = grid.columns.visibleColumns,\n            result    = new Location();\n        let rowIndex    = store.includes(record) ? store.indexOf(record) : me.rowIndex,\n            columnIndex = columns.includes(column) ? columns.indexOf(column) : me.columnIndex;\n        const\n            rowMin        = grid.hideHeaders ? 0 : -1,\n            rowMax        = store.count - 1,\n            colMax        = columns.length - 1,\n            atFirstRow    = rowIndex === rowMin,\n            atLastRow     = rowIndex === rowMax,\n            atFirstColumn = columnIndex === 0,\n            atLastColumn  = columnIndex === colMax;\n        switch (where) {\n            case Location.PREV_CELL:\n                if (atFirstColumn) {\n                    if (!atFirstRow) {\n                        columnIndex = colMax;\n                        rowIndex--;\n                    }\n                }\n                else {\n                    columnIndex--;\n                }\n                break;\n            case Location.NEXT_CELL:\n                if (atLastColumn) {\n                    if (!atLastRow) {\n                        columnIndex = 0;\n                        rowIndex++;\n                    }\n                }\n                else {\n                    columnIndex++;\n                }\n                break;\n            case Location.UP:\n                if (!atFirstRow) {\n                    rowIndex--;\n                }\n                break;\n            case Location.DOWN:\n                if (!atLastRow) {\n                    // From the col header, we drop to the topmost fully visible row.\n                    if (rowIndex === -1) {\n                        rowIndex = grid.rowManager.firstFullyVisibleRow.dataIndex;\n                    }\n                    else {\n                        rowIndex++;\n                    }\n                }\n                break;\n            case Location.FIRST_COLUMN:\n                columnIndex = 0;\n                break;\n            case Location.LAST_COLUMN:\n                columnIndex = colMax;\n                break;\n            case Location.FIRST_CELL:\n                rowIndex    = rowMin;\n                columnIndex = 0;\n                break;\n            case Location.LAST_CELL:\n                rowIndex    = rowMax;\n                columnIndex = colMax;\n                break;\n            case Location.PREV_PAGE:\n                rowIndex = Math.max(rowMin, rowIndex - Math.floor(grid.scrollable.clientHeight / grid.rowHeight));\n                break;\n            case Location.NEXT_PAGE:\n                rowIndex = Math.min(rowMax, rowIndex + Math.floor(grid.scrollable.clientHeight / grid.rowHeight));\n                break;\n        }\n        // Set the calculated coordinates in the result.\n        result.init({\n            grid,\n            rowIndex,\n            columnIndex\n        });\n        return result;\n    }\n    /**\n     * The cell DOM element which this Location references.\n     * @property {HTMLElement}\n     * @readonly\n     */\n    get cell() {\n        const\n            me = this,\n            {\n                grid,\n                id,\n                _cell\n            }  = me;\n        // Property value set\n        if (_cell) {\n            return _cell;\n        }\n        // On a header cell\n        if (id == null) {\n            return grid.columns.getById(me.columnId)?.element;\n        }\n        else {\n            const { row } = me;\n            if (row) {\n                return row.getCell(me.columnId) || row.getCell(grid.columns.getAt(me.columnIndex)?.id);\n            }\n        }\n    }\n    get row() {\n        // Use our record ID by preference, but fall back to our row index if not present\n        return this.grid.getRowById(this.id) || this.grid.getRow(this.rowIndex);\n    }\n    /**\n     * The DOM element which encapsulates the focusable target of this Location.\n     *\n     * This is usually the {@link #property-cell}, but if this is an actionable location, this\n     * may be another DOM element within the cell.\n     * @property {HTMLElement}\n     * @readonly\n     */\n    get target() {\n        const\n            { cell, _target }   = this,\n            { focusableFinder } = this.grid;\n        // We might be asked for our focusElement before we're fully rendered and painted.\n        if (cell) {\n            // Location was created in disableActionable mode with the target\n            // explicitly directed to the cell.\n            if (_target) {\n                return _target;\n            }\n            focusableFinder.currentNode = this.grid.focusableFinderCell = cell;\n            return focusableFinder.nextNode() || cell;\n        }\n    }\n    /**\n     * This property is `true` if the focus target is not the cell itself.\n     * @property {Boolean}\n     * @readonly\n     */\n    get isActionable() {\n        const\n            { cell, _target } = this,\n            activeEl          = cell && DomHelper.getActiveElement(cell),\n            containsFocus     = activeEl && cell.compareDocumentPosition(activeEl) & Node.DOCUMENT_POSITION_CONTAINED_BY;\n        // The actual target may be inside the cell, or just positioned to *appear* inside the cell\n        // such as event/task rendering.\n        return Boolean(containsFocus || (_target && _target !== this.cell));\n    }\n    /**\n     * This property is `true` if this location represents a column header.\n     * @property {Boolean}\n     * @readonly\n     */\n    get isColumnHeader() {\n        return this.cell && this.rowIndex === -1;\n    }\n    /**\n     * This property is `true` if this location represents a cell in the grid body.\n     * @property {Boolean}\n     * @readonly\n     */\n    get isCell() {\n        return this.cell && this.record;\n    }\n}\nLocation.UP           = 1;\nLocation.NEXT_CELL    = 2;\nLocation.DOWN         = 3;\nLocation.PREV_CELL    = 4;\nLocation.FIRST_COLUMN = 5;\nLocation.LAST_COLUMN  = 6;\nLocation.FIRST_CELL   = 7;\nLocation.LAST_CELL    = 8;\nLocation.PREV_PAGE    = 9;\nLocation.NEXT_PAGE    = 10;\nLocation._$name = 'Location';", "import Model from '../../Core/data/Model.js';\nimport Localizable from '../../Core/localization/Localizable.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport Events from '../../Core/mixin/Events.js';\nimport Widget from '../../Core/widget/Widget.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport Config from '../../Core/Config.js';\nimport Location from '../util/Location.js';\n/**\n * @module Grid/column/Column\n */\nconst validWidth = (value) => ((typeof value === 'number') || value?.endsWith('px'));\n/**\n * The base class for all other grid column types, used if no type is specified on a column.\n *\n * Default editor is a {@link Core.widget.TextField}.\n *\n * ```javascript\n * const grid = new Grid({\n *   columns : [{\n *     field : 'name',\n *     text  : 'Name'\n *   }, {\n *     text  : 'Hobby',\n *     field : 'others.hobby', // reading nested field data\n *   }, {\n *     type  : 'number', // Will use NumberColumn\n *     field : 'age',\n *     text  : 'Age'\n *   }]\n * });\n * ```\n *\n * ## Column types\n *\n * Grid ships with multiple different column types. Which type to use for a column is specified by the `type` config.\n * The built-in types are:\n *\n * * {@link Grid.column.ActionColumn action} - displays actions (clickable icons) in the cell.\n * * {@link Grid.column.AggregateColumn aggregate} - a column, which, when used as part of a Tree, aggregates the values\n *   of this column's descendants using a configured function which defaults to `sum`.\n * * {@link Grid.column.CheckColumn check} - displays a checkbox in the cell.\n * * {@link Grid.column.DateColumn date} - displays a date in the specified format.\n * * {@link Grid.column.NumberColumn number} - a column for showing/editing numbers.\n * * {@link Grid.column.PercentColumn percent} - displays a basic progress bar.\n * * {@link Grid.column.RatingColumn rating} - displays a star rating.\n * * {@link Grid.column.RowNumberColumn rownumber} - displays the row number in each cell.\n * * {@link Grid.column.TemplateColumn template} - uses a template for cell content.\n * * {@link Grid.column.TimeColumn time} - displays a time in the specified format.\n * * {@link Grid.column.TreeColumn tree} - displays a tree structure when using the {@link Grid.feature.Tree tree}\n *   feature.\n * * {@link Grid.column.WidgetColumn widget} - displays widgets in the cells.\n *\n * ## Grouped columns / headers\n *\n * You can group headers by defining parent and children columns. A group can be dragged as a whole, or users can drag\n * individual columns between groups. The same applies to column visibility using the column picker in the header menu,\n * a group can be toggled as a whole or each column individually.\n *\n * ```javascript\n * const grid = new Grid({\n *     {\n *             text     : 'Parent',\n *             children : [\n *                 { text : 'Child 1', field : 'field1', flex : 1 },\n *                 { text : 'Child 2', field : 'field2', flex : 1 }\n *             ]\n *         },\n *         ...\n * }\n * ```\n *\n * {@inlineexample Grid/column/ColumnGrouped.js}\n *\n * ## Collapsible columns\n *\n * By configuring a parent column with `collapsible: true` it is made collapsible. When collapsing all child columns\n * except the first one are hidden. This behaviour is configurable using the {@link #config-collapseMode} config. To\n * make a column start collapsed, set the {@link #config-collapsed} config to `true`.\n *\n * {@inlineexample Grid/column/ColumnCollapse.js}\n *\n * ## Cell renderers\n *\n * You can affect the contents and styling of cells in a column using a\n * {@link Grid.column.Column#config-renderer} function.\n *\n * ```javascript\n * const grid = new Grid({\n *   columns : [\n *   ...\n *     {\n *       field      : 'approved',\n *       text       : 'Approved',\n *       htmlEncode : false, // allow to use HTML code\n *       renderer({ value }) {\n *         return value === true ? '<b>Yes</b>' : '<i>No</i>';\n *       }\n *     }\n *     ...\n *     ]\n * });\n * ```\n *\n * ## Menus\n *\n * You can add custom items to the context menu for a columns header and for its cells, using\n * {@link Grid.column.Column#config-headerMenuItems} and {@link Grid.column.Column#config-cellMenuItems}. Here is an\n * example:\n *\n * ```javascript\n * const grid = new Grid({\n *   columns : [\n *     ...\n *     {\n *       type  : 'number',\n *       field : 'age',\n *       text  : 'Age',\n *       headerMenuItems: [{\n *           text : 'My unique header item',\n *           icon : 'b-fa b-fa-paw',\n *           onItem() { console.log('item clicked'); }\n *       }],\n *       cellMenuItems: [{\n *           text : 'My unique cell item',\n *           icon : 'b-fa b-fa-plus',\n *           onItem() { console.log('item clicked'); }\n *       }]\n *     }\n *   ...\n *   ]\n * });\n * ```\n *\n * @extends Core/data/Model\n * @classtype column\n * @mixes Core/mixin/Events\n * @mixes Core/localization/Localizable\n * @column\n */\nexport default class Column extends Model.mixin(Events, Localizable) {\n    static $name =  'Column';\n    /**\n     * Column name alias which you can use in the `columns` array of a Grid.\n     *\n     * ```javascript\n     * class MyColumn extends Column {\n     *     static get type() {\n     *        return 'mycolumn';\n     *     }\n     * }\n     * ```\n     *\n     * ```javascript\n     * const grid = new Grid({\n     *    columns : [\n     *       { type : 'mycolumn', text : 'The column', field : 'someField', flex : 1 }\n     *    ]\n     * });\n     * ```\n     *\n     * @static\n     * @member {String} type\n     */\n    static type = 'column';\n    //region Config\n    /**\n     * Default settings for the column, applied in constructor. None by default, override in subclass.\n     * @member {Object} defaults\n     * @returns {Object}\n     * @readonly\n     */\n    static get fields() {\n        /**\n         * @hideFields readOnly\n         */\n        return [\n            //region Common\n            'type',\n            /**\n             * Header text\n             * @prp {String} text\n             * @category Common\n             */\n            'text',\n            /**\n             * The {@link Core.data.field.DataField#config-name} of the {@link Core.data.Model data model} field to\n             * read a cells value from.\n             *\n             * Also accepts dot notation to read nested or related data, for example `'address.city'`.\n             *\n             * @prp {String} field\n             * @readonly\n             * @category Common\n             */\n            'field',\n            // NOTE: This is duplicated in WidgetColumn and partly in TreeColumn so remember to change there too if\n            // changing the signature of this function\n            /**\n             * Renderer function, used to format and style the content displayed in the cell. Return the cell text you\n             * want to display. Can also affect other aspects of the cell, such as styling.\n             *\n             * **NOTE:** If you mutate `cellElement`, and you want to prevent cell content from being reset during\n             * rendering, please return `undefined` from the renderer (or just omit the `return` statement) and make\n             * sure that the {@link #config-alwaysClearCell} config is set to `false`.\n             *\n             * ```javascript\n             * new Grid({\n             *     columns : [\n             *         // Returns an empty string if status field value is undefined\n             *         { text : 'Status', renderer : ({ record }) => record.status ?? '' },\n             *\n             *         // From Grid v6.0 there is no need for the undefined check\n             *         // { text : 'Status', renderer : ({ record }) => record.status }\n             *     ]\n             * });\n             * ```\n             *\n             * You can also return a {@link Core.helper.DomHelper#typedef-DomConfig} object describing the markup\n             * ```javascript\n             * new Grid({\n             *     columns : [\n             *         {\n             *              text : 'Status',\n             *              renderer : ({ record }) => {\n             *                  return {\n             *                      class : 'myClass',\n             *                      children : [\n             *                          {\n             *                              tag : 'i',\n             *                              class : 'fa fa-pen'\n             *                          },\n             *                          {\n             *                              tag : 'span',\n             *                              html : record.name\n             *                          }\n             *                      ]\n             *                  };\n             *              }\n             *         }\n             *     ]\n             * });\n             * ```\n             *\n             * You can modify the row element too from inside a renderer to add custom CSS classes:\n             *\n             * ```javascript\n             * new Grid({\n             *     columns : [\n             *         {\n             *             text     : 'Name',\n             *             renderer : ({ record, row }) => {\n             *                // Add special CSS class to new rows that have not yet been saved\n             *               row.cls.newRow = record.isPhantom;\n             *\n             *               return record.name;\n             *         }\n             *     ]\n             * });\n             * ```\n             *\n             * @config {Function} renderer\n             * @param {Object} renderData Object containing renderer parameters\n             * @param {HTMLElement} renderData.cellElement Cell element, for adding CSS classes, styling etc. Can be `null` in case of export\n             * @param {*} renderData.value Value to be displayed in the cell\n             * @param {Core.data.Model} renderData.record Record for the row\n             * @param {Grid.column.Column} renderData.column This column\n             * @param {Grid.view.Grid} renderData.grid This grid\n             * @param {Grid.row.Row} renderData.row Row object. Can be null in case of export.\n             *   Use the {@link Grid.row.Row#function-assignCls row's API} to manipulate CSS class names.\n             * @param {Object} renderData.size Set `size.height` to specify the desired row height for the current\n             *   row. Largest specified height is used, falling back to configured {@link Grid/view/Grid#config-rowHeight}\n             *   in case none is specified. Can be null in case of export\n             * @param {Number} renderData.size.height Set this to request a certain row height\n             * @param {Number} renderData.size.configuredHeight Row height that will be used if none is requested\n             * @param {Boolean} renderData.isExport True if record is being exported to allow special handling during export.\n             * @param {Boolean} renderData.isMeasuring True if the column is being measured for a `resizeToFitContent` call.\n             *   In which case an advanced renderer might need to take different actions.\n             * @returns {String|DomConfig|DomConfig[]|null}\n             *\n             * @category Rendering\n             */\n            'renderer',\n            //'reactiveRenderer',\n            /**\n             * Column width. If value is Number then width is in pixels\n             * @config {Number|String} width\n             * @category Common\n             */\n            'width',\n            /**\n             * Column width as a flex weight. All columns with flex specified divide the available space (after\n             * subtracting fixed widths) between them according to the flex value. Columns that have `flex : 2` will be\n             * twice as wide as those with `flex : 1` (and so on)\n             * @prp {Number|String} flex\n             * @category Common\n             */\n            'flex',\n            /**\n             * This config sizes a column to fits its content. It is used instead of `width` or `flex`.\n             *\n             * This config requires the {@link Grid.feature.ColumnAutoWidth} feature which responds to changes in the\n             * grid's store and synchronizes the widths' of all `autoWidth` columns.\n             *\n             * If this config is not a Boolean value, it is passed as the only argument to the `resizeToFitContent`\n             * method to constrain the column's width.\n             *\n             * @config {Boolean|Number|Number[]} autoWidth\n             * @category Common\n             */\n            'autoWidth',\n            /**\n             * This config enables automatic height for all cells in this column. It is achieved by measuring the height\n             * a cell after rendering it to DOM, and then sizing the row using that height (if it is greater than other\n             * heights used for the row).\n             *\n             * Heads up if you render your Grid on page load, if measurement happens before the font you are using is\n             * loaded you might get slightly incorrect heights. For browsers that support it we detect that\n             * and remeasure when fonts are available.\n             *\n             * **NOTE:** Enabling this config comes with a pretty big performance hit. To maintain good performance,\n             * we recommend not using it. You can still set the height of individual rows manually, either through\n             * {@link Grid.data.GridRowModel#field-rowHeight data} or via {@link #config-renderer renderers}.\n             *\n             * Also note that this setting only works fully as intended with non-flex columns.\n             *\n             * Rows will always be at least {@link Grid.view.Grid#config-rowHeight} pixels tall\n             * even if an autoHeight cell contains no data.\n             *\n             * Manually setting a height from a {@link #config-renderer} in this column will take precedence over this\n             * config.\n             *\n             * @config {Boolean} autoHeight\n             * @category Common\n             */\n            'autoHeight',\n            /**\n             * Mode to use when measuring the contents of this column in calls to {@link #function-resizeToFitContent}.\n             * Available modes are:\n             *\n             * * 'exact'       - Most precise, renders and measures all cells (Default, slowest)\n             * * 'textContent' - Renders all cells but only measures the one with the longest `textContent`\n             * * 'value'       - Renders and measures only the cell with the longest data (Fastest)\n             * * 'none'/falsy  - Resize to fit content not allowed, a call does nothing\n             *\n             * @config {'exact'|'textContent'|'value'|'none'|null} fitMode\n             * @default 'exact'\n             * @category Common\n             */\n            { name : 'fitMode', defaultValue : 'exact' },\n            //endregion\n            //region Interaction\n            /**\n             * Set this to `true` to not allow any type of editing in this column.\n             * @prp {Boolean} readOnly\n             */\n            'readOnly',\n            /**\n             * A config object used to create the input field which will be used for editing cells in the\n             * column. Used when {@link Grid.feature.CellEdit} feature is enabled. The Editor refers to\n             * {@link #config-field} for a data source.\n             *\n             * Configure this as `false` or `null` to prevent cell editing in this column.\n             *\n             * All subclasses of {@link Core.widget.Field} can be used as editors. The most popular are:\n             * - {@link Core.widget.TextField}\n             * - {@link Core.widget.NumberField}\n             * - {@link Core.widget.DateField}\n             * - {@link Core.widget.TimeField}\n             * - {@link Core.widget.Combo}\n             *\n             * If record has method set + capitalized field, method will be called, e.g. if record has method named\n             * `setFoobar` and the {@link #config-field} is `foobar`, then instead of `record.foobar = value`,\n             * `record.setFoobar(value)` will be called.\n             *\n             * `Function` may be used for React application parameter for using JSX components as editors.\n             *\n             * ```javascript\n             *  columns : [\n             *         {\n             *             type   : 'name',\n             *             field  : 'name',\n             *             width  : 250,\n             *             editor : ref => <TextEditor ref={ref}/>\n             *         },\n             *         ...\n             * ]\n             * ```\n             *\n             * NOTE: React editor component must implement `setValue` method which usually internally calls `setState`.\n             * React `setState` is asynchronous so we need to return Promise which will be resolved when `setState`\n             * finishes. A typical example of `setValue` method implemented in a React editor is:\n             *\n             * ```javascript\n             * setValue(value) {\n             *     return new Promise(resolve => this.setState({ value }, () => resolve(value)));\n             * }\n             * ```\n             *\n             * @config {Boolean|String|InputFieldConfig|Core.widget.Field|Function|null} editor\n             * @param {*} ref React `RefObject` for editor JSX component.\n             * @returns {*} Returns React editor JSX component template\n             *\n             * @category Interaction\n             */\n            { name : 'editor', defaultValue : {} },\n            /**\n             * A config object used to configure an {@link Core.widget.Editor} which contains this Column's\n             * {@link #config-editor input field} if {@link Grid.feature.CellEdit} feature is enabled.\n             * @config {EditorConfig} cellEditor\n             * @category Interaction\n             */\n            'cellEditor',\n            /**\n             * A function which is called when a cell edit is requested to finish.\n             *\n             * This may be an `async` function which performs complex validation. The return value should be:\n             * - `false` - To indicate a generic validation error\n             * - `true` - To indicate a successful validation, which will complete the editing\n             * - a string - To indicate an error message of the failed validation. This error message will be cleared\n             * upon any subsequent user input.\n             *\n             * The action for the failed validation is defined with the {@link #config-invalidAction} config.\n             *\n             * For example for synchronous validation:\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *    columns : [\n             *       {\n             *          type : 'text',\n             *          text : 'The column',\n             *          field : 'someField',\n             *          flex : 1,\n             *          finalizeCellEdit : ({ value }) => {\n             *              return value.length < 4 ? 'Value length should be at least 4 characters' : true;\n             *          }\n             *       }\n             *    ]\n             * });\n             * ```\n             * Here we've defined a validation `finalizeCellEdit` function, which marks all edits with new value\n             * less than 4 characters length as invalid.\n             *\n             * For asynchronous validation you can make the validation function async:\n             *\n             * ```javascript\n             * finalizeCellEdit : async ({ value }) => {\n             *     return await performRemoteValidation(value);\n             * }\n             * ```\n             *\n             * @config {Function} finalizeCellEdit\n             * @param {Object} context An object describing the state of the edit at completion request time.\n             * @param {Core.widget.Field} context.inputField The field configured as the column's `editor`.\n             * @param {Core.data.Model} context.record The record being edited.\n             * @param {*} context.oldValue The old value of the cell.\n             * @param {*} context.value The new value of the cell.\n             * @param {Grid.view.Grid} context.grid The host grid.\n             * @param {Object} context.editorContext The {@link Grid.feature.CellEdit} context object.\n             * @param {Grid.column.Column} context.editorContext.column The column being edited.\n             * @param {Core.data.Model} context.editorContext.record The record being edited.\n             * @param {HTMLElement} context.editorContext.cell The cell element hosting the editor.\n             * @param {Core.widget.Editor} context.editorContext.editor The floating Editor widget which is hosting the input field.\n             * @returns {Boolean|void}\n             * @async\n             *\n             * @category Interaction\n             */\n            'finalizeCellEdit',\n            /**\n             * Setting this option means that pressing the `ESCAPE` key after editing the field will\n             * revert the field to the value it had when the edit began. If the value is _not_ changed\n             * from when the edit started, the input field's {@link Core.widget.Field#config-clearable}\n             * behaviour will be activated. Finally, the edit will be canceled.\n             * @config {Boolean} revertOnEscape\n             * @default true\n             * @category Interaction\n             */\n            { name : 'revertOnEscape', defaultValue : true },\n            /**\n             * How to handle a request to complete a cell edit in this column if the field is invalid.\n             * There are three choices:\n             *  - `block` The default. The edit is not exited, the field remains focused.\n             *  - `allow` Allow the edit to be completed.\n             *  - `revert` The field value is reverted and the edit is completed.\n             * @config {'block'|'allow'|'revert'} invalidAction\n             * @default 'block'\n             * @category Interaction\n             */\n            { name : 'invalidAction', defaultValue : 'block' },\n            /**\n             * Allow sorting of data in the column. You can pass true/false to enable/disable sorting, or provide a\n             * custom sorting function, or a config object for a {@link Core.util.CollectionSorter}\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *     columns : [\n             *          {\n             *              // Disable sorting for this column\n             *              sortable : false\n             *          },\n             *          {\n             *              field : 'name',\n             *              // Custom sorting for this column\n             *              sortable(user1, user2) {\n             *                  return user1.name < user2.name ? -1 : 1;\n             *              }\n             *          },\n             *          {\n             *              // A config object for a Core.util.CollectionSorter\n             *              sortable : {\n             *                  property         : 'someField',\n             *                  direction        : 'DESC',\n             *                  useLocaleCompare : 'sv-SE'\n             *              }\n             *          }\n             *     ]\n             * });\n             * ```\n             * When providing a custom sorting function, if the sort feature is configured with\n             * `prioritizeColumns : true` that function will also be used for programmatic sorting of the store:\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *     features : {\n             *       sort : {\n             *           prioritizeColumns : true\n             *       }\n             *     },\n             *\n             *     columns : [\n             *          {\n             *              field : 'name',\n             *              // Custom sorting for this column\n             *              sortable(user1, user2) {\n             *                  return user1.name < user2.name ? -1 : 1;\n             *              }\n             *          }\n             *     ]\n             * });\n             *\n             * // Will use sortable() from the column definition above\n             * grid.store.sort('name');\n             * ```\n             *\n             * @config {Boolean|Function|CollectionSorterConfig} sortable\n             * @param {Core.data.Model} left Left side model to compare\n             * @param {Core.data.Model} right Right side model to compare\n             * @returns {Number}\n             * @default true\n             * @category Interaction\n             */\n            {\n                name         : 'sortable',\n                defaultValue : true,\n                // Normalize function/object forms\n                convert(value, data, column) {\n                    if (!value) {\n                        return false;\n                    }\n                    if (value === true) {\n                        return true;\n                    }\n                    const sorter = {};\n                    if (typeof value === 'function') {\n                        sorter.originalSortFn = value;\n                        // Scope for sortable() expected to be the column\n                        sorter.sortFn = value.bind(column);\n                    }\n                    else if (typeof value === 'object') {\n                        Object.assign(sorter, value);\n                        if (sorter.fn) {\n                            sorter.sortFn = sorter.fn;\n                            delete sorter.fn;\n                        }\n                    }\n                    return sorter;\n                }\n            },\n            /**\n             * Allow searching in the column (respected by QuickFind and Search features)\n             * @config {Boolean} searchable\n             * @default true\n             * @category Interaction\n             */\n            { name : 'searchable', defaultValue : true },\n            /**\n             * If `true`, this column will show a collapse/expand icon in its header, only applicable for parent columns\n             * @config {Boolean} collapsible\n             * @default false\n             * @category Interaction\n             */\n            { name : 'collapsible', defaultValue : false },\n            /**\n             * The collapsed state of this column, only applicable for parent columns\n             * @config {Boolean} collapsed\n             * @default false\n             * @category Interaction\n             */\n            { name : 'collapsed', defaultValue : false },\n            /**\n             * The collapse behavior when collapsing a parent column. Specify \"toggleAll\" or \"showFirst\".\n             * * \"showFirst\" toggles visibility of all but the first columns.\n             * * \"toggleAll\" toggles all children, useful if you have a special initially hidden column which gets shown\n             * in collapsed state.\n             * @config {String} collapseMode\n             * @default 'showFirst'\n             * @category Interaction\n             */\n            { name : 'collapseMode' },\n            /**\n             * Allow filtering data in the column (if {@link Grid.feature.Filter} or {@link Grid.feature.FilterBar}\n             * feature is enabled).\n             *\n             * Also allows passing a custom filtering function that will be called for each record with a single\n             * argument of format `{ value, record, [operator] }`. Returning `true` from the function includes the\n             * record in the filtered set.\n             *\n             * Configuration object may be used for {@link Grid.feature.FilterBar} feature to specify `filterField`. See\n             * an example in the code snippet below or check {@link Grid.feature.FilterBar} page for more details.\n             *\n             * ```\n             * const grid = new Grid({\n             *     columns : [\n             *          {\n             *              field : 'name',\n             *              // Disable filtering for this column\n             *              filterable : false\n             *          },\n             *          {\n             *              field : 'age',\n             *              // Custom filtering for this column\n             *              filterable: ({ value, record }) => Math.abs(record.age - value) < 10\n             *          },\n             *          {\n             *              field : 'start',\n             *              // Changing default field type\n             *              filterable: {\n             *                  filterField : {\n             *                      type : 'datetime'\n             *                  }\n             *              }\n             *          },\n             *          {\n             *              field : 'city',\n             *              // Filtering for a value out of a list of values\n             *              filterable: {\n             *                  filterField : {\n             *                      type  : 'combo',\n             *                      value : '',\n             *                      items : [\n             *                          'Paris',\n             *                          'Dubai',\n             *                          'Moscow',\n             *                          'London',\n             *                          'New York'\n             *                      ]\n             *                  }\n             *              }\n             *          },\n             *          {\n             *              field : 'score',\n             *              filterable : {\n             *                  // This filter fn doesn't return 0 values as matching filter 'less than'\n             *                  filterFn : ({ record, value, operator, property }) => {\n             *                      switch (operator) {\n             *                          case '<':\n             *                              return record[property] === 0 ? false : record[property] < value;\n             *                          case '=':\n             *                              return record[property] == value;\n             *                          case '>':\n             *                              return record[property] > value;\n             *                      }\n             *                  }\n             *              }\n             *          }\n             *     ]\n             * });\n             * ```\n             *\n             * When providing a custom filtering function, if the filter feature is configured with\n             * `prioritizeColumns : true` that function will also be used for programmatic filtering of the store:\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *     features : {\n             *         filter : {\n             *             prioritizeColumns : true\n             *         }\n             *     },\n             *\n             *     columns : [\n             *          {\n             *              field : 'age',\n             *              // Custom filtering for this column\n             *              filterable: ({ value, record }) => Math.abs(record.age - value) < 10\n             *          }\n             *     ]\n             * });\n             *\n             * // Will use filterable() from the column definition above\n             * grid.store.filter({\n             *     property : 'age',\n             *     value    : 50\n             * });\n             * ```\n             *\n             * To use custom `FilterField` combo `store` it should contain one of these\n             * {@link Core.data.Store#config-data} or {@link Core.data.AjaxStore#config-readUrl} configs.\n             * Otherwise combo will get data from owner Grid store.\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *     columns : [\n             *          {\n             *              field : 'name',\n             *              filterable: {\n             *                  filterField {\n             *                      type  : 'combo',\n             *                      store : new Store({\n             *                          data : ['Adam', 'Bob', 'Charlie']\n             *                      })\n             *                  }\n             *              }\n             *          }\n             *     ]\n             * });\n             * ```\n             *\n             * or\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *     columns : [\n             *          {\n             *              field : 'name',\n             *              filterable: {\n             *                  filterField : {\n             *                     type  : 'combo',\n             *                     store : new AjaxStore({\n             *                         readUrl  : 'data/names.json',\n             *                         autoLoad : true\n             *                     })\n             *                  }\n             *              }\n             *          }\n             *     ]\n             * });\n             * ```\n             *\n             * @config {Boolean|Function|Object} filterable\n             * @param {Object} data Data object\n             * @param {*} data.value Record value\n             * @param {Core.data.Model} data.record Record instance\n             * @returns {Boolean} Returns `true` if value matches condition\n             * @default true\n             * @category Interaction\n             */\n            {\n                name         : 'filterable',\n                defaultValue : true,\n                // Normalize function/object forms\n                convert(value) {\n                    if (!value) {\n                        return false;\n                    }\n                    if (value === true) {\n                        return true;\n                    }\n                    const filter = {\n                        columnOwned : true\n                    };\n                    if (typeof value === 'function') {\n                        filter.filterFn = value;\n                    }\n                    else if (typeof value === 'object') {\n                        Object.assign(filter, value);\n                    }\n                    return filter;\n                }\n            },\n            /**\n             * Setting this flag to `true` will prevent dropping child columns into a group column\n             * @config {Boolean} sealed\n             * @default false\n             * @category Interaction\n             */\n            { name : 'sealed' },\n            /**\n             * Allow column visibility to be toggled through UI\n             * @config {Boolean} hideable\n             * @default true\n             * @category Interaction\n             */\n            { name : 'hideable', defaultValue : true },\n            /**\n             * Set to false to prevent this column header from being dragged\n             * @config {Boolean} draggable\n             * @category Interaction\n             */\n            { name : 'draggable', defaultValue : true },\n            /**\n             * Set to false to prevent grouping by this column\n             * @config {Boolean} groupable\n             * @category Interaction\n             */\n            { name : 'groupable', defaultValue : true },\n            /**\n             * Set to `false` to prevent the column from being drag-resized when the ColumnResize plugin is enabled.\n             * @config {Boolean} resizable\n             * @default true\n             * @category Interaction\n             */\n            { name : 'resizable', defaultValue : true },\n            //endregion\n            //region Rendering\n            /**\n             * Renderer function for group headers (when using Group feature).\n             * ```javascript\n             * const grid = new Grid({\n             *     columns : [\n             *         {\n             *             text : 'ABC',\n             *             groupRenderer(renderData) {\n             *                 return {\n             *                      class : {\n             *                          big   : true,\n             *                          small : false\n             *                      },\n             *                      children : [\n             *                          { tag : 'img', src : 'img.png' },\n             *                          renderData.groupRowFor\n             *                      ]\n             *                 };\n             *             }\n             *         }\n             *     ]\n             * });\n             * ```\n             *\n             * @config {Function} groupRenderer\n             * @param {Object} renderData\n             * @param {HTMLElement} renderData.cellElement Cell element, for adding CSS classes, styling etc.\n             * @param {*} renderData.groupRowFor Current group value\n             * @param {Core.data.Model} renderData.record Record for the row\n             * @param {Core.data.Model[]} renderData.groupRecords Records in the group\n             * @param {Grid.column.Column} renderData.column Current rendering column\n             * @param {Grid.column.Column} renderData.groupColumn Column that the grid is grouped by\n             * @param {Number} renderData.count Number of records in the group\n             * @param {Grid.view.Grid} renderData.grid This grid\n             * @returns {DomConfig|String|null} The header grouping text or DomConfig object representing the HTML markup\n             *\n             * @category Rendering\n             */\n            'groupRenderer',\n            /**\n             * Renderer function for the column header.\n             *\n             * @config {Function} headerRenderer\n             * @param {Object} renderData\n             * @param {Grid.column.Column} renderData.column This column\n             * @param {HTMLElement} renderData.headerElement The header element\n             * @returns {String|null} The text or markup to show in the column header\n             *\n             * @category Rendering\n             */\n            'headerRenderer',\n            /**\n             * A tooltip string to show when hovering the column header, or a config object which can\n             * reconfigure the shared tooltip by setting boolean, numeric and string config values.\n             * @config {String|TooltipConfig} tooltip\n             * @category Rendering\n             */\n            'tooltip',\n            /**\n             * Renderer function for the cell tooltip (used with {@link Grid.feature.CellTooltip} feature).\n             * Specify `false` to disable tooltip for this column.\n             *\n             * @config {Function|Boolean} tooltipRenderer\n             * @param {Object} renderData\n             * @param {HTMLElement} renderData.cellElement Cell element\n             * @param {Core.data.Model} renderData.record Record for cell row\n             * @param {Grid.column.Column} renderData.column Cell column\n             * @param {Grid.feature.CellTooltip} renderData.cellTooltip Feature instance, used to set tooltip content async\n             * @param {MouseEvent} renderData.event The event that triggered the tooltip\n             * @returns {String|DomConfig|null}\n             *\n             * @category Rendering\n             */\n            'tooltipRenderer',\n            /**\n             * CSS class added to each cell in this column\n             * @prp {String} cellCls\n             * @category Rendering\n             */\n            'cellCls',\n            /**\n             * CSS class added to the header of this column\n             * @config {String} cls\n             * @category Rendering\n             */\n            'cls',\n            /**\n             * Icon to display in header. Specifying an icon will render a `<i>` element with the icon as value for the\n             * class attribute\n             * @prp {String} icon\n             * @category Rendering\n             */\n            'icon',\n            //endregion\n            //region Layout\n            /**\n             * Text align. Accepts `'left'`/`'center'`/`'right'` or direction neutral `'start'`/`'end'`\n             * @config {'left'|'center'|'right'|'start'|'end'} align\n             * @category Layout\n             */\n            'align',\n            /**\n             * Column minimal width. If value is `Number`, then minimal width is in pixels\n             * @config {Number|String} minWidth\n             * @default 60\n             * @category Layout\n             */\n            { name : 'minWidth', defaultValue : 60 },\n            /**\n             * Column maximal width. If value is Number, then maximal width is in pixels\n             * @config {Number|String} maxWidth\n             * @category Common\n             */\n            'maxWidth',\n            /**\n             * Columns hidden state. Specify `true` to hide the column, `false` to show it.\n             * @prp {Boolean} hidden\n             * @category Layout\n             */\n            { name : 'hidden', defaultValue : false },\n            /**\n             * Convenient way of putting a column in the \"locked\" region. Same effect as specifying region: 'locked'.\n             * If you have defined your own regions (using {@link Grid.view.Grid#config-subGridConfigs}) you should use\n             * {@link #config-region} instead of this one.\n             * @config {Boolean} locked\n             * @default false\n             * @category Layout\n             */\n            { name : 'locked' },\n            /**\n             * Region (part of the grid, it can be configured with multiple) where to display the column. Defaults to\n             * {@link Grid.view.Grid#config-defaultRegion}.\n             *\n             * A column under a grouped header automatically belongs to the same region as the grouped header.\n             *\n             * @config {String} region\n             * @category Layout\n             */\n            { name : 'region' },\n            /**\n             * Specify `true` to merge cells within the column whose value match between rows, making the first\n             * occurrence of the value span multiple rows.\n             *\n             * Only applies when using the {@link Grid/feature/MergeCells MergeCells feature}.\n             *\n             * This setting can also be toggled using the column header menu.\n             *\n             * @config {Boolean} mergeCells\n             * @category Merge cells\n             */\n            { name : 'mergeCells', type : 'boolean' },\n            /**\n             * Set to `false` to prevent merging cells in this column using the column header menu.\n             *\n             * Only applies when using the {@link Grid/feature/MergeCells MergeCells feature}.\n             *\n             * @config {Boolean} mergeable\n             * @default true\n             * @category Merge cells\n             */\n            { name : 'mergeable', type : 'boolean', defaultValue : true },\n            /**\n             * An empty function by default, but provided so that you can override it. This function is called each time\n             * a merged cell is rendered. It allows you to manipulate the DOM config object used before it is synced to\n             * DOM, thus giving you control over styling and contents.\n             *\n             * NOTE: The function is intended for formatting, you should not update records in it since updating records\n             * triggers another round of rendering.\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *   columns : [\n             *     {\n             *       field      : 'project',\n             *       text       : 'Project',\n             *       mergeCells : 'true,\n             *       mergedRenderer({ domConfig, value, fromIndex, toIndex }) {\n             *         domConfig.className.highlight = value === 'Important project';\n             *       }\n             *    }\n             *  ]\n             * });\n             * ```\n             *\n             * @config {Function}\n             * @param {Object} detail An object containing the information needed to render a task.\n             * @param {*} detail.value Value that will be displayed in the merged cell\n             * @param {Number} detail.fromIndex Index in store of the first row of the merged cell\n             * @param {Number} detail.toIndex Index in store of the last row of the merged cell\n             * @param {Core.helper.DomHelper#typedef-DomConfig} detail.domConfig DOM config object for the merged cell\n             * element\n             * @category Merge cells\n             */\n            'mergedRenderer',\n            //endregion\n            // region Menu\n            /**\n             * Show column picker for the column\n             * @config {Boolean} showColumnPicker\n             * @default true\n             * @category Menu\n             */\n            { name : 'showColumnPicker', defaultValue : true },\n            /**\n             * false to prevent showing a context menu on the column header element\n             * @config {Boolean} enableHeaderContextMenu\n             * @default true\n             * @category Menu\n             */\n            { name : 'enableHeaderContextMenu', defaultValue : true },\n            /**\n             * Set to `false` to prevent showing a context menu on the cell elements in this column\n             * @config {Boolean} enableCellContextMenu\n             * @default true\n             * @category Menu\n             */\n            { name : 'enableCellContextMenu', defaultValue : true },\n            /**\n             * Extra items to show in the header context menu for this column.\n             *\n             * ```javascript\n             * headerMenuItems : {\n             *     customItem : { text : 'Custom item' }\n             * }\n             * ```\n             *\n             * @config {Object<String,MenuItemConfig|Boolean|null>} headerMenuItems\n             * @category Menu\n             */\n            'headerMenuItems',\n            /**\n             * Extra items to show in the cell context menu for this column, `null` or `false` to not show any menu items\n             * for this column.\n             *\n             * ```javascript\n             * cellMenuItems : {\n             *     customItem : { text : 'Custom item' }\n             * }\n             * ```\n             *\n             * @config {Object<String,MenuItemConfig|Boolean|null>} cellMenuItems\n             * @category Menu\n             */\n            'cellMenuItems',\n            //endregion\n            //region Summary\n            /**\n             * Summary type (when using Summary feature). Valid types are:\n             *\n             * * `'sum'` - Sum of all values in the column\n             * * `'add'` - Alias for sum\n             * * `'count'` - Number of rows\n             * * `'countNotEmpty'` - Number of rows containing a value\n             * * `'average'` - Average of all values in the column\n             * * `callbackFn` - A custom function, used with `store.reduce`. Its return value becomes the value of the accumulator parameter on the next invocation of callbackFn\n             * </dl>\n             * @config {'sum'|'add'|'count'|'countNotEmpty'|'average'|Function} sum\n             * @param {Number|*} result The value resulting from the previous call to callbackFn. On the first call, its value is initialValue if the latter is specified; otherwise its value is first element.\n             * @param {Core.data.Model} value The value of the current element.\n             * @param {Number} index The index position of currentValue. On the first call, its value is 0 if initialValue is specified, otherwise 1.\n             * @returns {Number|*}\n             * @category Summary\n             */\n            'sum',\n            /**\n             * Summary configs, use if you need multiple summaries per column. Replaces {@link #config-sum} and\n             * {@link #config-summaryRenderer} configs.\n             * @config {ColumnSummaryConfig[]} summaries\n             * @category Summary\n             */\n            'summaries',\n            /**\n             * Renderer function for summary (when using Summary feature). The renderer is called with an object having\n             * the calculated summary `sum` parameter. Function returns a string value to be rendered.\n             *\n             * Example:\n             *\n             * ```javascript\n             * columns : [{\n             *     type            : 'number',\n             *     text            : 'Score',\n             *     field           : 'score',\n             *     sum             : 'sum',\n             *     summaryRenderer : ({ sum }) => `Total amount: ${sum}`\n             * }]\n             * ```\n             *\n             * @config {Function} summaryRenderer\n             * @param {Object} data Object containing renderer parameters\n             * @param {Number|*} data.sum The sum parameter\n             * @returns {String|DomConfig|null}\n             * @category Summary\n             */\n            'summaryRenderer',\n            //endregion\n            //region Misc\n            /**\n             * Column settings at different responsive levels, see responsive demo under examples/\n             * @config {Object} responsiveLevels\n             * @category Misc\n             */\n            'responsiveLevels',\n            /**\n             * Tags, may be used by ColumnPicker feature for grouping columns by tag in the menu\n             * @config {String[]} tags\n             * @category Misc\n             */\n            'tags',\n            /**\n             * Column config to apply to normal config if viewed on a touch device\n             * @config {GridColumnConfig} touchConfig\n             * @category Misc\n             */\n            'touchConfig',\n            /**\n             * When using the tree feature, exactly one column should specify { tree: true }\n             * @config {Boolean} tree\n             * @category Misc\n             */\n            'tree',\n            /**\n             * Determines which type of filtering to use for the column. Usually determined by the column type used,\n             * but may be overridden by setting this field.\n             * @config {'text'|'date'|'number'|'duration'} filterType\n             * @category Misc\n             */\n            'filterType',\n            /**\n             * By default, any rendered column cell content is HTML-encoded. Set this flag to `false` disable this and\n             * allow rendering html elements\n             * @config {Boolean} htmlEncode\n             * @default true\n             * @category Misc\n             */\n            { name : 'htmlEncode', defaultValue : true },\n            /**\n             * By default, the header text is HTML-encoded. Set this flag to `false` disable this and allow html\n             * elements in the column header\n             * @config {Boolean} htmlEncodeHeaderText\n             * @default true\n             * @category Misc\n             */\n            { name : 'htmlEncodeHeaderText', defaultValue : true },\n            /**\n             * Set to `true`to automatically call DomHelper.sync for html returned from a renderer. Should in most cases\n             * be more performant than replacing entire innerHTML of cell and also allows CSS transitions to work. Has\n             * no effect unless {@link #config-htmlEncode} is disabled. Returned html must contain a single root element\n             * (that can have multiple children). See PercentColumn for example usage.\n             * @config {Boolean} autoSyncHtml\n             * @default false\n             * @category Misc\n             */\n            { name : 'autoSyncHtml', defaultValue : false },\n            /**\n             * Set to `false` to not always clear cell content if the {@link #config-renderer} returns `undefined`\n             * or has no `return` statement. This is useful when you mutate the cellElement, and want to prevent\n             * cell content from being reset during rendering. **This is the default behaviour until 6.0.**\n             *\n             * Set to `true` to always clear cell content regardless of renderer return value. **This will be default\n             * behaviour from 6.0.**\n             * @config {Boolean} alwaysClearCell\n             * @default false\n             * @category Misc\n             */\n            { name : 'alwaysClearCell', defaultValue : false },\n            /**\n             * An array of the widgets to append to the column header\n             * ```javascript\n             * columns : [\n             * {\n             *     text          : 'Name',\n             *     field         : 'name',\n             *     flex          : 1,\n             *     headerWidgets : [\n             *         {\n             *             type   : 'button',\n             *             text   : 'Add row',\n             *             cls    : 'b-raised b-blue',\n             *             async onAction() {\n             *                 const [newRecord] = grid.store.add({\n             *                     name : 'New user'\n             *                 });\n             *\n             *                 await grid.scrollRowIntoView(newRecord);\n             *\n             *                 await grid.features.cellEdit.startEditing({\n             *                     record : newRecord,\n             *                     field  : 'name'\n             *                 });\n             *             }\n             *         }\n             *     ]\n             * }]\n             * ```\n             * @config {ContainerItemConfig[]} headerWidgets\n             * @private\n             * @category Misc\n             */\n            { name : 'headerWidgets' },\n            /**\n             * Set to `true` to have the {@link Grid.feature.CellEdit} feature update the record being edited live upon\n             * field edit instead of when editing is finished by using `TAB` or `ENTER`\n             * @config {Boolean} instantUpdate\n             * @category Misc\n             */\n            { name : 'instantUpdate', defaultValue : false },\n            { name : 'repaintOnResize', defaultValue : false },\n            /**\n             * An optional query selector to select a sub element within the cell being\n             * edited to align a cell editor's `X` position and `width` to.\n             * @config {String} editTargetSelector\n             * @category Misc\n             */\n            'editTargetSelector',\n            //endregion\n            //region Export\n            /**\n             * Used by the Export feature. Set to `false` to omit a column from an exported dataset\n             * @config {Boolean} exportable\n             * @default true\n             * @category Export\n             */\n            { name : 'exportable', defaultValue : true },\n            /**\n             * Column type which will be used by {@link Grid.util.TableExporter}. See list of available types in\n             * TableExporter docs. Returns undefined by default, which means column type should be read from the record\n             * field.\n             * @config {String} exportedType\n             * @category Export\n             */\n            { name : 'exportedType' },\n            //endregion\n            {\n                name         : 'ariaLabel',\n                defaultValue : 'L{Column.columnLabel}'\n            },\n            {\n                name         : 'cellAriaLabel',\n                defaultValue : 'L{cellLabel}'\n            }\n        ];\n    }\n    // prevent undefined fields from being exposed, to simplify spotting errors\n    static get autoExposeFields() {\n        return false;\n    }\n    //endregion\n    //region Init\n    construct(data, store) {\n        const me = this;\n        me.masterStore = store;\n        // Store might be an array\n        if (store) {\n            me._grid = Array.isArray(store) ? store[0].grid : store.grid;\n        }\n        me.localizableProperties = Config.mergeMethods.distinct(data.localizableProperties, ['text', 'ariaLabel', 'cellAriaLabel']);\n        if (data.localeClass) {\n            me.localeClass = data.localeClass;\n        }\n        super.construct(...arguments);\n        // Default value for region is assigned by the ColumnStore in createRecord(), same for `locked`\n        // Allow field : null if the column does not rely on a record field.\n        // For example the CheckColumn when used by GridSelection.\n        if (me.isLeaf && !('field' in me.data)) {\n            me.field = '_' + (me.type || '') + (++Column.emptyCount);\n            me.noFieldSpecified = true;\n        }\n        if (!me.width && !me.flex && !me.children) {\n            // Set the width silently because we're in construction.\n            me.set({\n                width : Column.defaultWidth,\n                flex  : null\n            }, null, true);\n        }\n        me.headerWidgets && me.initHeaderWidgets(me.headerWidgets);\n        if (me.isParent) {\n            me.meta.visibleChildren = new Set();\n            // Trigger adding expand/collapse button\n            if (me.collapsible) {\n                me.collapsible = true;\n            }\n        }\n        me.rendererReturningContent = me.renderer?.toString().includes('return ');\n    }\n    /**\n     * Checks whether the other column is in the same position and configured the same as this Column.\n     * @param {Grid.column.Column} other The partner column to check\n     * @returns {Boolean} `true` if these two Columns should be kept in sync.\n     * @private\n     */\n    shouldSync(other) {\n        // Two columns in different grids should be kept in sync if:\n        //  they have the same header text\n        //  and they have the same field or same renderer\n        //  and they are positioned the same; after an identical set of previous siblings\n        return other.isColumn &&\n            other.text === this.text &&\n            (other.field === this.field || String(other.renderer) === String(this.renderer)) &&\n            ((!other.previousSibling && !this.previousSibling) || other.previousSibling.shouldSync(this.previousSibling));\n    }\n    get isCollapsible() {\n        return this.children?.length > 1 && this.collapsible;\n    }\n    get collapsed() {\n        return this.get('collapsed');\n    }\n    set collapsed(collapsed) {\n        // Avoid triggering redraw\n        this.set('collapsed', collapsed, true);\n        // This triggers redraw\n        this.onCollapseChange(!collapsed);\n        this.trigger('toggleCollapse', { collapsed });\n    }\n    onCellFocus(location) {\n        this.location = location;\n        this.updateHeaderAriaLabel(this.localizeProperty('ariaLabel'));\n        // Update cell if cell is in the grid\n        if (location.rowIndex !== -1) {\n            this.updateCellAriaLabel(this.localizeProperty('cellAriaLabel'));\n        }\n    }\n    updateHeaderAriaLabel(headerAriaLabel) {\n        DomHelper.setAttributes(this.element, {\n            'aria-label' : headerAriaLabel\n        });\n    }\n    updateCellAriaLabel(cellAriaLabel) {\n        if (!this.location?.isSpecialRow && this.location?.cell) {\n            if (!cellAriaLabel?.length) {\n                cellAriaLabel = this.location.column.text;\n            }\n            DomHelper.setAttributes(this.location.cell, {\n                'aria-label' : cellAriaLabel\n            });\n        }\n    }\n    doDestroy() {\n        this.data?.editor?.destroy?.();\n        this.destroyHeaderWidgets();\n        super.doDestroy();\n    }\n    //endregion\n    //region Header widgets\n    set headerWidgets(widgets) {\n        this.initHeaderWidgets(widgets);\n        this.set('headerWidgets', widgets);\n    }\n    get headerWidgets() {\n        return this.get('headerWidgets');\n    }\n    initHeaderWidgets(widgets) {\n        this.destroyHeaderWidgets();\n        const headerWidgetMap = this.headerWidgetMap = {};\n        for (const config of widgets) {\n            const widget = Widget.create({ owner : this, ...config });\n            headerWidgetMap[widget.ref || widget.id] = widget;\n        }\n    }\n    destroyHeaderWidgets() {\n        // Clean up any headerWidgets used\n        for (const widget of Object.values(this.headerWidgetMap || {})) {\n            widget.destroy?.();\n        }\n    }\n    //endregion\n    //region Fields\n    // Yields the automatic cell tagging class, eg b-number-cell from NumberColumn etc\n    static generateAutoCls() {\n        const classes = [];\n        // Create the auto class for cells owned by this column class\n        // For example NumberColumn cells get b-number-cell\n        // DurationColumn cells get b-duration-cell b-number-cell\n        for (let c = this; c !== Column; c = c.superclass) {\n            c.type && c.type !== c.superclass.type && classes.push(`b-${c.type.toLowerCase()}-cell`);\n        }\n        const columnAutoCls = classes.join(' ');\n        (Column.autoClsMap || (Column.autoClsMap = new Map())).set(this, columnAutoCls);\n        return columnAutoCls;\n    }\n    /**\n     * Returns the full CSS class set for a cell at the passed {@link Grid.util.Location}\n     * as an object where property keys with truthy values denote a class to be added\n     * to the cell.\n     * @param {Grid.util.Location} cellContext\n     * @returns {Object} An object in which property keys with truthy values are used as\n     * the class names on the cell element.\n     * @internal\n     */\n    getCellClass(cellContext) {\n        const\n            { record, column } = cellContext,\n            {\n                cellCls,\n                internalCellCls,\n                grid,\n                constructor,\n                align\n            }          = column,\n            autoCls    = Column.autoClsMap?.get(constructor) || constructor.generateAutoCls(),\n            isEditing  = cellContext.cell.classList.contains('b-editing'),\n            result     = {\n                [grid.cellCls]                 : grid.cellCls,\n                [autoCls]                      : autoCls,\n                [cellCls]                      : cellCls,\n                [internalCellCls]              : internalCellCls,\n                'b-cell-dirty'                 : record.isFieldModified(column.field) && (column.compositeField || record.fieldMap[column.field]?.persist !== false),\n                [`b-grid-cell-align-${align}`] : align,\n                'b-selected'                   : grid.selectionMode.cell && grid.isCellSelected(cellContext),\n                'b-focused'                    : grid.isFocused(cellContext),\n                'b-auto-height'                : column.autoHeight,\n                'b-editing'                    : isEditing\n            };\n        // Check cell CSS should not be applied to group header rows\n        if (record.isSpecialRow && result['b-checkbox-selection']) {\n            result['b-checkbox-selection'] = false;\n        }\n        return result;\n    }\n    get locked() {\n        return this.data.region === 'locked';\n    }\n    set locked(locked) {\n        this.region = locked ? 'locked' : 'normal';\n    }\n    // Children of grouped header always uses same region as the group\n    get region() {\n        if (!this.parent.isRoot) {\n            return this.parent.region;\n        }\n        return this.get('region');\n    }\n    set region(region) {\n        this.set('region', region);\n    }\n    // parent headers cannot be sorted by\n    get sortable() {\n        return this.isLeaf && this.data.sortable;\n    }\n    set sortable(sortable) {\n        this.set('sortable', sortable);\n    }\n    // parent headers cannot be grouped by\n    get groupable() {\n        return Boolean(this.isLeaf && this.field && this.data.groupable);\n    }\n    set groupable(groupable) {\n        this.set('groupable', groupable);\n    }\n    /**\n     * The Field to use as editor for this column\n     * @private\n     * @readonly\n     */\n    get editor() {\n        const me = this;\n        let { editor } = me.data;\n        if (editor && !editor.isWidget) {\n            // Give frameworks a shot at injecting their own editor, wrapped as a widget\n            const result = me.grid.processCellEditor({ editor, field : me.field });\n            if (result) {\n                // Use framework editor\n                editor = me.data.editor = result.editor;\n            }\n            else {\n                if (typeof editor === 'string') {\n                    editor = {\n                        type : editor\n                    };\n                }\n                // The two configs, default and configured must be deep merged.\n                editor = me.data.editor = Widget.create(ObjectHelper.merge(me.defaultEditor, {\n                    owner : me.grid,\n                    // Field labels must be present for A11Y purposes, but are clipped out of visibility.\n                    // Screen readers will be able to access them and announce them.\n                    label : StringHelper.encodeHtml(me.text)\n                }, editor));\n            }\n        }\n        return editor;\n    }\n    set editor(editor) {\n        this.data.editor = editor;\n    }\n    /**\n     * A config object specifying the editor to use to edit this column.\n     * @private\n     * @readonly\n     */\n    get defaultEditor() {\n        return {\n            type : 'textfield',\n            name : this.field\n        };\n    }\n    //endregion\n    //region Grid, SubGrid & Element\n    /**\n     * Extracts the value from the record specified by this Column's {@link #config-field} specification\n     * in a format that can be used as a value to match by a {@link Grid.feature.Filter filtering} operation.\n     *\n     * The default implementation returns the {@link #function-getRawValue} value, but this may be\n     * overridden in subclasses.\n     * @param {Core.data.Model} record The record from which to extract the field value.\n     * @returns {*} The value of the referenced field if any.\n     */\n    getFilterableValue(record) {\n        return this.getRawValue(record);\n    }\n    // Create an ownership hierarchy which links columns up to their SubGrid if no owner injected.\n    get owner() {\n        return this._owner || this.subGrid;\n    }\n    set owner(owner) {\n        this._owner = owner;\n    }\n    get grid() {\n        return this._grid || this.parent?.grid;\n    }\n    // Private, only used in tests where standalone Headers are created with no grid\n    // from which to lookup the associate SubGrid.\n    set subGrid(subGrid) {\n        this._subGrid = subGrid;\n    }\n    /**\n     * Get the SubGrid to which this column belongs\n     * @property {Grid.view.SubGrid}\n     * @readonly\n     */\n    get subGrid() {\n        return this._subGrid || this.grid?.getSubGridFromColumn(this);\n    }\n    /**\n     * Get the element for the SubGrid to which this column belongs\n     * @property {HTMLElement}\n     * @readonly\n     * @private\n     */\n    get subGridElement() {\n        return this.subGrid.element;\n    }\n    /**\n     * The header element for this Column. *Only available after the grid has been rendered*.\n     *\n     * **Note that column headers are rerendered upon mutation of Column values, so this\n     * value is volatile and should not be cached, but should be read whenever needed.**\n     * @property {HTMLElement}\n     * @readonly\n     */\n    get element() {\n        return this.grid.getHeaderElement(this);\n    }\n    get previousVisibleSibling() {\n        // During move from one region to another, nextSibling might not be wired up to the new next sibling in region.\n        // (Because the order in master store did not change)\n        const region = this.region;\n        let prev = this.previousSibling;\n        while (prev && (prev.hidden || prev.region !== region)) {\n            prev = prev.previousSibling;\n        }\n        return prev;\n    }\n    get nextVisibleSibling() {\n        // During move from one region to another, nextSibling might not be wired up to the new next sibling in region.\n        // (Because the order in master store did not change)\n        const region = this.region;\n        let next = this.nextSibling;\n        while (next && (next.hidden || next.region !== region)) {\n            next = next.nextSibling;\n        }\n        return next;\n    }\n    get isLastInSubGrid() {\n        return !this.nextVisibleSibling && (this.parent.isRoot || this.parent.isLastInSubGrid);\n    }\n    get allowDrag() {\n        return !this.parent.isRoot || Boolean(this.nextVisibleSibling || this.previousVisibleSibling);\n    }\n    /**\n     * The text wrapping element for this Column. *Only available after the grid has been rendered*.\n     *\n     * This is the full-width element which *contains* the text-bearing element and any icons.\n     *\n     * **Note that column headers are rerendered upon mutation of Column values, so this\n     * value is volatile and should not be cached, but should be read whenever needed.**\n     * @property {HTMLElement}\n     * @readonly\n     */\n    get textWrapper() {\n        return DomHelper.getChild(this.element, '.b-grid-header-text');\n    }\n    /**\n     * The text containing element for this Column. *Only available after the grid has been rendered*.\n     *\n     * **Note that column headers are rerendered upon mutation of Column values, so this\n     * value is volatile and should not be cached, but should be read whenever needed.**\n     * @property {HTMLElement}\n     * @readonly\n     */\n    get textElement() {\n        return DomHelper.down(this.element, '.b-grid-header-text-content');\n    }\n    /**\n     * The child element into which content should be placed. This means where any\n     * contained widgets such as filter input fields should be rendered. *Only available after the grid has been\n     * rendered*.\n     *\n     * **Note that column headers are rerendered upon mutation of Column values, so this\n     * value is volatile and should not be cached, but should be read whenever needed.**\n     * @property {HTMLElement}\n     * @readonly\n     */\n    get contentElement() {\n        return DomHelper.down(this.element, '.b-grid-header-children');\n    }\n    //endregion\n    //region Misc properties\n    get isSorted() {\n        return this.grid.store.sorters.some(s => s.field === this.field);\n    }\n    get isFocusable() {\n        return this.isLeaf;\n    }\n    static get text() {\n        return this.$meta.fields.defaults.text;\n    }\n    /**\n     * Returns header text based on {@link #config-htmlEncodeHeaderText} config value.\n     * @returns {String}\n     * @internal\n     */\n    get headerText() {\n        return this.htmlEncodeHeaderText ? StringHelper.encodeHtml(this.text) : this.text;\n    }\n    /**\n     * An object which contains a map of the header widgets keyed by their {@link Core.widget.Widget#config-ref ref}.\n     * @property {Object<String,Core.widget.Widget>} headerWidgetMap\n     * @private\n     * @readonly\n     */\n    //endregion\n    //region Show/hide\n    get isVisible() {\n        return !this.hidden && (!this.parent || this.parent.isVisible);\n    }\n    /**\n     * Hides this column.\n     */\n    hide(silent = false, hidingParent = false) {\n        const\n            me         = this,\n            { parent } = me;\n        // Reject non-change\n        if (!me.hidden) {\n            me.hidden = true;\n            if (parent && !parent.isRoot && !parent.isTogglingAll) {\n                // check if all sub columns are hidden, if so hide parent\n                const anyVisible = parent.children.some(child => child.hidden !== true);\n                if (!anyVisible && !parent.hidden) {\n                    silent = true; // hiding parent will trigger event\n                    parent.hide();\n                }\n            }\n            if (me.isParent) {\n                me.children.forEach(child => child.hide(true, true));\n            }\n            // Keep state when hiding parent, to be able to restore when showing\n            else if (!parent.isRoot) {\n                parent.meta.visibleChildren[hidingParent ? 'add' : 'delete'](me);\n            }\n            if (!silent) {\n                me.stores.forEach(store => store.trigger('columnHide', { column : me }));\n            }\n        }\n    }\n    /**\n     * Shows this column.\n     */\n    show(silent = false) {\n        const\n            me         = this,\n            { parent } = me;\n        // Reject non-change\n        if (me.hidden) {\n            me.hidden = false;\n            if (parent?.hidden) {\n                parent.show();\n            }\n            if (me.isParent) {\n                // Only show children\n                me.meta.visibleChildren?.forEach(child => child.show(true));\n            }\n            // event is triggered on chained stores\n            if (!silent) {\n                me.stores.forEach(store => store.trigger('columnShow', { column : me }));\n            }\n        }\n    }\n    /**\n     * Toggles the column visibility.\n     * @param {Boolean} [force] Set to true (visible) or false (hidden) to force a certain state\n     */\n    toggle(forceVisible) {\n        if ((this.hidden && forceVisible === undefined) || forceVisible === true) {\n            return this.show();\n        }\n        if ((!this.hidden && forceVisible === undefined) || forceVisible === false) {\n            return this.hide();\n        }\n    }\n    /**\n     * Toggles the column visibility of all children of a parent column.\n     * @param {Grid.column.Column[]} [columns] The set of child columns to toggle, defaults to all children\n     * @param {Boolean} [force] Set to true (visible) or false (hidden) to force a certain state\n     */\n    toggleChildren(columns = this.children, force = undefined) {\n        const me = this;\n        me.grid.columns?.beginBatch();\n        me.isTogglingAll = true;\n        columns.forEach(childColumn => childColumn.toggle(force));\n        me.isTogglingAll = false;\n        me.grid.columns?.endBatch();\n    }\n    /**\n     * Toggles the collapsed state of the column. Based on the {@link #config-collapseMode}, this either hides all\n     * but the first child column, or toggles the visibility state of all children (if you want to have a special\n     * column shown in collapsed mode).\n     *\n     * Only applicable for columns with child columns.\n     * @private\n     * @param {Boolean} [force] Set to true (expanded) or false (collapsed) to force a certain state\n     */\n    onCollapseChange(force = undefined) {\n        const me = this;\n        if (me.collapseMode === 'toggleAll') {\n            me.toggleChildren();\n        }\n        else {\n            const { firstChild } = me;\n            // For flexed child column, stamp a width on it in collapsed state\n            if (firstChild.flex != null && me.collapsed) {\n                firstChild.oldFlex = firstChild.flex;\n                firstChild.width = firstChild.element.offsetWidth;\n            }\n            else if (!me.collapsed && firstChild.oldFlex) {\n                // For previously flexed child column, restore the flex value;\n                firstChild.flex = firstChild.oldFlex;\n                firstChild.oldFlex = null;\n            }\n            me.grid.columns?.beginBatch();\n            me.isTogglingAll = true;\n            me.children.slice(1).forEach(childColumn => childColumn.toggle(force));\n            me.isTogglingAll = false;\n            me.grid.columns?.endBatch();\n        }\n    }\n    set collapsible(collapsible) {\n        const me = this;\n        me.set('collapsible', collapsible);\n        if (me.isParent) {\n            const { headerWidgets = [] } = me;\n            if (collapsible) {\n                headerWidgets.push({\n                    type        : 'button',\n                    ref         : 'collapseExpand',\n                    toggleable  : true,\n                    pressed     : me.collapsed,\n                    icon        : `b-icon-collapse-${me.grid.rtl ? 'right' : 'left'}`,\n                    pressedIcon : `b-icon-collapse-${me.grid.rtl ? 'left' : 'right'}`,\n                    cls         : 'b-grid-header-collapse-button b-transparent',\n                    onToggle    : ({ pressed }) => me.collapsed = pressed\n                });\n            }\n            else {\n                const index = headerWidgets.findIndex(w => w.ref === 'collapseExpand');\n                index > -1 && headerWidgets.splice(index, 1);\n            }\n            me.headerWidgets = headerWidgets;\n            if (me.collapsed) {\n                me.onCollapseChange(false);\n            }\n        }\n    }\n    get collapsible() {\n        return this.get('collapsible');\n    }\n    //endregion\n    //region Index & id\n    /**\n     * Generates an id for the column when none is set. Generated ids are 'col1', 'col2' and so on. If a field is\n     * specified (as it should be in most cases) the field name is used instead: 'name1', 'age2' ...\n     * @private\n     * @returns {String}\n     */\n    generateId() {\n        if (!Column.generatedIdIndex) {\n            Column.generatedIdIndex = 0;\n        }\n        return (this.field ? this.field.replace(/\\./g, '-') : 'col') + (++Column.generatedIdIndex);\n    }\n    /**\n     * Index among all flattened columns\n     * @property {Number}\n     * @readOnly\n     * @internal\n     */\n    get allIndex() {\n        return this.masterStore.indexOf(this);\n    }\n    //endregion\n    //region Width\n    // Returns size in pixels for measured value\n    measureSize(value) {\n        return DomHelper.measureSize(value, this.subGrid?.element);\n    }\n    /**\n     * Returns minimal width in pixels for applying to style according to the current `width` and `minWidth`.\n     * @internal\n     */\n    get calcMinWidth() {\n        const { width, minWidth } = this.data;\n        if (validWidth(width) && validWidth(minWidth)) {\n            return Math.max(parseInt(width) || 0, parseInt(minWidth) || 0);\n        }\n        else {\n            return width;\n        }\n    }\n    /**\n     * Get/set columns width in px. If column uses flex, width will be undefined.\n     * Setting a width on a flex column cancels out flex.\n     *\n     * **NOTE:** Grid might be configured to always stretch the last column, in which case the columns actual width\n     * might deviate from the configured width.\n     *\n     * ```javascript\n     * let grid = new Grid({\n     *     appendTo : 'container',\n     *     height   : 200,\n     *     width    : 400,\n     *     columns  : [{\n     *         text  : 'First column',\n     *         width : 100\n     *     }, {\n     *         text  : 'Last column',\n     *         width : 100 // last column in the grid is always stretched to fill the free space\n     *     }]\n     * });\n     *\n     * grid.columns.last.element.offsetWidth; // 300 -> this points to the real element width\n     * ```\n     * @property {Number|String}\n     */\n    get width() {\n        return this.data.width;\n    }\n    set width(width) {\n        const data = { width };\n        if (width && ('flex' in this.data)) {\n            data.flex = null; // remove flex when setting width to enable resizing flex columns\n        }\n        this.set(data);\n    }\n    set flex(flex) {\n        const data = { flex };\n        if (flex && ('width' in this.data)) {\n            data.width = null; // remove width when setting flex\n        }\n        this.set(data);\n    }\n    get flex() {\n        return this.data.flex;\n    }\n    // This method is used to calculate minimum row width for edge and safari\n    // It calculates minimum width of the row taking column hierarchy into account\n    calculateMinWidth() {\n        const\n            me       = this,\n            width    = me.measureSize(me.width),\n            minWidth = me.measureSize(me.minWidth);\n        let minChildWidth = 0;\n        if (me.children) {\n            minChildWidth = me.children.reduce((result, column) => {\n                return result + column.calculateMinWidth();\n            }, 0);\n        }\n        return Math.max(width, minWidth, minChildWidth);\n    }\n    /**\n     * Resizes the column to match the widest string in it. By default it also measures the column header, this\n     * behaviour can be configured by setting {@link Grid.view.Grid#config-resizeToFitIncludesHeader}.\n     *\n     * Called internally when you double click the edge between\n     * column headers, but can also be called programmatically. For performance reasons it is limited to checking 1000\n     * rows surrounding the current viewport.\n     *\n     * @param {Number|Number[]} widthMin Minimum allowed width. If content width is less than this, this width is used\n     * instead. If this parameter is an array, the first element is `widthMin` and the seconds is `widthMax`.\n     * @param {Number} widthMax Maximum allowed width. If the content width is greater than this number, this width\n     * is used instead.\n     */\n    resizeToFitContent(widthMin, widthMax, batch = false) {\n        const\n            me                    = this,\n            {\n                grid,\n                element,\n                fitMode\n            } = me,\n            { rowManager, store } = grid,\n            { count }             = store;\n        if (count <= 0 || me.fitMode === 'none' || !me.fitMode) {\n            return;\n        }\n        const\n            [row]       = rowManager.rows,\n            {\n                rowElement,\n                cellElement\n            }           = grid.beginGridMeasuring(),\n            cellContext = new Location({\n                grid,\n                column : me,\n                id     : null\n            });\n        let maxWidth = 0,\n            start, end, i, record, value, length, longest = { length : 0, record : null };\n        // Fake element data to be able to use Row#renderCell()\n        cellElement._domData = {\n            columnId : me.id,\n            row,\n            rowElement\n        };\n        cellContext._cell             = cellElement;\n        cellContext.updatingSingleRow = true;\n        cellContext.isMeasuring       = true;\n        // Clear cellElement, since it is being reused between columns\n        cellElement.innerHTML = '';\n        // Measure header unless configured not to\n        if (grid.resizeToFitIncludesHeader && !grid.hideHeaders) {\n            // Cache the padding\n            if (!grid.$headerPadding) {\n                const style = globalThis.getComputedStyle(element);\n                grid.$headerPadding = parseInt(style.paddingLeft);\n            }\n            // Grab the header text content element\n            const headerText = element.querySelector('.b-grid-header-text-content');\n            // Restyle it to shrinkwrap its text, measure and then restore\n            headerText.style.cssText = 'flex: none; width: auto';\n            maxWidth = headerText.offsetWidth + grid.$headerPadding * 2 + 2; // +2 to avoid overflow ellipsis\n            headerText.style.cssText = '';\n        }\n        // If it's a very large dataset, measure the maxWidth of the field in the 1000 rows\n        // surrounding the rendered block.\n        if (count > 1000) {\n            start = Math.max(Math.min(rowManager.topIndex + Math.round(rowManager.rowCount / 2) - 500, count - 1000), 0);\n            end = start + 1000;\n        }\n        else {\n            start = 0;\n            end = count;\n        }\n        for (i = start; i < end; i++) {\n            record = store.getAt(i);\n            value = me.getRawValue(record);\n            // In value mode we determine the record with the longest value, no rendering involved\n            if (fitMode === 'value') {\n                length = String(value).length;\n            }\n            // In exact and textContent modes we have to render the records\n            else {\n                cellContext._record   = longest.record;\n                cellContext._id       = record.id;\n                cellContext._rowIndex = i;\n                row.renderCell(cellContext);\n                // Reading textContent is \"cheap\", it does not require a layout\n                if (fitMode === 'textContent') {\n                    length = cellElement.textContent.length;\n                }\n                // Using exact mode, measure the cell = expensive\n                else {\n                    const width = cellElement.offsetWidth;\n                    if (width > maxWidth) {\n                        maxWidth = width;\n                    }\n                }\n            }\n            if (length > longest.length) {\n                longest = { record, length, rowIndex : i };\n            }\n        }\n        // value mode and textContent mode both required us to render and measure the record determined to be the\n        // longest above\n        if (longest.length > 0 && (fitMode === 'value' || fitMode === 'textContent')) {\n            cellContext._record = longest.record;\n            cellContext._id = longest.record.id;\n            cellContext._rowIndex = longest.rowIndex;\n            row.renderCell(cellContext);\n            maxWidth = Math.max(maxWidth, cellElement.offsetWidth);\n        }\n        if (Array.isArray(widthMin)) {\n            [widthMin, widthMax] = widthMin;\n        }\n        maxWidth = Math.max(maxWidth, widthMin || 0);\n        maxWidth = Math.min(maxWidth, widthMax || 1e6);  // 1 million px default max\n        // Batch mode saves a little time by not removing the measuring elements between columns\n        if (!batch) {\n            grid.endGridMeasuring();\n        }\n        me.width = me.maxWidth ? (maxWidth = Math.min(maxWidth, me.maxWidth)) : maxWidth;\n        return maxWidth;\n    }\n    //endregion\n    //region State\n    /**\n     * Get column state, used by State mixin\n     * @private\n     */\n    getState() {\n        const\n            me    = this,\n            state = {\n                id     : me.id,\n                // State should only store column attributes which user can modify via UI (except column index).\n                // User can hide column, resize or move it to neighbor region\n                hidden : me.hidden,\n                region : me.region,\n                locked : me.locked\n            };\n        if (!me.children) {\n            state[me.flex ? 'flex' : 'width'] = me.flex || me.width;\n        }\n        if (me.isCollapsible) {\n            state.collapsed = me.collapsed;\n        }\n        return state;\n    }\n    /**\n     * Apply state to column, used by State mixin\n     * @private\n     */\n    applyState(state) {\n        const me = this;\n        me.beginBatch();\n        if ('locked' in state) {\n            me.locked = state.locked;\n        }\n        if ('width' in state) {\n            me.width = state.width;\n        }\n        if ('flex' in state) {\n            me.flex = state.flex;\n        }\n        if ('width' in state && me.flex) {\n            me.flex = undefined;\n        }\n        else if ('flex' in state && me.width) {\n            me.width = undefined;\n        }\n        if ('region' in state) {\n            me.region = state.region;\n        }\n        me.endBatch();\n        if ('hidden' in state) {\n            me.toggle(state.hidden !== true);\n        }\n        if ('collapsed' in state) {\n            me.collapsed = state.collapsed;\n        }\n    }\n    //endregion\n    //region Other\n    remove() {\n        const\n            { subGrid, grid } = this,\n            focusedCell       = subGrid && grid?.focusedCell;\n        // Prevent errors when removing the column that the owning grid has registered as focused.\n        if (focusedCell?.columnId === this.id) {\n            // Focus is in the grid, navigate before column is removed\n            if (grid.owns(DomHelper.getActiveElement(grid))) {\n                grid.navigateRight();\n            }\n            // Focus not in the grid, bump the focused cell pointer to the next visible column\n            // for when focus returns so it can go as close as possible.\n            else {\n                grid._focusedCell = new Location({\n                    grid,\n                    rowIndex : focusedCell.rowIndex,\n                    column   : subGrid.columns.getAdjacentVisibleLeafColumn(this.id, true, true)\n                });\n            }\n        }\n        super.remove();\n    }\n    /**\n     * Extracts the value from the record specified by this Column's {@link #config-field} specification.\n     *\n     * This will work if the field is a dot-separated path to access fields in associated records, eg\n     *\n     * ```javascript\n     *  field : 'resource.calendar.name'\n     * ```\n     *\n     * **Note:** This is the raw field value, not the value returned by the {@link #config-renderer}.\n     * @param {Core.data.Model} record The record from which to extract the field value.\n     * @returns {*} The value of the referenced field if any.\n     */\n    getRawValue(record) {\n        // Engine can change field value to null, in which case cell will render previous record value,\n        // before project commit\n        return record.getValue(this.field);\n    }\n    /**\n     * Refresh the cell for supplied record in this column, if that cell is rendered.\n     * @param {Core.data.Model} record Record used to get row to update the cell in\n     */\n    refreshCell(record) {\n        this.grid.rowManager.refreshCell(record, this.id);\n    }\n    /**\n     * Rerender the header for this column\n     */\n    refreshHeader() {\n        this.grid.refreshHeader(this);\n    }\n    /**\n     * Clear cell contents. Base implementation which just sets innerHTML to blank string.\n     * Should be overridden in subclasses to clean up for examples widgets.\n     * @param {HTMLElement} cellElement\n     * @internal\n     */\n    clearCell(cellElement) {\n        cellElement.innerHTML = '';\n        delete cellElement._content;\n    }\n    /**\n     * Override in subclasses to allow/prevent editing of certain rows.\n     * @param {Core.data.Model} record\n     * @internal\n     */\n    canEdit(record) {\n        // the record can decide which column is editable\n        if (record.isEditable) {\n            const isEditable = record.isEditable(this.field);\n            // returns undefined for unknown field\n            if (isEditable !== undefined) {\n                return isEditable;\n            }\n        }\n        return true;\n    }\n    /**\n     * Insert a child column(s) before an existing child column. Returns `null` if the parent column is\n     * {@link #config-sealed}\n     * @param {Core.data.Model|Core.data.Model[]} childColumn Column or array of columns to insert\n     * @param {Core.data.Model} [before] Optional column to insert before, leave out to append to the end\n     * @param {Boolean} [silent] Pass `true` to not trigger events during insert\n     * @returns {Core.data.Model|Core.data.Model[]|null}\n     * @category Parent & children\n     */\n    insertChild(childColumn, before = null, silent = false) {\n        childColumn = Array.isArray(childColumn) ? childColumn : [childColumn];\n        // If user dragged out only visible child of collapsed parent, make next sibling visible\n        childColumn.forEach(col => {\n            const { parent } = col;\n            if (parent?.collapsed && col === parent.firstChild && parent.children.length > 1 && parent.children.filter(child => !child.hidden).length === 1) {\n                col.nextSibling.hidden = false;\n            }\n        });\n        return (this.sealed && !this.inProcessChildren) ? null : super.insertChild(...arguments);\n    }\n    /**\n     * Override in subclasses to prevent this column from being filled with the {@link Grid.feature.FillHandle} feature\n     * @param {Object} data Object containing information about current cell and fill value\n     * @param {Grid.util.Location} data.cell Current cell data\n     * @param {Grid.util.Location[]} data.range Range from where to calculate values\n     * @param {Core.data.Model} data.record Current cell record\n     * @returns {Boolean}\n     * @internal\n     */\n    canFillValue() {\n        return true;\n    }\n    //endregion\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    // It extracts the current configs (fields) for the column, with special handling for sortable, editor, renderer and\n    // headerRenderer\n    getCurrentConfig(options) {\n        const result = super.getCurrentConfig(options);\n        // Use unbound sort fn\n        if (this.sortable?.originalSortFn) {\n            result.sortable = this.sortable.originalSortFn;\n        }\n        // Don't include internalRenderer in current config\n        if (result.renderer === this.internalRenderer) {\n            delete result.renderer;\n        }\n        // Same for headerRenderer\n        if (result.headerRenderer === this.internalHeaderRenderer) {\n            delete result.headerRenderer;\n        }\n        delete result.ariaLabel;\n        delete result.cellAriaLabel;\n        return result;\n    }\n}\n// Registered in ColumnStore as we can't have this in Column due to circular dependencies\nColumn.emptyCount = 0;\nColumn.defaultWidth = 100;\nColumn.exposeProperties();\nColumn._$name = 'Column';", "import Store from '../../Core/data/Store.js';\nimport Column from '../column/Column.js';\nimport Localizable from '../../Core/localization/Localizable.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport Objects from '../../Core/helper/util/Objects.js';\n/**\n * @module Grid/data/ColumnStore\n */\nconst\n    columnDefinitions = {\n        boolean : {\n            type : 'check'\n        },\n        date : {\n            type : 'date'\n        },\n        integer : {\n            type   : 'number',\n            format : {\n                maximumFractionDigits : 0\n            }\n        },\n        number : {\n            type : 'number'\n        }\n    },\n    lockedColumnSorters = [{\n        field : 'region'\n    }];\n/**\n * A store specialized in handling columns. Used by the Grid to hold its columns and used as a chained store by each SubGrid\n * to hold theirs. Should not be instanced directly, instead access it through `grid.columns` or `subGrid.columns`\n *\n * ```javascript\n * // resize first column\n * grid.columns.first.width = 200;\n *\n * // remove city column\n * grid.columns.get('city').remove();\n *\n * // add new column\n * grid.columns.add({text : 'New column'});\n *\n * // add new column to specific region (SubGrid)\n * grid.columns.add({text : 'New column', region : 'locked'});\n *\n * // add new column to 'locked' region (SubGrid)\n * grid.columns.add({text : 'New column', locked : true});\n * ```\n *\n * @extends Core/data/Store\n */\nexport default class ColumnStore extends Localizable(Store) {\n    //region Events\n    /**\n     * Fires when a column is shown.\n     * @event columnShow\n     * @param {Grid.data.ColumnStore} source The store which triggered the event.\n     * @param {Grid.column.Column} column The column which status has been changed.\n     */\n    /**\n     * Fires when a column has been hidden.\n     * @event columnHide\n     * @param {Grid.data.ColumnStore} source The store which triggered the event.\n     * @param {Grid.column.Column} column The column which status has been changed.\n     */\n    //endregion\n    static get defaultConfig() {\n        return {\n            modelClass : Column,\n            tree       : true,\n            /**\n             * Automatically adds a field definition to the store used by the Grid when adding a new Column displaying a\n             * non-existing field.\n             *\n             * To enable this behaviour:\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *     columns : {\n             *         autoAddField : true,\n             *         data         : [\n             *             // Column definitions here\n             *         ]\n             *     }\n             * }\n             *\n             * @config {Boolean}\n             * @default\n             */\n            autoAddField : false,\n            /**\n             * `ColumnStore` uses `syncDataOnLoad` by default (with `threshold : 1`), to ensure good performance when\n             * binding to columns in frameworks.\n             *\n             * See {@link Core/data/Store#config-syncDataOnLoad} for more information.\n             *\n             * @config {Boolean|SyncDataOnLoadOptions}\n             * @default true\n             * @readonly\n             */\n            syncDataOnLoad : {\n                threshold : 1\n            },\n            // Locked columns must sort to before non-locked\n            sorters : lockedColumnSorters,\n            // Make sure regions stick together when adding columns\n            reapplySortersOnAdd : true\n        };\n    }\n    construct(config) {\n        const me = this;\n        // Consequences of ColumnStore construction can cause reading of grid.columns\n        // so set the property early.\n        if (config.grid) {\n            config.grid._columnStore = me;\n            me.id = `${config.grid.id}-columns`;\n            // Visible columns must be invalidated on expand/collapse\n            config.grid.ion({\n                subGridCollapse : 'clearSubGridCaches',\n                subGridExpand   : 'clearSubGridCaches',\n                thisObj         : me\n            });\n        }\n        super.construct(config);\n        // So that we can invalidate cached collections which take computing so that we compute them\n        // only when necessary. For example when asking for the visible leaf columns, we do not want\n        // to compute that each time.\n        me.ion({\n            change  : me.onStoreChange,\n            sort    : () => me.updateChainedStores(),\n            thisObj : me,\n            prio    : 1\n        });\n    }\n    doDestroy() {\n        const allColumns = [];\n        if (!this.isChained) {\n            this.traverse(column => allColumns.push(column));\n        }\n        super.doDestroy();\n        // Store's destroy unjoins all records. Destroy all columns *after* that.\n        if (!this.isChained) {\n            allColumns.forEach(column => column.destroy());\n        }\n    }\n    // Overridden because the flat collection only contains top level columns,\n    // not leaves - group columns are *not* expanded.\n    /**\n     * Get column by id.\n     * @param {String|Number} id\n     * @returns {Grid.column.Column}\n     */\n    getById(id) {\n        return super.getById(id) || this.idRegister[id];\n    }\n    forEach(fn, thisObj = this) {\n        // Override to omit root\n        this.traverseWhile((n, i) => fn.call(thisObj, n, i), true);\n    }\n    get totalFixedWidth() {\n        let result = 0;\n        for (const col of this) {\n            if (!col.hidden) {\n                // if column has children (grouped header) use they to width increment\n                if (col.children) {\n                    col.children.forEach(childCol => result += this.calculateFixedWidth(childCol));\n                }\n                else {\n                    result += this.calculateFixedWidth(col);\n                }\n            }\n        }\n        return result;\n    }\n    get hasFlex() {\n        return this.visibleColumns.some(column => column.flex);\n    }\n    calculateFixedWidth(column) {\n        if (column.flex) {\n            return column.measureSize(Column.defaultWidth);\n        }\n        else {\n            return Math.max(column.measureSize(column.width), column.measureSize(column.minWidth));\n        }\n    }\n    /**\n     * Returns the top level columns. If using grouped columns, this is the top level columns. If no grouped\n     * columns are being used, this is the leaf columns.\n     * @property {Grid.column.Column[]}\n     * @readonly\n     */\n    get topColumns() {\n        return this.isChained ? this.masterStore.rootNode.children.filter(this.chainedFilterFn) : this.rootNode.children;\n    }\n    /**\n     * Returns the visible leaf headers which drive the rows' cell content.\n     * @property {Grid.column.Column[]}\n     * @readonly\n     */\n    get visibleColumns() {\n        const me = this;\n        if (!me._visibleColumns) {\n            me._visibleColumns = me.leaves.filter(column => column.isVisible && (!column.subGrid || !column.subGrid.collapsed));\n        }\n        return me._visibleColumns;\n    }\n    onStoreChange({ action, changes }) {\n        // no need to clear cache while resizing, or if column changes name\n        if (action === 'update' && !('hidden' in changes)) {\n            return;\n        }\n        this.clearCaches();\n    }\n    clearSubGridCaches({ subGrid }) {\n        subGrid.columns.clearCaches();\n        this.clearCaches();\n    }\n    clearCaches() {\n        this._visibleColumns = null;\n        this.masterStore?.clearCaches();\n    }\n    onMasterDataChanged(event) {\n        super.onMasterDataChanged(event);\n        // If master store has changes we also need to clear cached columns, in case a column was hidden\n        // no need to clear cache while resizing, or if column changes name\n        if (event.action !== 'update' || ('hidden' in event.changes)) {\n            this.clearCaches();\n        }\n    }\n    getAdjacentVisibleLeafColumn(columnOrId, next = true, wrap = false) {\n        const\n            columns = this.visibleColumns,\n            column  = (columnOrId instanceof Column) ? columnOrId : this.getById(columnOrId);\n        let idx = columns.indexOf(column) + (next ? 1 : -1);\n        // If we walked off either end, wrap if directed to do so,\n        // otherwise, return null;\n        if (!columns[idx]) {\n            if (wrap) {\n                idx = next ? 0 : columns.length - 1;\n            }\n            else {\n                return null;\n            }\n        }\n        return columns[idx];\n    }\n    /**\n     * Bottom columns are the ones displayed in the bottom row of a grouped header, or all columns if not using a grouped\n     * header. They are the columns that actually display any data.\n     * @property {Grid.column.Column[]}\n     * @readonly\n     */\n    get bottomColumns() {\n        return this.leaves;\n    }\n    /**\n     * Get column by field. To be sure that you are getting exactly the intended column, use {@link Core.data.Store#function-getById Store#getById()} with the\n     * columns id instead.\n     * @param {String} field Field name\n     * @returns {Grid.column.Column}\n     */\n    get(field) {\n        return this.findRecord('field', field, true);\n    }\n    /**\n     * Used internally to create a new record in the store. Creates a column of the correct type by looking up the\n     * specified type among registered columns.\n     * @private\n     */\n    createRecord(data) {\n        const\n            { grid = {} } = this, // Some ColumnStore tests lacks Grid\n            { store }     = grid,\n            dataField     = store?.modelClass?.fieldMap?.[data.field];\n        let columnClass = this.modelClass;\n        // Use the DataField's column definition as a default into which the incoming data is merged\n        if (dataField?.column) {\n            data = Objects.merge({}, dataField.column, data);\n        }\n        if (data.type) {\n            columnClass = ColumnStore.getColumnClass(data.type);\n            if (!columnClass) {\n                throw new Error(`Column type '${data.type}' not registered`);\n            }\n        }\n        if (data.locked) {\n            data.region = 'locked';\n            delete data.locked;\n        }\n        const column = new columnClass(data, this);\n        // Doing this after construction, in case the columnClass has a default value for region (Schedulers\n        // TimeAxisColumn has)\n        if (!column.data.region) {\n            column.data.region = grid.defaultRegion || 'normal';\n        }\n        // Add missing fields to Grids stores model\n        if (this.autoAddField && !column.noFieldSpecified && store && !dataField) {\n            let fieldDefinition = column.field;\n            // Some columns define the type to use for new fields (date, number etc)\n            if (column.constructor.fieldType) {\n                fieldDefinition = {\n                    name : column.field,\n                    type : column.constructor.fieldType\n                };\n            }\n            store.modelClass.addField(fieldDefinition);\n        }\n        return column;\n    }\n    /**\n     * indexOf extended to also accept a columns field, for backward compatibility.\n     * ```\n     * grid.columns.indexOf('name');\n     * ```\n     * @param {Core.data.Model|String} recordOrId\n     * @returns {Number}\n     */\n    indexOf(recordOrId) {\n        if (recordOrId == null) {\n            return -1;\n        }\n        const index = super.indexOf(recordOrId);\n        if (index > -1) return index;\n        // no record found by id, find by field since old code relies on that instead of id\n        return this.records.findIndex(r => r.field === recordOrId);\n    }\n    /**\n     * Removes all columns.\n     * @param {Boolean} [silent] Specify `true` to suppress events\n     * @returns {Boolean} `true` unless the action was prevented, in which case it returns `false`\n     * @fires beforeRemove\n     * @fires removeAll\n     * @fires change\n     * @category CRUD\n     */\n    removeAll(silent = false) {\n        const\n            me         = this,\n            isTimeAxis = me.some(i => i.isTimeAxisColumn);\n        if (isTimeAxis) {\n            return me.remove(me.query(i => !i.isTimeAxisColumn), silent);\n        }\n        return super.removeAll(silent);\n    }\n    /**\n     * Checks if any column uses autoHeight\n     * @internal\n     * @property {Boolean}\n     * @readonly\n     */\n    get usesAutoHeight() {\n        return this.find(column => column.autoHeight);\n    }\n    /**\n     * Checks if any flex column uses autoHeight\n     * @internal\n     * @property {Boolean}\n     * @readonly\n     */\n    get usesFlexAutoHeight() {\n        return this.find(column => column.autoHeight && column.flex != null);\n    }\n    // Let syncDataOnLoad match on id, field or type (in that order)\n    resolveSyncNode(rawData) {\n        if (rawData.id) {\n            return super.resolveSyncNode(rawData);\n        }\n        if (rawData.field) {\n            return {\n                id   : rawData.field,\n                node : this.allRecords.find(r => r.field === rawData.field)\n            };\n        }\n        if (rawData.type) {\n            return {\n                id   : rawData.type,\n                node : this.allRecords.find(r => r.type === rawData.type)\n            };\n        }\n        return { id : null, node : null };\n    }\n    //region Column types\n    /**\n     * Call from custom column to register it with ColumnStore. Required to be able to specify type in column config.\n     * @param {Function} columnClass The {@link Grid.column.Column} subclass to register.\n     * @param {Boolean} simpleRenderer Pass `true` if its default renderer does *not* use other fields from the passed\n     * record than its configured {@link Grid.column.Column#config-field}. This enables more granular cell updating\n     * upon record mutation.\n     *\n     * ```javascript\n     * // create and register custom column\n     * class CustomColumn {\n     *  static get type() {\n     *      return 'custom';\n     *  }\n     * }\n     * ColumnStore.registerColumnType(CustomColumn, true);\n     * // now possible to specify in column config\n     * let grid = new Grid({\n     *   columns: [\n     *     { type: 'custom', field: 'id' }\n     *   ]\n     * });\n     * ```\n     */\n    static registerColumnType(columnClass, simpleRenderer = false) {\n        columnClass.simpleRenderer = simpleRenderer;\n        (ColumnStore.columnTypes || (ColumnStore.columnTypes = {}))[columnClass.type] = columnClass;\n    }\n    /**\n     * Returns registered column class for specified type.\n     * @param type Type name\n     * @returns {Grid.column.Column}\n     * @internal\n     */\n    static getColumnClass(type) {\n        return ColumnStore.columnTypes && ColumnStore.columnTypes[type];\n    }\n    /**\n     * Generates a <strong>new </strong> {@link Grid.column.Column} instance which may be subsequently added to this\n     * store to represent the passed {@link Core.data.field.DataField} of the owning Grid's store.\n     * @param {Core.data.field.DataField|String} dataField The {@link Core.data.field.DataField field}\n     * instance or field name to generate a new {@link Grid.column.Column} for.\n     *\n     * ```javascript\n     * // Add column for the \"team\" field.\n     * grid.columns.add(grid.columns.generateColumnForField('team', {\n     *     width : 200\n     * }));\n     * ```\n     *\n     * @param {Object} [defaults] Defaults to apply to the new column.\n     * @returns {Grid.column.Column} A new Column which will render and edit the field correctly.\n     * @internal\n     */\n    generateColumnForField(dataField, defaults) {\n        if (typeof dataField === 'string' && this.grid) {\n            dataField = this.grid.store?.modelClass.fieldMap[dataField];\n        }\n        let column = dataField.column || columnDefinitions[dataField.type] || {};\n        // Upgrade string to be the column tyope\n        if (typeof column === 'string') {\n            column = { type : column };\n        }\n        // Configure over defaults\n        column = Object.assign({\n            text  : dataField.text || StringHelper.separate(dataField.name),\n            field : dataField.name\n        }, defaults, column);\n        // Special formatting for columns which represent number and integer fields.\n        if (dataField.precision != null) {\n            column.format.maximumFractionDigits = dataField.precision;\n        }\n        if (dataField.columnType) {\n            column.type = dataField.columnType;\n        }\n        // Upgrade object to a Column instance.\n        return this.createRecord(column);\n    }\n    //endregion\n}\n/**\n * Custom {@link Grid.data.ColumnStore} event which triggers when a column is resized, i.e. its width has been changed\n *\n * @param {Function} handler\n * @param {Object} [thisObj]\n */\nexport const columnResizeEvent = (handler, thisObj) => ({\n    update : ({ store, record, changes }) => {\n        let result = true;\n        if ('width' in changes || 'minWidth' in changes  || 'maxWidth' in changes || 'flex' in changes) {\n            result = handler.call(thisObj, { store, record, changes });\n        }\n        return result;\n    }\n});\n// Can't have this in Column due to circular dependencies\nColumnStore.registerColumnType(Column, true);\nColumnStore._$name = 'ColumnStore';", "import WidgetHelper from '../../Core/helper/WidgetHelper.js';\nimport Column from './Column.js';\nimport ColumnStore from '../data/ColumnStore.js';\n/**\n * @module Grid/column/WidgetColumn\n */\n/**\n * A column that displays widgets in the grid cells.\n *\n * {@inlineexample Grid/column/WidgetColumn.js}\n *\n * ```javascript\n * new Grid({\n *     appendTo : document.body,\n *\n *     columns : [\n *         {\n *              type: 'widget',\n *              text: 'Name',\n *              widgets: [\n *                  { type: 'textfield', name : 'firstName' },\n *                  { type: 'textfield', name : 'lastName' }\n *               ]\n *         }\n *     ]\n * });\n * ```\n *\n * If you use {@link Core.widget.Field Fields} inside this column, the field widget can optionally bind its value to a\n * field in the data model using the {@link Core/widget/Field#config-name} (as shown in the snippet above). This will\n * provide two-way data binding and update the underlying row record as you make changes in the field.\n *\n * If you use a {@link Core.widget.Button} and want it to display the value from the cell as its text, set its\n * {@link Core/widget/Widget#config-defaultBindProperty} to `'text'`:\n *\n * ```javascript\n * new Grid({\n *     columns : [\n *         {\n *              type: 'widget',\n *              widgets: [\n *                  { type: 'button', name : 'age', defaultBindProperty : 'text' },\n *               ]\n *         }\n *     ]\n * });\n * ```\n *\n * There is no `editor` provided. It is the configured widget's responsibility to provide editing if needed.\n *\n * @extends Grid/column/Column\n * @classtype widget\n * @column\n */\nexport default class WidgetColumn extends Column {\n    //region Config\n    static $name = 'WidgetColumn';\n    static type = 'widget';\n    static fields = [\n        /**\n         * An array of {@link Core.widget.Widget} config objects\n         * @config {ContainerItemConfig[]} widgets\n         * @category Common\n         */\n        'widgets'\n    ];\n    /**\n     * A renderer function, which gives you access to render data like the current `record`, `cellElement` and the\n     * {@link #config-widgets} of the column. See {@link #config-renderer}\n     * for more information.\n     *\n     * ```javascript\n     * new Grid({\n     *     columns : [\n     *         {\n     *              type: 'check',\n     *              field: 'allow',\n     *              // In the column renderer, we get access to the record and column widgets\n     *              renderer({ record, widgets }) {\n     *                  // Hide checkboxes in certain rows\n     *                  widgets[0].hidden = record.readOnly;\n     *              }\n     *         }\n     *     ]\n     * });\n     * ```\n     *\n     * @config {Function} renderer\n     * @param {Object} renderData Object containing renderer parameters\n     * @param {HTMLElement} renderData.cellElement Cell element, for adding CSS classes, styling etc. Can be `null` in case of export\n     * @param {*} renderData.value Value to be displayed in the cell\n     * @param {Core.data.Model} renderData.record Record for the row\n     * @param {Grid.column.Column} renderData.column This column\n     * @param {Core.widget.Widget[]} renderData.widgets An array of the widgets rendered into this cell\n     * @param {Grid.view.Grid} renderData.grid This grid\n     * @param {Grid.row.Row} renderData.row Row object. Can be null in case of export.\n     *   Use the {@link Grid.row.Row#function-assignCls row's API} to manipulate CSS class names.\n     * @param {Object} renderData.size Set `size.height` to specify the desired row height for the current row.\n     *   Largest specified height is used, falling back to configured {@link Grid/view/Grid#config-rowHeight}\n     *   in case none is specified. Can be null in case of export\n     * @param {Number} renderData.size.height Set this to request a certain row height\n     * @param {Number} renderData.size.configuredHeight Row height that will be used if none is requested\n     * @param {Boolean} renderData.isExport True if record is being exported to allow special handling during export\n     * @param {Boolean} renderData.isTreeGroup True if record is a generated tree group parent record\n     * @param {Boolean} renderData.isMeasuring True if the column is being measured for a `resizeToFitContent` call.\n     *   In which case an advanced renderer might need to take different actions.\n     * @returns {void}\n     *\n     * @category Rendering\n     */\n    static get defaults() {\n        return {\n            filterable      : false,\n            sortable        : false,\n            editor          : false,\n            searchable      : false,\n            fitMode         : false,\n            alwaysClearCell : false\n        };\n    }\n    //endregion\n    //region Init / Destroy\n    construct(config, store) {\n        const me = this;\n        me.widgetMap = {};\n        super.construct(...arguments);\n        // If column is cloned, renderer is already set up\n        if (me.renderer !== me.internalRenderer) {\n            me.externalRenderer = me.renderer;\n            me.renderer = me.internalRenderer;\n        }\n    }\n    doDestroy() {\n        // Destroy all the widgets we created.\n        for (const widget of Object.values(this.widgetMap)) {\n            widget.destroy && widget.destroy();\n        }\n        super.doDestroy();\n    }\n    // Called by grid when its read-only state is toggled\n    updateReadOnly(readOnly) {\n        for (const widget of Object.values(this.widgetMap)) {\n            if (!widget.cellInfo.record.readOnly) {\n                widget.readOnly = readOnly;\n            }\n        }\n    }\n    //endregion\n    //region Render\n    /**\n     * Renderer that displays a widget in the cell.\n     * @param {Object} renderData Render data\n     * @param {Grid.column.Column} renderData.column Rendered column\n     * @param {Core.data.Model} renderData.record Rendered record\n     * @private\n     */\n    internalRenderer(renderData) {\n        const\n            me                                        = this,\n            { cellElement, column, record, isExport } = renderData,\n            { widgets }                               = column;\n        // This renderer might be called from subclasses by accident\n        // This condition saves us from investigating bug reports\n        if (!isExport && widgets) {\n            // If there is no widgets yet and we're going to add them,\n            // need to make sure there is no content left in the cell after its previous usage\n            // by grid features such as grouping feature or so.\n            if (!cellElement.widgets) {\n                // Reset cell content\n                me.clearCell(cellElement);\n            }\n            cellElement.widgets = renderData.widgets = widgets.map((widgetCfg, i) => {\n                let widget, widgetNextSibling;\n                // If cell element already has widgets, check if we need to destroy/remove one\n                if (cellElement.widgets) {\n                    // Current widget\n                    widget = cellElement.widgets[i];\n                    // Store next element sibling to insert widget to correct position later\n                    widgetNextSibling = widget.element.nextElementSibling;\n                    // If we are not syncing content for present widget, remove it from cell and render again later\n                    if (widgetCfg.recreate && widget) {\n                        // destroy widget and remove reference to it\n                        delete me.widgetMap[widget.id];\n                        widget.destroy();\n                        cellElement.widgets[i] = null;\n                    }\n                }\n                // Ensure widget is created if first time through\n                if (!widget) {\n                    me.onBeforeWidgetCreate(widgetCfg, renderData);\n                    widgetCfg.recomposeAsync = false;\n                    widgetCfg.owner = me.grid;\n                    widget = WidgetHelper.append(widgetCfg, widgetNextSibling ? { insertBefore : widgetNextSibling } : cellElement)[0];\n                    me.widgetMap[widget.id] = widget;\n                    me.onAfterWidgetCreate(widget, renderData);\n                    if (widget.name) {\n                        widget.ion({\n                            change : ({ value, userAction }) => {\n                                if (userAction) {\n                                    widget.cellInfo.record.setValue(widget.name, value);\n                                }\n                            }\n                        });\n                    }\n                }\n                widget.cellInfo = {\n                    record,\n                    column\n                };\n                if (me.grid && !me.meta.isSelectionColumn) {\n                    widget.readOnly = me.grid.readOnly || record.readOnly;\n                }\n                if (me.onBeforeWidgetSetValue?.(widget, renderData) !== false) {\n                    const valueProperty = widgetCfg.valueProperty || ('value' in widget && 'value') || widget.defaultBindProperty;\n                    if (valueProperty) {\n                        const value = widget.name ? record.getValue(widget.name) : renderData.value;\n                        widget[valueProperty] = value;\n                    }\n                }\n                me.onAfterWidgetSetValue?.(widget, renderData);\n                return widget;\n            });\n        }\n        const result = me.externalRenderer?.(renderData);\n        if (isExport) {\n            return result;\n        }\n        if (!result && !widgets) {\n            return '';\n        }\n        return result;\n    }\n    //endregion\n    //region Other\n    /**\n     * Called before widget is created on rendering\n     * @param {ContainerItemConfig} widgetCfg Widget config\n     * @param {Object} renderData Render data\n     * @private\n     */\n    onBeforeWidgetCreate(widgetCfg, renderData) {}\n    /**\n     * Called after widget is created on rendering\n     * @param {Core.widget.Widget} widget Created widget\n     * @param {Object} renderData Render data\n     * @private\n     */\n    onAfterWidgetCreate(widget, renderData) {}\n    /**\n     * Called before the widget gets its value on rendering. Pass `false` to skip value setting while rendering\n     * @preventable\n     * @function onBeforeWidgetSetValue\n     * @param {Core.widget.Widget} widget Created widget\n     * @param {Object} renderData Render data\n     * @param {Grid.column.Column} renderData.column Rendered column\n     * @param {Core.data.Model} renderData.record Rendered record\n     */\n    /**\n     * Called after the widget gets its value on rendering.\n     * @function onAfterWidgetSetValue\n     * @param {Core.widget.Widget} widget Created widget\n     * @param {Object} renderData Render data\n     * @param {Grid.column.Column} renderData.column Rendered column\n     * @param {Core.data.Model} renderData.record Rendered record\n     */\n    // Overrides base implementation to cleanup widgets, for example when a cell is reused as part of group header\n    clearCell(cellElement) {\n        if (cellElement.widgets) {\n            cellElement.widgets.forEach(widget => {\n                // Destroy widget and remove reference to it\n                delete this.widgetMap[widget.id];\n                widget.destroy();\n            });\n            cellElement.widgets = null;\n        }\n        // Even if there is no widgets need to make sure there is no content left, for example after a cell has been reused as part of group header\n        super.clearCell(cellElement);\n    }\n    // Null implementation because there is no way of ascertaining whether the widgets get their width from\n    // the column, or the column shrinkwraps the Widget.\n    // Remember that the widget could have a width from a CSS rule which we cannot read.\n    // It might have width: 100%, or a flex which would mean it is sized by us, but we cannot read that -\n    // getComputedStyle would return the numeric width.\n    resizeToFitContent() {}\n    //endregion\n}\nColumnStore.registerColumnType(WidgetColumn);\nWidgetColumn.exposeProperties();\nWidgetColumn._$name = 'WidgetColumn';", "import ColumnStore from '../data/ColumnStore.js';\nimport WidgetColumn from './WidgetColumn.js';\nimport Checkbox from '../../Core/widget/Checkbox.js';\n/**\n * @module Grid/column/CheckColumn\n */\n/**\n * A column that displays a checkbox in the cell. The value of the backing field is toggled by the checkbox.\n *\n * Toggling of the checkboxes is disabled if a record is readOnly or if the CellEdit feature is not enabled.\n *\n * This column renders a {@link Core.widget.Checkbox checkbox} into each cell, and it is not intended to be changed.\n * If you want to hide certain checkboxes, you can use the {@link #config-renderer} method to access the checkbox widget\n * as it is being rendered.\n *\n * <div class=\"note\">\n * It is <strong>not valid</strong> to use this column without a {@link #config-field} setting because the\n * checked/unchecked state needs to be backed up in a record because rows are recycled and the state will be lost when a\n * row is reused.\n * </div>\n *\n * ```javascript\n * new Grid({\n *     appendTo : document.body,\n *\n *     columns : [\n *         {\n *              type: 'check',\n *              field: 'allow',\n *              // In the column renderer, we get access to the record and CheckBox widget\n *              renderer({ record, widgets }) {\n *                  // Hide checkboxes in certain rows\n *                  widgets[0].hidden = record.readOnly;\n *              }\n *         }\n *     ]\n * });\n * ```\n *\n * {@inlineexample Grid/column/CheckColumn.js}\n *\n * @extends Grid/column/WidgetColumn\n * @classtype check\n * @column\n */\nexport default class CheckColumn extends WidgetColumn {\n    //region Config\n    static $name = 'CheckColumn';\n    static type = 'check';\n    static fields = [\n        'checkCls',\n        'showCheckAll',\n        'onAfterWidgetSetValue',\n        'onBeforeWidgetSetValue',\n        'callOnFunctions',\n        'onBeforeToggle',\n        'onToggle',\n        'onToggleAll'\n    ];\n    static defaults = {\n        align : 'center',\n        /**\n         * CSS class name to add to checkbox\n         * @config {String}\n         * @category Rendering\n         */\n        checkCls : null,\n        /**\n         * True to show a checkbox in the column header to be able to select/deselect all rows\n         * @config {Boolean}\n         */\n        showCheckAll : false,\n        sortable : true,\n        filterable : true,\n        widgets : [{\n            type          : 'checkbox',\n            valueProperty : 'checked'\n        }]\n    };\n    construct(config, store) {\n        super.construct(...arguments);\n        const me = this;\n        Object.assign(me, {\n            externalHeaderRenderer         : me.headerRenderer,\n            externalOnBeforeWidgetSetValue : me.onBeforeWidgetSetValue,\n            externalOnAfterWidgetSetValue  : me.onAfterWidgetSetValue,\n            onBeforeWidgetSetValue : me.internalOnBeforeWidgetSetValue,\n            onAfterWidgetSetValue  : me.internalOnAfterWidgetSetValue,\n            headerRenderer         : me.internalHeaderRenderer\n        });\n        if (!me.meta.isSelectionColumn) {\n            const modelClass = me.grid?.store.modelClass;\n            if (!me.field) {\n                console.warn('CheckColumn MUST be configured with a field, otherwise the checked state will not be persistent. Widgets are recycled and reused');\n            }\n            else if (modelClass && !modelClass.fieldMap[me.field] && !me.constructor.suppressNoModelFieldWarning) {\n                console.warn(me.$$name + ' is configured with a field, but this is not part of your Model `fields` collection.');\n                modelClass.addField({ name : me.field, type : 'boolean' });\n            }\n        }\n    }\n    doDestroy() {\n        this.headerCheckbox?.destroy();\n        super.doDestroy();\n    }\n    internalHeaderRenderer({ headerElement, column }) {\n        let returnValue;\n        headerElement.classList.add('b-check-header');\n        if (column.showCheckAll) {\n            headerElement.classList.add('b-check-header-with-checkbox');\n            if (column.headerCheckbox) {\n                headerElement.appendChild(column.headerCheckbox.element);\n            }\n            else {\n                column.headerCheckbox = new Checkbox({\n                    appendTo          : headerElement,\n                    owner             : this.grid,\n                    ariaLabel         : 'L{Checkbox.toggleSelection}',\n                    internalListeners : {\n                        change  : 'onCheckAllChange',\n                        thisObj : column\n                    }\n                });\n            }\n        }\n        else {\n            returnValue = column.headerText;\n        }\n        returnValue = column.externalHeaderRenderer ? column.externalHeaderRenderer.call(this, ...arguments) : returnValue;\n        return column.showCheckAll ? undefined : returnValue;\n    }\n    updateCheckAllState(value) {\n        if (this.headerCheckbox) {\n            this.headerCheckbox.suspendEvents();\n            this.headerCheckbox.checked = value;\n            this.headerCheckbox.resumeEvents();\n        }\n    }\n    onCheckAllChange({ checked }) {\n        const me = this;\n        // If this column is bound to a field, update all records\n        if (me.field) {\n            const { store } = me.grid;\n            store.beginBatch();\n            store.forEach(record => me.updateRecord(record, me.field, checked));\n            store.endBatch();\n        }\n        /**\n         * Fired when the header checkbox is clicked to toggle its checked status.\n         * @event toggleAll\n         * @param {Grid.column.CheckColumn} source This Column\n         * @param {Boolean} checked The checked status of the header checkbox.\n         */\n        me.trigger('toggleAll', { checked });\n    }\n    //endregion\n    internalRenderer({ value, isExport, record, cellElement }) {\n        const result = super.internalRenderer(...arguments);\n        if (isExport) {\n            return result != null ? result : value == null ? '' : value;\n        }\n        if (record.readOnly && !this.meta.isSelectionColumn) {\n            cellElement.widgets[0].readOnly = true;\n        }\n        // In export, we're reusing widgets, therefore we need to clean the `checked` attribute by hand\n        if (value) {\n            cellElement.widgets[0].input.setAttribute('checked', true);\n        }\n        else {\n            cellElement.widgets[0].input.removeAttribute('checked');\n        }\n        return result;\n    }\n    //region Widget rendering\n    onBeforeWidgetCreate(widgetCfg, event) {\n        widgetCfg.cls = this.checkCls;\n    }\n    onAfterWidgetCreate(widget, event) {\n        event.cellElement.widget = widget;\n        widget.ion({\n            beforeChange : 'onBeforeCheckboxChange',\n            change       : 'onCheckboxChange',\n            thisObj      : this\n        });\n    }\n    internalOnBeforeWidgetSetValue(widget) {\n        widget.record     = widget.cellInfo.record;\n        this.isInitialSet = true;\n        this.externalOnBeforeWidgetSetValue?.(...arguments);\n    }\n    internalOnAfterWidgetSetValue(widget) {\n        this.isInitialSet = false;\n        this.externalOnAfterWidgetSetValue?.(...arguments);\n    }\n    //endregion\n    //region Events\n    onBeforeCheckboxChange({ source, checked, userAction }) {\n        const\n            me         = this,\n            { grid }   = me,\n            { record } = source.cellInfo;\n        // If we are bound to a data field, ensure we respect cellEdit setting\n        if ((userAction && me.field && (!grid.features.cellEdit || grid.features.cellEdit.disabled)) || (me.meta.isSelectionColumn && !grid.isSelectable(record) && checked)) {\n            return false;\n        }\n        if (!me.isInitialSet) {\n            /**\n             * Fired when a cell is clicked to toggle its checked status. Returning `false` will prevent status change.\n             * @event beforeToggle\n             * @param {Grid.column.Column} source This Column\n             * @param {Core.data.Model} record The record for the row containing the cell.\n             * @param {Boolean} checked The new checked status of the cell.\n             */\n            return me.trigger('beforeToggle', { record, checked });\n        }\n    }\n    onCheckboxChange({ source, checked }) {\n        if (!this.isInitialSet) {\n            const\n                me         = this,\n                { record } = source.cellInfo,\n                { field }  = me;\n            if (field) {\n                me.updateRecord(record, field, checked);\n                // Keep header checkbox in sync with reality.\n                if (checked) {\n                    // We check whether *all* records in the store are checked including filtered out ones.\n                    me.updateCheckAllState(me.grid.store.every(r => r[field], null, true));\n                }\n                else {\n                    me.updateCheckAllState(false);\n                }\n            }\n            /**\n             * Fired when a cell is clicked to toggle its checked status.\n             * @event toggle\n             * @param {Grid.column.Column} source This Column\n             * @param {Core.data.Model} record The record for the row containing the cell.\n             * @param {Boolean} checked The new checked status of the cell.\n             */\n            me.trigger('toggle', { record, checked, checkbox : source });\n        }\n    }\n    updateRecord(record, field, checked) {\n        record.setValue(field, checked);\n    }\n    //endregion\n    onCellKeyDown({ event, cellElement }) {\n        // SPACE key toggles the checkbox\n        if (event.key === ' ') {\n            const checkbox = cellElement.widget;\n            checkbox?.toggle();\n            // Prevent native browser scrolling\n            event.preventDefault();\n            // KeyMap and other features (like context menu) must not process this.\n            event.handled = true;\n        }\n    }\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    // It extracts the current configs (fields) for the column, with special handling for the hooks\n    getCurrentConfig(options) {\n        const result = super.getCurrentConfig(options);\n        delete result.onBeforeWidgetSetValue;\n        delete result.onAfterWidgetSetValue;\n        if (this.externalOnBeforeWidgetSetValue) {\n            result.onBeforeWidgetSetValue = this.externalOnBeforeWidgetSetValue;\n        }\n        if (this.externalOnAfterWidgetSetValue) {\n            result.onAfterWidgetSetValue = this.externalOnAfterWidgetSetValue;\n        }\n        return result;\n    }\n}\nColumnStore.registerColumnType(CheckColumn, true);\nCheckColumn._$name = 'CheckColumn';", "import Column from './Column.js';\nimport ColumnStore from '../data/ColumnStore.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\n/**\n * @module Grid/column/RowNumberColumn\n */\n/**\n * A column that displays the row number in each cell.\n *\n * There is no `editor`, since value is read-only.\n *\n * ```javascript\n * const grid = new Grid({\n *   appendTo : targetElement,\n *   width    : 300,\n *   columns  : [\n *     { type : 'rownumber' }\n *   ]\n * });\n * ```\n *\n * {@inlineexample Grid/column/RowNumberColumn.js}\n *\n * @extends Grid/column/Column\n * @classtype rownumber\n * @column\n */\nexport default class RowNumberColumn extends Column {\n    static $name = 'RowNumberColumn';\n    static type = 'rownumber';\n    static get defaults() {\n        return {\n            /**\n             * @config {Boolean} groupable\n             * @hide\n             */\n            groupable : false,\n            /**\n             * @config {Boolean} sortable\n             * @hide\n             */\n            sortable : false,\n            /**\n             * @config {Boolean} filterable\n             * @hide\n             */\n            filterable : false,\n            /**\n             * @config {Boolean} searchable\n             * @hide\n             */\n            searchable : false,\n            /**\n             * @config {Boolean} resizable\n             * @hide\n             */\n            resizable : false,\n            /**\n             * @config {Boolean} draggable\n             * @hide\n             */\n            draggable : false,\n            minWidth : 50,\n            width    : 50,\n            align    : 'right',\n            text     : '#',\n            editor   : false,\n            readOnly : true\n        };\n    }\n    construct(config) {\n        super.construct(...arguments);\n        const\n            me       = this,\n            { grid } = me;\n        me.internalCellCls        = 'b-row-number-cell';\n        me.externalHeaderRenderer = me.headerRenderer;\n        me.headerRenderer         = me.internalHeaderRenderer;\n        if (grid) {\n            // Update our width when the store mutates (tests test Columns in isolation with no grid, so we must handle that!)\n            grid.ion({\n                bindStore : 'bindStore',\n                thisObj   : me\n            });\n            me.bindStore({ store : grid.store, initial : true });\n            if (grid.store.count && !grid.rendered) {\n                grid.ion({\n                    paint   : 'resizeToFitContent',\n                    thisObj : me,\n                    once    : true\n                });\n            }\n        }\n    }\n    get groupHeaderReserved() {\n        return true;\n    }\n    bindStore({ store, initial }) {\n        const me = this;\n        me.detachListeners('grid');\n        store.ion({\n            name                                  : 'grid',\n            [`change${me.grid.asyncEventSuffix}`] : 'onStoreChange',\n            thisObj                               : me\n        });\n        if (!initial && !me.resizeToFitContent()) {\n            me.measureOnRender();\n        }\n    }\n    onStoreChange({ action, isMove }) {\n        if (action === 'dataset' || action === 'add' || action === 'remove' || action === 'removeall') {\n            // Ignore remove phase of move operation, resize on add phase only\n            if (action === 'remove' && isMove) {\n                return;\n            }\n            const result = this.resizeToFitContent();\n            // Gantt/Scheduler draws later when loading using CrudManager (refresh is suspended), catch first draw\n            if (action === 'dataset' && !result && this.grid.store.count) {\n                this.measureOnRender();\n            }\n        }\n    }\n    measureOnRender() {\n        this.grid.rowManager.ion({\n            renderDone() {\n                this.resizeToFitContent();\n            },\n            once    : true,\n            thisObj : this\n        });\n    }\n    /**\n     * Renderer that displays the row number in the cell.\n     * @private\n     */\n    renderer({ record, grid }) {\n        return record.isSpecialRow ? '' : grid.store.indexOf(record, true) + 1;\n    }\n    /**\n     * Resizes the column to match the widest string in it. Called when you double click the edge between column\n     * headers\n     */\n    resizeToFitContent() {\n        const\n            me                 = this,\n            { store, element } = me.grid,\n            { count }          = store;\n        if (count && !me.hidden) {\n            const cellElement = element.querySelector(`.b-grid-cell[data-column-id=\"${me.id}\"]`);\n            if (cellElement) {\n                const\n                    cellPadding = cellElement.isConnected\n                        ? parseInt(DomHelper.getStyleValue(cellElement, 'padding-left'))\n                        : (me._cachedCellPadding || 0),\n                    maxWidth    = DomHelper.measureText(count, cellElement);\n                me.width = Math.max(me.minWidth, maxWidth + 2 * cellPadding);\n                // Save the cell padding, to be used if getStyleValue (above) fails. Which happens if this function\n                // gets called when the Grid is disconnected from the DOM\n                me._cachedCellPadding = cellPadding;\n                return true;\n            }\n        }\n        return false;\n    }\n    set flex(f) {\n    }\n    internalHeaderRenderer({ headerElement, column }) {\n        headerElement.classList.add('b-rownumber-header');\n        return column.externalHeaderRenderer?.call(this, ...arguments) || column.headerText;\n    }\n}\nColumnStore.registerColumnType(RowNumberColumn, true);\nRowNumberColumn._$name = 'RowNumberColumn';", "import InstancePlugin from '../../../Core/mixin/InstancePlugin.js';\nimport Clipboardable from '../../../Core/mixin/Clipboardable.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\n/**\n * @module Grid/feature/base/CopyPasteBase\n */\n/**\n * Base copy-paste functionality for row-based widgets. Not to be used directly.\n * @abstract\n * @extends Core/mixin/InstancePlugin\n * @mixes Core/mixin/Clipboardable\n */\nexport default class CopyPasteBase extends InstancePlugin.mixin(Clipboardable) {\n    static configurable = {\n        /**\n         * If `true` this prevents cutting and pasting. Will default to `true` if {@link Grid/feature/CellEdit} feature\n         * is disabled. Set to `false` to prevent this behaviour.\n         * @config {Boolean}\n         */\n        copyOnly : null,\n        /**\n         * Default keyMap configuration: Ctrl/Cmd+c to copy, Ctrl/Cmd+x to cut and Ctrl/Cmd+v to paste. These keyboard\n         * shortcuts require a selection to be made.\n         * @config {Object<String,String>}\n         */\n        keyMap : {\n            'Ctrl+C' : 'copy',\n            'Ctrl+X' : 'cut',\n            'Ctrl+V' : 'paste'\n        },\n        /**\n         * Set this to `false` to not use native Clipboard API even if it is available\n         * @config {Boolean}\n         * @default\n         */\n        useNativeClipboard : false,\n        /**\n         * Provide a function to be able to customize the string value which is copied\n         *\n         * ````javascript\n         * new Grid({\n         *     features : {\n         *         cellCopyPaste : {\n         *             toCopyString({currentValue, column, record}) {\n         *                 if(record.isAvatar){\n         *                     return record.fullName;\n         *                 }\n         *                 return currentValue;\n         *             }\n         *         }\n         *     }\n         * });\n         * ````\n         *\n         * Note that this function is only called when copying cell values or copying values from other Bryntum\n         * component instances or from native clipboard.\n         *\n         * @config {Function}\n         * @param {Object} data\n         * @param {String} data.currentValue\n         * @param {Grid.column.Column} data.column\n         * @param {Core.data.Model} data.record\n         * @returns {String}\n         */\n        toCopyString : null,\n        /**\n         * Provide a function to be able to customize the value which will be set onto the record\n         *\n         * ````javascript\n         * new Grid({\n         *     features : {\n         *         cellCopyPaste : {\n         *             toPasteValue({currentValue, column, record, field}) {\n         *                 if(typeof currentValue === 'string'){\n         *                     return currentValue.replace('$', '');\n         *                 }\n         *                 return currentValue;\n         *             }\n         *         }\n         *     }\n         * });\n         * ````\n         *\n         * Note that this function is only called when pasting string values, either from CellCopyPaste or copying\n         * values from other Bryntum component instances or from native clipboard.\n         *\n         * @config {Function}\n         * @param {Object} data\n         * @param {String} data.currentValue\n         * @param {Grid.column.Column} data.column\n         * @param {Core.data.Model} data.record\n         * @returns {String}\n         */\n        toPasteValue : null,\n        /**\n         * If an empty value (null or empty string) is copied or cut, this config will replace that value.\n         * This allows for clipboard data to skip columns.\n         *\n         * For example, look at these two selections\n         * |  ROW  |   0  |      1       |       2      |   3  |\n         * |-------|------|--------------|--------------|------|\n         * | ROW 1 | SEL1 | not selected | not selected | SEL2 |\n         * | ROW 2 | SEL3 | SEL4 (empty) | SEL5 (empty) | SEL6 |\n         *\n         * The clipboardData for `ROW 1` will look like this:\n         `* SEL1\\t\\t\\SEl2\\nSEL3\\t\\t\\SEL4`\n         *\n         * And `ROW 2` will look like this:\n         * `SEL3\\t\\u{0020}\\t\\u{0020}\\tSEL6`\n         *\n         * `ROW 1` will set value `SEL1` at column index 0 and `SEL2` at column index 3. This leaves column index 1 and\n         * 2 untouched.\n         *\n         * `ROW 2` will set value `SEL3` at column index 0, `u{0020}` at column index 1 and 2, and `SEL`6 at column\n         * index 3.\n         *\n         * The default `u{0020}` is a blank space.\n         *\n         * Note that this only applies when copy-pasting cell values or copying rows from other Bryntum component\n         * instances or from native clipboard.\n         *\n         * @config {String}\n         * @default\n         */\n        emptyValueChar : '\\u{0020}',\n        /**\n         * The format a copied date value should have when converted to a string. To learn more about available formats,\n         * check out {@link Core.helper.DateHelper} docs.\n         * @config {String}\n         */\n        dateFormat : 'lll'\n    };\n    // Internal backwards compatibility\n    get clipboardRecords() {\n        return this.clipboardData || [];\n    }\n    /**\n     * Used by CellCopyPaste and RowCopyPaste to generate string representations of grid records\n     * @param cells\n     * @returns {String}\n     * @private\n     */\n    cellsToString(cells) {\n        const\n            me           = this;\n        let lastRowIndex = 0,\n            lastColIndex = 0,\n            stringData   = '';\n        // Sorted by rowIndex then by columnIndex\n        cells.sort((c1, c2) => c1.rowIndex === c2.rowIndex ? c1.columnIndex - c2.columnIndex : c1.rowIndex - c2.rowIndex);\n        for (const cell of cells) {\n            const { record, _column : column, rowIndex, columnIndex } = cell;\n            // Separate with \\n if new row\n            if (rowIndex > lastRowIndex) {\n                if (stringData.length > 0) {\n                    stringData += '\\n'.repeat(rowIndex - lastRowIndex);\n                }\n                lastRowIndex = rowIndex;\n                lastColIndex = columnIndex;\n            }\n            // Separate with \\t if new column\n            else if (columnIndex > lastColIndex) {\n                if (stringData.length > 0) {\n                    stringData += '\\t'.repeat(columnIndex - lastColIndex);\n                }\n                lastColIndex = columnIndex;\n            }\n            // The column can provide its own toClipboardString\n            let cellValue = column?.toClipboardString?.(cell);\n            // Or we use the raw value from the record\n            if (cellValue === undefined) {\n                cellValue = record.getValue(column.field);\n                // If a date, format it with the configured dateFormat\n                if (cellValue instanceof Date) {\n                    cellValue = DateHelper.format(cellValue, me.dateFormat);\n                }\n                else {\n                    cellValue = cellValue?.toString();\n                }\n            }\n            // The client can provide its own as well.\n            if (me.toCopyString) {\n                cellValue = me.toCopyString({ currentValue : cellValue, column, record });\n            }\n            cellValue = cellValue?.replace(/[\\n\\t]/, ' ');\n            stringData += cellValue || me.emptyValueChar;\n        }\n        return stringData;\n    }\n    /**\n     * Sets tab and new-line separated string data into records.\n     * Used by CellCopyPaste to set values into existing records.\n     * Used by RowCopyPaste to create new records from values\n     * @param clipboardData\n     * @param createNewRecords If `false`, a selected cell is required and data will be set to existing records\n     * @param store The store which to set/create new data to. Defaults to the clients default store.\n     * @param fields Provide an array of string fields to create records instead of using columns\n     * @returns {Object} modificationData\n     * @private\n     */\n    setFromStringData(clipboardData, createNewRecords = false, store = this.client.store, fields) {\n        const\n            me              = this,\n            { client }      = me,\n            {\n                columns,\n                _shiftSelectRange\n            }               = client,\n            modifiedRecords = new Set(),\n            // Converts the clipboard data into a 2-dimensional array of string values.\n            rows            = me.stringAs2dArray(clipboardData),\n            selectedCell    = client.selectedCells[0],\n            targetCells     = [],\n            affectedCells   = [];\n        // If there is a selected range, pasting should be repeated into that range\n        if (!createNewRecords && _shiftSelectRange?.some(cell => cell.equals(selectedCell))) {\n            const cellRows = me.cellSelectorsAs2dArray(_shiftSelectRange);\n            // The selection must fit the whole paste content. If pasting 2 rows for example, a number of rows that is\n            // divisible by 2 is required. Same for columns.\n            if (cellRows?.length % rows.length === 0 && cellRows.columnCount % rows.columnCount === 0) {\n                // This code will calculate each cell target to repeat the pasting on\n                for (let curI = 0; curI < cellRows.length; curI += rows.length) {\n                    for (let curX = 0; curX < cellRows.columnCount; curX += rows.columnCount) {\n                        targetCells.push(cellRows[curI][curX]);\n                    }\n                }\n            }\n        }\n        // No valid range, just use one target\n        if (!targetCells.length) {\n            targetCells.push(selectedCell);\n        }\n        for (const targetCell of targetCells) {\n            for (let rI = 0; rI < rows.length; rI++) {\n                const\n                    row          = rows[rI],\n                    targetRecord = createNewRecords\n                        ? new store.modelClass()\n                        : store.getAt(targetCell.rowIndex + rI);\n                // Starts with targetCell rowIndex and columnIndex and applies values from the clipboard string.\n                // \\n is interpreted as rowIndex++\n                // \\t is interpreted as columnIndex++\n                if (targetRecord && !targetRecord.readOnly) {\n                    for (let cI = 0; cI < row.length; cI++) {\n                        const\n                            targetColumn = fields ? null\n                                : columns.visibleColumns[createNewRecords ? cI : targetCell.columnIndex + cI],\n                            targetField  = targetColumn?.field || fields?.[cI];\n                        let value        = row[cI];\n                        // If no value, this column/field is skipped\n                        if (targetField && value && !targetColumn?.readOnly) {\n                            if (value === me.emptyValueChar) {\n                                value = null;\n                            }\n                            // Column provided paste conversion function\n                            if (targetColumn?.fromClipboardString) {\n                                value = targetColumn.fromClipboardString({\n                                    string : value,\n                                    record : targetRecord\n                                });\n                            }\n                            // Client provided paste customization function\n                            if (me.toPasteValue) {\n                                value = me.toPasteValue({\n                                    currentValue : value,\n                                    record       : targetRecord,\n                                    column       : targetColumn,\n                                    field        : targetField\n                                });\n                            }\n                            // If field is a dateField, parse the value with the configured dateFormat\n                            if (typeof value === 'string' && targetRecord.getFieldDefinition(targetField)?.isDateDataField) {\n                                const parsedDate = DateHelper.parse(value, me.dateFormat);\n                                if (!isNaN(parsedDate.getTime())) {\n                                    value = parsedDate;\n                                }\n                            }\n                            targetRecord.set(targetField, value, false, false, false, true);\n                            affectedCells.push(client.normalizeCellContext({ column : targetColumn, record : targetRecord }));\n                        }\n                    }\n                    modifiedRecords.add(targetRecord);\n                }\n            }\n        }\n        return {\n            modifiedRecords : [...modifiedRecords],\n            targetCells     : affectedCells\n        };\n    }\n    /**\n     * Converts an array of Location objects to a two-dimensional array where first level is rows and second level is\n     * columns. If the array is inconsistent in the number of columns present for each row, the function will return\n     * false.\n     * @param {Grid.util.Location[]} locations\n     * @private\n     */\n    cellSelectorsAs2dArray(locations) {\n        const\n            rows = [];\n        let rId  = null,\n            columns;\n        for (const location of locations) {\n            // If new id (new record) create new \"row\"\n            if (location.id !== rId) {\n                rId = location.id;\n                columns = [];\n                rows.push(columns);\n            }\n            columns.push(location);\n        }\n        // Save number of \"columns\" for easier access\n        rows.columnCount = rows[0].length;\n        // All \"rows\" must have the same number of columns\n        if (rows.some(row => row.length !== rows.columnCount)) {\n            return false;\n        }\n        return rows;\n    }\n    /**\n     * Converts a new-line- and tab-separated string to a two-dimensional array where first level is rows and second\n     * level is columns. If the string is inconsistent in the number of columns present for each row, the function will\n     * return false.\n     * @param {String} string String values separated with new-line(\\n,\\r or similar) and tabs (\\t)\n     * @private\n     */\n    stringAs2dArray(string) {\n        const\n            rows       = [],\n            stringRows = string.split(/\\r\\n|(?!\\r\\n)[\\n-\\r\\x85\\u2028\\u2029]/).filter(s => s.length);\n        for (const row of stringRows) {\n            const columns = row.split('\\t');\n            // All \"rows\" must have the same number of columns\n            if (rows.columnCount && columns.length !== rows.columnCount) {\n                return false;\n            }\n            // Save number of \"columns\" for easier access\n            rows.columnCount = columns.length;\n            rows.push(columns);\n        }\n        return rows;\n    }\n}\nCopyPasteBase._$name = 'CopyPasteBase';", "import StringHelper from '../../Core/helper/StringHelper.js';\n/**\n * @module Grid/feature/GridFeatureManager\n */\nconst\n    consumerToFeatureMap        = new Map(),\n    consumerToDefaultFeatureMap = new Map(),\n    DEFAULT_FOR_TYPE            = 'Grid',\n    remapToBase                 = {\n        Grid         : 'GridBase',\n        Scheduler    : 'SchedulerBase',\n        SchedulerPro : 'SchedulerProBase',\n        Gantt        : 'GanttBase'\n    },\n    classNameFix = /\\$\\d+$/;\n/**\n * Static class intended to register and query grid features (also applies to Scheduler, Scheduler Pro and Gantt).\n *\n * A feature for Grid, Scheduler, Scheduler Pro or Gantt must extend {@link Core/mixin/InstancePlugin}.\n *\n * <div class=\"note\"> Note that features for Calendar and TaskBoard differ, they should not be registered with\n * GridFeatureManager, and they use different base classes.\n * </div>\n *\n * ## Registering a custom feature\n *\n * First define a new feature, extending InstancePlugin:\n *\n * ```javascript\n * export default class MyFeature extends InstancePlugin {\n *    // Class name, needed since the actual class name might be mangled by the minifier\n *    static $name = 'MyFeature';\n *\n *    construct(client, config) {\n *        // Set things up here\n *    }\n * }\n * ```\n *\n * Then register it with GridFeatureManager:\n *\n * ```javascript\nGridFeatureManager._$name = 'GridFeatureManager';  * GridFeatureManager.registerFeature(MyFeature);\n * ```\n *\n * After that it is ready to use:\n *\n * ```javascript\n * const grid = new Grid({\n *    features : {\n *      myFeature : true\n *    }\n * });\n *\n * @non-feature\n * @class\n */\nexport default class GridFeatureManager {\n    /**\n     * Register a feature class with the Grid. Enables it to be created and configured using config Grid#features.\n     * @param {Function} featureClass The feature class constructor to register\n     * @param {Boolean} [onByDefault] Specify true to have the feature enabled per default\n     * @param {String|String[]} [forType] Specify a type to let the class applying the feature to determine if it should\n     * use it\n     */\n    static registerFeature(featureClass, onByDefault = false, forType = null, as = null) {\n        // Our built-in features should all define $name to survive minification/obfuscation, but user defined features might not\n        as = StringHelper.uncapitalize(as || (Object.prototype.hasOwnProperty.call(featureClass, '$name') && featureClass.$$name) || featureClass.name);\n        // Remove webpack's disambiguation suffix.\n        // For example ExcelExporter in Scheduler will be called ExcelExporter$1\n        // It must be found as ExcelExporter in the Scheduler's feature Map, so correct the name.\n        as = as.replace(classNameFix, '');\n        if (!Array.isArray(forType)) {\n            forType = [forType || DEFAULT_FOR_TYPE];\n        }\n        forType.forEach(forType => {\n            const\n                type                       = remapToBase[forType] || forType,\n                consumerFeaturesMap        = consumerToFeatureMap.get(type) || new Map(),\n                consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(type) || new Map();\n            consumerFeaturesMap.set(as, featureClass);\n            consumerDefaultFeaturesMap.set(featureClass, onByDefault);\n            consumerToFeatureMap.set(type, consumerFeaturesMap);\n            consumerToDefaultFeatureMap.set(type, consumerDefaultFeaturesMap);\n        });\n    }\n    /**\n     * Get all the features registered for the given type name in an object where keys are feature names and values are\n     * feature constructors.\n     *\n     * @param {String} [forType]\n     * @returns {Object}\n     */\n    static getTypeNameFeatures(forType = DEFAULT_FOR_TYPE) {\n        const\n            type                = remapToBase[forType] || forType,\n            consumerFeaturesMap = consumerToFeatureMap.get(type),\n            features            = {};\n        if (consumerFeaturesMap) {\n            consumerFeaturesMap.forEach((featureClass, as) => features[as] = featureClass);\n        }\n        return features;\n    }\n    /**\n     * Get all the default features registered for the given type name in an object where keys are feature names and\n     * values are feature constructors.\n     *\n     * @param {String} [forType]\n     * @returns {Object}\n     */\n    static getTypeNameDefaultFeatures(forType = DEFAULT_FOR_TYPE) {\n        const\n            type                       = remapToBase[forType] || forType,\n            consumerFeaturesMap        = consumerToFeatureMap.get(type),\n            consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(type);\n        const features = {};\n        if (consumerFeaturesMap && consumerDefaultFeaturesMap) {\n            consumerFeaturesMap.forEach((featureClass, as) => {\n                if (consumerDefaultFeaturesMap.get(featureClass)) {\n                    features[as] = featureClass;\n                }\n            });\n        }\n        return features;\n    }\n    /**\n     * Gets all the features registered for the given instance type name chain. First builds the type name chain then\n     * queries for features for each type name and combines them into one object, see\n     * {@link #function-getTypeNameFeatures-static}() for returned object description.\n     *\n     * If feature is registered for both parent and child type name then feature for child overrides feature for parent.\n     *\n     * @param {Object} instance\n     * @returns {Object}\n     */\n    static getInstanceFeatures(instance) {\n        return instance.$meta.names.reduce(\n            (features, typeName) => Object.assign(features, this.getTypeNameFeatures(typeName)),\n            {}\n        );\n    }\n    /**\n     * Gets all the *default* features registered for the given instance type name chain. First builds the type name\n     * chain then queries for features for each type name and combines them into one object, see\n     * {@link #function-getTypeNameFeatures-static}() for returned object description.\n     *\n     * If feature is registered for both parent and child type name then feature for child overrides feature for parent.\n     *\n     * @param {Object} instance\n     * @returns {Object}\n     */\n    static getInstanceDefaultFeatures(instance) {\n        return instance.$meta.names.reduce(\n            (features, typeName) => Object.entries(\n                this.getTypeNameFeatures(typeName)\n            ).reduce(\n                (features, [as, featureClass]) => {\n                    if (this.isDefaultFeatureForTypeName(featureClass, typeName)) {\n                        features[as] = featureClass;\n                    }\n                    else {\n                        delete features[as];\n                    }\n                    return features;\n                },\n                features\n            ),\n            {}\n        );\n    }\n    /**\n     * Checks if the given feature class is default for the type name\n     *\n     * @param {Core.mixin.InstancePlugin} featureClass Feature to check\n     * @param {String} [forType]\n     * @returns {Boolean}\n     */\n    static isDefaultFeatureForTypeName(featureClass, forType = DEFAULT_FOR_TYPE) {\n        const\n            type                       = remapToBase[forType] || forType,\n            consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(type);\n        return consumerDefaultFeaturesMap && consumerDefaultFeaturesMap.get(featureClass) || false;\n    }\n    /**\n     * Checks if the given feature class is default for the given instance type name chain. If the feature is not\n     * default for the parent type name but it is for the child type name, then the child setting overrides the parent\n     * one.\n     *\n     * @param {Core.mixin.InstancePlugin} featureClass Feature to check\n     * @param {String} [forType]\n     * @returns {Boolean}\n     */\n    static isDefaultFeatureForInstance(featureClass, instance) {\n        //const typeChain = ObjectHelper.getTypeNameChain(instance);\n        const typeChain = instance.$meta.names.slice().reverse();\n        let result = null;\n        for (let i = 0, len = typeChain.length; i < len && result === null; ++i) {\n            const consumerDefaultFeaturesMap = consumerToDefaultFeatureMap.get(typeChain[i]);\n            if (consumerDefaultFeaturesMap && consumerDefaultFeaturesMap.has(featureClass)) {\n                result = consumerDefaultFeaturesMap.get(featureClass);\n            }\n        }\n        return result || false;\n    }\n    /**\n     * Resets feature registration date, used in tests to reset state after test\n     *\n     * @internal\n     */\n    static reset() {\n        consumerToFeatureMap.clear();\n        consumerToDefaultFeatureMap.clear();\n    }\n}\n", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport Editor from '../../Core/widget/Editor.js';\nimport GlobalEvents from '../../Core/GlobalEvents.js';\nimport MessageDialog from '../../Core/widget/MessageDialog.js';\nimport Location from '../util/Location.js';\nimport '../../Core/widget/NumberField.js';\nimport '../../Core/widget/Combo.js';\nimport '../../Core/widget/DateField.js';\nimport '../../Core/widget/TimeField.js';\nconst\n    editingActions = {\n        finishAndEditNextRow  : 1,\n        finishAndEditPrevRow  : 1,\n        finishEditing         : 1,\n        cancelEditing         : 1,\n        finishAndEditNextCell : 1,\n        finishAndEditPrevCell : 1\n    },\n    allActions = {\n        ...editingActions,\n        startEditingFromKeyMap : 1,\n        finishAllSelected      : 1\n    };\n/**\n * @module Grid/feature/CellEdit\n */\n/**\n * Adding this feature to the grid and other Bryntum products which are based on the Grid (i.e. Scheduler, SchedulerPro, and Gantt)\n * enables cell editing. Any subclass of {@link Core.widget.Field Field} can be used\n * as editor for the {@link Grid.column.Column Column}. The most popular are:\n *\n * - {@link Core.widget.TextField TextField}\n * - {@link Core.widget.NumberField NumberField}\n * - {@link Core.widget.DateField DateField}\n * - {@link Core.widget.TimeField TimeField}\n * - {@link Core.widget.Combo Combo}\n *\n * Usage instructions:\n * ## Start editing\n * * Double click on a cell\n * * Press [ENTER] or [F2] with a cell selected (see {@link #keyboard-shortcuts Keyboard shortcuts} below)\n * * It is also possible to change double click to single click to start editing, using the {@link #config-triggerEvent} config\n *\n * ```javascript\n * new Grid({\n *    features : {\n *        cellEdit : {\n *            triggerEvent : 'cellclick'\n *        }\n *    }\n * });\n * ```\n *\n * ## Instant update\n * If {@link Grid.column.Column#config-instantUpdate} on the column is set to true, record will be\n * updated instantly as value in the editor is changed. In combination with {@link Core.data.Store#config-autoCommit} it\n * could result in excessive requests to the backend.\n * By default instantUpdate is false, but it is enabled for some special columns, such as Duration column in Scheduler\n * Pro and all date columns in Gantt.\n *\n * ## Keyboard shortcuts\n * ### While not editing\n * | Keys    | Action         | Action description                    |\n * |---------|--------------- |---------------------------------------|\n * | `Enter` | *startEditing* | Starts editing currently focused cell |\n * | `F2`    | *startEditing* | Starts editing currently focused cell |\n *\n * ### While editing\n * | Keys            | Action                  | Weight | Action description                                                                         |\n * |-----------------|-------------------------|:------:|--------------------------------------------------------------------------------------------|\n * | `Enter`         | *finishAndEditNextRow*  |        | Finish editing and start editing the same cell in next row                                 |\n * | `Shift`+`Enter` | *finishAndEditPrevRow*  |        | Finish editing and start editing the same cell in previous row                             |\n * | `F2`            | *finishEditing*         |        | Finish editing                                                                             |\n * | `Ctrl`+`Enter`  | *finishAllSelected*     |        | If {@link #config-multiEdit} is active, this applies new value on all selected rows/cells  |\n * | `Ctrl`+`Enter`  | *finishEditing*         |        | Finish editing                                                                             |\n * | `Escape`        | *cancelEditing*         |        | By default, first reverts the value back to its original value, next press cancels editing |\n * | `Tab`           | *finishAndEditNextCell* | 100    | Finish editing and start editing the next cell                                             |\n * | `Shift`+`Tab`   | *finishAndEditPrevCell* | 100    | Finish editing and start editing the previous cell                                         |\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#Grid/guides/customization/keymap.md).\n *\n * ## Editor configuration\n * Columns specify editor in their configuration. Editor can also by set by using a column type. Columns\n * may also contain these three configurations which affect how their cells are edited:\n * * {@link Grid.column.Column#config-invalidAction}\n * * {@link Grid.column.Column#config-revertOnEscape}\n * * {@link Grid.column.Column#config-finalizeCellEdit}\n *\n * ## Preventing editing of certain cells\n * You can prevent editing on a column by setting `editor` to false:\n *\n * ```javascript\n * new Grid({\n *    columns : [\n *       {\n *          type   : 'number',\n *          text   : 'Age',\n *          field  : 'age',\n *          editor : false\n *       }\n *    ]\n * });\n * ```\n *\n * To prevent editing in a specific cell, listen to the {@link #event-beforeCellEditStart} and return false:\n *\n * ```javascript\n * grid.on('beforeCellEditStart', ({ editorContext }) => {\n *     return editorContext.column.field !== 'id';\n * });\n * ```\n *\n * ## Choosing field on the fly\n * To use an alternative input field to edit a cell, listen to the {@link #event-beforeCellEditStart} and\n * set the `editor` property of the context to the input field you want to use:\n *\n * ```javascript\n * grid.on('beforeCellEditStart', ({ editorContext }) => {\n *     return editorContext.editor = myDateField;\n * });\n * ```\n *\n * ## Loading remote data into a combo box cell editor\n * If you need to prepare or modify the data shown by the cell editor, e.g. load remote data into the store used by a combo,\n * listen to the {@link #event-startCellEdit} event:\n * ```javascript\n * const employeeStore = new AjaxStore({ readUrl : '/cities' }); // A server endpoint returning data like:\n *                                                               // [{ id : 123, name : 'Bob Mc Bob' }, { id : 345, name : 'Lind Mc Foo' }]\n *\n * new Grid({\n *     // Example data including a city field which is an id used to look up entries in the cityStore above\n *     data : [\n *         { id : 1, name : 'Task 1', employeeId : 123 },\n *         { id : 2, name : 'Task 2', employeeId : 345 }\n *     ],\n *     columns : [\n *       {\n *          text   : 'Task',\n *          field  : 'name'\n *       },\n *       {\n *          text   : 'Assigned to',\n *          field  : 'employeeId',\n *          editor : {\n *               type : 'combo',\n *               store : employeeStore,\n *               // specify valueField'/'displayField' to match the data format in the employeeStore store\n *               valueField : 'id',\n *               displayField : 'name'\n *           },\n *           renderer : ({ value }) {\n *                // Use a renderer to show the employee name, which we find by querying employeeStore by the id of the grid record\n *                return employeeStore.getById(value)?.name;\n *           }\n *       }\n *    ],\n *    listeners : {\n *        // When editing, you might want to fetch data for the combo store from a remote resource\n *        startCellEdit({ editorContext }) {\n *            const { record, editor, column } = editorContext;\n *            if (column.field === 'employeeId') {\n *                // Load possible employees to assign to this particular task\n *                editor.inputField.store.load({ task : record.id });\n *            }\n *       }\n *    }\n * });\n * ```\n *\n * ## Editing on touch devices\n *\n * On touch devices, a single tap navigates and tapping an already selected cell after a short delay starts the editing.\n *\n * This feature is **enabled** by default.\n *\n * ## Validation\n *\n * To validate the cell editing process you can use the {@link Grid.column.Column#config-finalizeCellEdit} config.\n * Please refer to its documentation for details.\n *\n * {@inlineexample Grid/feature/CellEdit.js}\n *\n * @demo Grid/celledit\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype cellEdit\n * @feature\n */\nexport default class CellEdit extends Delayable(InstancePlugin) {\n    //region Config\n    static $name = 'CellEdit';\n    // Default configuration\n    static get defaultConfig() {\n        return {\n            /**\n             * Set to true to select the field text when editing starts\n             * @config {Boolean}\n             * @default\n             */\n            autoSelect : true,\n            /**\n             * What action should be taken when focus moves leaves the cell editor, for example when clicking outside.\n             * May be `'complete'` or `'cancel`'.\n             * @config {'complete'|'cancel'}\n             * @default\n             */\n            blurAction : 'complete',\n            /**\n             * Set to `false` to stop editing when clicking another cell after a cell edit.\n             * @config {Boolean}\n             * @default\n             */\n            continueEditingOnCellClick : true,\n            /**\n             * Set to true to have TAB key on the last cell (and ENTER anywhere in the last row) in the data set create\n             * a new record and begin editing it at its first editable cell.\n             *\n             * If a customized {@link #config-keyMap} is used, this setting will affect the customized keys instead of\n             * ENTER and TAB.\n             *\n             * If this is configured as an object, it is used as the default data value set for each new record.\n             * @config {Boolean|Object}\n             */\n            addNewAtEnd : null,\n            /**\n             * Set to `true` to add record to the parent of the last record, when configured with {@link #config-addNewAtEnd}.\n             * Only applicable when using a tree view and store.\n             *\n             * By default, it adds records to the root.\n             * @config {Boolean}\n             * @default false\n             */\n            addToCurrentParent : false,\n            /**\n             * Set to `true` to start editing when user starts typing text on a focused cell (as in Excel)\n             * @config {Boolean}\n             * @default false\n             */\n            autoEdit : null,\n            /**\n             * Set to `false` to not start editing next record when user presses enter inside a cell editor (or previous\n             * record if SHIFT key is pressed). This is set to `false` when {@link #config-autoEdit} is `true`. Please\n             * note that these key combinations could be different if a customized {@link #config-keyMap} is used.\n             * @config {Boolean}\n             * @default\n             */\n            editNextOnEnterPress : true,\n            /**\n             * Class to use as an editor. Default value: {@link Core.widget.Editor}\n             * @config {Core.widget.Widget}\n             * @typings {typeof Widget}\n             * @internal\n             */\n            editorClass : Editor,\n            /**\n             * The name of the grid event that will trigger cell editing. Defaults to\n             * {@link Grid.view.mixin.GridElementEvents#event-cellDblClick celldblclick} but can be changed to any other event,\n             * such as {@link Grid.view.mixin.GridElementEvents#event-cellClick cellclick}.\n             *\n             * ```javascript\n             * features : {\n             *     cellEdit : {\n             *         triggerEvent : 'cellclick'\n             *     }\n             * }\n             * ```\n             *\n             * @config {String}\n             * @default\n             */\n            triggerEvent : 'celldblclick',\n            // To edit a cell using a touch gesture, at least 300ms should have passed since last cell tap\n            touchEditDelay : 300,\n            focusCellAnimationDuration : false,\n            /**\n             * If set to `true` (which is default) this will make it possible to edit current column in multiple rows\n             * simultaneously.\n             *\n             * This is achieved by:\n             * 1. Select multiple rows or row's cells\n             * 2. Start editing simultaneously as selecting the last row or cell\n             * 3. When finished editing, press Ctrl+Enter to apply the new value to all selected rows.\n             *\n             * If a customized {@link #config-keyMap} is used, the Ctrl+Enter combination could map to something else.\n             *\n             * @config {Boolean}\n             * @default\n             */\n            multiEdit : true,\n            /**\n             * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n             * @config {Object<String,String>}\n             */\n            keyMap : {\n                Enter         : ['startEditingFromKeyMap', 'finishAndEditNextRow'],\n                'Ctrl+Enter'  : ['finishAllSelected', 'finishEditing'],\n                'Shift+Enter' : 'finishAndEditPrevRow',\n                'Alt+Enter'   : 'finishEditing',\n                F2            : ['startEditingFromKeyMap', 'finishEditing'],\n                Escape        : 'cancelEditing',\n                Tab           : { handler : 'finishAndEditNextCell', weight : 100 },\n                'Shift+Tab'   : { handler : 'finishAndEditPrevCell', weight : 100 }\n            },\n            /**\n             * A CSS selector for elements that when clicked, should not trigger editing. Useful if you render actionable\n             * icons or buttons into a grid cell.\n             * @config {String}\n             * @default\n             */\n            ignoreCSSSelector : 'button,.b-icon,.b-fa,svg',\n            /**\n             * A callback which returns a `blurAction` value depending on the tap out event and the editing context.\n             *\n             * If specified, it is passed the mousedown event and the editing context object.\n             * @internal\n             */\n            validateTapOut : null\n        };\n    }\n    // Plugin configuration. This plugin chains some functions in Grid.\n    static get pluginConfig() {\n        return {\n            assign : ['startEditing', 'finishEditing', 'cancelEditing'],\n            before : ['onElementKeyDown', 'onElementPointerUp'],\n            chain  : ['onElementClick', 'bindStore']\n        };\n    }\n    //endregion\n    //region Init\n    construct(grid, config) {\n        super.construct(grid, config);\n        const\n            me            = this,\n            gridListeners = {\n                renderRows : 'onGridRefreshed',\n                cellClick  : 'onCellClick',\n                thisObj    : me\n            };\n        me.grid = grid;\n        if (me.triggerEvent !== 'cellclick') {\n            gridListeners[me.triggerEvent] = 'onTriggerEditEvent';\n        }\n        if (me.autoEdit && !('editNextOnEnterPress' in config)) {\n            me.editNextOnEnterPress = false;\n        }\n        grid.ion(gridListeners);\n        grid.rowManager.ion({\n            changeTotalHeight : 'onGridRefreshed',\n            thisObj           : me\n        });\n        me.bindStore(grid.store);\n    }\n    bindStore(store) {\n        this.detachListeners('store');\n        store.ion({\n            name       : 'store',\n            update     : 'onStoreUpdate',\n            beforeSort : 'onStoreBeforeSort',\n            thisObj    : this\n        });\n    }\n    /**\n     * Displays an OK / Cancel confirmation dialog box owned by the current Editor. This is intended to be\n     * used by {@link Grid.column.Column#config-finalizeCellEdit} implementations. The returned promise resolves passing\n     * `true` if the \"OK\" button is pressed, and `false` if the \"Cancel\" button is pressed. Typing `ESC` rejects.\n     *\n     * @param {Object} options An options object for what to show.\n     * @param {String} [options.title] The title to show in the dialog header.\n     * @param {String} [options.message] The message to show in the dialog body.\n     * @param {String|Object} [options.cancelButton] A text or a config object to apply to the Cancel button.\n     * @param {String|Object} [options.okButton] A text or config object to apply to the OK button.\n     * @returns {Boolean}\n     */\n    async confirm(options) {\n        let result = true;\n        if (this.editorContext) {\n            // The input field must not lose containment of focus during this confirmation\n            // so temporarily make the MessageDialog a descendant widget.\n            MessageDialog.owner = this.editorContext.editor.inputField;\n            options.rootElement = this.grid.rootElement;\n            result = await MessageDialog.confirm(options);\n            MessageDialog.owner = null;\n        }\n        return result === MessageDialog.yesButton;\n    }\n    doDestroy() {\n        // To kill timeouts\n        this.grid.columns.allRecords.forEach(column => {\n            column._cellEditor?.destroy();\n        });\n        super.doDestroy();\n    }\n    doDisable(disable) {\n        if (disable && !this.isConfiguring) {\n            this.cancelEditing(true);\n        }\n        super.doDisable(disable);\n    }\n    set disabled(disabled) {\n        super.disabled = disabled;\n    }\n    get disabled() {\n        const { grid } = this;\n        return Boolean(super.disabled || grid.disabled || grid.readOnly);\n    }\n    //endregion\n    //region Editing\n    /**\n     * Is any cell currently being edited?\n     * @readonly\n     * @property {Boolean}\n     */\n    get isEditing() {\n        return Boolean(this.editorContext);\n    }\n    /**\n     * Returns the record currently being edited, or `null`\n     * @readonly\n     * @property {Core.data.Model}\n     */\n    get activeRecord() {\n        return this.editorContext?.record || null;\n    }\n    /**\n     * Internal function to create or get existing editor for specified cell.\n     * @private\n     * @param cellContext Cell to get or create editor for\n     * @returns {Core.widget.Editor} An Editor container which displays the input field.\n     * @category Internal\n     */\n    getEditorForCell({ id, cell, column, columnId, editor }) {\n        const\n            me = this,\n            {\n                grid,\n                editorClass\n            }  = me;\n        // Reuse the Editor by caching it on the column.\n        let cellEditor = column.cellEditor,\n            leftOffset = 0; // Only applicable for tree cells to show editor right of the icons etc\n        // Help Editor match size and position\n        if (column.editTargetSelector) {\n            const editorTarget = cell.querySelector(column.editTargetSelector);\n            leftOffset = editorTarget.offsetLeft;\n        }\n        editor.autoSelect = me.autoSelect;\n        // Still a config\n        if (!cellEditor?.isEditor) {\n            cellEditor = column.data.cellEditor = editorClass.create(editorClass.mergeConfigs({\n                type          : editorClass.type,\n                constrainTo   : null,\n                cls           : 'b-cell-editor',\n                inputField    : editor,\n                blurAction    : 'none',\n                invalidAction : column.invalidAction,\n                completeKey   : false,\n                cancelKey     : false,\n                owner         : grid,\n                align         : {\n                    align  : 't0-t0',\n                    offset : [leftOffset, 0]\n                },\n                internalListeners : me.getEditorListeners(),\n                // Listen for cell edit control keys from the Editor\n                onInternalKeyDown : me.onEditorKeydown.bind(me),\n                // React editor wrapper code uses this flag to enable mouse events pass through to editor\n                allowMouseEvents : editor.allowMouseEvents\n            }, cellEditor));\n        }\n        // If matchSize auto heights it, ensure it at least covers the cell.\n        cellEditor.minHeight = grid.rowHeight;\n        // If the input field needs changing, change it.\n        if (cellEditor.inputField !== editor) {\n            cellEditor.remove(cellEditor.items[0]);\n            cellEditor.add(editor);\n        }\n        // Ensure the X offset is set to clear TreeCell furniture\n        cellEditor.align.offset[0] = leftOffset;\n        // Keep the record synced with the value\n        if (column.instantUpdate && !editor.cellEditValueSetter) {\n            ObjectHelper.wrapProperty(editor, 'value', null, value => {\n                const\n                    { editorContext } = me,\n                    inputField = editorContext?.editor.inputField;\n                // Only tickle the record if the value has changed.\n                if (\n                    editorContext?.editor.isValid &&\n                    !ObjectHelper.isEqual(editorContext.record.getValue(editorContext.column.field), value) &&\n                    // If editor is a dateField, only allow picker input as not to trigger change on each keystroke.\n                    (!inputField?.isDateField || inputField._isPickerInput)\n                ) {\n                    editorContext.record.setValue(editorContext.column.field, value);\n                }\n            });\n            editor.cellEditValueSetter = true;\n        }\n        Object.assign(cellEditor.element.dataset, {\n            rowId : id,\n            columnId,\n            field : column.field\n        });\n        // First ESC press reverts\n        cellEditor.inputField.revertOnEscape = column.revertOnEscape;\n        return me.editor = cellEditor;\n    }\n    // Turned into function to allow overriding in Gantt, and make more configurable in general\n    getEditorListeners() {\n        return {\n            focusOut       : 'onEditorFocusOut',\n            focusIn        : 'onEditorFocusIn',\n            start          : 'onEditorStart',\n            beforeComplete : 'onEditorBeforeComplete',\n            complete       : 'onEditorComplete',\n            beforeCancel   : 'onEditorBeforeCancel',\n            cancel         : 'onEditorCancel',\n            beforeHide     : 'onBeforeEditorHide',\n            finishEdit     : 'onEditorFinishEdit',\n            thisObj        : this\n        };\n    }\n    onEditorStart({ source : editor }) {\n        const\n            me            = this,\n            editorContext = me.editorContext = editor.cellEditorContext;\n        if (editorContext) {\n            const { grid } = me;\n            // Should move editing to new cell on click, unless click is configured to start editing - in which case it\n            // will move anyway\n            if (me.triggerEvent !== 'cellclick') {\n                me.detachListeners('cellClickWhileEditing');\n                grid.ion({\n                    name      : 'cellClickWhileEditing',\n                    cellclick : 'onCellClickWhileEditing',\n                    thisObj   : me\n                });\n            }\n            me.removeEditingListeners?.();\n            // Handle tapping outside the grid element. Use GlobalEvents\n            // because it uses a capture:true listener before any other handlers\n            // might stop propagation.\n            // Cannot use delegate here. A tapped cell will match :not(#body-container)\n            me.removeEditingListeners = GlobalEvents.addListener({\n                globaltap : 'onTapOut',\n                thisObj   : me\n            });\n            /**\n             * Fires on the owning Grid when editing starts\n             * @event startCellEdit\n             * @on-owner\n             * @param {Grid.view.Grid} source Owner grid\n             * @param {Grid.util.Location} editorContext Editing context\n             * @param {Core.widget.Editor} editorContext.editor The Editor being used.\n             * Will contain an `inputField` property which is the field being used to perform the editing.\n             * @param {Grid.column.Column} editorContext.column Target column\n             * @param {Core.data.Model} editorContext.record Target record\n             * @param {HTMLElement} editorContext.cell Target cell\n             * @param {*} editorContext.value Cell value\n             */\n            grid.trigger('startCellEdit', { grid, editorContext });\n        }\n    }\n    onEditorBeforeComplete(context) {\n        const\n            { grid }      = this,\n            editor        = context.source,\n            editorContext = editor.cellEditorContext;\n        context.grid = grid;\n        context.editorContext = editorContext;\n        /**\n         * Fires on the owning Grid before the cell editing is finished, return false to signal that the value is invalid and editing should not be finalized.\n         * @on-owner\n         * @event beforeFinishCellEdit\n         * @param {Grid.view.Grid} grid Target grid\n         * @param {Grid.util.Location} editorContext Editing context\n         * @param {Core.widget.Editor} editorContext.editor The Editor being used.\n         * Will contain an `inputField` property which is the field being used to perform the editing.\n         * @param {Grid.column.Column} editorContext.column Target column\n         * @param {Core.data.Model} editorContext.record Target record\n         * @param {HTMLElement} editorContext.cell Target cell\n         * @param {*} editorContext.value Cell value\n         */\n        return grid.trigger('beforeFinishCellEdit', context);\n    }\n    onEditorComplete({ source : editor }) {\n        const\n            { grid }      = this,\n            editorContext = editor.cellEditorContext;\n        // Ensure the docs below are accurate!\n        editorContext.value = editor.inputField.value;\n        // Refresh grid if a related field was edited\n        if (editor.dataField.includes('.')) {\n            const relationName  = editor.dataField.split('.')[0];\n            if (editor.record.constructor.relations?.[relationName]) {\n                grid.rowManager.refresh();\n            }\n        }\n        /**\n         * Fires on the owning Grid when cell editing is finished\n         * @event finishCellEdit\n         * @on-owner\n         * @param {Grid.view.Grid} grid Target grid\n         * @param {Grid.util.Location} editorContext Editing context\n         * @param {Core.widget.Editor} editorContext.editor The Editor being used.\n         * Will contain an `inputField` property which is the field being used to perform the editing.\n         * @param {Grid.column.Column} editorContext.column Target column\n         * @param {Core.data.Model} editorContext.record Target record\n         * @param {HTMLElement} editorContext.cell Target cell\n         * @param {*} editorContext.value Cell value\n         */\n        grid.trigger('finishCellEdit', { grid, editorContext });\n    }\n    onEditorBeforeCancel() {\n        const { editorContext } = this;\n        /**\n         * Fires on the owning Grid before the cell editing is canceled, return `false` to prevent cancellation.\n         * @event beforeCancelCellEdit\n         * @preventable\n         * @on-owner\n         * @param {Grid.view.Grid} source Owner grid\n         * @param {Grid.util.Location} editorContext Editing context\n         */\n        return this.grid.trigger('beforeCancelCellEdit', { editorContext });\n    }\n    onEditorCancel({ event }) {\n        const { editorContext, muteEvents, grid } = this;\n        if (!muteEvents) {\n            /**\n             * Fires on the owning Grid when editing is cancelled\n             * @event cancelCellEdit\n             * @on-owner\n             * @param {Grid.view.Grid} source Owner grid\n             * @param {Grid.util.Location} editorContext Editing context\n             * @param {Event} event Included if the cancellation was triggered by a DOM event\n             */\n            grid.trigger('cancelCellEdit', { grid, editorContext, event });\n        }\n    }\n    onBeforeEditorHide({ source }) {\n        const\n            me = this,\n            {\n                row,\n                cell\n            }  = source.cellEditorContext;\n        // Clean up and restore cell to full visibility\n        // before we hide and attempt to revert focus to the cell.\n        cell?.classList.remove('b-editing');\n        row?.removeCls('b-editing');\n        me.detachListeners('cellClickWhileEditing');\n        me.removeEditingListeners();\n    }\n    onEditorFinishEdit({ source }) {\n        // Clean up context objects so we know we are not editing\n        source.cellEditorContext = this.editorContext = null;\n    }\n    /**\n     * Find the next succeeding or preceding cell which is editable (column.editor != false)\n     * @param {Grid.util.Location} cellInfo\n     * @param {Boolean} isForward\n     * @returns {Object}\n     * @private\n     * @category Internal\n     */\n    getAdjacentEditableCell(cellInfo, isForward) {\n        const\n            { grid }           = this,\n            { store, columns } = grid,\n            { visibleColumns } = columns;\n        let\n            rowId    = cellInfo.id,\n            column   = columns.getAdjacentVisibleLeafColumn(cellInfo.columnId, isForward);\n        while (rowId) {\n            if (column) {\n                if (column.editor && column.canEdit(cellInfo.record)) {\n                    return { id : rowId, columnId : column.id };\n                }\n                column = columns.getAdjacentVisibleLeafColumn(column, isForward);\n            }\n            else {\n                const record = store.getAdjacent(cellInfo.id, isForward, false, true);\n                rowId = record?.id;\n                if (record) {\n                    column = isForward ? visibleColumns[0] : visibleColumns[visibleColumns.length - 1];\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Adds a new, empty record at the end of the TaskStore with the initial\n     * data specified by the {@link Grid.feature.CellEdit#config-addNewAtEnd} setting.\n     *\n     * @private\n     * @returns {Core.data.Model} Newly added record\n     */\n    doAddNewAtEnd() {\n        const\n            newRecordConfig              = typeof this.addNewAtEnd === 'object' ? ObjectHelper.clone(this.addNewAtEnd) : {},\n            { grid : { store, rowManager }, addToCurrentParent } = this;\n        let record;\n        if (store.tree && addToCurrentParent) {\n            record = store.last.parent.appendChild(newRecordConfig);\n        }\n        else {\n            record = store.add(newRecordConfig)[0];\n        }\n        // If the new record was not added due to it being off the end of the rendered block\n        // ensure we force it to be there before we attempt to edit it.\n        if (!rowManager.getRowFor(record)) {\n            rowManager.displayRecordAtBottom();\n        }\n        return record;\n    }\n    /**\n     * Creates an editing context object for the passed cell context (target cell must be in the DOM).\n     *\n     * If the referenced cell is editable, a {@link Grid.util.Location} will\n     * be returned containing the following extra properties:\n     *\n     *     - editor\n     *     - value\n     *\n     * If the referenced cell is _not_ editable, `false` will be returned.\n     * @param {Object} cellContext an object which encapsulates a cell.\n     * @param {String} cellContext.id The record id of the row to edit\n     * @param {String} cellContext.columnId The column id of the column to edit\n     * @returns {Grid.util.Location}\n     * @private\n     */\n    getEditingContext(cellContext) {\n        cellContext = this.grid.normalizeCellContext(cellContext);\n        const { column, record } = cellContext;\n        // Cell must be in the DOM to edit.\n        // Cannot edit hidden columns and columns without an editor.\n        // Cannot edit special rows (groups etc).\n        if (column?.isVisible && column.editor && !column.readOnly && record && !record.isSpecialRow && !record.readOnly && column.canEdit(record)) {\n            // If the field name is a complex mapping (instead of using a field name with a dataSource)\n            // set it correctly. Row#renderCell gets its contentValue in this way.\n            const value = record ? column.getRawValue(record) : record;\n            Object.assign(cellContext, {\n                value  : value === undefined ? null : value,\n                editor : column.editor\n            });\n            return cellContext;\n        }\n        else {\n            return false;\n        }\n    }\n    startEditingFromKeyMap() {\n        return this.startEditing(this.grid.focusedCell);\n    }\n    /**\n     * Start editing specified cell. If no cellContext is given it starts with the first cell in the first row.\n     * This function is exposed on Grid and can thus be called as `grid.startEditing(...)`\n     * @param {Object} cellContext Cell specified in format { id: 'x', columnId/column/field: 'xxx' }. See\n     * {@link Grid.view.Grid#function-getCell} for details.\n     * @fires startCellEdit\n     * @returns {Promise} Resolved promise returns`true` if editing has been started, `false` if an {@link Core.widget.Editor#event-beforeStart} listener\n     * has vetoed the edit.\n     * @category Editing\n     * @on-owner\n     */\n    async startEditing(cellContext = {}) {\n        const me = this;\n        // If disabled no can do.\n        if (!me.disabled) {\n            const { grid } = me;\n            // If we got here from keyMap, start editing currently focused cell instead\n            if (cellContext?.fromKeyMap) {\n                cellContext = me.grid.focusedCell;\n            }\n            // When cell context is not available add the first cell context\n            if (ObjectHelper.isEmpty(cellContext)) {\n                cellContext.id = grid.firstVisibleRow.id;\n            }\n            // Has to expand before normalizing to a Location, since Location only maps to visible rows\n            if (grid.store.isTree && grid.features.tree) {\n                const record = cellContext.id ? grid.store.getById(cellContext.id) : cellContext.record ?? grid.store.getAt(cellContext.row);\n                if (record) {\n                    await grid.expandTo(record);\n                }\n                else {\n                    return false;\n                }\n            }\n            const editorContext = me.getEditingContext(cellContext);\n            // Cannot edit hidden columns and columns without an editor\n            // Cannot edit special rows (groups etc).\n            if (!editorContext) {\n                return false;\n            }\n            if (me.editorContext) {\n                // If the cancel was vetoed by a handler, we cannot start the new edit\n                if (me.cancelEditing() === false) {\n                    return false;\n                };\n            }\n            // Now that we know we can edit this cell, scroll the record into view and register it as last focusedCell\n            // While any potential scroll may be async, the desired cell will be rendered immediately.\n            if (!grid.focusedCell?.equals(editorContext)) {\n                grid.focusCell(editorContext);\n            }\n            /**\n             * Fires on the owning Grid before editing starts, return `false` to prevent editing\n             * @event beforeCellEditStart\n             * @on-owner\n             * @preventable\n             * @param {Grid.view.Grid} source Owner grid\n             * @param {Grid.util.Location} editorContext Editing context\n             * @param {Grid.column.Column} editorContext.column Target column\n             * @param {Core.data.Model} editorContext.record Target record\n             * @param {HTMLElement} editorContext.cell Target cell\n             * @param {Core.widget.Field} editorContext.editor The input field that the column is configured\n             * with (see {@link Grid.column.Column#config-field}). This property mey be replaced\n             * to be a different {@link Core.widget.Field field} in the handler, to take effect\n             * just for the impending edit.\n             * @param {Function} [editorContext.finalize] An async function may be injected into this property\n             * which performs asynchronous finalization tasks such as complex validation of confirmation. The\n             * value `true` or `false` must be returned.\n             * @param {Object} [editorContext.finalize.context] An object describing the editing context upon requested\n             * completion of the edit.\n             * @param {*} editorContext.value Cell value\n             */\n            if (grid.trigger('beforeCellEditStart', { grid, editorContext }) === false) {\n                return false;\n            }\n            const\n                editor = editorContext.editor = me.getEditorForCell(editorContext),\n                {\n                    row,\n                    cell,\n                    record\n                }      = editorContext;\n            // Prevent highlight when setting the value in the editor\n            editor.inputField.highlightExternalChange = false;\n            editor.cellEditorContext = editorContext;\n            editor.render(cell);\n            // CSS state must be set before the startEdit causes the Editor to align itself\n            // because if its target is overflow:hidden, it automatically constrains its size.\n            cell.classList.add('b-editing');\n            row.addCls('b-editing');\n            // Attempt to start edit.\n            // We will set up our context in onEditorStart *if* the start was successful.\n            if (!(await editor.startEdit({\n                target : cell,\n                field  : editor.inputField.name || editorContext.column.field,\n                value  : editorContext.value,\n                record\n            }))) {\n                // If the editor was vetoed, undo the CSS state.\n                cell.classList.remove('b-editing');\n                row.removeCls('b-editing');\n            }\n            me.onCellEditStart?.();\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Cancel editing, destroys the editor\n     * This function is exposed on Grid and can thus be called as `grid.cancelEditing(...)`\n     * @param {Boolean} silent Pass true to prevent method from firing event\n     * @fires cancelCellEdit\n     * @category Editing\n     * @on-owner\n     */\n    cancelEditing(silent = false, triggeredByEvent) {\n        const\n            me         = this,\n            { editor } = me;\n        if (!me.isEditing) {\n            return;\n        }\n        // If called from keyMap, first argument is an event, ignore that\n        if (silent.fromKeyMap) {\n            triggeredByEvent = silent;\n            silent = false;\n        }\n        me.muteEvents = silent;\n        const cancelResult = editor.cancelEdit(triggeredByEvent);\n        me.muteEvents = false;\n        // Cancel was prevented\n        if (cancelResult === false) {\n            // Cancel request may have been the result of focus loss\n            editor.inputField.focus();\n        }\n        else {\n            // In case editing is canceled while waiting for finishing promise\n            me.finishEditingPromise = false;\n            me.afterCellEdit?.();\n        }\n        return cancelResult;\n    }\n    /**\n     * Finish editing, update the underlying record and destroy the editor\n     * This function is exposed on Grid and can thus be called as `grid.finishEditing(...)`\n     * @fires finishCellEdit\n     * @category Editing\n     * @returns {Promise} Resolved promise returns `false` if the edit could not be finished due to the value being invalid or the\n     * Editor's `complete` event was vetoed.\n     * @on-owner\n     */\n    async finishEditing() {\n        const\n            me                      = this,\n            { editorContext, grid } = me;\n        let result = false;\n        // If already waiting for finishing promise, return that\n        if (me.finishEditingPromise) {\n            return me.finishEditingPromise;\n        }\n        if (editorContext) {\n            const { column } = editorContext;\n            // If completeEdit finds that the editor context has a finalize method in it,\n            // it will *await* the completion of that method before completing the edit\n            // so we must await completeEdit.\n            // We can override that finalize method by passing the column's own finalizeCellEdit.\n            // Set a flag (promise) indicating that we are in the middle of editing finalization\n            me.finishEditingPromise = editorContext.editor.completeEdit(column.bindCallback(column.finalizeCellEdit));\n            result = await me.finishEditingPromise;\n            // If grid is animating, wait for it to finish to not start a follow-up edit when things are moving\n            // (only applies to Scheduler for now, tested in Schedulers CellEdit.t.js)\n            await grid.waitForAnimations();\n            // reset the flag\n            me.finishEditingPromise = null;\n            if (result) {\n                me.afterCellEdit?.();\n            }\n        }\n        return result;\n    }\n    //endregion\n    //region Events\n    /**\n     * Event handler added when editing is active called when user clicks a cell in the grid during editing.\n     * It finishes editing and moves editor to the selected cell instead.\n     * @private\n     * @category Internal event handling\n     */\n    async onCellClickWhileEditing({ event, cellSelector }) {\n        const me = this;\n        // React cell editor is configured with `allowMouseEvents=true` to prevent editor from swallowing mouse events\n        // We ignore these events from editor here to not prevent editing\n        if (event.target.closest('.b-editor')) {\n            return;\n        }\n        if (DomHelper.isTouchEvent || event.target.matches(me.ignoreCSSSelector)) {\n            await me.finishEditing();\n            return;\n        }\n        // Ignore clicks if async finalization is running\n        if (me.finishEditingPromise) {\n            return;\n        }\n        // Ignore clicks in the editor.\n        if (me.editorContext && !me.editorContext.editor.owns(event.target)) {\n            if (me.getEditingContext(cellSelector)) {\n                // Attempt to finish the current edit.\n                // Will return false if the field is invalid.\n                if (await me.finishEditing()) {\n                    if (me.continueEditingOnCellClick) {\n                        await me.startEditing(cellSelector);\n                    }\n                }\n                // Previous edit was invalid, return to it.\n                else {\n                    me.grid.focusCell(me.editorContext);\n                    me.editor.inputField.focus();\n                }\n            }\n            else {\n                await me.finishEditing();\n            }\n        }\n    }\n    /**\n     * Starts editing if user taps selected cell again on touch device. Chained function called when user clicks a cell.\n     * @private\n     * @category Internal event handling\n     */\n    async onCellClick({ cellSelector, target, event, column }) {\n        if (column.onCellClick) {\n            // Columns may provide their own handling of cell editing\n            return;\n        }\n        const\n            me              = this,\n            { focusedCell } = me.client;\n        if (target.closest('.b-tree-expander')) {\n            return false;\n        }\n        else if (DomHelper.isTouchEvent &&\n            me._lastCellClicked === focusedCell?.cell &&\n            event.timeStamp - me.touchEditDelay > me._lastCellClickedTime\n        ) {\n            await me.startEditing(cellSelector);\n        }\n        else if (this.triggerEvent === 'cellclick') {\n            await me.onTriggerEditEvent({ cellSelector, target });\n        }\n        me._lastCellClicked     = focusedCell?.cell;\n        me._lastCellClickedTime = event.timeStamp;\n    }\n    // onElementPointerUp should be used to cancel editing before toggleCollapse handled\n    // otherwise data collisions may be happened\n    onElementPointerUp(event) {\n        if (event.target.closest('.b-tree-expander')) {\n            this.cancelEditing(undefined, event);\n        }\n    }\n    /**\n     * Called when the user triggers the edit action in {@link #config-triggerEvent} config. Starts editing.\n     * @private\n     * @category Internal event handling\n     */\n    async onTriggerEditEvent({ cellSelector, target, event }) {\n        const { editorContext, client } = this;\n        if (target.closest('.b-tree-expander') || (DomHelper.isTouchEvent && event.type === 'dblclick')) {\n            return;\n        }\n        // Should not start editing if cellMenu configured to be shown on event\n        if (event && client.features.cellMenu?.triggerEvent === event.type) {\n            return;\n        }\n        if (editorContext) {\n            // If we are already editing the cellSelector cell, or the editor cannot finish editing\n            // then we must not attempt to start an edit.\n            if (editorContext.equals(this.grid.normalizeCellContext(cellSelector)) || !(await this.finishEditing())) {\n                return;\n            }\n        }\n        await this.startEditing(cellSelector);\n    }\n    /**\n     * Update the input field if underlying data changes during edit.\n     * @private\n     * @category Internal event handling\n     */\n    onStoreUpdate({ changes, record }) {\n        const { editorContext } = this;\n        if (editorContext?.editor.isVisible) {\n            if (record === editorContext.record && editorContext.editor.dataField in changes) {\n                editorContext.editor.refreshEdit();\n            }\n        }\n    }\n    onStoreBeforeSort() {\n        const editor = this.editorContext?.editor;\n        if (this.isEditing && !editor?.isFinishing && !editor.isValid) {\n            return this.cancelEditing();\n        }\n    }\n    /**\n     * Realign editor if grid renders rows while editing is ongoing (as a result to autoCommit or WebSocket data received).\n     * @private\n     * @category Internal event handling\n     */\n    onGridRefreshed() {\n        const\n            me = this,\n            {\n                grid,\n                editorContext\n            }  = me;\n        if (editorContext && grid.isVisible && grid.focusedCell) {\n            const\n                cell       = grid.getCell(grid.focusedCell),\n                { editor } = editorContext;\n            // If refresh was triggered by the data change in onEditComplete\n            // do not re-show the editor.\n            if (cell && DomHelper.isInView(cell) && !editor.isFinishing) {\n                editorContext._cell = cell;\n                // Editor is inside the cell for A11Y reasons.\n                // So any refresh will remove its DOM.\n                // We need to silently restore and refocus it.\n                GlobalEvents.suspendFocusEvents();\n                editor.render(cell);\n                editor.showBy(cell);\n                editor.focus();\n                GlobalEvents.resumeFocusEvents();\n            }\n            else {\n                me.cancelEditing();\n            }\n        }\n    }\n    // Gets selected records or selected cells records\n    get gridSelection() {\n        return [...this.grid.selectedRows, ...this.grid.selectedCells];\n    }\n    // Tells keyMap what actions are available in certain conditions\n    isActionAvailable({ actionName, event }) {\n        const me = this;\n        // Non-default actions should always be let through\n        if (!allActions[actionName]) {\n            return;\n        }\n        if (!me.disabled && !event.target.closest('.b-grid-header')) {\n            if (me.isEditing) {\n                if (actionName === 'finishAllSelected') {\n                    return me.multiEdit && me.gridSelection.length > 1;\n                }\n                else if (editingActions[actionName]) {\n                    return true;\n                }\n            }\n            else if (actionName === 'startEditingFromKeyMap') {\n                return me.grid.focusedCell.cell === event.target;\n            }\n        }\n        return false;\n    }\n    // Will copy edited field value to all selected records\n    async finishAllSelected() {\n        const\n            me                    = this,\n            { dataField, record } = me.editor;\n        if (await me.finishEditing() && !me.isDestroyed) {\n            // Micro-optimization here - accessors could execute additional logic, so we only read it once\n            const value = record.getValue(dataField);\n            for (const selected of me.gridSelection) {\n                if (selected.isModel) {\n                    if (selected !== record) {\n                        selected.setValue(dataField, value);\n                    }\n                }\n                else {\n                    selected.record.set(selected.column.field, value);\n                }\n            }\n        }\n    }\n    // Will finish editing and start editing next row (unless it's a touch device)\n    // If addNewAtEnd, it will create a new row and edit that one if currently editing last row\n    async finishAndEditNextRow(event, previous = false) {\n        const\n            me         = this,\n            { grid }   = me,\n            { record } = me.editorContext;\n        let nextCell;\n        if (await me.finishEditing()) {\n            // Might be destroyed during the async operation\n            if (me.isDestroyed) {\n                return;\n            }\n            // Finalizing might have been blocked by an invalid value\n            if (!me.isEditing) {\n                // Move to previous\n                if (previous) {\n                    nextCell = grid.internalNextPrevRow(false, true, false);\n                }\n                // Move to next\n                else {\n                    // If we are at the last editable cell, optionally add a new row\n                    if (me.addNewAtEnd && record === grid.store.last) {\n                        await me.doAddNewAtEnd();\n                    }\n                    if (!me.isDestroyed) {\n                        nextCell = grid.internalNextPrevRow(true, true);\n                    }\n                }\n                // If we have moved, and we are configure to edit the next cell on Enter key...\n                if (nextCell && me.editNextOnEnterPress && !grid.touch) {\n                    await me.startEditing(nextCell);\n                }\n            }\n        }\n    }\n    // Will finish editing and start editing previous row\n    finishAndEditPrevRow(event) {\n        return this.finishAndEditNextRow(event, true);\n    }\n    // Will finish editing and start editing next cell\n    // If addNewAtEnd, it will create a new row and edit that one if currently editing last row\n    async finishAndEditNextCell(event, previous = false) {\n        const\n            me              = this,\n            { grid }        = me,\n            { focusedCell } = grid;\n        if (focusedCell && !me.finishEditingPromise) {\n            const {\n                rowIndex, columnIndex\n            } = focusedCell;\n            let cellInfo = me.getAdjacentEditableCell(focusedCell, !previous);\n            // If we are at the last editable cell, optionally add a new row\n            if (!cellInfo && !previous && me.addNewAtEnd) {\n                const currentEditableFinalizationResult = await me.finishEditing();\n                if (currentEditableFinalizationResult === true) {\n                    await me.doAddNewAtEnd();\n                }\n            }\n            let finalizationResult = true;\n            if (me.isEditing) {\n                finalizationResult = await me.finishEditing();\n            }\n            // Editing can have side effects.\n            if (me.isDestroyed) {\n                return;\n            }\n            // Re-grab the next editable cell because finishEditing may have changed the content under here\n            cellInfo = me.getAdjacentEditableCell(new Location({\n                grid,\n                rowIndex,\n                columnIndex\n            }), !previous);\n            if (cellInfo) {\n                if (finalizationResult) {\n                    grid.focusCell(cellInfo, {\n                        animate : me.focusCellAnimationDuration\n                    });\n                    if (!(await me.startEditing(cellInfo))) {\n                        // if editing a cell was vetoed, move on and try again\n                        await me.finishAndEditNextCell(event, previous);\n                    }\n                }\n                else {\n                    // finishing cell editing was not allowed, current editor value is invalid\n                }\n            }\n            // Finished editing last cell of last row, let grid handle\n            else if (grid.isNested && grid.owner &&\n                !grid.owner.catchFocus?.({ source : grid, navigationDirection : previous ? 'up' : 'down', editing : true })\n            ) {\n                grid.onTab(event);\n            }\n        }\n    }\n    // Will finish editing and start editing next cell\n    finishAndEditPrevCell(event) {\n        return this.finishAndEditNextCell(event, true);\n    }\n    // Handles autoedit\n    async onElementKeyDown(event) {\n        const\n            me              = this,\n            { grid }        = me,\n            { focusedCell } = grid;\n        // flagging event with handled = true used to signal that other features should probably not care about it\n        if (event.handled || !me.autoEdit || me.isEditing || !focusedCell || focusedCell.isActionable || event.ctrlKey) {\n            return;\n        }\n        const\n            { key }           = event,\n            isDelete          = event.key === 'Delete' || event.key === 'Backspace',\n            { gridSelection } = isDelete ? me : {},\n            isMultiDelete     = me.multiEdit && gridSelection?.length > 1;\n        // Any character or space starts editing while autoedit is true\n        if ((key.length <= 1 || (isDelete && !isMultiDelete)) && await me.startEditing(focusedCell)) {\n            const\n                { inputField } = me.editor,\n                { input }      = inputField;\n            // if editing started with a keypress and the editor has an input field, set its value\n            if (input) {\n                // Simulate a keydown in an input field by setting input value\n                // plus running our internal processing of that event\n                inputField.internalOnKeyEvent(event);\n                if (!event.defaultPrevented) {\n                    input.value = isDelete ? '' : key;\n                    inputField.internalOnInput(event);\n                }\n            }\n            event.preventDefault();\n        }\n        // If deleting while selected multiple rows or cells, the records are changed directly\n        else if (isMultiDelete) {\n            /**\n             * Fires on the owning Grid before deleting a range of selected cell values by pressing `Backspace` or `Del`\n             * buttons while {@link #config-autoEdit} is set to `true`. Return `false` to prevent editing.\n             * @event beforeCellDelete\n             * @on-owner\n             * @preventable\n             * @param {Grid.view.Grid} source Owner grid\n             * @param {Array<Grid.util.Location|Core.data.Model>} gridSelection An array of cell selectors or records\n             * that will have their values deleted (the records themself will not get deleted, only visible column\n             * values).\n             */\n            if (grid.trigger('beforeCellRangeDelete', { grid, gridSelection }) !== false) {\n                for (const selected of gridSelection) {\n                    if (selected.isModel) {\n                        grid.columns.visibleColumns.forEach(col => {\n                            !col.readOnly && selected.set(col.field, null);\n                        });\n                    }\n                    else if (!selected.column.readOnly) {\n                        selected.record.set(selected.column.field, null);\n                    }\n                }\n            }\n        }\n    }\n    // Prevents keys which the Grid handles from bubbling to the grid while editing\n    onEditorKeydown(event) {\n        if (event.key.length !== 1 && this.grid.matchKeyMapEntry(event) && !this.grid.matchKeyMapEntry(event, this.keyMap)) {\n            // Don't allow browser key commands such as PAGE-UP, PAGE-DOWN to continue.\n            if (!event.key.startsWith('Arrow') && !event.key === 'Backspace') {\n                event.preventDefault();\n            }\n            event.handled = true;\n            event.stopPropagation();\n            return false;\n        }\n    }\n    /**\n     * Cancel editing on widget focusout\n     * @private\n     */\n    async onEditorFocusOut(event) {\n        const\n            me              = this,\n            {\n                grid,\n                editor,\n                editorContext\n            }                   = me,\n            toCell              = new Location(event.relatedTarget),\n            isEditableCellClick = (toCell.grid === grid) && me.getEditingContext(toCell);\n        // If the editor is not losing focus as a result of its tidying up process\n        // And focus is moving to outside of the editor, then explicitly terminate.\n        if (editorContext && !editor.isFinishing && editor.owns(event._target)) {\n            // If configured to cancel on blur, or the context no longer owns a record, cancel the edit\n            if (me.blurAction === 'cancel' || !grid.store.includes(editorContext.record)) {\n                me.cancelEditing(undefined, event);\n            }\n            // If not already in the middle of editing finalization (that could be async)\n            // and it's not a onCellClickWhileEditing situation, finish the edit.\n            else if (!me.finishEditingPromise && (me.triggerEvent === 'cellclick' || (me.triggerEvent !== 'cellclick' && !isEditableCellClick))) {\n                await me.finishEditing();\n            }\n        }\n    }\n    onEditorFocusIn(event) {\n        const widget = event.toWidget;\n        if (widget === this.editor.inputField) {\n            if (this.autoSelect && widget.selectAll && !widget.readOnly && !widget.disabled) {\n                widget.selectAll();\n            }\n        }\n    }\n    /**\n     * Cancel edit on touch outside of grid for mobile Safari (focusout not triggering unless you touch something focusable)\n     * @private\n     */\n    async onTapOut({ event }) {\n        const\n            me         = this,\n            { target } = event;\n        // Only \"tap out\" if were not clicking an element with a _shadowRoot\n        if (!target._shadowRoot && !me.editor.owns(target) &&\n            (!me.grid.bodyContainer.contains(target) || event.button)) {\n            const\n                validateTapOut = me.resolveCallback(me.validateTapOut, me, false),\n                blurAction     = validateTapOut?.handler.call(validateTapOut.thisObj, event, me.editorContext) || me.blurAction;\n            me.editingStoppedByTapOutside = true;\n            if (blurAction === 'cancel') {\n                me.cancelEditing(undefined, event);\n            }\n            else {\n                await me.finishEditing();\n            }\n            delete me.editingStoppedByTapOutside;\n        }\n    }\n    /**\n     * Finish editing if clicking below rows (only applies when grid is higher than rows).\n     * @private\n     * @category Internal event handling\n     */\n    async onElementClick(event) {\n        if (event.target.classList.contains('b-grid-body-container') && this.editorContext) {\n            await this.finishEditing();\n        }\n    }\n    //endregion\n}\nCellEdit._$name = 'CellEdit'; GridFeatureManager.registerFeature(CellEdit, true);\n", "import ContextMenuBase from '../../Core/feature/base/ContextMenuBase.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\n/**\n * @module Grid/feature/CellMenu\n */\n/**\n * Right click to display context menu for cells.\n *\n * To invoke the cell menu in a keyboard-accessible manner, use the `SPACE` key when the cell is focused.\n *\n * ### Default cell menu items\n *\n * The Cell menu feature provides only one item by default:\n *\n * | Reference              | Text   | Weight | Description         |\n * |------------------------|--------|--------|---------------------|\n * | `removeRow`            | Delete | 100    | Delete row record   |\n *\n * And all the other items are populated by the other features:\n *\n * | Reference              | Text             | Weight | Feature                           | Description                                                                                   |\n * |------------------------|------------------|--------|-----------------------------------|-----------------------------------------------------------------------------------------------|\n * | `cut`                  | Cut record       | 110    | {@link Grid/feature/RowCopyPaste} | Cut row record                                                                                |\n * | `copy`                 | Copy record      | 120    | {@link Grid/feature/RowCopyPaste} | Copy row record                                                                               |\n * | `paste`                | Paste record     | 130    | {@link Grid/feature/RowCopyPaste} | Paste copied row records                                                                      |\n * | `search`               | Search for value | 200    | {@link Grid/feature/Search}       | Search for the selected cell text                                                             |\n * | `filterMenu`           | Filter           | 400    | {@link Grid/feature/Filter}       | Shows a submenu to control filtering. See [Filter submenu](#Grid/feature/Filter#menu-items). |\n * | `splitGrid`            | Split            | 500    | {@link Grid/feature/Split}        | Shows the \"Split grid\" sub menu                                                               |\n * | \\> `splitHorizontally` | Horizontally     | 100    | {@link Grid/feature/Split}        | Split horizontally                                                                            |\n * | \\> `splitVertically `  | Vertically       | 200    | {@link Grid/feature/Split}        | Split vertically                                                                              |\n * | \\> `splitBoth`         | Both             | 300    | {@link Grid/feature/Split}        | Split both ways                                                                               |\n * |`unsplitGrid`           | Split            | 400    | {@link Grid/feature/Split}        | Unsplit a previously split grid                                                               |\n *\n * ### Customizing the menu items\n *\n * The menu items in the Cell menu can be customized, existing items can be changed or removed,\n * and new items can be added. This is handled using the `items` config of the feature.\n *\n * Add extra items for all columns:\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         cellMenu : {\n *             items : {\n *                 extraItem : {\n *                     text   : 'My cell item',\n *                     icon   : 'fa fa-bus',\n *                     weight : 200,\n *                     onItem : () => ...\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * It is also possible to add items using columns config. See examples below.\n *\n * Add extra items for a single column:\n *\n * ```javascript\n * const grid = new Grid({\n *     columns: [\n *         {\n *             field         : 'city',\n *             text          : 'City',\n *             cellMenuItems : {\n *                 columnItem : {\n *                     text   : 'My unique cell item',\n *                     icon   : 'fa fa-beer',\n *                     onItem : () => ...\n *                 }\n *             }\n *         }\n *     ]\n * });\n * ```\n *\n * Remove existing item:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         cellMenu : {\n *             items : {\n *                 removeRow : false\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Customize existing item:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         cellMenu : {\n *             items : {\n *                 removeRow : {\n *                     text : 'Throw away',\n *                     icon : 'b-fa b-fa-dumpster'\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * It is also possible to manipulate the default items and add new items in the processing function:\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         cellMenu : {\n *             processItems({items, record}) {\n *                 if (record.cost > 5000) {\n *                     items.myItem = { text : 'Split cost' };\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * <div class=\"note\">The `processItems` implementation my be an `async` function which `awaits` a result to\n * mutate the `items` object.</div>\n *\n * Full information of the menu customization can be found in the [\"Customizing the Cell menu and the Header menu\"](#Grid/guides/customization/contextmenu.md)\n * guide.\n *\n * This feature is **enabled** by default.\n *\n * ## Keyboard shortcuts\n * This feature has the following default keyboard shortcuts:\n *\n * | Keys         | Action                 | Action description                            |\n * |--------------|------------------------|-----------------------------------------------|\n * | `Space`      | *showContextMenuByKey* | Shows context menu for currently focused cell |\n * | `Ctrl+Space` | *showContextMenuByKey* | Shows context menu for currently focused cell |\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#Grid/guides/customization/keymap.md).\n *\n * {@inlineexample Grid/feature/CellMenu.js}\n *\n * @demo Grid/contextmenu\n *\n * @extends Core/feature/base/ContextMenuBase\n * @classtype cellMenu\n * @feature\n */\nexport default class CellMenu extends ContextMenuBase {\n    //region Config\n    static get $name() {\n        return 'CellMenu';\n    }\n    static get defaultConfig() {\n        return {\n            /**\n             * A function called before displaying the menu that allows manipulations of its items.\n             * Returning `false` from this function prevents the menu being shown.\n             *\n             * ```javascript\n             * features : {\n             *     cellMenu : {\n             *         processItems({ items, record, column }) {\n             *             // Add or hide existing items here as needed\n             *             items.myAction = {\n             *                 text   : 'Cool action',\n             *                 icon   : 'b-fa b-fa-fw b-fa-ban',\n             *                 onItem : () => console.log(`Clicked ${record.name}`),\n             *                 weight : 1000 // Move to end\n             *             };\n             *\n             *             if (!record.allowDelete) {\n             *                 items.removeRow.hidden = true;\n             *             }\n             *         }\n             *     }\n             * },\n             * ```\n             *\n             * @config {Function}\n             * @param {Object} context An object with information about the menu being shown\n             * @param {Core.data.Model} context.record The record representing the current row\n             * @param {Grid.column.Column} context.column The current column\n             * @param {Object<String,MenuItemConfig|Boolean>} context.items An object containing the\n             *   {@link Core.widget.MenuItem menu item} configs keyed by their id\n             * @param {Event} context.event The DOM event object that triggered the show\n             * @returns {Boolean|null} Returning `false` from this function prevents the menu being shown\n             * @preventable\n             */\n            processItems : null,\n            /**\n             * {@link Core.widget.Menu} items object containing named child menu items to apply to the feature's\n             * provided context menu.\n             *\n             * This may add extra items as below, but you can also configure, or remove any of the default items by\n             * configuring the name of the item as `null`:\n             *\n             * ```javascript\n             * features : {\n             *     cellMenu : {\n             *         // This object is applied to the Feature's predefined default items\n             *         items : {\n             *             switchToDog : {\n             *                 text : 'Dog',\n             *                 icon : 'b-fa b-fa-fw b-fa-dog',\n             *                 onItem({record}) {\n             *                     record.dog = true;\n             *                     record.cat = false;\n             *                 },\n             *                 weight : 500     // Make this second from end\n             *             },\n             *             switchToCat : {\n             *                 text : 'Cat',\n             *                 icon : 'b-fa b-fa-fw b-fa-cat',\n             *                 onItem({record}) {\n             *                     record.dog = false;\n             *                     record.cat = true;\n             *                 },\n             *                 weight : 510     // Make this sink to end\n             *             },\n             *             removeRow : {\n             *                 // Change icon for the delete item\n             *                 icon : 'b-fa b-fa-times'\n             *             },\n             *             secretItem : null\n             *         }\n             *     }\n             * },\n             * ```\n             *\n             * @config {Object<String,MenuItemConfig|Boolean|null>}\n             */\n            items : null,\n            type : 'cell'\n            /**\n             * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n             * @config {Object<String,String>} keyMap\n             */\n        };\n    }\n    static get pluginConfig() {\n        const config = super.pluginConfig;\n        config.chain.push('populateCellMenu');\n        return config;\n    }\n    //endregion\n    //region Events\n    /**\n     * This event fires on the owning grid before the context menu is shown for a cell.\n     * Allows manipulation of the items to show in the same way as in the {@link #config-processItems}.\n     *\n     * Returning `false` from a listener prevents the menu from being shown.\n     *\n     * @event cellMenuBeforeShow\n     * @preventable\n     * @on-owner\n     * @param {Grid.view.Grid} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Object<String,MenuItemConfig>} items Menu item configs\n     * @param {Grid.column.Column} column Column\n     * @param {Core.data.Model} record Record\n     */\n    /**\n     * This event fires on the owning grid after the context menu is shown for a cell.\n     * @event cellMenuShow\n     * @on-owner\n     * @param {Grid.view.Grid} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Object<String,MenuItemConfig>} items Menu item configs\n     * @param {Grid.column.Column} column Column\n     * @param {Core.data.Model} record Record\n     */\n    /**\n     * This event fires on the owning grid when an item is selected in the cell context menu.\n     * @event cellMenuItem\n     * @on-owner\n     * @param {Grid.view.Grid} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Core.widget.MenuItem} item Selected menu item\n     * @param {Grid.column.Column} column Column\n     * @param {Core.data.Model} record Record\n     */\n    /**\n     * This event fires on the owning grid when a check item is toggled in the cell context menu.\n     * @event cellMenuToggleItem\n     * @on-owner\n     * @param {Grid.view.Grid} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Core.widget.MenuItem} item Selected menu item\n     * @param {Grid.column.Column} column Column\n     * @param {Core.data.Model} record Record\n     * @param {Boolean} checked Checked or not\n     */\n    //endregion\n    //region Menu handlers\n    showContextMenu(eventParams) {\n        const\n            me = this,\n            {\n                cellSelector,\n                event\n            }  = eventParams;\n        // Process the gesture as navigation so that the use may select/multiselect\n        // the items to include in their context menu operation.\n        // Also select if not already selected.\n        me.client.focusCell(cellSelector, {\n            doSelect : !me.client.isSelected(cellSelector),\n            event\n        });\n        super.showContextMenu(eventParams);\n    }\n    shouldShowMenu({ column }) {\n        return column && column.enableCellContextMenu !== false;\n    }\n    getDataFromEvent(event) {\n        const cellData = this.client.getCellDataFromEvent(event);\n        // Only yield data to show a menu if we are on a cell\n        if (cellData) {\n            return ObjectHelper.assign(super.getDataFromEvent(event), cellData);\n        }\n    }\n    beforeContextMenuShow({ record, items, column }) {\n        if (column.cellMenuItems === false) {\n            return false;\n        }\n        if (!record || record.isSpecialRow) {\n            items.removeRow = false;\n        }\n    }\n    //endregion\n    //region Getters/Setters\n    populateCellMenu({ items, column, record }) {\n        const { client } = this;\n        if (column?.cellMenuItems) {\n            ObjectHelper.merge(items, column.cellMenuItems);\n        }\n        if (!client.readOnly) {\n            items.removeRow = {\n                text        : 'L{removeRow}',\n                localeClass : this,\n                icon        : 'b-fw-icon b-icon-trash',\n                cls         : 'b-separator',\n                weight      : 100,\n                disabled    : record.readOnly,\n                onItem      : () => {\n                    // When using tree grouping, remove original records from the original store\n                    const store = client.features.treeGroup?.originalStore ?? client.store;\n                    store.remove(client.selectedRecords.filter(r => !r.readOnly).map(r => r.$original));\n                }\n            };\n        }\n    }\n    get showMenu() {\n        return true;\n    }\n    //endregion\n}\nCellMenu.featureClass = '';\nCellMenu._$name = 'CellMenu'; GridFeatureManager.registerFeature(CellMenu, true, ['Grid', 'Scheduler']);\nGridFeatureManager.registerFeature(CellMenu, false, ['Gantt']);\n", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport TemplateHelper from '../../Core/helper/TemplateHelper.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport BrowserHelper from '../../Core/helper/BrowserHelper.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\n/**\n * @module Grid/feature/ColumnDragToolbar\n */\n/**\n * Displays a toolbar while dragging column headers. Drop on a button in the toolbar to activate a certain function,\n * for example to group by that column. This feature simplifies certain operations on touch devices.\n *\n * This feature is <strong>disabled</strong> by default, but turned on automatically on touch devices.\n *\n * {@inlineexample Grid/feature/ColumnDragToolbar.js}\n *\n * @demo Grid/columndragtoolbar\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype columnDragToolbar\n * @feature\n */\nexport default class ColumnDragToolbar extends Delayable(InstancePlugin) {\n    //region Config\n    static get $name() {\n        return 'ColumnDragToolbar';\n    }\n    // Plugin configuration. This plugin chains some of the functions in Grid\n    static get pluginConfig() {\n        return {\n            after : ['render']\n        };\n    }\n    //endregion\n    //region Init\n    construct(grid, config) {\n        if (grid.features.columnReorder) {\n            grid.features.columnReorder.ion({ beforeDestroy : 'onColumnReorderBeforeDestroy', thisObj : this });\n        }\n        this.grid = grid;\n        super.construct(grid, config);\n    }\n    doDestroy() {\n        const me = this;\n        if (me.grid.features.columnReorder && !me.grid.features.columnReorder.isDestroyed) {\n            me.detachFromColumnReorder();\n        }\n        me.element && me.element.remove();\n        me.element = null;\n        super.doDestroy();\n    }\n    doDisable(disable) {\n        if (this.initialized) {\n            if (disable) {\n                this.detachFromColumnReorder();\n            }\n            else {\n                this.init();\n            }\n        }\n        super.doDisable(disable);\n    }\n    init() {\n        const\n            me   = this,\n            grid = me.grid;\n        if (!grid.features.columnReorder) {\n            return;\n        }\n        me.reorderDetacher = grid.features.columnReorder.ion({\n            gridheaderdragstart({ context }) {\n                const column = grid.columns.getById(context.element.dataset.columnId);\n                me.showToolbar(column);\n            },\n            gridheaderdrag : ({ context }) => me.onDrag(context),\n            gridheaderabort : () => {\n                me.hideToolbar();\n            },\n            gridHeaderDrop : me.onDrop,\n            thisObj : me\n        });\n        me.initialized = true;\n    }\n    onColumnReorderBeforeDestroy() {\n        this.detachFromColumnReorder();\n    }\n    detachFromColumnReorder() {\n        const me = this;\n        me.grid.features.columnReorder.un('beforedestroy', me.onColumnReorderBeforeDestroy, me);\n        me.reorderDetacher && me.reorderDetacher();\n        me.reorderDetacher = null;\n    }\n    /**\n     * Initializes this feature on grid render.\n     * @private\n     */\n    render() {\n        if (!this.initialized) {\n            this.init();\n        }\n    }\n    //endregion\n    //region Toolbar\n    showToolbar(column) {\n        const\n            me      = this,\n            buttons = me.grid.getColumnDragToolbarItems(column, []),\n            groups  = [];\n        me.clearTimeout(me.buttonHideTimer);\n        buttons.forEach(button => {\n            button.text = button.localeClass.L(button.text);\n            let group = groups.find(group => group.text === button.group);\n            if (!group) {\n                group = {\n                    text    : button.localeClass.L(button.group),\n                    buttons : []\n                };\n                groups.push(group);\n            }\n            group.buttons.push(button);\n        });\n        me.element = DomHelper.append(me.grid.element, me.template(groups));\n        me.groups  = groups;\n        me.buttons = buttons;\n        me.column  = column;\n    }\n    async hideToolbar() {\n        const\n            me      = this,\n            element = me.element;\n        if (element) {\n            element.classList.add('b-remove');\n            await EventHelper.waitForTransitionEnd({\n                element,\n                mode    : 'animation',\n                thisObj : me.client\n            });\n            element.remove();\n            me.element = null;\n        }\n    }\n    //endregion\n    //region Events\n    onDrag(info) {\n        const me = this;\n        if (info.dragProxy.getBoundingClientRect().top - me.grid.element.getBoundingClientRect().top > 100) {\n            me.element.classList.add('b-closer');\n        }\n        else {\n            me.element.classList.remove('b-closer');\n        }\n        if (me.hoveringButton) {\n            me.hoveringButton.classList.remove('b-hover');\n            me.hoveringButton = null;\n        }\n        if (info.targetElement?.closest('.b-columndragtoolbar')) {\n            me.element.classList.add('b-hover');\n            const\n                button = info.targetElement.closest('.b-columndragtoolbar  .b-target-button:not([data-disabled=true])');\n            if (button) {\n                button.classList.add('b-hover');\n                me.hoveringButton = button;\n            }\n        }\n        else {\n            me.element.classList.remove('b-hover');\n        }\n    }\n    onDrop({ context }) {\n        const\n            me                = this,\n            { targetElement } = context;\n        if (targetElement && targetElement.matches('.b-columndragtoolbar .b-target-button:not([data-disabled=true])')) {\n            const button = me.buttons.find(button => button.ref === targetElement.dataset.ref);\n            if (button) {\n                targetElement.classList.add('b-activate');\n                me.buttonHideTimer = me.setTimeout(() => {\n                    me.hideToolbar();\n                    button.onDrop({ column : me.column });\n                }, 100);\n            }\n        }\n        else {\n            me.hideToolbar();\n        }\n    }\n    //endregion\n    template(groups) {\n        return TemplateHelper.tpl`\n            <div class=\"b-columndragtoolbar\">     \n            <div class=\"b-title\"></div>          \n            ${groups.map(group => TemplateHelper.tpl`\n                <div class=\"b-group\">\n                    <div class=\"b-buttons\">\n                    ${group.buttons.map(btn => TemplateHelper.tpl`\n                        <div class=\"b-target-button\" data-ref=\"${btn.ref}\" data-disabled=\"${btn.disabled}\">\n                            <i class=\"${btn.icon}\"></i>\n                            ${btn.text}\n                        </div>\n                    `)}\n                    </div>\n                    <div class=\"b-title\">${group.text}</div>\n                </div>\n            `)}\n            </div>`;\n    }\n}\nColumnDragToolbar.featureClass = 'b-hascolumndragtoolbar';\n// used by default on touch devices, can be enabled otherwise\nColumnDragToolbar._$name = 'ColumnDragToolbar'; GridFeatureManager.registerFeature(ColumnDragToolbar, BrowserHelper.isTouchDevice);\n", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport GridFeatureManager from './GridFeatureManager.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\n/**\n * @module Grid/feature/ColumnPicker\n */\n/**\n * Displays a column picker (to show/hide columns) in the header context menu. Columns can be displayed in sub menus\n * by region or tag. Grouped headers are displayed as menu hierarchies.\n *\n * {@inlineexample Grid/feature/ColumnPicker.js}\n *\n * This feature is <strong>enabled</strong> by default.\n *\n * @demo Grid/columns\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype columnPicker\n * @feature\n */\nexport default class ColumnPicker extends InstancePlugin {\n    //region Config\n    static $name = 'ColumnPicker';\n    static configurable = {\n        /**\n         * Groups columns in the picker by region (each region gets its own sub menu)\n         * @config {Boolean}\n         * @default\n         */\n        groupByRegion : false,\n        /**\n         * Groups columns in the picker by tag, each column may be shown under multiple tags. See\n         * {@link Grid.column.Column#config-tags}\n         * @config {Boolean}\n         * @default\n         */\n        groupByTag : false,\n        /**\n         * Configure this as `true` to have the fields from the Grid's {@link Core.data.Store}'s\n         * {@link Core.data.Store#config-modelClass} added to the menu to create __new__ columns\n         * to display the fields.\n         *\n         * This may be combined with the {@link Grid.view.mixin.GridState stateful} ability of the grid\n         * to create a self-configuring grid.\n         * @config {Boolean}\n         * @default\n         */\n        createColumnsFromModel : false,\n        menuCls : 'b-column-picker-menu b-sub-menu'\n    };\n    static get pluginConfig() {\n        return {\n            chain : ['populateHeaderMenu', 'getColumnDragToolbarItems']\n        };\n    }\n    get grid() {\n        return this.client;\n    }\n    //endregion\n    //region Context menu\n    /**\n     * Get menu items, either a straight list of columns or sub menus per subgrid\n     * @private\n     * @param columnStore Column store to traverse\n     * @returns {MenuItemConfig[]} Menu item configs\n     */\n    getColumnPickerItems(columnStore) {\n        const\n            me                        = this,\n            { createColumnsFromModel } = me;\n        let result;\n        if (me.groupByRegion) {\n            // submenus for grids regions\n            result = me.grid.regions.map(region => {\n                const columns = me.grid.getSubGrid(region).columns.topColumns;\n                return {\n                    text     : StringHelper.capitalize(region),\n                    menu     : me.buildColumnMenu(columns),\n                    disabled : columns.length === 0,\n                    region\n                };\n            });\n            if (createColumnsFromModel) {\n                result.push({\n                    text : me.L('L{newColumns}'),\n                    menu : me.createAutoColumnItems()\n                });\n            }\n        }\n        else if (me.groupByTag) {\n            // submenus for column tags\n            const tags = {};\n            columnStore.topColumns.forEach(column => {\n                column.tags && Array.isArray(column.tags) && column.hideable !== false && column.tags.forEach(tag => {\n                    if (!tags[tag]) {\n                        tags[tag] = 1;\n                    }\n                });\n            });\n            result = Object.keys(tags).sort().map(tag => ({\n                text            : StringHelper.capitalize(tag),\n                menu            : me.buildColumnMenu(me.getColumnsForTag(tag)),\n                tag,\n                onBeforeSubMenu : ({ item, itemEl }) => {\n                    me.refreshTagMenu(item, itemEl);\n                }\n            }));\n            if (createColumnsFromModel) {\n                result.push({\n                    text : me.L('L{newColumns}'),\n                    menu : me.createAutoColumnItems()\n                });\n            }\n        }\n        else {\n            // all columns in same menu\n            result = me.buildColumnMenu(columnStore.topColumns);\n            if (createColumnsFromModel) {\n                result.items.push(...ObjectHelper.transformNamedObjectToArray(me.createAutoColumnItems()));\n            }\n        }\n        return result;\n    }\n    createAutoColumnItems() {\n        const\n            me             = this,\n            { grid }       = me,\n            {\n                columns,\n                store\n            }              = grid,\n            { modelClass } = store,\n            { allFields }  = modelClass,\n            result         = {};\n        for (let i = 0, { length } = allFields; i < length; i++) {\n            const\n                field     = allFields[i],\n                fieldName = field.name;\n            if (!columns.get(fieldName)) {\n                // Don't include system-level \"internal\" fields from the base Model classes like rowHeight or cls.\n                if (!field.internal) {\n                    result[fieldName] = {\n                        text     : field.text || StringHelper.separate(field.name),\n                        checked  : false,\n                        onToggle : (event) => {\n                            const column = columns.get(fieldName);\n                            if (column) {\n                                column[event.checked ? 'show' : 'hide']();\n                            }\n                            else {\n                                columns.add(columns.generateColumnForField(field, {\n                                    region : me.forColumn.region\n                                }));\n                            }\n                            event.bubbles = false;\n                        }\n                    };\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Get all columns that has the specified tag.\n     * @private\n     * @param tag\n     * @returns {Grid.column.Column[]}\n     */\n    getColumnsForTag(tag) {\n        return this.grid.columns.records.filter(column =>\n            column.tags && Array.isArray(column.tags) && column.tags.includes(tag) && column.hideable !== false\n        );\n    }\n    /**\n     * Refreshes checked status for a tag menu. Needed since columns can appear under multiple tags.\n     * @private\n     */\n    refreshTagMenu(item, itemEl) {\n        const columns = this.getColumnsForTag(item.tag);\n        columns.forEach(column => {\n            const subItem = item.items.find(subItem => subItem.column === column);\n            if (subItem) subItem.checked = column.hidden !== true;\n        });\n    }\n    /**\n     * Traverses columns to build menu items for the column picker.\n     * @private\n     */\n    buildColumnMenu(columns) {\n        let currentRegion = columns.length > 0 && columns[0].region;\n        const\n            { grid } = this,\n            items    = columns.reduce((items, column) => {\n                const visibleInRegion = grid.columns.visibleColumns.filter(col => col.region === column.region);\n                if (column.hideable !== false) {\n                    const itemConfig = {\n                        grid,\n                        column,\n                        text     : column.headerText,\n                        checked  : column.hidden !== true,\n                        disabled : column.hidden !== true && visibleInRegion.length === 1,\n                        cls      : column.region !== currentRegion ? 'b-separator' : ''\n                    };\n                    currentRegion = column.region;\n                    if (column.children && !column.isCollapsible) {\n                        itemConfig.menu = this.buildColumnMenu(column.children);\n                    }\n                    items.push(itemConfig);\n                }\n                return items;\n            }, []);\n        return {\n            cls : this.menuCls,\n            items\n        };\n    }\n    /**\n     * Populates the header context menu items.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateHeaderMenu({ column, items }) {\n        const\n            me          = this,\n            { columns } = me.grid;\n        /**\n         * The column on which the context menu was invoked.\n         * @property {Grid.column.Column} forColumn\n         * @readonly\n         * @private\n         */\n        me.forColumn = column;\n        if (column.showColumnPicker !== false && columns.some(col => col.hideable)) {\n            // column picker\n            items.columnPicker = {\n                text        : 'L{columnsMenu}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-columns',\n                cls         : 'b-separator',\n                weight      : 200,\n                menu        : me.getColumnPickerItems(columns),\n                onToggle    : me.onColumnToggle,\n                disabled    : me.disabled\n            };\n        }\n        // menu item for hiding this column\n        if (column.hideable !== false && !column.parent.isCollapsible) {\n            items.hideColumn = {\n                text        : 'L{hideColumn}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-hide-column',\n                weight      : 210,\n                disabled    : !column.allowDrag || me.disabled,\n                onItem      : () => column.hide()\n            };\n        }\n    }\n    /**\n     * Handler for column hide/show menu checkitems.\n     * @private\n     * @param {Object} event The {@link Core.widget.MenuItem#event-toggle} event.\n     */\n    onColumnToggle({ menu, item, checked }) {\n        if (Boolean(item.column.hidden) !== !checked) {\n            item.column[checked ? 'show' : 'hide']();\n            const\n                { grid, column }      = item,\n                { columns, features } = grid,\n                // Sibling items, needed to disable other item if it is the last one in region\n                siblingItems          = menu.items,\n                // Columns left visible in same region as this items column\n                visibleInRegion       = columns.visibleColumns.filter(col => col.region === item.column.region),\n                // Needed to access \"hide-column\" item outside of column picker\n                hideItem              = features.headerMenu?.enabled && features.headerMenu.menu.widgetMap.hideColumn;\n            // Do not allow user to hide the last column in any region\n            if (visibleInRegion.length === 1) {\n                const lastVisibleItem = siblingItems.find(menuItem => menuItem.column === visibleInRegion[0]);\n                if (lastVisibleItem) {\n                    lastVisibleItem.disabled = true;\n                }\n                // Also disable \"Hide column\" item if only one column left in this region\n                if (hideItem && column.region === item.column.region) {\n                    hideItem.disabled = true;\n                }\n            }\n            // Multiple columns visible, enable \"hide-column\" and all items for that region\n            else {\n                visibleInRegion.forEach(col => {\n                    const siblingItem = siblingItems.find(sibling => sibling.column === col);\n                    if (siblingItem) {\n                        siblingItem.disabled = false;\n                    }\n                });\n                if (hideItem && column.region === item.column.region) {\n                    hideItem.disabled = false;\n                }\n            }\n            // Reflect status in submenu.\n            item.menu?.eachWidget(subItem => {\n                subItem.checked = checked;\n            });\n            const parentItem = menu.owner;\n            if (parentItem && parentItem.column === column.parent) {\n                parentItem.checked = siblingItems.some(subItem => subItem.checked === true);\n            }\n        }\n    }\n    /**\n     * Supply items to ColumnDragToolbar\n     * @private\n     */\n    getColumnDragToolbarItems(column, items) {\n        const visibleInRegion = this.grid.columns.visibleColumns.filter(col => col.region === column.region);\n        if (column.hideable !== false && visibleInRegion.length > 1) {\n            items.push({\n                text        : 'L{hideColumnShort}',\n                ref         : 'hideColumn',\n                group       : 'L{column}',\n                localeClass : this,\n                icon        : 'b-fw-icon b-icon-hide-column',\n                weight      : 101,\n                onDrop      : ({ column }) => column.hide()\n            });\n        }\n        return items;\n    }\n    //endregion\n}\nColumnPicker._$name = 'ColumnPicker'; GridFeatureManager.registerFeature(ColumnPicker, true);\n", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport DragHelper from '../../Core/helper/DragHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport Widget from '../../Core/widget/Widget.js';\nimport ScrollManager from '../../Core/util/ScrollManager.js';\n/**\n * @module Grid/feature/ColumnReorder\n */\n/**\n * Allows user to reorder columns by dragging headers. To get notified about column reorder listen to `change` event\n * on {@link Grid.data.ColumnStore columns} store.\n *\n * {@inlineexample Grid/feature/ColumnReorder.js}\n *\n * This feature is <strong>enabled</strong> by default.\n *\n * @demo Grid/columns\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype columnReorder\n * @feature\n */\nexport default class ColumnReorder extends Delayable(InstancePlugin) {\n    //region Init\n    static $name = 'ColumnReorder';\n    ignoreSelectors = [\n        '.b-grid-header-resize-handle',\n        '.b-field'\n    ];\n    // Plugin configuration. This plugin chains some functions in Grid\n    static pluginConfig = {\n        after : ['onInternalPaint', 'renderContents']\n    };\n    /**\n     * Initialize drag & drop (called from render)\n     * @private\n     */\n    init() {\n        const\n            me         = this,\n            { grid }   = me,\n            gridEl     = grid.element,\n            containers = DomHelper.children(gridEl, '.b-grid-headers');\n        containers.push(...DomHelper.children(gridEl, '.b-grid-header-children'));\n        if (me.dragHelper) {\n            // update the dragHelper with the new set of containers it should operate upon\n            me.dragHelper.containers = containers;\n        }\n        else {\n            // When using state provider in Salesforce we get into init before component is rendered\n            // which makes it impossible to locate correct root node. This is why we set up drag helper on paint\n            // https://github.com/bryntum/support/issues/6998\n            grid.whenVisible(() => me.createDragHelper());\n        }\n    }\n    createDragHelper() {\n        const\n            me         = this,\n            { grid }   = me,\n            gridEl     = grid.element,\n            containers = DomHelper.children(gridEl, '.b-grid-headers');\n        containers.push(...DomHelper.children(gridEl, '.b-grid-header-children'));\n        me.dragHelper = new DragHelper({\n            name                       : 'columnReorder',\n            mode                       : 'container',\n            dragThreshold              : 10,\n            targetSelector             : '.b-grid-header',\n            floatRootOwner             : grid,\n            rtlSource                  : grid,\n            outerElement               : grid.headerContainer,\n            // Require that we drag inside grid header while dragging if we don't have a drag toolbar or external drop\n            // target defined\n            dropTargetSelector         : '.b-grid-headers, .b-groupbar, .b-columndragtoolbar',\n            externalDropTargetSelector : '.b-groupbar, .b-columndragtoolbar',\n            monitoringConfig : {\n                scrollables : [{\n                    element : '.b-grid-headers'\n                }]\n            },\n            scrollManager : ScrollManager.new({\n                direction : 'horizontal',\n                element   : grid.headerContainer\n            }),\n            containers,\n            isElementDraggable(element) {\n                const abort = Boolean(element.closest(me.ignoreSelectors.join(',')));\n                if (abort || me.disabled) {\n                    return false;\n                }\n                const\n                    columnEl = element.closest(this.targetSelector),\n                    column   = columnEl && grid.columns.getById(columnEl.dataset.columnId),\n                    isLast   = column?.childLevel === 0 && grid.subGrids[column.region].columns.count === 1;\n                return Boolean(column) && column.draggable !== false && !isLast;\n            },\n            ignoreSelector    : '.b-filter-icon,.b-grid-header-resize-handle',\n            internalListeners : {\n                beforeDragStart : me.onBeforeDragStart,\n                dragstart       : me.onDragStart,\n                drag            : me.onDrag,\n                drop            : me.onDrop,\n                abort           : me.onAbort,\n                thisObj         : me\n            }\n        });\n        me.relayEvents(me.dragHelper, ['dragStart', 'drag', 'drop', 'abort'], 'gridHeader');\n        return me.dragHelper;\n    }\n    //endregion\n    //region Plugin config\n    doDestroy() {\n        this.dragHelper?.scrollManager.destroy();\n        this.dragHelper?.destroy();\n        super.doDestroy();\n    }\n    get grid() {\n        return this.client;\n    }\n    //endregion\n    //region Events (drop)\n    onBeforeDragStart({ context, event }) {\n        const\n            me          = this,\n            { element } = context,\n            column      = context.column = me.client.columns.getById(element.dataset.columnId);\n        me.dragHelper.autoSizeClonedTarget = !me.usingGroupBarWidget;\n        /**\n         * This event is fired prior to starting a column drag gesture. The drag is canceled if a listener returns `false`.\n         * @on-owner\n         * @event beforeColumnDragStart\n         * @param {Grid.view.Grid} source The grid instance.\n         * @param {Grid.column.Column} column The dragged column.\n         * @param {Event} event The browser event.\n         * @preventable\n         */\n        return column.allowDrag && me.client.trigger('beforeColumnDragStart', { column, event });\n    }\n    onDragStart({ context, event }) {\n        const\n            me                            = this,\n            { grid, usingGroupBarWidget } = me,\n            { column, dragProxy }                    = context;\n        if (!grid.features.columnDragToolbar && !usingGroupBarWidget) {\n            const headerContainerBox = grid.element.querySelector('.b-grid-header-container').getBoundingClientRect();\n            me.dragHelper.minY = headerContainerBox.top;\n            me.dragHelper.maxY = headerContainerBox.bottom;\n        }\n        grid.element.classList.add('b-dragging-header');\n        if (usingGroupBarWidget) {\n            dragProxy.classList.add('b-grid-reordering-columns-with-groupbar');\n        }\n        // Hide compact filter field while dragging\n        if (grid.features.filterBar && grid.features.filterBar.compactMode) {\n            dragProxy.classList.add('b-filter-bar-compact');\n        }\n        dragProxy.style.fontSize = DomHelper.getStyleValue(context.element, 'fontSize');\n        /**\n         * This event is fired when a column drag gesture has started.\n         * @on-owner\n         * @event columnDragStart\n         * @param {Grid.view.Grid} source The grid instance.\n         * @param {Grid.column.Column} column The dragged column.\n         * @param {Event} event The browser event.\n         */\n        grid.trigger('columnDragStart', { column, event });\n    }\n    onDrag({ context, event }) {\n        const\n            me        = this,\n            grid                     = me.client,\n            { column, insertBefore : insertBeforeElement } = context,\n            insertBefore                                   = grid.columns.getById(insertBeforeElement?.dataset.columnId),\n            targetHeader = Widget.fromElement(event.target, 'gridheader');\n        // If SubGrid is configured with a sealed column set, do not allow moving into it\n        if (targetHeader?.subGrid.sealedColumns) {\n            context.valid = false;\n        }\n        /**\n         * This event is fired when a column is being dragged, and you can set the `valid` flag on t\n         * @event columnDrag\n         * @on-owner\n         * @param {Grid.view.Grid} source The grid instance.\n         * @param {Grid.column.Column} column The dragged column.\n         * @param {Grid.column.Column} insertBefore The column before which the dragged column will be inserted.\n         * @param {Event} event The browser event.\n         * @param {Object} context\n         * @param {Boolean} context.valid Set this to true or false to indicate whether the drop position is valid.\n         */\n        grid.trigger('columnDrag', { column, insertBefore, event, context });\n    }\n    /**\n     * Handle drop\n     * @private\n     */\n    onDrop({ context, event }) {\n        if (!context.valid) {\n            return this.onInvalidDrop({ context, event });\n        }\n        const\n            me              = this,\n            { grid }        = me,\n            { column }      = context,\n            element         = context.dragging,\n            onHeader        = context.target.closest('.b-grid-header'),\n            droppedInRegion = context.draggedTo?.dataset.region,\n            isReorder       = droppedInRegion || onHeader;\n        let vetoed, newParent, insertBefore, toRegion, oldParent;\n        grid.element.classList.remove('b-dragging-header');\n        // Regular grid column reorder\n        if (isReorder) {\n            // If dropping on right edge of grid-headers element, append to that subgrid\n            const\n                onColumn = onHeader ? grid.columns.get(onHeader.dataset.column) : grid.subGrids[droppedInRegion].columns.last,\n                sibling  = context.insertBefore;\n            toRegion     = droppedInRegion || onColumn.region;\n            oldParent    = column.parent;\n            insertBefore = sibling ? grid.columns.getById(sibling.dataset.columnId) : grid.subGrids[toRegion].columns.last.nextSibling;\n            if (insertBefore) {\n                newParent = insertBefore.parent;\n            }\n            else {\n                const groupNode = onHeader?.parentElement.closest('.b-grid-header');\n                if (groupNode) {\n                    newParent = grid.columns.getById(groupNode.dataset.columnId);\n                }\n                else {\n                    newParent = grid.columns.rootNode;\n                }\n            }\n            // If dropped into its current position in the same SubGrid - abort\n            vetoed = (toRegion === column.region && oldParent === newParent && (onColumn === column.previousSibling || insertBefore === column.nextSibling));\n            element.remove();\n        }\n        // Clean up element used during drag drop as it will not be removed by Grid when it refreshes its header elements\n        /**\n         * This event is fired when a column is dropped, and you can return false from a listener to abort the operation.\n         * @event beforeColumnDropFinalize\n         * @on-owner\n         * @param {Grid.view.Grid} source The grid instance.\n         * @param {Grid.column.Column} column The dragged column.\n         * @param {Grid.column.Column} insertBefore The column before which the dragged column will be inserted.\n         * @param {Grid.column.Column} newParent The new parent column.\n         * @param {Event} event The browser event.\n         * @param {String} region The region where the column was dropped.\n         * @preventable\n         */\n        vetoed = vetoed || grid.trigger('beforeColumnDropFinalize', {\n            column, newParent, insertBefore, event, region : toRegion\n        }) === false;\n        if (!vetoed && isReorder) {\n            // Insert the column into its new place, which might be vetoed if column is sealed\n            vetoed = !newParent.insertChild(column, insertBefore);\n        }\n        context.valid = !vetoed;\n        if (!vetoed && isReorder) {\n            column.region = toRegion;\n            // Check if we should remove last child\n            if (oldParent.children.length === 0) {\n                oldParent.parent.removeChild(oldParent);\n            }\n        }\n        /**\n         * This event is always fired after a column is dropped. The `valid` param is true if the operation was not\n         * vetoed and the column was moved in the column store.\n         * @event columnDrop\n         * @on-owner\n         * @param {Grid.view.Grid} source The grid instance.\n         * @param {Grid.column.Column} column The dragged column.\n         * @param {Grid.column.Column} insertBefore The column before which the dragged column will be inserted.\n         * @param {Grid.column.Column} newParent The new parent column.\n         * @param {Boolean} valid true if the operation was not vetoed.\n         * @param {Event} event The browser event.\n         * @param {String} region The region where the column was dropped.\n         * @preventable\n         */\n        grid.trigger('columnDrop', { column, newParent, insertBefore, valid : context.valid, event, region : toRegion });\n    }\n    onAbort({ context, event }) {\n        this.onInvalidDrop({ context, event });\n    }\n    /**\n     * Handle invalid drop\n     * @private\n     */\n    onInvalidDrop({ context, event }) {\n        const\n            { grid }   = this,\n            { column } = context;\n        grid.trigger('columnDrop', { column, valid : false, event });\n        grid.element.classList.remove('b-dragging-header');\n    }\n    //endregion\n    //region Render\n    /**\n     * Updates DragHelper with updated headers when grid contents is rerendered\n     * @private\n     */\n    renderContents() {\n        // columns shown, hidden or reordered\n        this.init();\n    }\n    /**\n     * Initializes this feature on grid paint.\n     * @private\n     */\n    onInternalPaint() {\n        // always reinit on paint\n        this.init();\n    }\n    /**\n     * Returns true if a reorder operation is active\n     * @property {Boolean}\n     * @readonly\n     */\n    get isReordering() {\n        return Boolean(this.dragHelper?.isDragging);\n    }\n    //endregion\n}\nColumnReorder.featureClass = 'b-column-reorder';\nColumnReorder._$name = 'ColumnReorder'; GridFeatureManager.registerFeature(ColumnReorder, true);\n", "import ResizeHelper from '../../Core/helper/ResizeHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport BrowserHelper from '../../Core/helper/BrowserHelper.js';\n/**\n * @module Grid/feature/ColumnResize\n */\n/**\n * Enables user to resize columns by dragging a handle on the right hand side of the header. To get notified about column\n * resize listen to `change` event on {@link Grid.data.ColumnStore columns} store.\n *\n * This feature is <strong>enabled</strong> by default.\n *\n * {@inlineexample Grid/feature/ColumnResize.js}\n *\n * @demo Grid/columns\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype columnResize\n * @feature\n */\nexport default class ColumnResize extends InstancePlugin {\n    static get $name() {\n        return 'ColumnResize';\n    }\n    static get configurable() {\n        return {\n            /**\n             * Resize all cells below a resizing header during dragging.\n             * `'auto'` means `true` on non-mobile platforms.\n             * @config {String|Boolean}\n             * @default\n             */\n            liveResize : 'auto'\n        };\n    }\n    //region Init\n    construct(grid, config) {\n        const me = this;\n        me.grid = grid;\n        super.construct(grid, config);\n        me.resizer = new ResizeHelper({\n            name              : 'columnResize',\n            targetSelector    : '.b-grid-header',\n            handleSelector    : '.b-grid-header-resize-handle',\n            outerElement      : grid.element,\n            rtlSource         : grid,\n            internalListeners : {\n                beforeresizestart : me.onBeforeResizeStart,\n                resizestart       : me.onResizeStart,\n                resizing          : me.onResizing,\n                resize            : me.onResize,\n                cancel            : me.onCancel,\n                thisObj           : me\n            }\n        });\n    }\n    doDestroy() {\n        this.resizer?.destroy();\n        super.doDestroy();\n    }\n    //endregion\n    changeLiveResize(liveResize) {\n        if (liveResize === 'auto') {\n            return !BrowserHelper.isMobileSafari;\n        }\n        return liveResize;\n    }\n    //region Events\n    onBeforeResizeStart() {\n        return !this.disabled;\n    }\n    onResizeStart({ context }) {\n        const\n            { grid, resizer } = this,\n            column            = context.column = grid.columns.getById(context.element.dataset.columnId);\n        resizer.minWidth = column.minWidth;\n        grid.element.classList.add('b-column-resizing');\n    }\n    /**\n     * Handle drag event - resize the column live unless it's a touch gesture\n     * @private\n     */\n    onResizing({ context }) {\n        if (context.valid && this.liveResize) {\n            this.grid.resizingColumns = true;\n            context.column.width = context.newWidth;\n        }\n    }\n    /**\n     * Handle drop event (only used for touch)\n     * @private\n     */\n    onResize({ context }) {\n        const\n            { grid } = this,\n            { column } = context;\n        grid.element.classList.remove('b-column-resizing');\n        if (context.valid) {\n            if (this.liveResize) {\n                grid.resizingColumns = false;\n                grid.afterColumnsResized(column);\n            }\n            else {\n                column.width = context.newWidth;\n            }\n        }\n    }\n    /**\n     * Restore column width on cancel (ESC)\n     * @private\n     */\n    onCancel({ context }) {\n        const { grid } = this;\n        grid.element.classList.remove('b-column-resizing');\n        context.column.width = context.elementWidth;\n        grid.resizingColumns = false;\n    }\n    //endregion\n}\nColumnResize._$name = 'ColumnResize'; GridFeatureManager.registerFeature(ColumnResize, true);\n", "import FieldFilterPicker, { isFilterableField, isSupportedDurationField } from '../../Core/widget/FieldFilterPicker.js';\nimport ArrayHelper from '../../Core/helper/ArrayHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport '../../Core/widget/Combo.js';\nimport '../../Core/widget/Checkbox.js';\nimport '../../Core/widget/NumberField.js';\nimport '../../Core/widget/TextField.js';\nimport '../../Core/widget/DateField.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\n/**\n * @module Grid/widget/GridFieldFilterPicker\n */\n/**\n * Subclass of {@link Core.widget.FieldFilterPicker} allowing configuration using an\n * existing {@link Grid.view.Grid}.\n *\n * See also {@link Grid.widget.GridFieldFilterPickerGroup}.\n *\n * @extends Core/widget/FieldFilterPicker\n * @classtype gridfieldfilterpicker\n * @demo Grid/fieldfilters\n * @widget\n */\nexport default class GridFieldFilterPicker extends FieldFilterPicker {\n    //region Config\n    static get $name() {\n        return 'GridFieldFilterPicker';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'gridfieldfilterpicker';\n    }\n    /** @hideconfigs store */\n    static configurable = {\n        /**\n         * {@link Grid.view.Grid} from which to read the available field list. In order to\n         * appear as a selectable property for a filter, a column must have a `field` property.\n         * If the column has a `text` property, that will be shown as the displayed text in the\n         * selector; otherwise, the `field` property will be shown as-is.\n         *\n         * The grid's {@link Core.data.Store}'s {@link Core.data.Store#property-modelClass} will be\n         * examined to find field data types.\n         *\n         * You can limit available fields to a subset of the grid's columns using the\n         * {@link #config-allowedFieldNames} configuration property.\n         *\n         * @config {Grid.view.Grid}\n         */\n        grid : null,\n        /**\n         * Optional array of field names that are allowed as selectable properties for filters.\n         * This is a subset of the field names found in the {@link #config-grid}'s columns. When supplied, only\n         * the named fields will be shown in the property selector combo.\n         *\n         * Note that field names are case-sensitive and should match the data field name in the store\n         * model.\n         *\n         * @config {String[]}\n         */\n        allowedFieldNames : null\n    };\n    //endregion\n    afterConstruct() {\n        const\n            me = this;\n        if (!me.grid) {\n            throw new Error(`${me.constructor.$name} requires 'grid' to be configured.`);\n        }\n        me.fields = me.fields ?? {};  // Force `fields` changer if fields is left null, to merge w/ grid fields\n        super.afterConstruct();\n    }\n    updateGrid(newGrid) {\n        if (!newGrid.store?.modelClass) {\n            throw new Error(`Grid does not have a store with a modelClass defined.`);\n        }\n        if (!newGrid.columns) {\n            throw new Error(`Grid does not have a column store.`);\n        }\n    }\n    /**\n     * Gets the filterable fields backing any of the configured `grid`'s columns, for those columns for which\n     * it is possible to do so.\n     * @private\n     * @returns {Object} Filterable fields dictionary of the form { [fieldName]: { title, type } }\n     */\n    static getColumnFields(columnStore, modelClass, allowedFieldNames) {\n        return Object.fromEntries(\n            columnStore?.reduce((outFields, { field: fieldName, text, filterType, filterable }) => {\n                // Transform each column's `field` and `text` to [fieldName, { title, type }] by looking up the\n                // field type, excluding any fields not found in the model. Prefer column.filterType if available.\n                // Columns with `filterable` but no `filterType` get assigned `auto`.\n                if (!allowedFieldNames || allowedFieldNames.includes(fieldName)) {\n                    const\n                        field     = fieldName && modelClass.getFieldDefinition(fieldName),\n                        fieldType = isFilterableField(field) ? field.type : undefined;\n                    if (fieldType || filterType || filterable) {\n                        outFields.push([\n                            fieldName,\n                            {\n                                title : text || fieldName,\n                                type  : filterType ??\n                                    (isSupportedDurationField(field) ? 'duration' : fieldType) ??\n                                    'auto'\n                            }\n                        ]);\n                    }\n                }\n                return outFields;\n            }, []) ?? []);\n    }\n    changeFields(newFields) {\n        let localFields = newFields;\n        if (Array.isArray(newFields)) {\n            VersionHelper.deprecate('Core', '6.0.0', 'FieldOption[] deprecated, use Object<String, FieldOption[]> keyed by field name instead');\n            // Support old array syntax for `fields` during deprecation\n            localFields = ArrayHelper.keyBy(localFields, 'name');\n        }\n        const mergedFields = ObjectHelper.merge(\n            {},\n            GridFieldFilterPicker.getColumnFields(this.grid.columns, this.grid.store?.modelClass),\n            localFields\n        );\n        return this.allowedFieldNames\n            ? Object.fromEntries(this.allowedFieldNames.map(fieldName => [fieldName, mergedFields[fieldName]]))\n            : mergedFields;\n    }\n}\nGridFieldFilterPicker.initClass();\nGridFieldFilterPicker._$name = 'GridFieldFilterPicker';", "import FieldFilterPickerGroup from '../../Core/widget/FieldFilterPickerGroup.js';\nimport './GridFieldFilterPicker.js';\nimport '../../Core/widget/Checkbox.js';\nimport '../../Core/widget/Label.js';\n/**\n * @module Grid/widget/GridFieldFilterPickerGroup\n */\n/**\n * Extends {@link Core.widget.FieldFilterPickerGroup} to allow providing a {@link Grid.view.Grid} from which\n * available fields will be read. This is useful when a grid is already configured with a set of columns\n * containing display names and type information.\n *\n * The grid should have a {@link Grid.data.ColumnStore} configured (see {@link Grid.view.Grid#config-columns})\n * and a {@link Core.data.Store} whose {@link Core.data.Store#property-modelClass} contains fields with\n * specific data types.\n *\n * Optionally, you can also use {@link #config-allowedFieldNames} to restrict the set of fields shown in the\n * widget.\n *\n * For example:\n *\n * ```javascript\n * new GridFieldFilterPickerGroup({\n *     appendTo : domElement,\n *\n *     grid : myGrid,\n *\n *     filters : [{\n *         property : 'startDate',\n *         operator : '<=',\n *         value    : new Date()\n *     }]\n * });\n * ```\n *\n * @classtype gridfieldfilterpickergroup\n * @extends Core/widget/FieldFilterPickerGroup\n * @demo Grid/fieldfilters\n * @widget\n */\nexport default class GridFieldFilterPickerGroup extends FieldFilterPickerGroup {\n    //region Config\n    static get $name() {\n        return 'GridFieldFilterPickerGroup';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'gridfieldfilterpickergroup';\n    }\n    /** @hideconfigs fields, store */\n    static configurable = {\n        /**\n         * {@link Grid.view.Grid} from which to read the available field list. In order to\n         * appear as a selectable property for a filter, a column must have a `field` property.\n         * If the column has a `text` property, that will be shown as the displayed text in the\n         * selector; otherwise, the `field` property will be shown as-is.\n         *\n         * The grid's {@link Core.data.Store}'s {@link Core.data.Store#property-modelClass} will be\n         * examined to find field data types.\n         *\n         * You can limit available fields to a subset of the grid's columns using the\n         * {@link #config-allowedFieldNames} configuration property.\n         *\n         * @config {Grid.view.Grid}\n         */\n        grid : null,\n        /**\n         * Optional array of field names that are allowed as selectable properties for filters.\n         * This should be a subset of the field names found in the {@link #config-grid}'s store. When supplied,\n         * only the named fields will be shown in the property selector combo.\n         *\n         * @config {String[]}\n         */\n        allowedFieldNames : null\n    };\n    //endregion\n    static childPickerType = 'gridfieldfilterpicker';\n    validateConfig() {\n        if (!this.grid) {\n            throw new Error(`${this.constructor.$name} requires the 'grid' config property.`);\n        }\n    }\n    getFilterPickerConfig(filter) {\n        const { grid, allowedFieldNames, fields } = this;\n        return {\n            ...super.getFilterPickerConfig(filter),\n            fields,\n            grid,\n            allowedFieldNames\n        };\n    }\n    updateGrid(newGrid) {\n        this.store = this.grid.store;\n    }\n    /**\n     * @private\n     */\n    canManage(filter) {\n        const me = this;\n        return super.canManage(filter) && (!me.allowedFieldNames || me.allowedFieldNames.includes(filter.property));\n    }\n}\nGridFieldFilterPickerGroup.initClass();\nGridFieldFilterPickerGroup._$name = 'GridFieldFilterPickerGroup';", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport WidgetHelper from '../../Core/helper/WidgetHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport CollectionFilter from '../../Core/util/CollectionFilter.js';\nimport '../../Core/widget/NumberField.js';\nimport '../../Core/widget/Combo.js';\nimport '../../Core/widget/DateField.js';\nimport '../../Core/widget/TimeField.js';\nimport GridFeatureManager from './GridFeatureManager.js';\nimport '../widget/GridFieldFilterPickerGroup.js';\nimport FieldFilterPicker, { filterableFieldDataTypes } from '../../Core/widget/FieldFilterPicker.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\nimport DomClassList from '../../Core/helper/util/DomClassList.js';\n/**\n * @module Grid/feature/Filter\n */\n// Map column.filterType, column.type, or dataField.type -> CollectionFilter.type\nexport const fieldTypeMap = {\n    date     : 'date',\n    int      : 'number',\n    integer  : 'number',\n    number   : 'number',\n    string   : 'string',\n    duration : 'duration',\n    time     : 'time',\n    auto     : 'auto'\n};\nconst\n    // Map right-hand side of fieldTypeMap above (CollectionFilter.type) to default operator for that type\n    defaultOperators = {\n        date     : '=',\n        number   : '=',\n        string   : 'includes',\n        duration : '=',\n        relation : null,\n        auto     : '*'\n    },\n    // Allow filters with supported DataField types, plus 'relation'\n    allowedFilterTypes = {\n        ...filterableFieldDataTypes,\n        relation : true\n    },\n    menuItemsWithSeparators = {\n        filterDateIsToday     : true,\n        filterDateIsThisWeek  : true,\n        filterDateIsThisMonth : true,\n        filterDateIsThisYear  : true\n    };\n/**\n * Feature that allows filtering of the grid by settings filters on columns. The actual filtering is done by the store.\n * For info on programmatically handling filters, see {@link Core.data.mixin.StoreFilter}.\n *\n * {@inlineexample Grid/feature/Filter.js}\n *\n * ```javascript\n * // Filtering turned on but no default filter\n * const grid = new Grid({\n *   features : {\n *     filter : true\n *   }\n * });\n *\n * // Using default filter\n * const grid = new Grid({\n *   features : {\n *     filter : { property : 'city', value : 'Gavle' }\n *   }\n * });\n * ```\n *\n * A column can supply a custom filtering function as its {@link Grid.column.Column#config-filterable} config. When\n * filtering by that column using the UI that function will be used to determine which records to include. See\n * {@link Grid.column.Column#config-filterable Column#filterable} for more information.\n *\n * ```javascript\n * // Custom filtering function for a column\n * const grid = new Grid({\n *    features : {\n *        filter : true\n *    },\n *\n *    columns: [\n *        {\n *          field      : 'age',\n *          text       : 'Age',\n *          type       : 'number',\n *          // Custom filtering function that checks \"greater than\" no matter\n *          // which field user filled in :)\n *          filterable : ({ record, value, operator }) => record.age > value\n *        }\n *    ]\n * });\n * ```\n *\n * If this feature is configured with `prioritizeColumns : true`, those functions will also be used when filtering\n * programmatically:\n *\n * ```javascript\n * const grid = new Grid({\n *    features : {\n *        filter : {\n *            prioritizeColumns : true\n *        }\n *    },\n *\n *    columns: [\n *        {\n *          field      : 'age',\n *          text       : 'Age',\n *          type       : 'number',\n *          filterable : ({ record, value, operator }) => record.age > value\n *        }\n *    ]\n * });\n *\n * // Because of the prioritizeColumns config above, any custom filterable function\n * // on a column will be used when programmatically filtering by that columns field\n * grid.store.filter({\n *     property : 'age',\n *     value    : 41\n * });\n * ```\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * **Note:** This feature cannot be used together with {@link Grid.feature.FilterBar} feature, they are\n * mutually exclusive.\n *\n * ## Keyboard shortcuts\n * This feature has the following default keyboard shortcuts:\n *\n * | Keys   | Action                  | Action description                                                     |\n * |--------|-------------------------|------------------------------------------------------------------------|\n * | F      | showFilterEditorByKey   | When the column header is focused, this shows the filter input field   |\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#Grid/guides/customization/keymap.md).\n *\n * ## Menu items\n *\n * The following items are populated under the Filter submenu (in the cell and column header context menus) when the Filter feature is active.\n *\n * | Item reference                | Text                 | Weight | Enabled by default | Description                                                                                                                                           |\n * |-------------------------------|----------------------|--------|--------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------|\n * | `filterAuto*`                 | Contains             | 310    | true               | Filters records in the store to those where the column field contains the selected cell value                                                         |\n * | `filterBooleanIsTrue`         | True                 | 310    | true               | Filters records in the store to those where the column field is true                                                                                  |\n * | `filterBooleanIsFalse`        | False                | 320    | true               | Filters records in the store to those where the column field is false                                                                                 |\n * | `filterDateEmpty`             | Empty                | 310    | true               | Filters records in the store to those where the column field empty                                                                                    |\n * | `filterDateNotEmpty`          | Not empty            | 320    | true               | Filters records in the store to those where the column field not empty                                                                                |\n * | `filterDate=`                 | Equals               | 330    | true               | Filters records in the store to those where the column field is equal to the selected cell value                                                      |\n * | `filterDate!=`                | Does not equal       | 340    | true               | Filters records in the store to those where the column field is not equal to the selected cell value                                                  |\n * | `filterDate<`                 | Less than            | 350    | true               | Filters records in the store to those where the column field is less than the selected cell value                                                     |\n * | `filterDate>`                 | Greater than         | 360    | true               | Filters records in the store to those where the column field is greater than the selected cell value                                                  |\n * | `filterDateIsToday`           | Today                | 370    | true               | Filters records in the store to those where the column field is today                                                                                 |\n * | `filterDateIsTomorrow`        | Tomorrow             | 380    | true               | Filters records in the store to those where the column field is tomorrow                                                                              |\n * | `filterDateIsYesterday`       | Yesterday            | 390    | true               | Filters records in the store to those where the column field is yesterday                                                                             |\n * | `filterDateIsThisWeek`        | This week            | 400    | true               | Filters records in the store to those where the column field is this week                                                                             |\n * | `filterDateIsNextWeek`        | Next week            | 410    | true               | Filters records in the store to those where the column field is next week                                                                             |\n * | `filterDateIsLastWeek`        | Last week            | 420    | true               | Filters records in the store to those where the column field is last week                                                                             |\n * | `filterDateIsThisMonth`       | This month           | 430    | true               | Filters records in the store to those where the column field is this month                                                                            |\n * | `filterDateIsNextMonth`       | Next month           | 440    | true               | Filters records in the store to those where the column field is next month                                                                            |\n * | `filterDateIsLastMonth`       | Last month           | 450    | true               | Filters records in the store to those where the column field is last month                                                                            |\n * | `filterDateIsThisYear`        | This year            | 460    | true               | Filters records in the store to those where the column field is this year                                                                             |\n * | `filterDateIsNextYear`        | Next year            | 470    | true               | Filters records in the store to those where the column field is next year                                                                             |\n * | `filterDateIsLastYear`        | Last year            | 480    | true               | Filters records in the store to those where the column field is last year                                                                             |\n * | `filterDateIsYearToDate`      | Year to date         | 490    | true               | Filters records in the store to those where the column field is within the year to date                                                               |\n * | `filterDurationEmpty`         | Empty                | 310    | true               | Filters records in the store to those where the column field is empty                                                                                 |\n * | `filterDurationNotEmpty`      | Not empty            | 320    | true               | Filters records in the store to those where the column field is not empty                                                                             |\n * | `filterDuration=`             | Equals               | 330    | true               | Filters records in the store to those where the column field is equal to the selected cell value                                                      |\n * | `filterDuration!=`            | Does not equal       | 340    | true               | Filters records in the store to those where the column field is not equal to the selected cell value                                                  |\n * | `filterDuration>`             | Greater than         | 350    | true               | Filters records in the store to those where the column field is greater than the selected cell value                                                  |\n * | `filterDuration<`             | Less than            | 360    | true               | Filters records in the store to those where the column field is less than the selected cell value                                                     |\n * | `filterDuration>=`            | Greater or equals    | 370    | true               | Filters records in the store to those where the column field is greater than or equal to the selected cell value                                      |\n * | `filterDuration<=`            | Less or equals       | 380    | true               | Filters records in the store to those where the column field is less than or equal to the selected cell value                                         |\n * | `filterNumberEmpty`           | Empty                | 310    | true               | Filters records in the store to those where the column field is empty                                                                                 |\n * | `filterNumberNotEmpty`        | Not empty            | 320    | true               | Filters records in the store to those where the column field is not empty                                                                             |\n * | `filterNumber=`               | Equals               | 330    | true               | Filters records in the store to those where the column field is equal to the selected cell value                                                      |\n * | `filterNumber!=`              | Does not equal       | 340    | true               | Filters records in the store to those where the column field is not equal to the selected cell value                                                  |\n * | `filterNumber>`               | Greater than         | 350    | true               | Filters records in the store to those where the column field is greater than the selected cell value                                                  |\n * | `filterNumber<`               | Less than            | 360    | true               | Filters records in the store to those where the column field is less than the selected cell value                                                     |\n * | `filterNumber>=`              | Greater or equals    | 370    | true               | Filters records in the store to those where the column field is greater than or equal to the selected cell value                                      |\n * | `filterNumber<=`              | Less or equals       | 380    | true               | Filters records in the store to those where the column field is less than or equal to the selected cell value                                         |\n * | `filterRelationEmpty`         | Empty                | 310    | true               | Filters records in the store to those where the column field is empty                                                                                 |\n * | `filterRelationNotEmpty`      | Not empty            | 320    | true               | Filters records in the store to those where the column field is not empty                                                                             |\n * | `filterRelation=`             | Equals               | 330    | true               | Filters records in the store to those where the column field is equal to the selected cell value                                                      |\n * | `filterRelation!=`            | Does not equal       | 340    | true               | Filters records in the store to those where the column field is not equal to the selected cell value                                                  |\n * | `filterStringEmpty`           | Empty                | 310    | true               | Filters records in the store to those where the column field is empty                                                                                 |\n * | `filterStringNotEmpty`        | Not empty            | 320    | true               | Filters records in the store to those where the column field is not empty                                                                             |\n * | `filterString=`               | Equals               | 330    | true               | Filters records in the store to those where the column field is equal to the selected cell value                                                      |\n * | `filterString!=`              | Does not equal       | 340    | true               | Filters records in the store to those where the column field is not equal to the selected cell value                                                  |\n * | `filterStringIncludes`        | Contains             | 350    | true               | Filters records in the store to those where the column field contains the selected cell value                                                         |\n * | `filterStringDoesNotInclude`  | Does not contain     | 360    | true               | Filters records in the store to those where the column field does not contain the selected cell value                                                 |\n * | `filterStringStartsWith`      | Starts with          | 370    | true               | Filters records in the store to those where the column field starts with to the selected cell value                                                   |\n * | `filterStringEndsWith`        | Ends with            | 380    | true               | Filters records in the store to those where the column field ends with to the selected cell value                                                     |\n * | `editFilter`                  | Edit filter          | 500    | false              | Opens a popup to edit the current filter. Will be renamed `filterEdit` in 6.0. Only shown when current column is filtered.                            |\n * | `filterRemove`                | Remove filter        | 510    | false              | Stops filtering by selected column field. Will be renamed `filterRemove` in 6.0. Only shown when current column is filtered.                          |\n * | `disableFilter`               | Disable filter       | 520    | false              | Temporarily stops filtering by selected column field. Will be renamed `filterDisable` in 6.0. Only shown when current column is filtered.             |\n *\n * ## Legacy UI mode\n *\n * To use the more limited legacy UI instead, configure {@link #config-legacyMode} to `true`.\n *\n * You can supply a field config to use for the filtering field displayed for string type columns (legacy mode only):\n *\n * ```javascript\n * // For string-type columns you can also replace the filter UI with a custom field:\n * columns: [\n *     {\n *         field : 'city',\n *         // Filtering for a value out of a list of values\n *         filterable: {\n *             filterField : {\n *                 type  : 'combo',\n *                 items : [\n *                     'Paris',\n *                     'Dubai',\n *                     'Moscow',\n *                     'London',\n *                     'New York'\n *                 ]\n *             }\n *         }\n *     }\n * ]\n * ```\n *\n * You can also change default fields, for example this will use {@link Core.widget.DateTimeField} in filter popup\n * (legacy mode only):\n *\n * ```javascript\n * columns : [\n *     {\n *         type       : 'date',\n *         field      : 'start',\n *         filterable : {\n *             filterField : {\n *                 type : 'datetime'\n *             }\n *         }\n *     }\n * ]\n * ```\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Grid/filtering\n * @classtype filter\n * @feature\n */\nexport default class Filter extends InstancePlugin {\n    //region Init\n    static get $name() {\n        return 'Filter';\n    }\n    static get configurable() {\n        return {\n            /**\n             * Use custom filtering functions defined on columns also when programmatically filtering by the columns\n             * field.\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *     columns : [\n             *         {\n             *             field : 'age',\n             *             text : 'Age',\n             *             filterable({ record, value }) {\n             *               // Custom filtering, return true/false\n             *             }\n             *         }\n             *     ],\n             *\n             *     features : {\n             *         filter : {\n             *             prioritizeColumns : true // <--\n             *         }\n             *     }\n             * });\n             *\n             * // Because of the prioritizeColumns config above, any custom\n             * // filterable function on a column will be used when\n             * // programmatically filtering by that columns field\n             * grid.store.filter({\n             *     property : 'age',\n             *     value    : 30\n             * });\n             * ```\n             *\n             * @config {Boolean}\n             * @default\n             * @category Common\n             */\n            prioritizeColumns : false,\n            /**\n             * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n             * @config {Object<String,String>}\n             */\n            keyMap : {\n                f : 'showFilterEditorByKey'\n            },\n            /**\n             * `true` to enable the more limited legacy UI mode.\n             *\n             * @config {Boolean}\n             * @default\n             * @category Common\n             */\n            legacyMode : false,\n            /**\n             * Optional configuration to use when configuring the {@link Grid.widget.GridFieldFilterPickerGroup} shown in the\n             * column header popup, when not in legacy mode.\n             *\n             * @config {GridFieldFilterPickerGroupConfig}\n             * @category Common\n             */\n            pickerConfig : null,\n            /**\n             * When true, close the popup when the last filter shown in the popup is removed using the remove button. Not\n             * applicable in legacy mode.\n             *\n             * @config {Boolean}\n             * @default\n             * @category Common\n             */\n            closeEmptyPopup : false\n        };\n    }\n    construct(grid, config) {\n        if (grid.features.filterBar) {\n            throw new Error('Grid.feature.Filter feature may not be used together with Grid.feature.FilterBar. These features are mutually exclusive.');\n        }\n        const me = this;\n        me.grid = grid;\n        me.closeFilterEditor = me.closeFilterEditor.bind(me);\n        if (config?.isMulti) {\n            VersionHelper.deprecate('Grid', '6.0.0', 'Filter plugin config isMulti deprecated, use pickerConfig instead');\n            if (typeof config.isMulti === 'object') {\n                config.pickerConfig = config.isMulti;\n            }\n            delete config.isMulti;\n        }\n        super.construct(grid, config);\n        me.bindStore(grid.store);\n        if (config && typeof config === 'object') {\n            const clone = ObjectHelper.clone(config);\n            // Remove non-CollectionFilter config properties, to use config as filter\n            delete clone.prioritizeColumns;\n            delete clone.legacyMode;\n            delete clone.pickerConfig;\n            delete clone.dateFormat;\n            delete clone.closeEmptyPopup;\n            if (!ObjectHelper.isEmpty(clone)) {\n                grid.store.filter(clone, null, grid.isConfiguring);\n            }\n        }\n    }\n    doDestroy() {\n        this.filterTip?.destroy();\n        this.filterEditorPopup?.destroy();\n        super.doDestroy();\n    }\n    get store() {\n        return this.grid.store;\n    }\n    bindStore(store) {\n        this.detachListeners('store');\n        store.ion({\n            name         : 'store',\n            beforeFilter : 'onStoreBeforeFilter',\n            filter       : 'onStoreFilter',\n            thisObj      : this\n        });\n        if (this.client.isPainted) {\n            this.refreshHeaders(false);\n        }\n    }\n    //endregion\n    //region Plugin config\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['renderHeader', 'populateCellMenu', 'populateHeaderMenu', 'onElementClick', 'bindStore']\n        };\n    }\n    //endregion\n    //region Refresh headers\n    /**\n     * Update headers to match stores filters. Called on store load and grid header render.\n     * @param reRenderRows Also refresh rows?\n     * @private\n     */\n    refreshHeaders(reRenderRows) {\n        const\n            me      = this,\n            grid    = me.grid,\n            element = grid.headerContainer;\n        if (element) {\n            // remove .latest from all filters, will be applied to actual latest\n            DomHelper.children(element, '.b-filter-icon.b-latest').forEach(iconElement => iconElement.classList.remove('b-latest'));\n            if (!me.filterTip) {\n                me.filterTip = new Tooltip({\n                    forElement  : element,\n                    forSelector : '.b-filter-icon',\n                    getHtml({ activeTarget }) {\n                        return activeTarget.dataset.filterText;\n                    }\n                });\n            }\n            if (!grid.store.isFiltered) {\n                me.filterTip.hide();\n            }\n            grid.columns.visibleColumns.forEach(column => {\n                if (column.filterable !== false) {\n                    const\n                        columnFilters    = me.store.filters.allValues.filter(({ property, disabled, internal }) =>\n                            property === column.field && !disabled && !internal),\n                        isColumnFiltered = columnFilters.length > 0,\n                        headerEl = column.element;\n                    if (headerEl) {\n                        const textEl = column.textWrapper;\n                        let filterIconEl = textEl?.querySelector('.b-filter-icon'),\n                            filterText;\n                        if (isColumnFiltered) {\n                            const bullet = '&#x2022 ';\n                            filterText = `${me.L('L{filter}')}: ` +\n                                (columnFilters.length > 1 ? '<br/><br/>' : '') +\n                                columnFilters.map(columnFilter => {\n                                    let value = columnFilter.value ?? '';\n                                    const\n                                        isArray = Array.isArray(value),\n                                        relation = me.store?.modelRelations?.find(\n                                            ({ foreignKey }) => foreignKey === columnFilter.property);\n                                    if (columnFilter.displayValue) {\n                                        value = columnFilter.displayValue;\n                                    }\n                                    else {\n                                        if (!me.legacyMode && relation) {\n                                            // Look up remote display value per filterable-field config (FieldFilterPicker.js#FieldOption)\n                                            const { relatedDisplayField } = me.pickerConfig?.fields?.[columnFilter.property];\n                                            if (relatedDisplayField) {\n                                                const getDisplayValue = foreignId => relation.foreignStore.getById(foreignId)?.[relatedDisplayField];\n                                                if (isArray) {\n                                                    value = value.map(getDisplayValue)\n                                                        .sort((a, b) => (a ?? '').localeCompare(b ?? ''));\n                                                }\n                                                else {\n                                                    value = getDisplayValue(value);\n                                                }\n                                            }\n                                        }\n                                        else if (column.formatValue && value) {\n                                            value = isArray\n                                                ? value.map(val => column.formatValue(val))\n                                                : column.formatValue(value);\n                                        }\n                                        if (isArray) {\n                                            value = `[ ${value.join(', ')} ]`;\n                                        }\n                                    }\n                                    return (columnFilters.length > 1 ? bullet : '') +\n                                        (typeof columnFilter === 'string'\n                                            ? columnFilter\n                                            : `${columnFilter.operator} ${value}`);\n                                }).join('<br/><br/>');\n                        }\n                        else {\n                            filterText = me.L('L{applyFilter}');\n                        }\n                        if (!filterIconEl) {\n                            // putting icon in header text to have more options for positioning it\n                            filterIconEl = DomHelper.createElement({\n                                parent    : textEl,\n                                tag       : 'div',\n                                className : 'b-filter-icon',\n                                dataset   : {\n                                    filterText\n                                }\n                            });\n                        }\n                        else {\n                            filterIconEl.dataset.filterText = filterText;\n                        }\n                        // latest applied filter distinguished with class to enable highlighting etc.\n                        if (column.field === me.store.latestFilterField) filterIconEl.classList.add('b-latest');\n                        headerEl.classList.add('b-filterable');\n                        headerEl.classList.toggle('b-filter', isColumnFiltered);\n                    }\n                    column.meta.isFiltered = isColumnFiltered;\n                }\n            });\n            if (reRenderRows) {\n                grid.refreshRows();\n            }\n        }\n    }\n    //endregion\n    //region Filter\n    applyFilter(column, filterConfig) {\n        const { store } = this;\n        // Must add the filter silently, so that the column gets a reference to its $filter\n        // before the filter happens and events are broadcast.\n        column.$filter = store.addFilter(this.injectColumnFilterConfig(column, filterConfig), true);\n        // Apply the new set of store filters.\n        store.filter();\n    }\n    injectColumnFilterConfig(column, filterConfig) {\n        const { filterFn } = column.filterable;\n        return ObjectHelper.assign(filterConfig, {\n            ...column.filterable,\n            ...filterConfig,\n            property : column.field,\n            // Only inject a filterBy configuration if the column has a custom filterBy\n            [filterFn ? 'filterBy' : '_'] : function(record) {\n                return filterFn({ value : this.value, record, operator : this.operator, property : this.property, column });\n            }\n        });\n    }\n    removeFilter(column, onlyForOperator) {\n        if (!this.legacyMode && !column.filterable?.filterField) {\n            for (const filter of this.getCurrentMultiFilters(column)) {\n                if (!onlyForOperator || filter.operator === onlyForOperator) {\n                    this.store.removeFilter(filter);\n                }\n            }\n        }\n        else {\n            this.store.removeFilter(column.field);\n        }\n    }\n    disableFilter(column) {\n        for (const filter of this.getCurrentMultiFilters(column)) {\n            filter.disabled = true;\n            this.store.filter(filter);\n        }\n        this.store.filter();\n    }\n    getCurrentMultiFilters(column) {\n        return this.store.filters.values.filter(filter => filter.property === column.field);\n    }\n    getPopupDateItems(column, fieldType, filter, initialValue, store, changeCallback, closeCallback, filterField) {\n        const\n            me      = this,\n            onClose = changeCallback;\n        function onClear() {\n            me.removeFilter(column);\n        }\n        function onKeydown({ event }) {\n            if (event.key === 'Enter') {\n                changeCallback();\n            }\n        }\n        function onChange({ source, value }) {\n            if (value == null) {\n                onClear();\n            }\n            else {\n                me.clearSiblingsFields(source);\n                me.applyFilter(column, { operator : source.operator, value, displayValue : source._value, type : 'date' });\n            }\n        }\n        return [\n            ObjectHelper.assign({\n                type        : 'date',\n                ref         : 'on',\n                placeholder : 'L{on}',\n                localeClass : me,\n                clearable   : true,\n                label       : '<i class=\"b-fw-icon b-icon-filter-equal\"></i>',\n                value       : filter?.operator === 'sameDay' ? filter.value : initialValue,\n                operator    : 'sameDay',\n                onKeydown,\n                onChange,\n                onClose,\n                onClear\n            }, filterField),\n            ObjectHelper.assign({\n                type        : 'date',\n                ref         : 'before',\n                placeholder : 'L{before}',\n                localeClass : me,\n                clearable   : true,\n                label       : '<i class=\"b-fw-icon b-icon-filter-before\"></i>',\n                value       : filter?.operator === '<' ? filter.value : null,\n                operator    : '<',\n                onKeydown,\n                onChange,\n                onClose,\n                onClear\n            }, filterField),\n            ObjectHelper.assign({\n                type        : 'date',\n                ref         : 'after',\n                cls         : 'b-last-row',\n                placeholder : 'L{after}',\n                localeClass : me,\n                clearable   : true,\n                label       : '<i class=\"b-fw-icon b-icon-filter-after\"></i>',\n                value       : filter?.operator === '>' ? filter.value : null,\n                operator    : '>',\n                onKeydown,\n                onChange,\n                onClose,\n                onClear\n            }, filterField)\n        ];\n    }\n    getPopupNumberItems(column, fieldType, filter, initialValue, store, changeCallback, closeCallback, filterField) {\n        const\n            me    = this,\n            onEsc = changeCallback;\n        function onClear() {\n            me.removeFilter(column);\n        }\n        function onKeydown({ event }) {\n            if (event.key === 'Enter') {\n                changeCallback();\n            }\n        }\n        function onChange({ source, value }) {\n            if (value == null) {\n                onClear();\n            }\n            else {\n                me.clearSiblingsFields(source);\n                me.applyFilter(column, { operator : source.operator, value });\n            }\n        }\n        return [\n            ObjectHelper.assign({\n                type        : 'number',\n                placeholder : 'L{Filter.equals}',\n                localeClass : me,\n                clearable   : true,\n                label       : '<i class=\"b-fw-icon b-icon-filter-equal\"></i>',\n                value       : filter?.operator === '=' ? filter.value : initialValue,\n                operator    : '=',\n                onKeydown,\n                onChange,\n                onEsc,\n                onClear\n            }, filterField),\n            ObjectHelper.assign({\n                type        : 'number',\n                placeholder : 'L{lessThan}',\n                localeClass : me,\n                clearable   : true,\n                label       : '<i class=\"b-fw-icon b-icon-filter-less\"></i>',\n                value       : filter?.operator === '<' ? filter.value : null,\n                operator    : '<',\n                onKeydown,\n                onChange,\n                onEsc,\n                onClear\n            }, filterField),\n            ObjectHelper.assign({\n                type        : 'number',\n                cls         : 'b-last-row',\n                placeholder : 'L{moreThan}',\n                localeClass : me,\n                clearable   : true,\n                label       : '<i class=\"b-fw-icon b-icon-filter-more\"></i>',\n                value       : filter?.operator === '>' ? filter.value : null,\n                operator    : '>',\n                onKeydown,\n                onChange,\n                onEsc,\n                onClear\n            }, filterField)\n        ];\n    }\n    clearSiblingsFields(sourceField) {\n        this.filterEditorPopup?.items.forEach(field => {\n            field !== sourceField && field?.clear();\n        });\n    }\n    getPopupDurationItems(column, fieldType, filter, initialValue, store, changeCallback, closeCallback, filterField) {\n        const\n            me      = this,\n            onEsc   = changeCallback,\n            onClear = () => me.removeFilter(column);\n        function onChange({ source, value }) {\n            if (value == null) {\n                onClear();\n            }\n            else {\n                me.clearSiblingsFields(source);\n                me.applyFilter(column, { operator : source.operator, value });\n            }\n        }\n        return [\n            ObjectHelper.assign({\n                type        : 'duration',\n                placeholder : 'L{Filter.equals}',\n                localeClass : me,\n                clearable   : true,\n                label       : '<i class=\"b-fw-icon b-icon-filter-equal\"></i>',\n                value       : filter?.operator === '=' ? filter.value : initialValue,\n                operator    : '=',\n                onChange,\n                onEsc,\n                onClear\n            }, filterField),\n            ObjectHelper.assign({\n                type        : 'duration',\n                placeholder : 'L{lessThan}',\n                localeClass : me,\n                clearable   : true,\n                label       : '<i class=\"b-fw-icon b-icon-filter-less\"></i>',\n                value       : filter?.operator === '<' ? filter.value : null,\n                operator    : '<',\n                onChange,\n                onEsc,\n                onClear\n            }, filterField),\n            ObjectHelper.assign({\n                type        : 'duration',\n                cls         : 'b-last-row',\n                placeholder : 'L{moreThan}',\n                localeClass : me,\n                clearable   : true,\n                label       : '<i class=\"b-fw-icon b-icon-filter-more\"></i>',\n                value       : filter?.operator === '>' ? filter.value : null,\n                operator    : '>',\n                onChange,\n                onEsc,\n                onClear\n            }, filterField)\n        ];\n    }\n    getPopupStringItems(column, fieldType, filter, initialValue, store, changeCallback, closeCallback, filterField) {\n        const me = this;\n        return [ObjectHelper.assign({\n            type        : 'text',\n            cls         : 'b-last-row',\n            placeholder : 'L{filter}',\n            localeClass : me,\n            clearable   : true,\n            label       : '<i class=\"b-fw-icon b-icon-filter-equal\"></i>',\n            value       : filter ? filter.value || filter : initialValue,\n            operator    : '*',\n            onChange({ source, value }) {\n                if (value === '') {\n                    closeCallback();\n                }\n                else {\n                    me.applyFilter(column, { operator : source.operator, value, displayValue : source.displayField && source.records ? source.records.map(rec => rec[source.displayField]).join(', ') : undefined });\n                    // Leave multiselect filter combo visible to be able to select many items at once\n                    if (!source.multiSelect) {\n                        changeCallback();\n                    }\n                }\n            },\n            onClose : changeCallback,\n            onClear : closeCallback\n        }, filterField)];\n    }\n    /**\n     * Get fields to display in filter popup.\n     * @param {Grid.column.Column} column Column\n     * @param fieldType Type of field, number, date etc.\n     * @param filter Current filter\n     * @param initialValue\n     * @param store Grid store\n     * @param changeCallback Callback for when filter has changed\n     * @param closeCallback Callback for when editor should be closed\n     * @param filterField filter field\n     * @returns {*}\n     * @private\n     */\n    getPopupItems(column, fieldType, filter, initialValue, store, changeCallback, closeCallback, filterField) {\n        const me = this;\n        if (me.useLegacyModeForColumn(column) || filterField) {\n            switch (fieldType) {\n                case 'date':\n                    return me.getPopupDateItems(...arguments);\n                case 'number':\n                    return me.getPopupNumberItems(...arguments);\n                case 'duration':\n                    return me.getPopupDurationItems(...arguments);\n                default:\n                    return me.getPopupStringItems(...arguments);\n            }\n        }\n        return [me.getFieldFilterPickerGroup(column)];\n    }\n    getFieldFilterPickerGroup(column) {\n        const me = this;\n        return {\n            ...me.pickerConfig,\n            type              : 'gridfieldfilterpickergroup',\n            ref               : 'pickerGroup',\n            limitToProperty   : column.field,\n            grid              : me.grid,\n            propertyFieldCls  : 'b-transparent property-field',\n            operatorFieldCls  : 'b-transparent operator-field',\n            valueFieldCls     : 'b-transparent value-field',\n            internalListeners : {\n                beforeAddFilter : ({ filter }) => {\n                    me.injectColumnFilterConfig(column, filter);\n                },\n                remove  : me.onPopupFilterRemove,\n                keydown : me.onPopupKeydown,\n                thisObj : me\n            },\n            triggerChangeOnInput : false\n        };\n    }\n    onPopupFilterRemove() {\n        if (this.closeEmptyPopup && this.filterEditorPopup.widgetMap.pickerGroup.filters.length === 0) {\n            // Must delay so normal change event happens and store gets filtered\n            this.delay(this.closeFilterEditor, 0);\n        }\n    }\n    onPopupKeydown({ event }) {\n        if (event.key === 'Enter') {\n            // Must delay so normal change event happens and store gets filtered\n            this.delay(this.closeFilterEditor, 0);\n        }\n    }\n    /**\n     * Shows a popup where a filter can be edited.\n     * @param {Grid.column.Column|String} column Column to show filter editor for\n     * @param {*} [value] The initial value of the filter value input\n     * @param {String} [operator] The initial operator of the filter operator selector (non-legacy mode)\n     * @param {Boolean} [forceAddBlank] Whether to add a blank filter row even if other filters exist\n     *                  (non-legacy mode; default false)\n     */\n    showFilterEditor(column, value, operator, forceAddBlank = false) {\n        column = this.grid.columns.getById(column);\n        const\n            me         = this,\n            { store }  = me,\n            headerEl   = column.element,\n            filter     = store.filters.getBy('property', column.field),\n            fieldType  = me.getFilterType(column),\n            legacyMode = me.useLegacyModeForColumn(column);\n        if (column.filterable === false) {\n            return;\n        }\n        // Destroy previous filter popup\n        me.closeFilterEditor();\n        const items = me.getPopupItems(\n            column,\n            fieldType,\n            // Only pass filter if it's not an internal filter\n            filter?.internal ? null : filter,\n            value,\n            store,\n            me.closeFilterEditor,\n            () => {\n                me.removeFilter(column);\n                me.closeFilterEditor();\n            },\n            column.filterable.filterField\n        );\n        // Localize placeholders\n        items.forEach(item => item.placeholder = item.placeholder ? this.L(item.placeholder) : item.placeholder);\n        me.filterEditorPopup = WidgetHelper.openPopup(headerEl, {\n            owner : me.grid,\n            cls   : new DomClassList('b-filter-popup', {\n                'b-filter-popup-legacymode' : legacyMode\n            }),\n            scrollAction : 'realign',\n            layout       : {\n                type  : 'vbox',\n                align : 'stretch'\n            },\n            items\n        });\n        if (!legacyMode) {\n            // Add a blank default filter if none present, or if forceAddBlank=true\n            if (forceAddBlank || !me.grid.store?.filters.find(filter => filter.property === column.field)) {\n                me.filterEditorPopup.widgetMap.pickerGroup.addFilter({\n                    type     : fieldType,\n                    property : column.field,\n                    operator : operator ?? defaultOperators[fieldType],\n                    value\n                });\n            }\n            me.filterEditorPopup.items[0].focus();\n        }\n    }\n    /**\n     * Close the filter editor.\n     */\n    closeFilterEditor() {\n        // Must defer the destroy because it may be closed by an event like a \"change\" event where\n        // there may be plenty of code left to execute which must not execute on destroyed objects.\n        this.filterEditorPopup?.setTimeout(this.filterEditorPopup.destroy);\n        this.filterEditorPopup = null;\n    }\n    //endregion\n    //region Context menu\n    getFilterType(column) {\n        const\n            fieldName = column.field,\n            field     = this.client.store.modelClass.getFieldDefinition(fieldName),\n            type      = column.filterType ?? fieldTypeMap[column.type] ?? fieldTypeMap[field?.type],\n            relation  = this.store?.modelRelations?.find(({ foreignKey }) => foreignKey === fieldName);\n        if (relation) {\n            return 'relation';\n        }\n        else if (type === 'auto' && this.store && !this.useLegacyModeForColumn(column)) {\n            return FieldFilterPicker.inferFieldType(this.store, fieldName);\n        }\n        else if (type) {\n            return fieldTypeMap[type];\n        }\n        return 'auto';\n    }\n    populateCellMenuWithDateItems({ column, record, items }) {\n        const\n            property = column.field,\n            type     = this.getFilterType(column);\n        if (type === 'date') {\n            const\n                me       = this,\n                value    = record.getValue(property),\n                filter   = operator => {\n                    me.applyFilter(column, {\n                        operator,\n                        value,\n                        displayValue : column.formatValue ? column.formatValue(value) : value,\n                        type         : 'date'\n                    });\n                };\n            items.filterDateEquals = {\n                text        : 'L{on}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-filter-equal',\n                cls         : 'b-separator',\n                weight      : 300,\n                disabled    : me.disabled,\n                onItem      : () => filter('=')\n            };\n            items.filterDateBefore = {\n                text        : 'L{before}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-filter-before',\n                weight      : 310,\n                disabled    : me.disabled,\n                onItem      : () => filter('<')\n            };\n            items.filterDateAfter = {\n                text        : 'L{after}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-filter-after',\n                weight      : 320,\n                disabled    : me.disabled,\n                onItem      : () => filter('>')\n            };\n        }\n    }\n    populateCellMenuWithNumberItems({ column, record, items }) {\n        const\n            property = column.field,\n            type     = this.getFilterType(column);\n        if (type === 'number') {\n            const\n                me       = this,\n                value    = record.getValue(property),\n                filter   = operator => {\n                    me.applyFilter(column, { operator, value });\n                };\n            items.filterNumberEquals = {\n                text        : 'L{equals}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-filter-equal',\n                cls         : 'b-separator',\n                weight      : 300,\n                disabled    : me.disabled,\n                onItem      : () => filter('=')\n            };\n            items.filterNumberLess = {\n                text        : 'L{lessThan}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-filter-less',\n                weight      : 310,\n                disabled    : me.disabled,\n                onItem      : () => filter('<')\n            };\n            items.filterNumberMore = {\n                text        : 'L{moreThan}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-filter-more',\n                weight      : 320,\n                disabled    : me.disabled,\n                onItem      : () => filter('>')\n            };\n        }\n    }\n    addMenuItemsForDataType(menuItems, dataType, filterFn, activeOperators) {\n        const allowedOperators = FieldFilterPicker.defaultOperators[dataType]\n            .filter(({ argCount, isArrayValued }) => !(argCount > 1 || isArrayValued));\n        let weight = 300;\n        for (const { value: operator, text, argCount } of allowedOperators) {\n            menuItems[`filter${StringHelper.capitalize(dataType)}${StringHelper.capitalize(operator)}`] = {\n                text     : StringHelper.capitalize(FieldFilterPicker.L(text)),\n                weight   : weight += 10,\n                icon     : activeOperators.includes(operator) ? 'b-icon b-icon-check' : null,\n                disabled : this.disabled,\n                onItem   : () => filterFn(operator, argCount)\n            };\n        }\n    }\n    populateCellMenuWithDurationItems({ column, record, items }) {\n        const\n            type = this.getFilterType(column);\n        if (type === 'duration') {\n            const\n                me       = this,\n                value    = column.getFilterableValue(record),\n                filter   = operator => {\n                    me.applyFilter(column, { operator, value });\n                };\n            items.filterDurationEquals = {\n                text        : 'L{equals}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-filter-equal',\n                cls         : 'b-separator',\n                weight      : 300,\n                disabled    : me.disabled,\n                onItem      : () => filter('=')\n            };\n            items.filterDurationLess = {\n                text        : 'L{lessThan}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-filter-less',\n                weight      : 310,\n                disabled    : me.disabled,\n                onItem      : () => filter('<')\n            };\n            items.filterDurationMore = {\n                text        : 'L{moreThan}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-filter-more',\n                weight      : 320,\n                disabled    : me.disabled,\n                onItem      : () => filter('>')\n            };\n        }\n    }\n    populateCellMenuWithStringItems({ column, record, items }) {\n        const type = this.getFilterType(column);\n        if (!/(date|number|duration)/.test(type)) {\n            const\n                me       = this,\n                value    = column.getFilterableValue(record),\n                operator = column.filterable.filterField?.operator ?? '*';\n            items.filterStringEquals = {\n                text        : 'L{equals}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-filter-equal',\n                cls         : 'b-separator',\n                weight      : 300,\n                disabled    : me.disabled,\n                onItem      : () => me.applyFilter(column, { value, operator })\n            };\n        }\n    }\n    /**\n     * In non-legacy mode, gets the cell/header context menu items: a top-level Filter item having a submenu with\n     * operator and edit/remove options). Not used by legacy mode.\n     * @private\n     */\n    getMenuItems(column, record) {\n        const\n            me = this,\n            submenuItems = {},\n            type = me.getFilterType(column);\n        if (column.filterable === false) {\n            return {};\n        }\n        if (allowedFilterTypes[type]) {\n            const\n                value = record ? column.getFilterableValue(record) : undefined,\n                activeOperators = me.getCurrentMultiFilters(column)\n                    .filter(filter => !filter.disabled)\n                    .map(({ operator }) => operator),\n                maxArgCount = record ? 1 : undefined,\n                allowedOperators = FieldFilterPicker.defaultOperators[type]\n                    .filter(({ argCount, isArrayValued }) => !(argCount > maxArgCount || isArrayValued));\n            let weight = 300;\n            for (const { value: operator, text, argCount } of allowedOperators) {\n                const key = `filter${StringHelper.capitalize(type)}${StringHelper.capitalize(operator)}`;\n                submenuItems[key] = {\n                    text     : StringHelper.capitalize(FieldFilterPicker.L(text)),\n                    weight   : weight += 10,\n                    icon     : activeOperators.includes(operator) ? 'b-icon b-icon-check' : null,\n                    disabled : me.disabled,\n                    cls      : menuItemsWithSeparators[key] ? 'b-separator' : null,\n                    onItem   : () => me.onOperatorMenuItem(column, value, operator, argCount)\n                };\n            }\n        }\n        if (column.meta.isFiltered) {\n            Object.assign(submenuItems, me.getMenuItemsForFilteredColumn(column, record !== undefined));\n        }\n        return {\n            filterMenu : {\n                text        : 'L{filter}',\n                localeClass : me,\n                menu        : submenuItems,\n                icon        : 'b-fw-icon b-icon-filter',\n                weight      : record ? 400 : 100\n            }\n        };\n    }\n    /**\n     * Handle clicking on an operator item in the filter submenu.\n     * @param {Grid.column.Column} column The column to which the menu belongs\n     * @param {*} value The cell value if this context menu belongs to a grid cell, undefined if header menu\n     * @param {String} operator The selected operator, e.g. `'='`, `'isToday'`. See `CollectionFilter`.\n     * @param {String} type The selected operator, e.g. `'='`, `'isToday'`. See `CollectionFilter`.\n     * @param {Number} argCount The number of arguments required by the operator\n     * @private\n     */\n    onOperatorMenuItem(column, value, operator, argCount = 1) {\n        const\n            me        = this,\n            type      = me.getFilterType(column),\n            wasActive = me.getCurrentMultiFilters(column)\n                .find(filter => !filter.disabled && filter.operator === operator);\n        if (wasActive) {\n            me.removeFilter(column, operator);\n        }\n        else {\n            if (argCount == 0 || value !== undefined) {\n                me.applyFilter(column, {\n                    property      : column.field,\n                    operator,\n                    type,\n                    value         : argCount === 1 ? value : null,\n                    caseSensitive : false,\n                    disabled      : value == null && argCount > 0   // Can't apply filter yet; incomplete\n                });\n            }\n            else {\n                me.showFilterEditor(column, null, operator, true);\n            }\n        }\n    }\n    /**\n     * Get the context menu items (cell and header) that apply when the column is already filtered, e.g. edit,\n     * remove, disable. Used by both legacy and regular modes.\n     * @param {Grid.column.Column} column The column to which the menu pertains\n     * @param {Boolean} isCellMenu Whether this is a cell's context menu (not header)\n     * @returns {Object<String,MenuItemConfig>} An `items` config containing the appropriate menu item configs\n     * @private\n     */\n    getMenuItemsForFilteredColumn(column, isCellMenu) {\n        const\n            me = this,\n            canRemoveFilter = !me.disabled && (me.legacyMode || me.columnHasRemovableFilters(column));\n        return {\n            // Don't show 'edit' in legacy mode cell menu (legacy mode header menu handled elsewhere)\n            editFilter : me.legacyMode ? undefined : {\n                text        : 'L{editFilter}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-edit',\n                cls         : 'b-separator',\n                weight      : 500,\n                disabled    : !canRemoveFilter,\n                onItem      : () => me.showFilterEditor(column)\n            },\n            [isCellMenu ? 'filterRemove' : 'removeFilter'] : {\n                text        : 'L{removeFilter}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-remove',\n                cls         : 'b-separator',\n                weight      : 510,\n                disabled    : !canRemoveFilter,\n                onItem      : () => me.removeFilter(column)\n            },\n            disableFilter : {\n                text        : 'L{disableFilter}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-filter-disable',\n                weight      : 520,\n                disabled    : me.disabled || !me.columnHasEnabledFilters(column),\n                onItem      : () => me.disableFilter(column)\n            }\n        };\n    }\n    /**\n     * Add menu items for filtering.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown\n     * @param {Core.data.Model} options.record Record for which the menu will be shown\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateCellMenu({ column, record, items, ...rest }) {\n        const me = this;\n        if (column.filterable !== false && !record.isSpecialRow) {\n            if (me.useLegacyModeForColumn(column)) {\n                me.populateCellMenuWithDateItems({ column, record, items, ...rest });\n                me.populateCellMenuWithNumberItems({ column, record, items, ...rest });\n                me.populateCellMenuWithDurationItems({ column, record, items, ...rest });\n                me.populateCellMenuWithStringItems({ column, record, items, ...rest });\n                if (column.meta.isFiltered) {\n                    Object.assign(items, me.getMenuItemsForFilteredColumn(column, true));\n                }\n            }\n            else {\n                // New default UI allows all applicable operators defined by adv filter UI\n                Object.assign(items, me.getMenuItems(column, record));\n            }\n        }\n    }\n    /**\n     * Used to determine whether the 'remove filters' menu item should be enabled.\n     * @internal\n     */\n    columnHasRemovableFilters(column) {\n        const me = this;\n        return Boolean(me.getCurrentMultiFilters(column).find(filter =>\n            !me.canDeleteFilter || (me.callback(me.canDeleteFilter, me, [filter]) !== false)));\n    }\n    /**\n     * Used to determine whether the 'disable filters' menu item should be enabled.\n     * @internal\n     */\n    columnHasEnabledFilters(column) {\n        return Boolean(this.getCurrentMultiFilters(column).find(filter => !filter.disabled));\n    }\n    /**\n     * Add menu item for removing filter if column is filtered.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateHeaderMenu({ column, items }) {\n        const me = this;\n        if (me.useLegacyModeForColumn(column)) {\n            if (column.meta.isFiltered) {\n                items.editFilter = {\n                    text        : 'L{editFilter}',\n                    localeClass : me,\n                    weight      : 100,\n                    icon        : 'b-fw-icon b-icon-filter',\n                    cls         : 'b-separator',\n                    disabled    : me.disabled,\n                    onItem      : () => me.showFilterEditor(column)\n                };\n                items.removeFilter = {\n                    text        : 'L{removeFilter}',\n                    localeClass : me,\n                    weight      : 110,\n                    icon        : 'b-fw-icon b-icon-remove',\n                    disabled    : me.disabled || (!me.legacyMode && !me.columnHasRemovableFilters(column)),\n                    onItem      : () => me.removeFilter(column)\n                };\n                items.disableFilter = {\n                    text        : 'L{disableFilter}',\n                    localeClass : me,\n                    icon        : 'b-fw-icon b-icon-filter-disable',\n                    weight      : 115,\n                    disabled    : me.disabled || !me.columnHasEnabledFilters(column),\n                    onItem      : () => me.disableFilter(column)\n                };\n            }\n            else if (column.filterable !== false) {\n                items.filter = {\n                    text        : 'L{filter}',\n                    localeClass : me,\n                    weight      : 100,\n                    icon        : 'b-fw-icon b-icon-filter',\n                    cls         : 'b-separator',\n                    disabled    : me.disabled,\n                    onItem      : () => me.showFilterEditor(column)\n                };\n            }\n        }\n        else {\n            Object.assign(items, me.getMenuItems(column));\n        }\n    }\n    useLegacyModeForColumn(column) {\n        return this.legacyMode || ((column.filterable?.filterFn ?? column.filterable?.filterField) != undefined);\n    }\n    //endregion\n    //region Events\n    // Intercept filtering by a column that has a custom filtering fn, and inject that fn\n    onStoreBeforeFilter({ filters }) {\n        const { columns } = this.client;\n        for (let i = 0; i < filters.count; i++) {\n            const filter = filters.getAt(i);\n            // Only take ownership of filters which are not internal\n            if (!filter.internal) {\n                const column = (filter.columnOwned || this.prioritizeColumns) && columns.find(col => col.filterable !== false && col.field === filter.property);\n                if (column?.filterable?.filterFn) {\n                    // If the filter was sourced from the store, replace it with a filter which\n                    // uses the column's filterFn\n                    if (!column.$filter) {\n                        column.$filter = new CollectionFilter({\n                            columnOwned : true,\n                            property    : filter.property,\n                            operator    : filter.operator,\n                            value       : filter.value,\n                            filterBy(record) {\n                                return column.filterable.filterFn({ value : this.value, record, operator : this.operator, property : this.property, column });\n                            }\n                        });\n                    }\n                    // Update value and operator used by filters filtering fn\n                    column.$filter.value = filter.value;\n                    column.$filter.displayValue = filter.displayValue;\n                    column.$filter.operator = filter.operator;\n                    filters.splice(i, 1, column.$filter);\n                }\n            }\n        }\n    }\n    /**\n     * Store filtered; refresh headers.\n     * @private\n     */\n    onStoreFilter() {\n        // Pass false to not refresh rows.\n        // Store's refresh event will refresh the rows.\n        this.refreshHeaders(false);\n    }\n    /**\n     * Called after headers are rendered, make headers match stores initial sorters\n     * @private\n     */\n    renderHeader() {\n        this.refreshHeaders(false);\n    }\n    /**\n     * Called when user clicks on the grid. Only care about clicks on the filter icon.\n     * @param {MouseEvent} event\n     * @private\n     */\n    onElementClick({ target }) {\n        if (this.filterEditorPopup) {\n            this.closeFilterEditor();\n        }\n        if (target.classList.contains('b-filter-icon')) {\n            const headerEl = target.closest('.b-grid-header');\n            this.showFilterEditor(headerEl.dataset.columnId);\n            return false;\n        }\n    }\n    /**\n     * Called when user presses F-key grid.\n     * @param {MouseEvent} event\n     * @private\n     */\n    showFilterEditorByKey({ target }) {\n        const headerEl = target.matches('.b-grid-header') && target;\n        // Header must be focused\n        if (headerEl) {\n            this.showFilterEditor(headerEl.dataset.columnId);\n        }\n        return Boolean(headerEl);\n    }\n    // Only care about F key when a filterable header is focused\n    isActionAvailable({ event, actionName }) {\n        if (actionName === 'showFilterEditorByKey') {\n            const\n                headerElement = event.target.closest('.b-grid-header'),\n                column = headerElement && this.client.columns.find(col => col.id === headerElement.dataset.columnId);\n            return Boolean(column?.filterable);\n        }\n    }\n    //endregion\n}\nFilter._$name = 'Filter'; GridFeatureManager.registerFeature(Filter);\n", "import Duration from '../../Core/data/Duration.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport WidgetHelper from '../../Core/helper/WidgetHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport '../../Core/widget/NumberField.js';\nimport '../../Core/widget/Combo.js';\nimport '../../Core/widget/DateField.js';\nimport '../../Core/widget/TimeField.js';\nimport GridFeatureManager from './GridFeatureManager.js';\nimport CollectionFilter from '../../Core/util/CollectionFilter.js';\nconst complexOperators = {\n    '*'          : null,\n    isIncludedIn : null,\n    startsWith   : null,\n    endsWidth    : null\n};\n/**\n * @module Grid/feature/FilterBar\n */\n/**\n * Feature that allows filtering of the grid by entering filters on column headers.\n * The actual filtering is done by the store.\n * For info on programmatically handling filters, see {@link Core.data.mixin.StoreFilter StoreFilter}.\n *\n * {@inlineexample Grid/feature/FilterBar.js}\n *\n * ```javascript\n * // filtering turned on but no initial filter\n * const grid = new Grid({\n *   features: {\n *     filterBar : true\n *   }\n * });\n *\n * // using initial filter\n * const grid = new Grid({\n *   features : {\n *     filterBar : { filter: { property : 'city', value : 'Gavle' } }\n *   }\n * });\n * ```\n *\n * ## Enabling filtering for a column\n * The individual filterability of columns is defined by a `filterable` property on the column which defaults to `true`.\n * If `false`, that column is not filterable. Note: If you have multiple columns configured with the same `field` value,\n * assign an {@link Core.data.Model#field-id} to the columns to ensure filters work correctly.\n *\n * The property value may also be a custom filter function.\n *\n * The property value may also be an object which may contain the following two properties:\n *  - **filterFn** : `Function` A custom filtering function\n *  - **filterField** : `Object` A config object for the filter value input field. See {@link Core.widget.TextField} or\n *  the other field widgets for reference.\n *\n * ```javascript\n * // Custom filtering function for a column\n * const grid = new Grid({\n *   features : {\n *     filterBar : true\n *   },\n *\n *   columns: [\n *      {\n *        field      : 'age',\n *        text       : 'Age',\n *        type       : 'number',\n *        // Custom filtering function that checks \"greater than\"\n *        filterable : ({ record, value }) => record.age > value\n *      },\n *      {\n *        field : 'name',\n *        // Filterable may specify a filterFn and a config for the filtering input field\n *        filterable : {\n *          filterFn : ({ record, value }) => record.name.toLowerCase().indexOf(value.toLowerCase()) !== -1,\n *          filterField : {\n *            emptyText : 'Filter name'\n *          }\n *        }\n *      },\n *      {\n *        field : 'city',\n *        text : 'Visited',\n *        flex : 1,\n *        // Filterable with multiselect combo to pick several items to filter\n *        filterable : {\n *          filterField : {\n *            type        : 'combo',\n *            multiSelect : true,\n *            items       : ['Barcelona', 'Moscow', 'Stockholm']\n *          }\n *        }\n *      }\n *   ]\n * });\n * ```\n *\n * If this feature is configured with `prioritizeColumns : true`, those functions will also be used when filtering\n * programmatically:\n *\n * ```javascript\n * const grid = new Grid({\n *    features : {\n *        filterBar : {\n *            prioritizeColumns : true\n *        }\n *    },\n *\n *    columns: [\n *        {\n *          field      : 'age',\n *          text       : 'Age',\n *          type       : 'number',\n *          // Custom filtering function that checks \"greater than\" no matter\n *          // which field user filled in :)\n *          filterable : ({ record, value, operator }) => record.age > value\n *        }\n *    ]\n * });\n *\n * // Will be used when filtering programmatically or using the UI\n * grid.store.filter({\n *     property : 'age',\n *     value    : 41\n * });\n * ```\n *\n * ## Filtering using a multiselect combo\n *\n * To filter the grid by choosing values which should match with the store data, use a {@link Core.widget.Combo}, and configure\n * your grid like so:\n *\n * ```javascript\n * const grid = new Grid({\n *    features : {\n *        filterBar : true\n *    },\n *\n *    columns : [\n *        {\n *            id         : 'name',\n *            field      : 'name',\n *            text       : 'Name',\n *            filterable : {\n *                filterField : {\n *                    type         : 'combo',\n *                    multiSelect  : true,\n *                    valueField   : 'name',\n *                    displayField : 'name'\n *                }\n *            }\n *        }\n *    ]\n * });\n * ```\n *\n * You can also filter the {@link Core.widget.Combo} values, for example to filter out empty values. Example:\n *\n * ```javascript\n * const grid = new Grid({\n *    features : {\n *        filterBar : true\n *    },\n *\n *    columns : [\n *        {\n *            text       : 'Airline',\n *            field      : 'airline',\n *            flex       : 1,\n *            filterable : {\n *                filterField : {\n *                    type         : 'combo',\n *                    multiSelect  : true,\n *                    valueField   : 'airline',\n *                    displayField : 'airline',\n *                    store        : {\n *                        filters : {\n *                            // Filter out empty values\n *                            filterBy : record => !!record.airline\n *                        }\n *                    }\n *                }\n *            }\n *        }\n *    ]\n * });\n * ```\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * **Note:** This feature cannot be used together with {@link Grid.feature.Filter filter} feature, they are mutually\n * exclusive.\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Grid/filterbar\n * @classtype filterBar\n * @feature\n */\nexport default class FilterBar extends InstancePlugin {\n    //region Config\n    static get $name() {\n        return 'FilterBar';\n    }\n    static get configurable() {\n        return {\n            /**\n             * Use custom filtering functions defined on columns also when programmatically filtering by the columns\n             * field.\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *     columns : [\n             *         {\n             *             field : 'age',\n             *             text : 'Age',\n             *             filterable({ record, value }) {\n             *               // Custom filtering, return true/false\n             *             }\n             *         }\n             *     ],\n             *\n             *     features : {\n             *         filterBar : {\n             *             prioritizeColumns : true // <--\n             *         }\n             *     }\n             * });\n             *\n             * // Because of the prioritizeColumns config above, any custom\n             * // filterable function on a column will be used when\n             * // programmatically filtering by that columns field\n             * grid.store.filter({\n             *     property : 'age',\n             *     value    : 30\n             * });\n             * ```\n             *\n             * @config {Boolean}\n             * @default\n             * @category Common\n             */\n            prioritizeColumns : false,\n            /**\n             * The delay in milliseconds to wait after the last keystroke before applying filters.\n             * Set to 0 to not trigger filtering from keystrokes, requires pressing ENTER instead\n             * @config {Number}\n             * @default\n             * @category Common\n             */\n            keyStrokeFilterDelay : 300,\n            /**\n             * Toggle compact mode. In this mode the filtering fields are styled to transparently overlay the headers,\n             * occupying no additional space.\n             * @member {Boolean} compactMode\n             * @category Common\n             */\n            /**\n             * Specify `true` to enable compact mode for the filter bar. In this mode the filtering fields are styled\n             * to transparently overlay the headers, occupying no additional space.\n             * @config {Boolean}\n             * @default\n             * @category Common\n             */\n            compactMode : false,\n            /**\n             * By default, column filter is removed when a column is hidden or this feature is disabled. Set this flag\n             * to `false` to keep filters in these scenarios.\n             * @member {Boolean}\n             * @category Common\n             * @default\n             */\n            clearStoreFiltersOnHide : true,\n            /**\n             * Determines `filterBar` visibility. By default it is set to `false` and to hide the `filterBar` set\n             * this flag to `true`.\n             * @prp {Boolean}\n             * @category Common\n             * @default\n             */\n            hidden : false,\n            /**\n             * Use to set initial filter.\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *   features : {\n             *     filterBar : { filter: { property : 'city', value : 'Gavle' } }\n             *   }\n             * });\n             * ```\n             *\n             * @config {CollectionFilterConfig|Function}\n             * @returns {Boolean}\n             * @category Common\n             */\n            filter : null,\n            keyMap : {\n                // Private\n                ArrowUp    : { handler : 'disableGridNavigation', preventDefault : false },\n                ArrowRight : { handler : 'disableGridNavigation', preventDefault : false },\n                ArrowDown  : { handler : 'disableGridNavigation', preventDefault : false },\n                ArrowLeft  : { handler : 'disableGridNavigation', preventDefault : false },\n                Enter      : { handler : 'disableGridNavigation', preventDefault : false }\n            }\n        };\n    }\n    static get pluginConfig() {\n        return {\n            before : ['renderContents'],\n            chain  : ['afterColumnsChange', 'renderHeader', 'populateHeaderMenu', 'bindStore']\n        };\n    }\n    static get properties() {\n        return {\n            filterFieldCls           : 'b-filter-bar-field',\n            filterFieldInputCls      : 'b-filter-bar-field-input',\n            filterableColumnCls      : 'b-filter-bar-enabled',\n            filterFieldInputSelector : '.b-filter-bar-field-input',\n            filterableColumnSelector : '.b-filter-bar-enabled',\n            filterParseRegExp        : /^\\s*([<>=*])?(.*)$/,\n            storeTrackingSuspended   : 0\n        };\n    }\n    //endregion\n    //region Init\n    construct(grid, config) {\n        if (grid.features.filter) {\n            throw new Error('Grid.feature.FilterBar feature may not be used together with Grid.feature.Filter, These features are mutually exclusive.');\n        }\n        const me = this;\n        me.grid = grid;\n        me.onColumnFilterFieldChange = me.onColumnFilterFieldChange.bind(me);\n        super.construct(grid, Array.isArray(config) ? {\n            filter : config\n        } : config);\n        me.bindStore(grid.store);\n        if (me.filter) {\n            grid.store.filter(me.filter);\n        }\n        me.gridDetacher = grid.ion({ beforeElementClick : 'onBeforeElementClick', thisObj : me });\n    }\n    bindStore(store) {\n        this.detachListeners('store');\n        store.ion({\n            name         : 'store',\n            beforeFilter : 'onStoreBeforeFilter',\n            filter       : 'onStoreFilter',\n            thisObj      : this\n        });\n    }\n    doDestroy() {\n        this.destroyFilterBar();\n        this.gridDetacher?.();\n        super.doDestroy();\n    }\n    doDisable(disable) {\n        const { columns } = this.grid;\n        // Disable the fields\n        columns?.forEach(column => {\n            const widget = this.getColumnFilterField(column);\n            if (widget) {\n                widget.disabled = disable;\n            }\n        });\n        super.doDisable(disable);\n    }\n    updateHidden(hidden) {\n        if (!this.isConfiguring) {\n            if (hidden) {\n                this.hideFilterBar();\n            }\n            else {\n                this.showFilterBar();\n            }\n        }\n    }\n    updateCompactMode(value) {\n        this.client.headerContainer.classList[value ? 'add' : 'remove']('b-filter-bar-compact');\n        for (const prop in this._columnFilters) {\n            const field       = this._columnFilters[prop];\n            field.placeholder = value ? field.column.headerText : null;\n        }\n    }\n    //endregion\n    //region FilterBar\n    destroyFilterBar() {\n        this.grid.columns?.forEach(this.destroyColumnFilterField, this);\n    }\n    /**\n     * Hides the filtering fields.\n     */\n    hideFilterBar() {\n        const me = this;\n        // We don't want to hear back store \"filter\" event while we're resetting store filters\n        me.clearStoreFiltersOnHide && me.suspendStoreTracking();\n        // Hide the fields, each silently - no updating of the store's filtered state until the end\n        me.grid.columns?.forEach(col => me.hideColumnFilterField(col, true));\n        // Now update the filtered state\n        me.grid.store.filter();\n        me.clearStoreFiltersOnHide && me.resumeStoreTracking();\n        me._hidden = true;\n    }\n    /**\n     * Shows the filtering fields.\n     */\n    showFilterBar() {\n        this.suspendStoreTracking();\n        this.renderFilterBar(this.clearStoreFiltersOnHide);\n        this.resumeStoreTracking();\n        this._hidden = false;\n    }\n    /**\n     * Toggles the filtering fields visibility.\n     */\n    toggleFilterBar() {\n        if (this.hidden) {\n            this.showFilterBar();\n        }\n        else {\n            this.hideFilterBar();\n        }\n    }\n    /**\n     * Renders the filtering fields for filterable columns.\n     * @private\n     */\n    renderFilterBar(applyFilter) {\n        if (this.grid.hideHeaders) {\n            return;\n        }\n        this.grid.columns.visibleColumns.forEach(column => this.renderColumnFilterField(column, applyFilter));\n        this.rendered = true;\n    }\n    //endregion\n    //region FilterBar fields\n    /**\n     * Renders text field filter in the provided column header.\n     * @param {Grid.column.Column} column Column to render text field filter for.\n     * @private\n     */\n    renderColumnFilterField(column, applyFilters) {\n        const\n            me         = this,\n            { grid  }  = me,\n            filterable = me.getColumnFilterable(column);\n        // we render fields for filterable columns only\n        if (filterable && column.isVisible) {\n            const\n                headerEl = column.element,\n                filter   = grid.store.filters.get(column.id) || grid.store.filters.getBy('property', column.field);\n            let widget = me.getColumnFilterField(column);\n            // if we haven't created a field yet we build it from scratch\n            if (!widget) {\n                const\n                    type            = `${column.filterType || 'text'}field`,\n                    { filterField } = filterable,\n                    externalCls     = filterField?.cls;\n                if (externalCls) {\n                    delete filterable.filterField.cls;\n                }\n                widget = WidgetHelper.append(ObjectHelper.assign({\n                    type,\n                    cls : {\n                        [me.filterFieldCls] : 1,\n                        [externalCls]       : externalCls\n                    },\n                    // Simplifies debugging / testing\n                    dataset : {\n                        column : column.field\n                    },\n                    column,\n                    owner                : grid,\n                    clearable            : true,\n                    name                 : column.field,\n                    value                : (filter && !filter._filterBy && !filter.internal) ? me.buildFilterValue(filter) : '',\n                    inputCls             : me.filterFieldInputCls,\n                    keyStrokeChangeDelay : me.keyStrokeFilterDelay,\n                    onChange             : me.onColumnFilterFieldChange,\n                    onClear              : me.onColumnFilterFieldChange,\n                    disabled             : me.disabled,\n                    placeholder          : me.compactMode ? column.headerText : null,\n                    // Also copy formats, DateColumn, TimeColumn etc\n                    format               : column.format\n                }, filterField), headerEl)[0];\n                if (!filterField?.hasOwnProperty('min')) {\n                    Object.defineProperty(widget, 'min', {\n                        get : () => column.editor?.min,\n                        set : () => null\n                    });\n                }\n                if (!filterField?.hasOwnProperty('max')) {\n                    Object.defineProperty(widget, 'max', {\n                        get : () => column.editor?.max,\n                        set : () => null\n                    });\n                }\n                if (!filterField?.hasOwnProperty('strictParsing')) {\n                    Object.defineProperty(widget, 'strictParsing', {\n                        get : () => column.editor?.strictParsing,\n                        set : () => null\n                    });\n                }\n                // Avoid DomSync cleaning up this widget as it syncs column headers\n                widget.element.retainElement = true;\n                me.setColumnFilterField(column, widget);\n                const hasFilterFieldStoreData = filterField?.store && (filterField.store.readUrl || filterField.store.data || filterField.store.isChained);\n                // If no store is provided for filterable or store is empty, load values lazily from the grid store upon showing the picker list\n                if (widget.isCombo && !hasFilterFieldStoreData && widget.store.count === 0) {\n                    const\n                        configuredValue = widget.value,\n                        refreshData     = () => {\n                            // Might have replaced the widgets store at runtime, make sure we should still force refresh\n                            if (!(widget.store.readUrl || widget.store.isChained)) {\n                                widget.store.data = grid.store.getDistinctValues(column.field, true).map(value => grid.store.modelClass.new({\n                                    id             : value,\n                                    [column.field] : value\n                                }));\n                            }\n                        };\n                    widget.value = null;\n                    if (!widget.store.isSorted) {\n                        widget.store.sort({\n                            field     : column.field,\n                            ascending : true\n                        });\n                    }\n                    widget.picker.ion({ beforeShow : refreshData });\n                    refreshData();\n                    widget.value = configuredValue;\n                }\n                // If no initial filter exists but a value was provided to the widget, filter by it\n                // unless the store is configured to not autoLoad\n                if (!me.filter && widget.value && grid.store.autoLoad !== false) {\n                    me.onColumnFilterFieldChange({ source : widget, value : widget.value });\n                }\n            }\n            // if we have one...\n            else {\n                if (applyFilters) {\n                    // Apply widget filter on first render\n                    me.onColumnFilterFieldChange({ source : widget, value : widget.value });\n                }\n                // re-append the widget to its parent node (in case the column header was redrawn (happens when resizing columns))\n                widget.render(headerEl);\n                // show widget in case it was hidden\n                widget.show();\n            }\n            headerEl.classList.add(me.filterableColumnCls);\n        }\n    }\n    /**\n     * Fills in column filter fields with values from the grid store filters.\n     * @private\n     */\n    updateColumnFilterFields() {\n        const\n            me                 = this,\n            { columns, store } = me.grid;\n        let field, filter;\n        // During this phase we should not respond to field change events.\n        // See onColumnFilterFieldChange.\n        me._updatingFields = true;\n        for (const column of columns.visibleColumns) {\n            field = me.getColumnFilterField(column);\n            if (field && !column.$isApplyingFilter) {\n                filter = store.filters.get(column.id) || store.filters.getBy('property', column.field);\n                if (filter && !filter.internal) {\n                    // For filtering functions we keep what user typed into the field, we cannot construct a filter\n                    // string from them\n                    if (!filter._filterBy) {\n                        field.value = me.buildFilterValue(filter);\n                    }\n                    else {\n                        field.value = filter.value;\n                    }\n                }\n                // No filter, clear field\n                else {\n                    field.value = '';\n                }\n            }\n        }\n        me._updatingFields = false;\n    }\n    getColumnFilterable(column) {\n        if (!column.isRoot && column.filterable !== false && column.field && column.isLeaf) {\n            if (typeof column.filterable === 'function') {\n                column.filterable = {\n                    filterFn : column.filterable\n                };\n            }\n            return column.filterable;\n        }\n    }\n    destroyColumnFilterField(column) {\n        const widget = this.getColumnFilterField(column);\n        if (widget) {\n            this.hideColumnFilterField(column, true);\n            // destroy filter UI field\n            widget.destroy();\n            // remember there is no field bound anymore\n            this.setColumnFilterField(column, undefined);\n        }\n    }\n    hideColumnFilterField(column, silent) {\n        const\n            me        = this,\n            { store } = me.grid,\n            columnEl  = column.element,\n            widget    = me.getColumnFilterField(column);\n        if (widget) {\n            if (!me.isDestroying) {\n                // hide field\n                widget.hide();\n            }\n            const { $filter } = column;\n            if (!store.isDestroyed && me.clearStoreFiltersOnHide && $filter) {\n                store.removeFilter($filter, silent);\n            }\n            columnEl?.classList.remove(me.filterableColumnCls);\n        }\n    }\n    /**\n     * Returns column filter field instance.\n     * @param {Grid.column.Column} column Column to get filter field for.\n     * @returns {Core.widget.Widget}\n     */\n    getColumnFilterField(column) {\n        return this._columnFilters?.[column.id];\n    }\n    setColumnFilterField(column, widget) {\n        this._columnFilters = this._columnFilters || {};\n        this._columnFilters[column.data.id] = widget;\n    }\n    //endregion\n    //region Filters\n    parseFilterValue(column, value, field) {\n        if (Array.isArray(value) || value instanceof Duration) {\n            return {\n                value\n            };\n        }\n        if (ObjectHelper.isDate(value)) {\n            return {\n                operator : field.isDateField ? 'sameDay' : (field.isTimeField ? 'sameTime' : '='),\n                value\n            };\n        }\n        const match = String(value).match(this.filterParseRegExp);\n        return {\n            operator : match[1] || column.filterable?.operator || '*',\n            value    : match[2]\n        };\n    }\n    buildFilterValue({ operator, value }) {\n        return (value instanceof Date || Array.isArray(value) || value instanceof Duration) ? value : (operator in complexOperators ? '' : operator) + value;\n    }\n    //endregion\n    // region Events\n    // Intercept filtering by a column that has a custom filtering fn, and inject that fn\n    onStoreBeforeFilter({ filters }) {\n        const { columns } = this.client;\n        for (let i = 0; i < filters.count; i++) {\n            const\n                filter = filters.getAt(i),\n                column = (filter.columnOwned || this.prioritizeColumns) && columns.find(col => col.filterable !== false && col.field === filter.property);\n            if (column?.filterable?.filterFn) {\n                // If the filter was sourced from the store, replace it with a filter which\n                // uses the column's filterFn\n                if (!column.$filter) {\n                    column.$filter = new CollectionFilter({\n                        columnOwned : true,\n                        property    : filter.property,\n                        id          : column.id,\n                        filterBy(record) {\n                            return column.filterable.filterFn({\n                                value : this.value, record, property : this.property, column\n                            });\n                        }\n                    });\n                }\n                // Update value used by filters filtering fn\n                column.$filter.value = filter.value;\n                filters.splice(i, 1, column.$filter);\n            }\n        }\n    }\n    /**\n     * Fires when store gets filtered. Refreshes field values in column headers.\n     * @private\n     */\n    onStoreFilter() {\n        if (!this.storeTrackingSuspended && this.rendered) {\n            this.updateColumnFilterFields();\n        }\n    }\n    afterColumnsChange({ action, changes, column, columns }) {\n        // Ignore if columns change while this filter bar is hidden, or if column changeset does not include hidden\n        // state\n        if (!this.hidden && changes?.hidden) {\n            const hidden = changes.hidden.value;\n            if (hidden) {\n                this.destroyColumnFilterField(column);\n            }\n            else {\n                this.renderColumnFilterField(column);\n            }\n        }\n        if (action === 'remove') {\n            columns.forEach(col => this.destroyColumnFilterField(col));\n        }\n    }\n    suspendStoreTracking() {\n        this.storeTrackingSuspended++;\n    }\n    resumeStoreTracking() {\n        this.storeTrackingSuspended--;\n    }\n    /**\n     * Called after headers are rendered, make headers match stores initial sorters\n     * @private\n     */\n    renderHeader() {\n        if (!this.hidden) {\n            this.renderFilterBar();\n        }\n    }\n    renderContents() {\n        // Grid suspends events when restoring state, thus we are not informed about toggled columns and might end up\n        // with wrong fields in headers. To prevent that, we remove all field elements here since they are restored in\n        // renderColumnFilterField() later anyway\n        if (this._columnFilters) {\n            for (const field of Object.values(this._columnFilters)) {\n                field?.element.remove();\n            }\n        }\n    }\n    disableGridNavigation(event) {\n        /* If we have navigated (ArrowUp, ArrowLeft, ArrowDown, ArrowRight, Enter) in a filter field, \"catch\" the key\n         * call.\n         */\n        return event.target.matches(this.filterFieldInputSelector);\n    }\n    onBeforeElementClick({ event }) {\n        // prevent other features reacting when clicking a filter field (or any element inside it)\n        if (event.target.closest(`.${this.filterFieldCls}`)) {\n            return false;\n        }\n    }\n    /**\n     * Called when a column text filter field value is changed by user.\n     * @param  {Core.widget.TextField} field Filter text field.\n     * @param  {String} value New filtering value.\n     * @private\n     */\n    onColumnFilterFieldChange({ source: field, value }) {\n        const\n            me           = this,\n            { column }   = field,\n            { filterFn } = column.filterable,\n            { store }    = me.grid,\n            filter       = column.$filter || store.filters.find(f => (f.id === column.id || f.property === column.field) && !f.internal);\n        // Don't respond if we set the value in response to a filter\n        if (me._updatingFields) {\n            return;\n        }\n        const isClearingFilter = value == null || value === '' || Array.isArray(value) && value.length === 0;\n        // Remove previous iteration of the column's filter\n        store.removeFilter(filter, true);\n        column.$filter = null;\n        column.$isApplyingFilter = true;\n        if (isClearingFilter) {\n            // This is a no-op if there was no matching filter anyway\n            if (!filter) {\n                column.$isApplyingFilter = false;\n                return;\n            }\n        }\n        else {\n            // Must add the filter silently, so that the column gets a reference to its $filter\n            // before events are broadcast\n            column.$filter = store.addFilter({\n                property                                                                              : field.name,\n                ...me.parseFilterValue(column, value, field),\n                [typeof column.filterable?.caseSensitive === 'boolean' ? 'caseSensitive' : undefined] : column.filterable?.caseSensitive,\n                // Only inject a filterBy configuration if the column has a custom filterBy\n                [filterFn ? 'filterBy' : '_'] : function(record) {\n                    return filterFn({ value : this.value, record, operator : this.operator, property : this.property, column });\n                }\n            }, true);\n        }\n        // Apply the new set of store filters.\n        store.filter();\n        column.$isApplyingFilter = false;\n    }\n    //endregion\n    //region Menu items\n    /**\n     * Adds a menu item to toggle filter bar visibility.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateHeaderMenu({ items }) {\n        items.toggleFilterBar = {\n            text        : this.hidden ? 'L{enableFilterBar}' : 'L{disableFilterBar}',\n            localeClass : this,\n            weight      : 120,\n            icon        : 'b-fw-icon b-icon-filter',\n            cls         : 'b-separator',\n            onItem      : () => this.toggleFilterBar()\n        };\n    }\n    //endregion\n}\nFilterBar.featureClass = 'b-filter-bar';\nFilterBar._$name = 'FilterBar'; GridFeatureManager.registerFeature(FilterBar);\n", "import DomDataStore from '../../Core/data/DomDataStore.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from './GridFeatureManager.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport ArrayHelper from '../../Core/helper/ArrayHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\n/**\n * @module Grid/feature/Group\n */\n/**\n * Enables rendering and handling of row groups. The actual grouping is done in the store, but triggered by `[shift]` +\n * clicking headers or by using two finger tap (one on header, one anywhere on grid). Use `[shift]` + `[alt]` + click to\n * remove a column grouper.\n *\n * {@inlineexample Grid/feature/Group.js}\n *\n * Groups can be expanded/collapsed by clicking on the group row or pressing [space] when group row is selected.\n * The actual grouping is done by the store, see {@link Core.data.mixin.StoreGroup#function-group}.\n *\n * Grouping by a field performs sorting by the field automatically. It's not possible to prevent sorting.\n * If you group, the records have to be sorted so that records in a group stick together. You can either control sorting\n * direction, or provide a custom sorting function called {@link #config-groupSortFn} to your feature config object.\n *\n * For info on programmatically handling grouping, see {@link Core.data.mixin.StoreGroup}.\n *\n * Example snippets:\n *\n * ```javascript\n * // grouping feature is enabled, no default value though\n * let grid = new Grid({\n *     features : {\n *         group : true\n *     }\n * });\n *\n * // use initial grouping\n * let grid = new Grid({\n *     features : {\n *         group : 'city'\n *     }\n * });\n *\n * // default grouper and custom renderer, which will be applied to each cell except the \"group\" cell\n * let grid = new Grid({\n *     features : {\n *       group : {\n *           field : 'city',\n *           ascending : false,\n *           renderer : ({ isFirstColumn, count, groupRowFor, record }) => isFirstColumn ? `${groupRowFor} (${count})` : ''\n *       }\n *     }\n * });\n *\n * // group using custom sort function\n * let grid = new Grid({\n *     features : {\n *         group       : {\n *             field       : 'city',\n *             groupSortFn : (a, b) => a.city.length < b.city.length ? -1 : 1\n *         }\n *     }\n * });\n *\n * // can also be specified on the store\n * let grid = new Grid({\n *     store : {\n *         groupers : [\n *             { field : 'city', ascending : false }\n *         ]\n *     }\n * });\n *\n * // custom sorting function can also be specified on the store\n * let grid = new Grid({\n *     store : {\n *         groupers : [{\n *             field : 'city',\n *             fn : (recordA, recordB) => {\n *                 // apply custom logic, for example:\n *                 return recordA.city.length < recordB.city.length ? -1 : 1;\n *             }\n *         }]\n *     }\n * });\n * ```\n *\n * Currently, grouping is not supported when using pagination, the underlying store cannot group data that is split into\n * pages.\n *\n * {@note}Custom height for group header rows cannot be set with CSS, should instead be defined in a renderer function\n * using the `size` param. See the {@link #config-renderer} config for details.{/@note}\n *\n * ## Grouping by multi-value fields\n *\n * The group field's value may be an array. This means that one record can be a member of more than one\n * group. When this is the case, the second and subsequent generated groups contain a\n * {@link Core.data.Model#function-link linked record} which is a copy of the original record.\n *\n * {@inlineexample Grid/feature/GroupMulti.js}\n *\n * ## Keyboard shortcuts\n * This feature has the following default keyboard shortcuts:\n *\n * | Keys     | Action        | Action description                                                         |\n * |----------|---------------|----------------------------------------------------------------------------|\n * | `Space`  | *toggleGroup* | When a group header is focused, this expands or collapses the grouped rows |\n *\n * For more information on how to customize keyboard shortcuts, please see the\n * [Customizing keyboard shortcuts guide](#Grid/guides/customization/keymap.md)\n *\n * This feature is **enabled** by default.\n *\n * @demo Grid/grouping\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype group\n * @feature\n */\nexport default class Group extends InstancePlugin {\n    static get $name() {\n        return 'Group';\n    }\n    static get configurable() {\n        return {\n            /**\n             * The name of the record field to group by.\n             * @config {String}\n             * @default\n             */\n            field : null,\n            /**\n             * A function used to sort the groups.\n             * When grouping, the records have to be sorted so that records in a group stick together.\n             * Technically that means that records having the same {@link #config-field} value\n             * should go next to each other.\n             * And this function (if provided) is responsible for applying such grouping order.\n             * ```javascript\n             * const grid = new Grid({\n             *     features : {\n             *         group : {\n             *             // group by category\n             *             field       : 'category',\n             *             groupSortFn : (a, b) => {\n             *                 const\n             *                     aCategory = a.category || '',\n             *                     bCategory = b.category || '';\n             *\n             *                 // 1st sort by \"calegory\" field\n             *                 return aCategory > bCategory ? -1 :\n             *                     aCategory < bCategory ? 1 :\n             *                     // inside calegory groups we sort by \"name\" field\n             *                     (a.name > b.name ? -1 : 1);\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             *\n             * @config {Function}\n             * @param {*} first The first value to compare\n             * @param {*} second The second value to compare\n             * @returns {Number}  Returns `1` if first value is greater than second value, `-1` if the opposite is true or `0` if they're equal\n             */\n            groupSortFn : null,\n            /**\n             * A function which produces the HTML for a group header.\n             * The function is called in the context of this Group feature object.\n             * Default group renderer displays the `groupRowFor` and `count`.\n             *\n             * @config {Function}\n             * @param {Object} renderData Object containing renderer parameters\n             * @param {*} renderData.groupRowFor The value of the `field` for the group. Type depends on `field` used for grouping\n             * @param {Core.data.Model} renderData.record The group record representing the group\n             * @param {Number} renderData.count Number of records in the group\n             * @param {Grid.column.Column} renderData.column The column the renderer runs for\n             * @param {Boolean} renderData.isFirstColumn True, if `column` is the first column. If `RowNumberColumn` is the real first column, it's not taken into account\n             * @param {Grid.column.Column} renderData.groupColumn The column under which the `field` is shown\n             * @param {Object} renderData.size Sizing information for the group header row, only `height` is relevant\n             * @param {Number} renderData.size.height The height of the row, set this if you want a custom height for the group header row.\n             *   That is UI part, so do not rely on its existence\n             * @param {Grid.view.Grid} renderData.grid The owning grid\n             * @param {HTMLElement} renderData.rowElement The owning row element\n             * @returns {DomConfig|String|null}\n             * @default\n             *\n             * @category Rendering\n             */\n            renderer : null,\n            /**\n             * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n             * @config {Object<String,String>}\n             */\n            keyMap : {\n                ' ' : 'toggleGroup'\n            },\n            /**\n             * By default, clicking anywhere in a group row toggles its expanded/collapsed state.\n             *\n             * Configure this as `false` to limit this to only toggling on click of the expanded/collapsed\n             * state icon.\n             * @prp {Boolean}\n             * @default\n             */\n            toggleOnRowClick : true\n        };\n    }\n    //region Init\n    construct(grid, config) {\n        const me = this;\n        if (grid.features.tree) {\n            return;\n        }\n        // groupSummary feature needs to be initialized first, if it is used\n        me._thisIsAUsedExpression(grid.features.groupSummary);\n        // process initial config into an actual config object\n        config = me.processConfig(config);\n        me.grid = grid;\n        super.construct(grid, config);\n        me.bindStore(grid.store);\n        grid.rowManager.ion({\n            beforeRenderRow : 'onBeforeRenderRow',\n            renderCell      : 'renderCell',\n            // The feature gets to see cells being rendered before the GroupSummary feature\n            // because this injects header content into group header rows and adds rendering\n            // info to the cells renderData which GroupSummary must comply with.\n            prio    : 1100,\n            thisObj : me\n        });\n    }\n    // Group feature handles special config cases, where user can supply a string or a group config object\n    // instead of a normal config object\n    processConfig(config) {\n        if (typeof config === 'string') {\n            return {\n                field     : config,\n                ascending : null\n            };\n        }\n        return config;\n    }\n    // override setConfig to process config before applying it (used mainly from ReactGrid)\n    setConfig(config) {\n        if (config === null) {\n            this.store.clearGroupers();\n        }\n        else {\n            super.setConfig(this.processConfig(config));\n        }\n    }\n    bindStore(store) {\n        this.detachListeners('store');\n        store.ion({\n            name        : 'store',\n            group       : 'onStoreGroup',\n            change      : 'onStoreChange',\n            toggleGroup : 'onStoreToggleGroup',\n            thisObj     : this\n        });\n        this.onStoreGroup({ groupers : store.groupers });\n    }\n    updateRenderer(renderer) {\n        this.groupRenderer = renderer;\n    }\n    updateField(field) {\n        // Do not reapply grouping if already grouped by the field. This will prevent group direction from flipping\n        // when splitting grids using group feature configured with field (store is shared)\n        if (!this.isConfiguring || !this.store.groupers?.some(g => g.field === field)) {\n            this.store.group({\n                field,\n                ascending : this.ascending,\n                fn        : this.groupSortFn\n            });\n        }\n    }\n    updateGroupSortFn(fn) {\n        if (!this.isConfiguring) {\n            this.store.group({\n                field     : this.field,\n                ascending : this.ascending,\n                fn\n            });\n        }\n    }\n    doDestroy() {\n        super.doDestroy();\n    }\n    doDisable(disable) {\n        const { store } = this;\n        // Grouping mostly happens in store, need to clear groupers there to remove headers.\n        // Use configured groupers as first sorters to somewhat maintain the order\n        if (disable && store.isGrouped) {\n            const { sorters } = store;\n            sorters.unshift(...store.groupers);\n            this.currentGroupers = store.groupers;\n            store.clearGroupers();\n            store.sort(sorters);\n        }\n        else if (!disable && this.currentGroupers) {\n            store.group(this.currentGroupers[0]);\n            this.currentGroupers = null;\n        }\n        super.doDisable(disable);\n    }\n    get store() {\n        return this.grid.store;\n    }\n    //endregion\n    //region Plugin config\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            assign : ['collapseAll', 'expandAll'],\n            chain  : ['renderHeader', 'populateHeaderMenu', 'getColumnDragToolbarItems', 'onElementTouchStart',\n                'onElementClick', 'bindStore']\n        };\n    }\n    //endregion\n    //region Expand/collapse\n    refreshGrid(groupRecord) {\n        const { store, rowManager } = this.grid;\n        // If collapsing the group reduces amount of records below amount of rendered rows, we need to refresh\n        // entire view\n        // https://github.com/bryntum/support/issues/5893\n        if (rowManager.rowCount > store.count || !rowManager.getRowFor(groupRecord)) {\n            rowManager.renderFromRow();\n        }\n        else {\n            // render from group record and down, no need to touch those above\n            rowManager.renderFromRecord(groupRecord);\n        }\n    }\n    /**\n     * Collapses or expands a group depending on its current state\n     * @param {Core.data.Model|String} recordOrId Record or records id for a group row to collapse or expand\n     * @param {Boolean} collapse Force collapse (`true`) or expand (`false`)\n     * @fires togglegroup\n     */\n    toggleCollapse(recordOrId, collapse) {\n        this.internalToggleCollapse(recordOrId, collapse);\n    }\n    /**\n     * Collapses or expands a group depending on its current state\n     * @param {Core.data.Model|String} recordOrId Record or records id for a group row to collapse or expand\n     * @param {Boolean} collapse Force collapse (true) or expand (true)\n     * @param {Boolean} [skipRender] True to not render rows\n     * @param {Event} [domEvent] The user interaction event (eg a `click` event) if the toggle request was\n     * instigated by user interaction.\n     * @internal\n     * @fires togglegroup\n     */\n    internalToggleCollapse(recordOrId, collapse, skipRender = false, domEvent) {\n        const\n            me              = this,\n            { store, grid } = me,\n            groupRecord     = store.getById(recordOrId);\n        if (!groupRecord.isGroupHeader) {\n            return;\n        }\n        collapse = collapse === undefined ? !groupRecord.meta.collapsed : collapse;\n        /**\n         * Fired when a group is going to be expanded or collapsed using the UI.\n         * Returning `false` from a listener prevents the operation\n         * @event beforeToggleGroup\n         * @on-owner\n         * @preventable\n         * @param {Core.data.Model} groupRecord Group record\n         * @param {Boolean} collapse Collapsed (true) or expanded (false)\n         * @param {Event} domEvent The user interaction event (eg a `click` event) if the toggle request was\n         * instigated by user interaction.\n         */\n        if (grid.trigger('beforeToggleGroup', { groupRecord, collapse, domEvent }) === false) {\n            return;\n        }\n        me.isToggling = true;\n        if (collapse) {\n            store.collapse(groupRecord);\n        }\n        else {\n            store.expand(groupRecord);\n        }\n        me.isToggling = false;\n        if (!skipRender) {\n            me.refreshGrid(groupRecord);\n        }\n        /**\n         * Group expanded or collapsed\n         * @event toggleGroup\n         * @on-owner\n         * @param {Core.data.Model} groupRecord Group record\n         * @param {Boolean} collapse Collapsed (true) or expanded (false)\n         */\n        grid.trigger('toggleGroup', { groupRecord, collapse });\n        grid.afterToggleGroup();\n    }\n    /**\n     * Collapse all groups. This function is exposed on Grid and can thus be called as `grid.collapseAll()`\n     * @on-owner\n     * @typings {Promise<void>}\n     */\n    collapseAll() {\n        const me = this;\n        if (me.store.isGrouped && !me.disabled) {\n            me.store.groupRecords.forEach(r => me.internalToggleCollapse(r, true, true));\n            me.grid.refreshRows(true);\n        }\n    }\n    /**\n     * Expand all groups. This function is exposed on Grid and can thus be called as `grid.expandAll()`\n     * @on-owner\n     * @typings {Promise<void>}\n     */\n    expandAll() {\n        const me = this;\n        if (me.store.isGrouped && !me.disabled) {\n            me.store.groupRecords.forEach(r => me.internalToggleCollapse(r, false, true));\n            me.grid.refreshRows();\n        }\n    }\n    //endregion\n    //region Rendering\n    /**\n     * Called before rendering row contents, used to reset rows no longer used as group rows\n     * @private\n     */\n    onBeforeRenderRow({ row }) {\n        // row.id contains previous record id on before render\n        const oldRecord    = row.grid.store.getById(row.id);\n        // force update of inner html if this row used for group data\n        row.forceInnerHTML = row.forceInnerHTML || oldRecord?.isGroupHeader;\n    }\n    /**\n     * Called when a cell is rendered, styles the group rows first cell.\n     * @private\n     */\n    renderCell(renderData) {\n        const\n            me         = this,\n            {\n                cellElement,\n                row,\n                column,\n                grid\n            }          = renderData,\n            { meta }   = renderData.record,\n            rowClasses = {\n                'b-group-row'            : 0,\n                'b-grid-group-collapsed' : 0\n            };\n        if (!me.disabled && me.store.isGrouped && 'groupRowFor' in meta) {\n            // do nothing with action column to make possible using actions for groups\n            if (column.type === 'action') {\n                return;\n            }\n            // let column clear the cell, in case it needs to do some cleanup\n            column.clearCell(cellElement);\n            // this is a group row, add css classes\n            rowClasses['b-grid-group-collapsed'] = meta.collapsed;\n            rowClasses['b-group-row']            = 1;\n            if (grid.buildGroupHeader) {\n                grid.buildGroupHeader(renderData);\n            }\n            else {\n                me.buildGroupHeader(renderData);\n            }\n            if (column === me.groupHeaderColumn) {\n                DomHelper.createElement({\n                    parent      : cellElement,\n                    tag         : 'i',\n                    className   : 'b-group-state-icon',\n                    nextSibling : cellElement.firstChild\n                });\n                cellElement.classList.add('b-group-title');\n                cellElement.$groupHeader = cellElement._hasHtml = true;\n            }\n        }\n        else if (cellElement.$groupHeader) {\n            cellElement.querySelector('.b-group-state-icon')?.remove();\n            cellElement.classList.remove('b-group-title');\n            cellElement.$groupHeader = false;\n        }\n        // Still need to sync row classes is disabled or not grouped.\n        // Previous b-group-row and b-grid-group-collapsed classes must be removed.\n        row.assignCls(rowClasses);\n    }\n    // renderData.cellElement is required\n    buildGroupHeader(renderData) {\n        const\n            me               = this,\n            {\n                record,\n                cellElement,\n                column,\n                persist\n            }                = renderData,\n            { grid }         = me,\n            meta             = record.meta,\n            groupRowFor      = meta.emptyArray ? grid.L('L{Object.None}') : meta.groupRowFor,\n            { groupSummary } = grid.features,\n            // Need to adjust count if group summary is used\n            count            = meta.childCount - (groupSummary && groupSummary.target !== 'header' ? 1 : 0);\n        let html         = null,\n            applyDefault = true;\n        if (persist || column) {\n            const\n                groupColumn         = grid.columns.get(meta.groupField),\n                isGroupHeaderColumn = renderData.isFirstColumn = column === me.groupHeaderColumn;\n            // First try using columns groupRenderer (might not even have a column if grouping programmatically)\n            if (groupColumn?.groupRenderer) {\n                if (isGroupHeaderColumn) {\n                    // groupRenderer could return nothing and just apply changes directly to DOM element\n                    html = groupColumn.groupRenderer({\n                        ...renderData,\n                        groupRowFor,\n                        groupRecords : record.groupChildren,\n                        groupColumn,\n                        count\n                    });\n                    applyDefault = false;\n                }\n            }\n            // Secondly use features groupRenderer, if configured with one\n            else if (me.groupRenderer) {\n                // groupRenderer could return nothing and just apply changes directly to DOM element\n                html = me.groupRenderer({\n                    ...renderData,\n                    groupRowFor,\n                    groupRecords  : record.groupChildren,\n                    groupColumn,\n                    count,\n                    isFirstColumn : isGroupHeaderColumn\n                });\n            }\n            // Third, just display unformatted value and child count (also applied for features groupRenderer that do\n            // not output any html of their own)\n            if (isGroupHeaderColumn && html == null && applyDefault && DomHelper.getChildElementCount(cellElement) === 0) {\n                html = StringHelper.encodeHtml(`${groupRowFor === '__novalue__' ? '' : groupRowFor} (${count})`);\n            }\n        }\n        else if (me.groupRenderer) {\n            // groupRenderer could return nothing and just apply changes directly to DOM element\n            html = me.groupRenderer(renderData);\n        }\n        // Renderers could return nothing and just apply changes directly to DOM element\n        if (typeof html === 'string') {\n            cellElement.innerHTML = html;\n        }\n        else if (typeof html === 'object') {\n            DomSync.sync({\n                targetElement : cellElement,\n                domConfig     : {\n                    onlyChildren : true,\n                    children     : ArrayHelper.asArray(html)\n                }\n            });\n        }\n        // If groupRenderer added elements to the cell, we need to remember that to clear it on re-usage as a normal cell\n        if (DomHelper.getChildElementCount(cellElement) > 0) {\n            cellElement._hasHtml = true;\n        }\n        return cellElement.innerHTML;\n    }\n    get groupHeaderColumn() {\n        return this.grid.columns.visibleColumns.find(column => !column.groupHeaderReserved);\n    }\n    /**\n     * Called when a header is rendered, adds grouping icon if grouped by that column.\n     * @private\n     * @param headerContainerElement\n     */\n    renderHeader(headerContainerElement = this.grid.headerContainer) {\n        const { store, grid } = this;\n        if (headerContainerElement && store.isGrouped) {\n            // Sorted from start, reflect in rendering\n            for (const groupInfo of store.groupers) {\n                // Might be grouping by field without column, which is valid\n                const\n                    column = grid.columns.get(groupInfo.field),\n                    header = column && grid.getHeaderElement(column.id);\n                header?.classList.add('b-group', groupInfo.ascending ? 'b-asc' : 'b-desc');\n                // If sort feature is active, it provides the icon - if not we add it here\n                if (header && (!grid.features.sort?.enabled || column.sortable === false)) {\n                    const textEl = column.textWrapper;\n                    if (!textEl?.querySelector('.b-sort-icon')) {\n                        DomHelper.createElement({\n                            parent    : textEl,\n                            className : 'b-sort-icon'\n                        });\n                    }\n                }\n            }\n        }\n    }\n    //endregion\n    //region Context menu\n    /**\n     * Supply items for headers context menu.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateHeaderMenu({ column, items }) {\n        const me = this;\n        if (column.groupable !== false) {\n            items.groupAsc = {\n                text        : 'L{groupAscending}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-group-asc',\n                cls         : 'b-separator',\n                weight      : 400,\n                disabled    : me.disabled,\n                onItem      : () => me.store.group(column.field, true)\n            };\n            items.groupDesc = {\n                text        : 'L{groupDescending}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-group-desc',\n                weight      : 410,\n                disabled    : me.disabled,\n                onItem      : () => me.store.group(column.field, false)\n            };\n        }\n        if (me.store.isGrouped) {\n            items.groupRemove = {\n                text        : 'L{stopGrouping}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-clear',\n                cls         : column.groupable ? '' : 'b-separator',\n                weight      : 420,\n                disabled    : me.disabled,\n                onItem      : () => me.store.clearGroupers()\n            };\n        }\n    }\n    /**\n     * Supply items to ColumnDragToolbar\n     * @private\n     */\n    getColumnDragToolbarItems(column, items) {\n        const\n            me                  = this,\n            { store, disabled } = me;\n        items.push({\n            text        : 'L{groupAscendingShort}',\n            group       : 'L{group}',\n            localeClass : me,\n            icon        : 'b-icon b-icon-group-asc',\n            ref         : 'groupAsc',\n            cls         : 'b-separator',\n            weight      : 110,\n            disabled,\n            onDrop      : ({ column }) => store.group(column.field, true)\n        });\n        items.push({\n            text        : 'L{groupDescendingShort}',\n            group       : 'L{group}',\n            localeClass : me,\n            icon        : 'b-icon b-icon-group-desc',\n            ref         : 'groupDesc',\n            weight      : 110,\n            disabled,\n            onDrop      : ({ column }) => store.group(column.field, false)\n        });\n        const grouped = store.groupers?.some(col => col.field === column.field) && !disabled;\n        items.push({\n            text        : 'L{stopGroupingShort}',\n            group       : 'L{group}',\n            localeClass : me,\n            icon        : 'b-icon b-icon-clear',\n            ref         : 'groupRemove',\n            disabled    : !grouped,\n            weight      : 110,\n            onDrop      : ({ column }) => store.removeGrouper(column.field)\n        });\n        return items;\n    }\n    //endregion\n    //region Events - Store\n    /**\n     * Called when store grouping changes. Reflects on header and rerenders rows.\n     * @private\n     */\n    onStoreGroup({ groupers }) {\n        const\n            { grid }        = this,\n            { element }     = grid,\n            curGroupHeaders = element && DomHelper.children(element, '.b-grid-header.b-group');\n        if (element) {\n            for (const header of curGroupHeaders) {\n                header.classList.remove('b-group', 'b-asc', 'b-desc');\n            }\n            if (groupers) {\n                this.renderHeader();\n            }\n        }\n    }\n    onStoreChange({ action, records }) {\n        const\n            { client }            = this,\n            { rowManager, store } = client;\n        if (store.isGrouped && action === 'move') {\n            const\n                { field } = store.groupers[0],\n                fromRow   = Math.min(...records.reduce((result, record) => {\n                    // Get index of the new group\n                    result.push(store.indexOf(record.groupParent.get(store.id)));\n                    // Get index of the old group\n                    if (field in record.meta.modified) {\n                        const oldGroup = store.groupRecords.find(r => r.meta.groupRowFor === record.meta.modified[field]);\n                        if (oldGroup) {\n                            result.push(store.indexOf(oldGroup));\n                        }\n                    }\n                    return result;\n                }, []));\n            rowManager.renderFromRow(rowManager.getRow(fromRow));\n        }\n    }\n    // React to programmatic expand/collapse\n    onStoreToggleGroup({ groupRecord }) {\n        if (!this.isToggling) {\n            this.refreshGrid(groupRecord);\n        }\n    }\n    //endregion\n    //region Events - Grid\n    /**\n     * Store touches when user touches header, used in onElementTouchEnd.\n     * @private\n     */\n    onElementTouchStart(event) {\n        const\n            me         = this,\n            { target } = event,\n            header     = target.closest('.b-grid-header'),\n            column     = header && me.grid.getColumnFromElement(header);\n        // If it's a multi touch, group.\n        if (event.touches.length > 1 && column && column.groupable !== false && !me.disabled) {\n            me.store.group(column.field);\n        }\n    }\n    /**\n     * React to click on headers (to group by that column if [alt] is pressed) and on group rows (expand/collapse).\n     * @private\n     * @param event\n     * @returns {Boolean}\n     */\n    onElementClick(event) {\n        const\n            me         = this,\n            { store }  = me,\n            { target } = event,\n            row        = target.closest('.b-group-row'),\n            header     = target.closest('.b-grid-header'),\n            field      = header?.dataset.column;\n        // prevent expand/collapse if disabled or clicked on item with own handler\n        if (\n            target.classList.contains('b-resizer') ||\n            me.disabled ||\n            target.classList.contains('b-action-item') ||\n            event.handled\n        ) {\n            return;\n        }\n        // Header\n        if (header && field) {\n            const columnGrouper = store.groupers?.find(g => g.field === field);\n            // Store has a grouper for this column's field; flip grouper order\n            if (columnGrouper && !event.shiftKey) {\n                columnGrouper.ascending = !columnGrouper.ascending;\n                store.group();\n                return false;\n            }\n            // Group or ungroup\n            else if (event.shiftKey) {\n                const column = me.grid.columns.get(field);\n                if (column.groupable !== false) {\n                    if (event.altKey) {\n                        store.removeGrouper(field);\n                    }\n                    else {\n                        store.group(field);\n                    }\n                }\n            }\n        }\n        // Anywhere on group-row if toggleOnRowClick set, otherwise only on icon\n        if (row && (me.toggleOnRowClick || event.target.classList.contains('b-group-state-icon'))) {\n            me.internalToggleCollapse(DomDataStore.get(row).id, undefined, undefined, event);\n            return false;\n        }\n    }\n    /**\n     * Toggle groups with [space].\n     * @private\n     * @param event\n     */\n    toggleGroup(event) {\n        const\n            { grid }        = this,\n            { focusedCell } = grid;\n        // only catch space when focus is on a group header cell\n        if (!this.disabled && !focusedCell.isActionable && focusedCell.record?.isGroupHeader) {\n            this.internalToggleCollapse(focusedCell.id);\n            // Other features (like context menu) must not process this.\n            return true;\n        }\n        return false;\n    }\n    //endregion\n}\nGroup._$name = 'Group'; GridFeatureManager.registerFeature(Group, true, ['Grid', 'Scheduler']);\nGridFeatureManager.registerFeature(Group, false, ['TreeGrid']);\n", "import ContextMenuBase from '../../Core/feature/base/ContextMenuBase.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\n/**\n * @module Grid/feature/HeaderMenu\n */\n/**\n * Right click column header or focus it and press SPACE key to show the context menu for headers.\n *\n * ### Default header menu items\n *\n * The Header menu has no default items provided by the `HeaderMenu` feature, but there are other features\n * that populate the header menu with the following items:\n *\n * | Reference         | Text                              | Weight | Feature                                        | Description                                       |\n * |-------------------|-----------------------------------|--------|------------------------------------------------|---------------------------------------------------|\n * | `filter`          | Filter                            | 100    | {@link Grid.feature.Filter Filter}             | Shows the filter popup to add a filter            |\n * | `editFilter`      | Edit filter                       | 100    | {@link Grid.feature.Filter Filter}             | Shows the filter popup to change/remove a filter  |\n * | `removeFilter`    | Remove filter                     | 110    | {@link Grid.feature.Filter Filter}             | Stops filtering by selected column field          |\n * | `toggleFilterBar` | Hide filter bar / Show filter bar | 120    | {@link Grid.feature.FilterBar FilterBar}       | Toggles filter bar visibility                     |\n * | `columnPicker`    | Columns                           | 200    | {@link Grid.feature.ColumnPicker ColumnPicker} | Shows a submenu to control columns visibility     |\n * | \\>column.id*      | column.text*                      |        | {@link Grid.feature.ColumnPicker ColumnPicker} | Check item to hide/show corresponding column      |\n * | `hideColumn`      | Hide column                       | 210    | {@link Grid.feature.ColumnPicker ColumnPicker} | Hides selected column                             |\n * | `rename`          | Rename column text                | 215    | {@link Grid.feature.ColumnRename ColumnRename} | Edits the header text of the column               |\n * | `toggleCollapse`  | Collapse column / Expand column   | 215    | This feature                                   | Expands or collapses a collapsible column         |\n * | `movePrev  `      | Move previous                     | 220    | This feature                                   | Moves selected column before its previous sibling |\n * | `moveNext`        | Move next                         | 230    | This feature                                   | Moves selected column after its next sibling      |\n * | `sortAsc`         | Sort ascending                    | 300    | {@link Grid.feature.Sort Sort}                 | Sort by the column field in ascending order       |\n * | `sortDesc`        | Sort descending                   | 310    | {@link Grid.feature.Sort Sort}                 | Sort by the column field in descending order      |\n * | `multiSort`       | Multi sort                        | 320    | {@link Grid.feature.Sort Sort}                 | Shows a submenu to control multi-sorting          |\n * | \\>`addSortAsc`    | Add ascending sorting             | 330    | {@link Grid.feature.Sort Sort}                 | Adds ascending sorter using the column field      |\n * | \\>`addSortDesc`   | Add descending sorting            | 340    | {@link Grid.feature.Sort Sort}                 | Adds descending sorter using the column field     |\n * | \\>`removeSorter`  | Remove sorter                     | 350    | {@link Grid.feature.Sort Sort}                 | Stops sorting by selected column field            |\n * | `groupAsc`        | Group ascending                   | 400    | {@link Grid.feature.Group Group}               | Group by the column field in ascending order      |\n * | `groupDesc`       | Group descending                  | 410    | {@link Grid.feature.Group Group}               | Group by the column field in descending order     |\n * | `groupRemove`     | Stop grouping                     | 420    | {@link Grid.feature.Group Group}               | Stops grouping                                    |\n * | `mergeCells`      | Merge cells                       | 500    | {@link Grid.feature.MergeCells}                | Merge cells with same value in a sorted column    |\n *\n * \\* - items that are generated dynamically\n *\n * \\> - first level of submenu\n *\n * ### Customizing the menu items\n *\n * The menu items in the Header menu can be customized, existing items can be changed or removed,\n * and new items can be added. This is handled using the `items` config of the feature.\n *\n * Add extra items for all columns:\n *\n * ```javascript\n * const grid = new Grid({\n *   features : {\n *     headerMenu : {\n *       items : {\n *         extraItem : { text: 'My header item', icon: 'fa fa-car', weight: 200, onItem : () => ... }\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * It is also possible to add items using columns config. See examples below.\n *\n * Add extra items for a single column:\n *\n * ```javascript\n * const grid = new Grid({\n *   columns: [\n *     {\n *       field: 'name',\n *       text: 'Name',\n *       headerMenuItems: {\n *         columnItem : { text: 'My unique header item', icon: 'fa fa-flask', onItem : () => ... }\n *       }\n *     }\n *   ]\n * });\n * ```\n *\n * Remove built-in item:\n *\n * ```javascript\n * const grid = new Grid({\n *   features : {\n *     headerMenu : {\n *       items : {\n *          // Hide 'Stop grouping'\n *          groupRemove : false\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * Customize built-in item:\n *\n * ```javascript\n * const grid = new Grid({\n *   features : {\n *     headerMenu : {\n *       items : {\n *          hideColumn : {\n *              text : 'Bye bye column'\n *          }\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * Remove nested menu item:\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         headerMenu : {\n *             items : {\n *                 multiSort : {\n *                     menu : { removeSorter : false }\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * It is also possible to manipulate the default items and add new items in the processing function:\n *\n * ```javascript\n * const grid = new Grid({\n *   features : {\n *     headerMenu : {\n *       processItems({items, record}) {\n *           if (record.cost > 5000) {\n *              items.myItem = { text : 'Split cost' };\n *           }\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * <div class=\"note\">The `processItems` implementation my be an `async` function which `awaits` a result to\n * mutate the `items` object.</div>\n *\n * Full information of the menu customization can be found in the \"Customizing the Cell menu and the Header menu\" guide.\n *\n * This feature is <strong>enabled</strong> by default.\n *\n * ## Keyboard shortcuts\n * This feature has the following default keyboard shortcuts:\n *\n * | Keys           | Action                 | Action description                              |\n * |----------------|------------------------|-------------------------------------------------|\n * | `Space`        | *showContextMenuByKey* | Shows context menu for currently focused header |\n * | `Ctrl`+`Space` | *showContextMenuByKey* | Shows context menu for currently focused header |\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#Grid/guides/customization/keymap.md)\n *\n * {@inlineexample Grid/feature/HeaderMenu.js}\n *\n * @demo Grid/contextmenu\n *\n * @extends Core/feature/base/ContextMenuBase\n * @classtype headerMenu\n * @feature\n */\nexport default class HeaderMenu extends ContextMenuBase {\n    //region Config\n    static get $name() {\n        return 'HeaderMenu';\n    }\n    static get configurable() {\n        return {\n            type : 'header',\n            /**\n             * This is a preconfigured set of items used to create the default context menu.\n             *\n             * The `items` provided by this feature are listed in the intro section of this class. You can\n             * configure existing items by passing a configuration object to the keyed items.\n             *\n             * To remove existing items, set corresponding keys to `null`:\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         headerMenu : {\n             *             items : {\n             *                 filter        : null,\n             *                 columnPicker  : null\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             *\n             * See the feature config in the above example for details.\n             *\n             * @config {Object<String,MenuItemConfig|Boolean|null>} items\n             */\n            items : null,\n            /**\n             * Configure as `true` to show two extra menu options to move the selected column to either\n             * before its previous sibling, or after its next sibling.\n             *\n             * This is a keyboard-accessible version of drag/drop column reordering.\n             * @config {Boolean}\n             * @category Accessibility\n             */\n            moveColumns : null\n            /**\n             * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n             * @config {Object<String,String>} keyMap\n             */\n        };\n    }\n    static get defaultConfig() {\n        return {\n            /**\n             * A function called before displaying the menu that allows manipulations of its items.\n             * Returning `false` from this function prevents the menu being shown.\n             *\n             * ```javascript\n             *   features         : {\n             *       headerMenu : {\n             *           processItems({ column, items }) {\n             *               // Add or hide existing items here as needed\n             *               items.myAction = {\n             *                   text   : 'Cool action',\n             *                   icon   : 'b-fa b-fa-fw b-fa-ban',\n             *                   onItem : () => console.log('Some coolness'),\n             *                   weight : 300 // Move to end\n             *               };\n             *\n             *               // Hide column picker\n             *               items.columnPicker.hidden = true;\n             *           }\n             *       }\n             *   },\n             * ```\n             *\n             * @config {Function}\n             * @param {Object} context An object with information about the menu being shown\n             * @param {Grid.column.Column} context.column The current column\n             * @param {Object<String,MenuItemConfig|Boolean>} context.items An object containing the\n             *   {@link Core.widget.MenuItem menu item} configs keyed by their id\n             * @param {Event} context.event The DOM event object that triggered the show\n             * @returns {Boolean|null} Returning `false` from this function prevents the menu being shown\n             * @preventable\n             */\n            processItems : null\n        };\n    }\n    static get pluginConfig() {\n        const config = super.pluginConfig;\n        config.chain.push('populateHeaderMenu');\n        return config;\n    }\n    //endregion\n    //region Events\n    /**\n     * This event fires on the owning Grid before the context menu is shown for a header.\n     * Allows manipulation of the items to show in the same way as in the {@link #config-processItems}.\n     *\n     * Returning `false` from a listener prevents the menu from being shown.\n     *\n     * @event headerMenuBeforeShow\n     * @on-owner\n     * @preventable\n     * @param {Grid.view.Grid} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Object<String,MenuItemConfig>} items Menu item configs\n     * @param {Grid.column.Column} column Column\n     */\n    /**\n     * This event fires on the owning Grid after the context menu is shown for a header\n     * @event headerMenuShow\n     * @on-owner\n     * @param {Grid.view.Grid} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Object<String,MenuItemConfig>} items Menu item configs\n     * @param {Grid.column.Column} column Column\n     */\n    /**\n     * This event fires on the owning Grid when an item is selected in the header context menu.\n     * @event headerMenuItem\n     * @on-owner\n     * @param {Grid.view.Grid} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Core.widget.MenuItem} item Selected menu item\n     * @param {Grid.column.Column} column Column\n     */\n    /**\n     * This event fires on the owning Grid when a check item is toggled in the header context menu.\n     * @event headerMenuToggleItem\n     * @on-owner\n     * @param {Grid.view.Grid} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Core.widget.MenuItem} item Selected menu item\n     * @param {Grid.column.Column} column Column\n     * @param {Boolean} checked Checked or not\n     */\n    //endregion\n    //region Menu handlers\n    shouldShowMenu(eventParams) {\n        const { column } = eventParams;\n        return column && column.enableHeaderContextMenu !== false && column !== this.client.timeAxisColumn;\n    }\n    getDataFromEvent(event) {\n        return ObjectHelper.assign(super.getDataFromEvent(event), this.client.getHeaderDataFromEvent(event));\n    }\n    populateHeaderMenu({ items, column }) {\n        const me = this;\n        if (column) {\n            if (column.headerMenuItems) {\n                ObjectHelper.merge(items, column.headerMenuItems);\n            }\n            if (column.isCollapsible) {\n                const\n                    { collapsed } = column,\n                    icon          = collapsed\n                        ? me.client.rtl ? 'left' : 'right'\n                        : me.client.rtl ? 'right' : 'left';\n                items.toggleCollapse = {\n                    weight : 215,\n                    icon   : `b-fw-icon b-icon-collapse-${icon}`,\n                    text   : me.L(collapsed ? 'L{expandColumn}' : 'L{collapseColumn}'),\n                    onItem : () => column.collapsed = !collapsed\n                };\n            }\n            if (me.moveColumns) {\n                const\n                    columnToMoveBefore = me.getColumnToMoveBefore(column),\n                    columnToMoveAfter  = me.getColumnToMoveAfter(column);\n                if (columnToMoveBefore) {\n                    items.movePrev = {\n                        weight : 220,\n                        icon   : 'b-fw-icon b-icon-column-move-left',\n                        text   : me.L('L{moveBefore}', StringHelper.encodeHtml(columnToMoveBefore.text)),\n                        onItem : () => {\n                            const { parent : oldParent } = column;\n                            // If the operation was successful, postprocess. Check for\n                            // parent being empty and set the new region.\n                            if (columnToMoveBefore.parent.insertChild(column, columnToMoveBefore)) {\n                                column.region = columnToMoveBefore.region;\n                                // If we have removed the last child, remove the empty group.\n                                // Column#sealed may have vetoed the operation.\n                                if (!oldParent.children?.length) {\n                                    oldParent.remove();\n                                }\n                            }\n                        }\n                    };\n                }\n                if (columnToMoveAfter) {\n                    items.moveNext = {\n                        weight : 230,\n                        icon   : 'b-fw-icon b-icon-column-move-right',\n                        text   : me.L('L{moveAfter}', StringHelper.encodeHtml(columnToMoveAfter.text)),\n                        onItem : () => {\n                            const { parent : oldParent } = column;\n                            // If the operation was successful, postprocess. Check for\n                            // parent being empty and set the new region.\n                            if (columnToMoveAfter.parent.insertChild(column, columnToMoveAfter.nextSibling)) {\n                                column.region = columnToMoveAfter.region;\n                                // If we have removed the last child, remove the empty group.\n                                // Column#sealed may have vetoed the operation.\n                                if (!oldParent.children?.length) {\n                                    oldParent.remove();\n                                }\n                            }\n                        }\n                    };\n                }\n            }\n        }\n        return items;\n    }\n    getColumnToMoveBefore(column) {\n        const { previousSibling, parent } = column;\n        if (previousSibling) {\n            return previousSibling.children && !column.children ? previousSibling.children[previousSibling.children.length - 1] : previousSibling;\n        }\n        // Move to before parent\n        if (!parent.isRoot) {\n            return parent;\n        }\n    }\n    getColumnToMoveAfter(column) {\n        const { nextSibling, parent } = column;\n        if (nextSibling) {\n            return nextSibling;\n        }\n        // Move to before parent\n        if (!parent.isRoot) {\n            return parent;\n        }\n    }\n}\nHeaderMenu.featureClass = '';\nHeaderMenu._$name = 'HeaderMenu'; GridFeatureManager.registerFeature(HeaderMenu, true);\n", "import EventHelper from '../../Core/helper/EventHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\n/**\n * @module Grid/feature/RegionResize\n */\n/**\n * Makes the splitter between grid section draggable so you can resize grid sections.\n *\n * {@inlineexample Grid/feature/RegionResize.js}\n *\n * ```javascript\n * // enable RegionResize\n * const grid = new Grid({\n *   features: {\n *     regionResize: true\n *   }\n * });\n * ```\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Grid/features\n * @classtype regionResize\n * @feature\n */\nexport default class RegionResize extends InstancePlugin {\n    // region Init\n    static $name = 'RegionResize';\n    static get pluginConfig() {\n        return {\n            chain : ['onElementPointerDown', 'onElementDblClick', 'onElementTouchMove', 'onSubGridCollapse', 'onSubGridExpand', 'render']\n        };\n    }\n    static configurable = {\n        /**\n         * Set to `false` to hide splitter's collapse/expand buttons\n         * @prp {Boolean}\n         * @default\n         */\n        showSplitterButtons : true,\n        /**\n         * This flag prevents dragging if set to `false` but the collapse / expand buttons will still be functional.\n         * @prp {Boolean}\n         * @default\n         */\n        enableDragging : true\n    };\n    //endregion\n    updateShowSplitterButtons(value) {\n        this.client.element.classList.toggle('b-hide-splitter-buttons', !value);\n    }\n    onElementDblClick(event) {\n        const\n            me         = this,\n            { client } = me,\n            splitterEl = event.target.closest('.b-grid-splitter-collapsed');\n        // If collapsed splitter is dblclicked and region is not expanding\n        // It is unlikely that user might dblclick splitter twice and even if he does, nothing should happen.\n        // But just in case lets not expand twice.\n        if (splitterEl && !me.expanding) {\n            me.expanding = true;\n            let region  = splitterEl.dataset.region,\n                subGrid = client.getSubGrid(region);\n            // Usually collapsed splitter means corresponding region is collapsed. But in case of last two regions one\n            // splitter can be collapsed in two directions. So, if corresponding region is expanded then last one is collapsed\n            if (!subGrid.collapsed) {\n                region  = client.getLastRegions()[1];\n                subGrid = client.getSubGrid(region);\n            }\n            subGrid.expand().then(() => me.expanding = false);\n        }\n    }\n    //region Move splitter\n    /**\n     * Begin moving splitter.\n     * @private\n     * @param splitterElement Splitter element\n     * @param {Event} domEvent The initiating DOM event.\n     */\n    startMove(splitterElement, domEvent) {\n        const\n            me              = this,\n            { clientX }     = domEvent,\n            { client }      = me,\n            region          = splitterElement.dataset.region,\n            gridEl          = client.element,\n            nextRegion      = client.regions[client.regions.indexOf(region) + 1],\n            nextSubGrid     = client.getSubGrid(nextRegion),\n            splitterSubGrid = client.getSubGrid(region);\n        let\n            subGrid = splitterSubGrid,\n            flip    = 1;\n        if (subGrid.flex != null) {\n            // If subgrid has flex, check if next one does not\n            if (nextSubGrid.flex == null) {\n                subGrid = nextSubGrid;\n                flip    = -1;\n            }\n        }\n        if (client.rtl) {\n            flip *= -1;\n        }\n        if (splitterElement.classList.contains('b-grid-splitter-collapsed')) {\n            return;\n        }\n        const availableWidth = Object.values(client.subGrids).reduce((sum, subGrid) => {\n            return subGrid.width + sum;\n        }, 0);\n        /**\n         * Fired by the Grid when a sub-grid resize gesture starts\n         * @event splitterDragStart\n         * @on-owner\n         * @param {Grid.view.Grid} source The Grid instance.\n         * @param {Grid.view.SubGrid} subGrid The subgrid about to be resized\n         * @param {Event} domEvent The native DOM event\n         */\n        client.trigger('splitterDragStart', { subGrid, domEvent });\n        me.dragContext = {\n            element       : splitterElement,\n            headerEl      : subGrid.header.element,\n            subGridEl     : subGrid.element,\n            subGrid,\n            splitterSubGrid,\n            originalWidth : subGrid.element.offsetWidth,\n            originalX     : clientX,\n            minWidth      : subGrid.minWidth || 0,\n            maxWidth      : Math.min(availableWidth, subGrid.maxWidth || availableWidth),\n            flip\n        };\n        gridEl.classList.add('b-moving-splitter');\n        splitterSubGrid.toggleSplitterCls('b-moving');\n        me.pointerDetacher = EventHelper.on({\n            element     : document,\n            pointermove : 'onPointerMove',\n            pointerup   : 'onPointerUp',\n            thisObj     : me\n        });\n    }\n    /**\n     * Stop moving splitter.\n     * @param {Event} domEvent The initiating DOM event.\n     * @private\n     */\n    endMove(domEvent) {\n        const\n            me                      = this,\n            { dragContext, client } = me;\n        if (dragContext) {\n            const { subGrid } = dragContext;\n            domEvent.preventDefault();\n            me.pointerDetacher();\n            client.element.classList.remove('b-moving-splitter');\n            dragContext.splitterSubGrid.toggleSplitterCls('b-moving', false);\n            me.dragContext = null;\n            /**\n             * Fired by the Grid after a sub-grid has been resized using the splitter\n             * @event splitterDragEnd\n             * @on-owner\n             * @param {Grid.view.Grid} source The Grid instance.\n             * @param {Grid.view.SubGrid} subGrid The resized subgrid\n             * @param {Event} domEvent The native DOM event\n             */\n            client.trigger('splitterDragEnd', { subGrid, domEvent });\n        }\n    }\n    onCollapseClick(subGrid, splitterEl, domEvent) {\n        const\n            me         = this,\n            { client } = me,\n            region     = splitterEl.dataset.region,\n            regions    = client.getLastRegions();\n        /**\n         * Fired by the Grid when the collapse icon is clicked. Return `false` to prevent the default collapse action,\n         * if you want to implement your own behavior.\n         * @event splitterCollapseClick\n         * @on-owner\n         * @preventable\n         * @param {Grid.view.Grid} source The Grid instance.\n         * @param {Grid.view.SubGrid} subGrid The subgrid\n         * @param {Event} domEvent The native DOM event\n         */\n        if (client.trigger('splitterCollapseClick', { subGrid, domEvent }) === false) {\n            return;\n        }\n        // Last splitter in the grid is responsible for collapsing/expanding last 2 regions and is always related to the\n        // left one. Check if we are working with last splitter\n        if (regions[0] === region) {\n            const lastSubGrid = client.getSubGrid(regions[1]);\n            if (lastSubGrid.collapsed) {\n                lastSubGrid.expand();\n                return;\n            }\n        }\n        subGrid.collapse();\n    }\n    onExpandClick(subGrid, splitterEl, domEvent) {\n        const\n            me         = this,\n            { client } = me,\n            region     = splitterEl.dataset.region,\n            regions    = client.getLastRegions();\n        /**\n         * Fired by the Grid when the expand icon is clicked. Return `false` to prevent the default expand action,\n         * if you want to implement your own behavior.\n         * @event splitterExpandClick\n         * @preventable\n         * @param {Grid.view.Grid} source The Grid instance.\n         * @param {Grid.view.SubGrid} subGrid The subgrid\n         * @param {Event} domEvent The native DOM event\n         */\n        if (client.trigger('splitterExpandClick', { subGrid, domEvent }) === false) {\n            return;\n        }\n        // Last splitter in the grid is responsible for collapsing/expanding last 2 regions and is always related to the\n        // left one. Check if we are working with last splitter\n        if (regions[0] === region) {\n            if (!subGrid.collapsed) {\n                const lastSubGrid = client.getSubGrid(regions[1]);\n                lastSubGrid.collapse();\n                return;\n            }\n        }\n        subGrid.expand();\n    }\n    /**\n     * Update splitter position.\n     * @private\n     * @param newClientX\n     */\n    updateMove(newClientX) {\n        const { dragContext } = this;\n        if (dragContext) {\n            const\n                diffX    = newClientX - dragContext.originalX,\n                newWidth = Math.max(Math.min(dragContext.maxWidth, dragContext.originalWidth + diffX * dragContext.flip), 0);\n            // SubGrids monitor their own size and keep any splitters synced\n            dragContext.subGrid.width = Math.max(newWidth, dragContext.minWidth);\n        }\n    }\n    //endregion\n    //region Events\n    /**\n     * Start moving splitter on mouse down (on splitter).\n     * @private\n     * @param event\n     */\n    onElementPointerDown(event) {\n        const\n            me         = this,\n            { target } = event,\n            // Only care about left clicks, avoids a bug found by monkeys\n            splitter   = event.button === 0 && target.closest(':not(.b-row-reordering):not(.b-dragging-event):not(.b-dragging-task):not(.b-dragging-header):not(.b-dragselecting) .b-grid-splitter'),\n            subGrid    = splitter && me.client.getSubGrid(splitter.dataset.region);\n        let toggle;\n        if (splitter) {\n            if (target.closest('.b-grid-splitter-button-collapse')) {\n                me.onCollapseClick(subGrid, splitter, event);\n            }\n            else if (target.closest('.b-grid-splitter-button-expand')) {\n                me.onExpandClick(subGrid, splitter, event);\n            }\n            else if (me.enableDragging) {\n                me.startMove(splitter, event);\n                toggle = splitter;\n            }\n        }\n        if (event.pointerType === 'touch') {\n            // Touch on splitter makes splitter wider, touch outside or expand/collapse makes it smaller again\n            me.toggleTouchSplitter(toggle);\n        }\n    }\n    /**\n     * Move splitter on mouse move.\n     * @private\n     * @param event\n     */\n    onPointerMove(event) {\n        if (this.dragContext) {\n            this.updateMove(event.clientX);\n            event.preventDefault();\n        }\n    }\n    onElementTouchMove(event) {\n        if (this.dragContext) {\n            // Needed to prevent scroll in Mobile Safari, preventing pointermove is not enough\n            event.preventDefault();\n        }\n    }\n    /**\n     * Stop moving splitter on mouse up.\n     * @private\n     * @param event\n     */\n    onPointerUp(event) {\n        if (this.enableDragging) {\n            this.endMove(event);\n        }\n    }\n    onSubGridCollapse({ subGrid }) {\n        const\n            splitterEl = this.client.resolveSplitter(subGrid),\n            regions    = this.client.getLastRegions();\n        // if last region was collapsed\n        if (regions[1] === subGrid.region) {\n            splitterEl.classList.add('b-grid-splitter-allow-collapse');\n        }\n    }\n    onSubGridExpand({ subGrid }) {\n        const splitterEl = this.client.resolveSplitter(subGrid);\n        splitterEl.classList.remove('b-grid-splitter-allow-collapse');\n    }\n    //endregion\n    /**\n     * Adds b-touching CSS class to splitterElements when touched. Removes when touched outside.\n     * @private\n     * @param splitterElement\n     */\n    toggleTouchSplitter(splitterElement) {\n        const\n            me                  = this,\n            { touchedSplitter } = me;\n        // If other splitter is touched, deactivate old one\n        if (splitterElement && touchedSplitter && splitterElement.dataset.region !== touchedSplitter.dataset.region) {\n            me.toggleTouchSplitter();\n        }\n        // Either we have touched a splitter (should activate) or touched outside (should deactivate)\n        const splitterSubGrid = me.client.getSubGrid(splitterElement ? splitterElement.dataset.region : touchedSplitter?.dataset.region);\n        if (splitterSubGrid) {\n            splitterSubGrid.toggleSplitterCls('b-touching', Boolean(splitterElement));\n            if (splitterElement) {\n                splitterSubGrid.startSplitterButtonSyncing();\n            }\n            else {\n                splitterSubGrid.stopSplitterButtonSyncing();\n            }\n        }\n        me.touchedSplitter = splitterElement;\n    }\n    render() {\n        const { regions, subGrids } = this.client;\n        // Multiple regions, only allow collapsing to the edges by hiding buttons\n        if (regions.length > 2) {\n            // Only works in a 3 subgrid scenario. To support more subgrids we have to merge splitters or something\n            // on collapse. Not going down that path currently...\n            subGrids[regions[0]].splitterElement.classList.add('b-left-only');\n            subGrids[regions[1]].splitterElement.classList.add('b-right-only');\n        }\n    }\n    updateEnableDragging(value) {\n        this.client.element.classList.toggle('b-grid-splitter-no-drag', !value);\n    }\n}\nRegionResize.featureClass = 'b-split';\nRegionResize._$name = 'RegionResize'; GridFeatureManager.registerFeature(RegionResize);\n", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport DomClassList from '../../Core/helper/util/DomClassList.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from './GridFeatureManager.js';\n/**\n * @module Grid/feature/Sort\n */\nconst emptyArray = Object.freeze([]);\n/**\n * Allows sorting of grid by clicking (or tapping) headers, also displays which columns grid is sorted by (numbered if\n * using multisort). Use modifier keys for multisorting: [Ctrl/CMD + click] to add sorter, [Ctrl/CMD + Alt + click] to remove sorter.\n * The actual sorting is done by the store, see {@link Core.data.mixin.StoreSort#function-sort Store.sort()}.\n *\n * {@inlineexample Grid/feature/Sort.js}\n *\n * ```javascript\n * // sorting feature is enabled, no default value though\n * const grid = new Grid({\n *     features : {\n *         sort : true\n *     }\n * });\n *\n * // use initial sorting\n * const grid = new Grid({\n *     features : {\n *         sort : 'name'\n *     }\n * });\n *\n * // can also be specified on the store\n * const grid = new Grid({\n *     store : {\n *         sorters : [\n *             { field : 'name', ascending : false }\n *         ]\n *     }\n * });\n *\n * // custom sorting function can also be specified on the store\n * const grid = new Grid({\n *     store : {\n *         sorters : [{\n *             fn : (recordA, recordB) => {\n *                 // apply custom logic, for example:\n *                 return recordA.name.length < recordB.name.length ? -1 : 1;\n *             }\n *         }]\n *     }\n * });\n * ```\n *\n * For info on programmatically handling sorting, see {@link Core.data.mixin.StoreSort StoreSort}:\n *\n * ```javascript\n * const grid = new Grid({ });\n * // Programmatic sorting of the store, Grids rows and UI will be updated\n * grid.store.sort('age');\n * ```\n *\n * Grid columns can define custom sorting functions (see {@link Grid.column.Column#config-sortable Column.sortable}).\n * If this feature is configured with `prioritizeColumns: true`, those functions will also be used when sorting\n * programmatically:\n *\n * ```javascript\n * const grid = new Grid({\n *     columns : [\n *         {\n *             field : 'age',\n *             text : 'Age',\n *             sortable(lhs, rhs) {\n *               // Custom sorting, see Array#sort\n *             }\n *         }\n *     ],\n *\n *     features : {\n *         sort : {\n *             prioritizeColumns : true\n *         }\n *     }\n * });\n *\n * // Sortable fn will also be used when sorting programmatically\n * grid.store.sort('age');\n * ```\n *\n * This feature is **enabled** by default.\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Grid/sorting\n * @classtype sort\n * @feature\n */\nexport default class Sort extends InstancePlugin {\n    //region Config\n    static $name = 'Sort';\n    static configurable = {\n        /**\n         * Enable multi sort\n         * @config {Boolean}\n         * @default\n         */\n        multiSort : true,\n        /**\n         * Use custom sorting functions defined on columns also when programmatically sorting by the columns field.\n         *\n         * ```javascript\n         * const grid = new Grid({\n         *     columns : [\n         *         {\n         *             field : 'age',\n         *             text : 'Age',\n         *             sortable(lhs, rhs) {\n         *               // Custom sorting, see Array#sort\n         *             }\n         *         }\n         *     ],\n         *\n         *     features : {\n         *         sort : {\n         *             prioritizeColumns : true\n         *         }\n         *     }\n         * });\n         *\n         * grid.store.sort('age');\n         * ```\n         *\n         * @config {Boolean}\n         * @default\n         */\n        prioritizeColumns : false,\n        /**\n         * By default, clicking anywhere on the header text toggles the sorting state of a column.\n         *\n         * Configure this as `false` to only toggle the sorting state of a column on click of the\n         * \"arrow\" icon within the grid header.\n         * @config {Boolean}\n         * @default false\n         */\n        toggleOnHeaderClick : true\n    };\n    static get properties() {\n        return {\n            ignoreRe : new RegExp([\n                // Stop this feature from having to know the internals of two other optional features.\n                'b-grid-header-resize-handle',\n                'b-filter-icon'\n            ].join('|')),\n            sortableCls   : 'b-sortable',\n            sortedCls     : 'b-sort',\n            sortedAscCls  : 'b-asc',\n            sortedDescCls : 'b-desc'\n        };\n    }\n    //endregion\n    //region Init\n    construct(grid, config) {\n        // process initial config into an actual config object\n        config = this.processConfig(config);\n        this.grid = grid;\n        this.bindStore(this.store);\n        super.construct(grid, config);\n    }\n    // Sort feature handles special config cases, where user can supply a string or an array of sorters\n    // instead of a normal config object\n    processConfig(config) {\n        if (typeof config === 'string' || Array.isArray(config)) {\n            return {\n                field     : config,\n                ascending : null\n            };\n        }\n        return config;\n    }\n    // override setConfig to process config before applying it\n    setConfig(config) {\n        super.setConfig(this.processConfig(config));\n    }\n    bindStore(store) {\n        this.detachListeners('store');\n        store.ion({\n            name       : 'store',\n            beforeSort : 'onStoreBeforeSort',\n            sort       : 'syncHeaderSortState',\n            thisObj    : this\n        });\n        if (this.client?.isPainted) {\n            this.syncHeaderSortState();\n        }\n    }\n    set field(field) {\n        // Use columns sortable config for initial sorting if it is specified\n        const column = this.grid.columns.get(field);\n        if (column && typeof column.sortable === 'object') {\n            // Normalization of Store & CollectionSorter differences\n            column.sortable.field = column.sortable.property || field;\n            field = column.sortable;\n        }\n        // Do not reapply sorting if already sorted by the field. This will prevent sort direction from flipping\n        // when splitting grids using sort feature configured with field (store is shared)\n        if (!this.store.sorters?.some(g => g.field === field)) {\n            this.store.sort(field, this.ascending);\n        }\n    }\n    // Avoid caching store, it might change\n    get store() {\n        return this.grid[this.grid.sortFeatureStore];\n    }\n    //endregion\n    //region Plugin config\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['onElementClick', 'populateHeaderMenu', 'getColumnDragToolbarItems', 'renderHeader', 'onInternalPaint', 'bindStore']\n        };\n    }\n    //endregion\n    //region Headers\n    /**\n     * Update headers to match stores sorters (displays sort icon in correct direction on them)\n     * @private\n     */\n    syncHeaderSortState() {\n        const\n            me       = this,\n            { grid } = me;\n        if (!grid.hideHeaders && grid.isPainted) {\n            const\n                storeSorters = me.store.sorters.concat(me.store.groupers || emptyArray),\n                sorterCount  = storeSorters.length,\n                classList    = new DomClassList();\n            let\n                sorter;\n            // Sync the sortable, sorted, and sortIndex state of each leaf header element\n            for (const leafColumn of grid.columns.visibleColumns) {\n                if (!leafColumn.sortable) {\n                    continue;\n                }\n                const\n                    leafHeader = leafColumn.element,\n                    textEl     = leafColumn.textWrapper,\n                    // TimeAxisColumn in Scheduler has no textWrapper, since it has custom rendering,\n                    // but since it cannot be sorted by anyway lets just ignore it\n                    dataset    = textEl?.dataset;\n                let sortDirection = 'none';\n                // data-sortIndex is 1-based, and only set if there is > 1 sorter.\n                // iOS Safari throws a JS error if the requested delete property is not present.\n                dataset?.sortIndex && delete dataset.sortIndex;\n                classList.value = leafHeader.classList;\n                if (leafColumn.sortable === false) {\n                    classList.remove(me.sortableCls);\n                    textEl?.querySelector('.b-sort-icon')?.remove();\n                }\n                else {\n                    if (!textEl?.querySelector('.b-sort-icon')) {\n                        DomHelper.createElement({\n                            parent    : textEl,\n                            className : 'b-sort-icon'\n                        });\n                    }\n                    classList.add(me.sortableCls);\n                    sorter = storeSorters.find(sort =>\n                        sort.field === leafColumn.field ||\n                        (sort.sortFn && sort.sortFn === leafColumn.sortable.sortFn)\n                    );\n                    if (sorter) {\n                        if (sorterCount > 1 && dataset) {\n                            dataset.sortIndex = storeSorters.indexOf(sorter) + 1;\n                        }\n                        classList.add(me.sortedCls);\n                        if (sorter.ascending) {\n                            classList.add(me.sortedAscCls);\n                            classList.remove(me.sortedDescCls);\n                            sortDirection = 'ascending';\n                        }\n                        else {\n                            classList.add(me.sortedDescCls);\n                            classList.remove(me.sortedAscCls);\n                            sortDirection = 'descending';\n                        }\n                    }\n                    else {\n                        classList.remove(me.sortedCls);\n                        // Not optimal, but easiest way to make sure sort feature does not remove needed classes.\n                        // Better solution would be to use different names for sorting and grouping\n                        if (!classList['b-group']) {\n                            classList.remove(me.sortedAscCls);\n                            classList.remove(me.sortedDescCls);\n                        }\n                    }\n                }\n                // Update the element's classList\n                DomHelper.syncClassList(leafHeader, classList);\n                DomHelper.setAttributes(leafHeader, {\n                    'aria-sort' : sortDirection\n                });\n            }\n        }\n    }\n    //endregion\n    //region Context menu\n    /**\n     * Adds sort menu items to header context menu.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateHeaderMenu({ column, items }) {\n        const\n            me        = this,\n            { store } = me,\n            sortBy    = {  ...column.sortable, field : column.field, columnOwned : true };\n        if (column.sortable !== false) {\n            items.sortAsc = {\n                text        : 'L{sortAscending}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-sort-asc',\n                cls         : 'b-separator',\n                weight      : 300,\n                disabled    : me.disabled,\n                onItem      : () => store.sort(sortBy, true)\n            };\n            items.sortDesc = {\n                text        : 'L{sortDescending}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-sort-desc',\n                weight      : 310,\n                disabled    : me.disabled,\n                onItem      : () => store.sort(sortBy, false)\n            };\n            if (me.multiSort && me.grid.columns.records.some(col => col.sortable)) {\n                const sorter = store.sorters.find(s => s.field === column.field || (column.sortable.sortFn && column.sortable.sortFn === s.sortFn));\n                items.multiSort = {\n                    text        : 'L{multiSort}',\n                    localeClass : me,\n                    icon        : 'b-fw-icon b-icon-sort',\n                    weight      : 320,\n                    disabled    : me.disabled,\n                    menu        : {\n                        addSortAsc : {\n                            text        : sorter ? 'L{toggleSortAscending}' : 'L{addSortAscending}',\n                            localeClass : me,\n                            icon        : 'b-fw-icon b-icon-sort-asc',\n                            disabled    : sorter && sorter?.ascending,\n                            weight      : 330,\n                            onItem      : () => store.addSorter(sortBy, true)\n                        },\n                        addSortDesc : {\n                            text        : sorter ? 'L{toggleSortDescending}' : 'L{addSortDescending}',\n                            localeClass : me,\n                            icon        : 'b-fw-icon b-icon-sort-desc',\n                            disabled    : sorter && !sorter.ascending,\n                            weight      : 340,\n                            onItem      : () => store.addSorter(sortBy, false)\n                        },\n                        removeSorter : {\n                            text        : 'L{removeSorter}',\n                            localeClass : me,\n                            icon        : 'b-fw-icon b-icon-remove',\n                            weight      : 350,\n                            disabled    : !sorter,\n                            onItem      : () => {\n                                store.removeSorter(sortBy.field);\n                            }\n                        }\n                    }\n                };\n            }\n        }\n    }\n    /**\n     * Supply items to ColumnDragToolbar\n     * @private\n     */\n    getColumnDragToolbarItems(column, items) {\n        const\n            me                  = this,\n            { store, disabled } = me;\n        if (column.sortable !== false) {\n            const sorter = store.sorters.find(s => s.field === column.field);\n            items.push(\n                {\n                    text        : 'L{sortAscendingShort}',\n                    group       : 'L{sort}',\n                    localeClass : me,\n                    icon        : 'b-icon b-icon-sort-asc',\n                    ref         : 'sortAsc',\n                    cls         : 'b-separator',\n                    weight      : 105,\n                    disabled,\n                    onDrop      : ({ column }) => store.sort(column.field, true)\n                },\n                {\n                    text        : 'L{sortDescendingShort}',\n                    group       : 'L{sort}',\n                    localeClass : me,\n                    icon        : 'b-icon b-icon-sort-desc',\n                    ref         : 'sortDesc',\n                    weight      : 105,\n                    disabled,\n                    onDrop      : ({ column }) => store.sort(column.field, false)\n                },\n                {\n                    text        : 'L{addSortAscendingShort}',\n                    group       : 'L{multiSort}',\n                    localeClass : me,\n                    icon        : 'b-icon b-icon-sort-asc',\n                    ref         : 'multisortAddAsc',\n                    disabled    : disabled || (sorter && sorter.ascending),\n                    weight      : 105,\n                    onDrop      : ({ column }) => store.addSorter(column.field, true)\n                }, {\n                    text        : 'L{addSortDescendingShort}',\n                    group       : 'L{multiSort}',\n                    localeClass : me,\n                    icon        : 'b-icon b-icon-sort-desc',\n                    ref         : 'multisortAddDesc',\n                    disabled    : disabled || (sorter && !sorter.ascending),\n                    weight      : 105,\n                    onDrop      : ({ column }) => store.addSorter(column.field, false)\n                }, {\n                    text        : 'L{removeSorterShort}',\n                    group       : 'L{multiSort}',\n                    localeClass : me,\n                    icon        : 'b-icon b-icon-remove',\n                    ref         : 'multisortRemove',\n                    weight      : 105,\n                    disabled    : disabled || !sorter,\n                    onDrop      : ({ column }) => store.removeSorter(column.field)\n                }\n            );\n        }\n        return items;\n    }\n    //endregion\n    //region Events\n    // Intercept sorting by a column that has a custom sorting fn, and inject that fn\n    onStoreBeforeSort({ sorters }) {\n        const { columns } = this.client;\n        for (let i = 0; i < sorters.length; i++) {\n            const\n                sorter = sorters[i],\n                column = (sorter.columnOwned || this.prioritizeColumns) && columns.get(sorter.field);\n            if (column?.sortable?.sortFn) {\n                sorters[i] = { ...sorter, ...column.sortable, columnOwned : true };\n            }\n        }\n    }\n    /**\n     * Clicked on header, sort Store.\n     * @private\n     */\n    onElementClick(event) {\n        const\n            me         = this,\n            { store }  = me,\n            { target } = event,\n            header     = target.closest('.b-grid-header.b-sortable'),\n            field      = header?.dataset.column;\n        if (me.ignoreRe.test(target.className) || me.disabled || event.handled) {\n            return;\n        }\n        //Header\n        if (header && field && (me.toggleOnHeaderClick || target.closest('.b-sort-icon'))) {\n            const\n                column        = me.grid.columns.getById(header.dataset.columnId),\n                columnGrouper = store.isGrouped && store.groupers.find(g => g.field === field);\n            // The Group feature will handle the change of the grouper's direction\n            if (columnGrouper && !event.shiftKey) {\n                return;\n            }\n            if (column.sortable && !event.shiftKey) {\n                if (event.ctrlKey && event.altKey) {\n                    store.removeSorter(column.field);\n                }\n                else {\n                    const sortBy = {\n                        columnOwned : true,\n                        field       : column.field\n                    };\n                    // sortable as a function is handled by onStoreBeforeSort() above\n                    if (typeof column.sortable === 'object') {\n                        ObjectHelper.assign(sortBy, column.sortable);\n                    }\n                    store.sort(sortBy, null, event.ctrlKey && me.multiSort);\n                }\n            }\n        }\n    }\n    /**\n     * Called when grid headers are rendered, make headers match current sorters.\n     * @private\n     */\n    renderHeader() {\n        this.syncHeaderSortState();\n    }\n    onInternalPaint() {\n        this.syncHeaderSortState();\n    }\n    //endregion\n}\nSort.featureClass = 'b-sort';\nSort._$name = 'Sort'; GridFeatureManager.registerFeature(Sort, true);\n", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\n/**\n * @module Grid/feature/Stripe\n */\n/**\n * Stripes rows by adding alternating CSS classes to all row elements (`b-even` and `b-odd`).\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * ```javascript\n * let grid = new Grid({\n *   features: {\n *     stripe: true\n *   }\n * });\n *\n * {@inlineexample Grid/feature/Stripe.js}\n *\n * @demo Grid/columns\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype stripe\n * @feature\n */\nexport default class Stripe extends InstancePlugin {\n    static get $name() {\n        return 'Stripe';\n    }\n    construct(grid, config) {\n        super.construct(grid, config);\n        grid.ion({\n            renderrow : 'onRenderRow',\n            thisObj   : this\n        });\n    }\n    doDisable(disable) {\n        if (!this.isConfiguring) {\n            // Refresh rows to add/remove even/odd classes\n            this.client.refreshRows();\n        }\n        super.doDisable(disable);\n    }\n    /**\n     * Applies even/odd CSS when row is rendered\n     * @param {Grid.row.Row} rowModel\n     * @private\n     */\n    onRenderRow({ row }) {\n        const\n            { disabled } = this,\n            even         = row.dataIndex % 2 === 0;\n        row.assignCls({\n            'b-even' : !disabled && even,\n            'b-odd'  : !disabled && !even\n        });\n    }\n}\nStripe._$name = 'Stripe'; GridFeatureManager.registerFeature(Stripe);\n", "import Base from '../../Core/Base.js';\nimport DomDataStore from '../../Core/data/DomDataStore.js';\nimport ArrayHelper from '../../Core/helper/ArrayHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport DomClassList from '../../Core/helper/util/DomClassList.js';\nimport Location from '../util/Location.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\n/**\n * @module Grid/row/Row\n */\nconst cellContentRange     = document.createRange();\n/**\n * Represents a single rendered row in the grid. Consists of one row element for each SubGrid in use. The grid only\n * creates as many rows as needed to fill the current viewport (and a buffer). As the grid scrolls\n * the rows are repositioned and reused, there is not a one-to-one relation between rows and records.\n *\n * For normal use cases you should not have to use this class directly. Rely on using renderers instead.\n * @extends Core/Base\n */\nexport default class Row extends Base {\n    static $name = 'Row';\n    static get configurable() {\n        return {\n            /**\n             * When __read__, this a {@link Core.helper.util.DomClassList} of class names to be\n             * applied to this Row's elements.\n             *\n             * It can be __set__ using Object notation where each property name with a truthy value is added as\n             * a class, or as a regular space-separated string.\n             *\n             * @member {Core.helper.util.DomClassList} cls\n             * @accepts {Core.helper.util.DomClassList|Object<String,Boolean|Number>}\n             */\n            /**\n             * The class name to initially add to all row elements\n             * @config {String|Core.helper.util.DomClassList|Object<String,Boolean|Number>}\n             */\n            cls : {\n                $config : {\n                    equal : (c1, c2) => c1?.isDomClassList && c2?.isDomClassList && c1.isEqual(c2)\n                }\n            }\n        };\n    }\n    //region Init\n    /**\n     * Constructs a Row setting its index.\n     * @param {Object} config A configuration object which must contain the following two properties:\n     * @param {Grid.view.Grid} config.grid The owning Grid.\n     * @param {Grid.row.RowManager} config.rowManager The owning RowManager.\n     * @param {Number} config.index The index of the row within the RowManager's cache.\n     * @function constructor\n     * @internal\n     */\n    construct(config) {\n        // Set up defaults and properties\n        Object.assign(this, {\n            _elements      : {},\n            _elementsArray : [],\n            _cells         : {},\n            _allCells      : [],\n            _regions       : [],\n            lastHeight     : 0,\n            lastTop        : -1,\n            _dataIndex     : 0,\n            _top           : 0,\n            _height        : 0,\n            _id            : null,\n            forceInnerHTML : false,\n            isGroupFooter  : false,\n            // Create our cell rendering context\n            cellContext    : new Location({\n                grid        : config.grid,\n                id          : null,\n                columnIndex : 0\n            })\n        });\n        super.construct(config);\n        // For performance, the element translation method is set at Row consruct time.\n        // The default uses transform : translate(), it can be overridden if rows need\n        // to be positioned using layout, such as when sticky elements are used in cells.\n        if (this.grid.positionMode === 'position') {\n            this.translateElements = this.positionElements;\n        }\n    }\n    doDestroy() {\n        const me = this;\n        // No need to clean elements up if the entire thing is being destroyed\n        if (!me.rowManager.isDestroying) {\n            me.removeElements();\n            if (me.rowManager.idMap[me.id] === me) {\n                delete me.rowManager.idMap[me.id];\n            }\n        }\n        super.doDestroy();\n    }\n    //endregion\n    //region Data getters/setters\n    /**\n     * Get index in RowManagers rows array\n     * @property {Number}\n     * @readonly\n     */\n    get index() {\n        return this._index;\n    }\n    set index(index) {\n        this._index = index;\n    }\n    /**\n     * Get/set this rows current index in grids store\n     * @property {Number}\n     */\n    get dataIndex() {\n        return this._dataIndex;\n    }\n    set dataIndex(dataIndex) {\n        if (this._dataIndex !== dataIndex) {\n            this._dataIndex = dataIndex;\n            this.eachElement(element => {\n                element.dataset.index = dataIndex;\n                element.ariaRowIndex  = this.grid.hideHeaders ? dataIndex + 1 : dataIndex + 2;\n            });\n        }\n    }\n    /**\n     * Get/set id for currently rendered record\n     * @property {String|Number}\n     */\n    get id() {\n        return this._id;\n    }\n    set id(id) {\n        const\n            me    = this,\n            idObj = { id },\n            idMap = me.rowManager.idMap;\n        if (me._id !== id || idMap[id] !== me) {\n            if (idMap[me._id] === me) delete idMap[me._id];\n            idMap[id] = me;\n            me._id = id;\n            me.eachElement(element => {\n                DomDataStore.assign(element, idObj);\n                element.dataset.id = id;\n            });\n            me.eachCell(cell => DomDataStore.assign(cell, idObj));\n        }\n    }\n    //endregion\n    //region Row elements\n    /**\n     * Add a row element for specified region.\n     * @param {String} region Region to add element for\n     * @param {HTMLElement} element Element\n     * @private\n     */\n    addElement(region, element) {\n        const me = this;\n        let cellElement = element.firstElementChild;\n        me._elements[region] = element;\n        me._elementsArray.push(element);\n        me._regions.push(region);\n        DomDataStore.assign(element, { index : me.index });\n        me._cells[region] = [];\n        while (cellElement) {\n            me._cells[region].push(cellElement);\n            me._allCells.push(cellElement);\n            DomDataStore.set(cellElement, {\n                column     : cellElement.dataset.column,\n                columnId   : cellElement.dataset.columnId,\n                rowElement : cellElement.parentNode,\n                row        : me\n            });\n            cellElement = cellElement.nextElementSibling;\n        }\n        // making css selectors simpler, dataset has bad performance but it is only set once and never read\n        element.dataset.index = me.index;\n        element.ariaRowIndex  = me.grid.hideHeaders ? me.index + 1 : me.index + 2;\n        if (me.top !== null) {\n            me.translateElements(true);\n        }\n    }\n    /**\n     * Get the element for the specified region.\n     * @param {String} region\n     * @returns {HTMLElement}\n     */\n    getElement(region) {\n        return this._elements[region];\n    }\n    /**\n     * Get the {@link Core.helper.util.Rectangle element bounds} for the specified region of this Row.\n     * @param {String} region\n     * @returns {Core.helper.util.Rectangle}\n     */\n    getRectangle(region) {\n        return Rectangle.from(this.getElement(region));\n    }\n    /**\n     * Execute supplied function for each regions element.\n     * @param {Function} fn\n     */\n    eachElement(fn) {\n        this._elementsArray.forEach(fn);\n    }\n    /**\n     * Execute supplied function for each cell.\n     * @param {Function} fn\n     */\n    eachCell(fn) {\n        this._allCells.forEach(fn);\n    }\n    /**\n     * An object, keyed by region name (for example `locked` and `normal`) containing the elements which comprise the full row.\n     * @type {Object<String,HTMLElement>}\n     * @readonly\n     */\n    get elements() {\n        return this._elements;\n    }\n    /**\n     * The row element, only applicable when not using multiple grid sections (see {@link #property-elements})\n     * @type {HTMLElement}\n     * @readonly\n     */\n    get element() {\n        const region = Object.keys(this._elements)[0];\n        return this._elements[region];\n    }\n    //endregion\n    //region Cell elements\n    /**\n     * Row cell elements\n     * @property {HTMLElement[]}\n     * @readonly\n     */\n    get cells() {\n        return this._allCells;\n    }\n    /**\n     * Get cell elements for specified region.\n     * @param {String} region Region to get elements for\n     * @returns {HTMLElement[]} Array of cell elements\n     */\n    getCells(region) {\n        return this._cells[region];\n    }\n    /**\n     * Get the cell element for the specified column.\n     * @param {String|Number} columnId Column id\n     * @returns {HTMLElement} Cell element\n     */\n    getCell(columnId, strict = false) {\n        return this._allCells.find(cell => {\n            const cellData = DomDataStore.get(cell);\n            // cellData will always have String type, use == to handle a column with Number type\n            return cellData.columnId == columnId || (!strict && cellData.column == columnId);\n        });\n    }\n    removeElements(onlyRelease = false) {\n        const me = this;\n        // Triggered before the actual remove to allow cleaning up elements etc.\n        me.rowManager.trigger('removeRow', { row : me });\n        if (!onlyRelease) {\n            me.eachElement(element => element.remove());\n        }\n        me._elements = {};\n        me._cells = {};\n        me._elementsArray.length = me._regions.length = me._allCells.length = me.lastHeight = me.height = 0;\n        me.lastTop = -1;\n    }\n    //endregion\n    //region Height\n    /**\n     * Get/set row height\n     * @property {Number}\n     */\n    get height() {\n        return this._height;\n    }\n    set height(height) {\n        this._height = height;\n    }\n    /**\n     * Get row height including border\n     * @property {Number}\n     */\n    get offsetHeight() {\n        // me.height is specified height, add border height to it to get cells height to match specified rowHeight\n        // border height is measured in Grid#get rowManager\n        return this.height + this.grid._rowBorderHeight;\n    }\n    /**\n     * Sync elements height to rows height\n     * @private\n     */\n    updateElementsHeight(isExport) {\n        const me = this;\n        if (!isExport) {\n            me.rowManager.storeKnownHeight(me.id, me.height);\n        }\n        // prevent unnecessary style updates\n        if (me.lastHeight !== me.height) {\n            this.eachElement(element => element.style.height = `${me.offsetHeight}px`);\n            me.lastHeight = me.height;\n        }\n    }\n    //endregion\n    //region CSS\n    /**\n     * Add CSS classes to each element.\n     * @param {...String|Object<String,Boolean|Number>|Core.helper.util.DomClassList} classes\n     */\n    addCls(classes) {\n        this.updateCls(this.cls.add(classes));\n    }\n    /**\n     * Remove CSS classes from each element.\n     * @param {...String|Object<String,Boolean|Number>|Core.helper.util.DomClassList} classes\n     */\n    removeCls(classes) {\n        this.updateCls(this.cls.remove(classes));\n    }\n    /**\n     * Toggle CSS classes for each element.\n     * @param {Object<String,Boolean|Number>|Core.helper.util.DomClassList|...String} classes\n     * @param {Boolean} add\n     * @internal\n     */\n    toggleCls(classes, add) {\n        this.updateCls(this.cls[add ? 'add' : 'remove'](classes));\n    }\n    /**\n     * Adds/removes class names according to the passed object's properties.\n     *\n     * Properties with truthy values are added.\n     * Properties with false values are removed.\n     * @param {Object<String,Boolean|Number>} classes Object containing properties to set/clear\n     */\n    assignCls(classes) {\n        this.updateCls(this.cls.assign(classes));\n    }\n    changeCls(cls) {\n        return cls?.isDomClassList ? cls : new DomClassList(cls);\n    }\n    updateCls(cls) {\n        this.eachElement(element => DomHelper.syncClassList(element, cls));\n    }\n    setAttribute(attribute, value) {\n        this.eachElement(element => element.setAttribute(attribute, value));\n    }\n    removeAttribute(attribute) {\n        this.eachElement(element => element.removeAttribute(attribute));\n    }\n    //endregion\n    //region Position\n    /**\n     * Is this the very first row?\n     * @property {Boolean}\n     * @readonly\n     */\n    get isFirst() {\n        return this.dataIndex === 0;\n    }\n    /**\n     * Row top coordinate\n     * @property {Number}\n     * @readonly\n     */\n    get top() {\n        return this._top;\n    }\n    /**\n     * Row bottom coordinate\n     * @property {Number}\n     * @readonly\n     */\n    get bottom() {\n        return this._top + this._height + this.grid._rowBorderHeight;\n    }\n    /**\n     * Sets top coordinate, translating elements position.\n     * @param {Number} top Top coordinate\n     * @param {Boolean} [silent] Specify `true` to not trigger translation event\n     * @internal\n     */\n    setTop(top, silent) {\n        if (this._top !== top) {\n            this._top = top;\n            this.translateElements(silent);\n        }\n    }\n    /**\n     * Sets bottom coordinate, translating elements position.\n     * @param {Number} bottom Bottom coordinate\n     * @param {Boolean} [silent] Specify `true` to not trigger translation event\n     * @private\n     */\n    setBottom(bottom, silent) {\n        this.setTop(bottom - this.offsetHeight, silent);\n    }\n    // Used by export feature to position individual row\n    translate(top, silent = false) {\n        this.setTop(top, silent);\n        return top + this.offsetHeight;\n    }\n    /**\n     * Sets css transform to position elements at correct top position (translateY)\n     * @private\n     */\n    translateElements(silent) {\n        const\n            me                      = this,\n            { top, _elementsArray } = me;\n        if (me.lastTop !== top) {\n            for (let i = 0, { length } = _elementsArray; i < length; i++) {\n                _elementsArray[i].style.transform = `translate(0,${top}px)`;\n            }\n            !silent && me.rowManager.trigger('translateRow', { row : me });\n            me.lastTop = top;\n        }\n    }\n    /**\n     * Sets css top to position elements at correct top position\n     * @private\n     */\n    positionElements(silent) {\n        const\n            me                      = this,\n            { top, _elementsArray } = me;\n        if (me.lastTop !== top) {\n            for (let i = 0, { length } = _elementsArray; i < length; i++) {\n                _elementsArray[i].style.top = `${top}px`;\n            }\n            !silent && me.rowManager.trigger('translateRow', { row : me });\n            me.lastTop = top;\n        }\n    }\n    /**\n     * Moves all row elements up or down and updates model.\n     * @param {Number} offsetTop Pixels to offset the elements\n     * @private\n     */\n    offset(offsetTop) {\n        let newTop = this._top + offsetTop;\n        // Not allowed to go below zero (won't be reachable on scroll in that case)\n        if (newTop < 0) {\n            offsetTop -= newTop;\n            newTop = 0;\n        }\n        this.setTop(newTop);\n        return offsetTop;\n    }\n    //endregion\n    //region Render\n    /**\n     * Renders a record into this rows elements (trigger event that subgrids catch to do the actual rendering).\n     * @param {Number} recordIndex\n     * @param {Core.data.Model} record\n     * @param {Boolean} [updatingSingleRow]\n     * @param {Boolean} [batch]\n     * @private\n     */\n    render(recordIndex, record, updatingSingleRow = true, batch = false, isExport = false) {\n        const\n            me        = this,\n            {\n                cellContext,\n                cls,\n                elements,\n                grid,\n                rowManager,\n                height         : oldHeight,\n                _id            : oldId\n            }             = me,\n            rowElData     = DomDataStore.get(me._elementsArray[0]),\n            rowHeight     = rowManager._rowHeight,\n            { store }     = grid,\n            { isTree }    = store;\n        let i = 0,\n            size;\n        // no record specified, try looking up in store (false indicates empty row, don't do lookup)\n        if (!record && record !== false) {\n            record      = grid.store.getById(rowElData.id);\n            recordIndex = grid.store.indexOf(record);\n        }\n        // Bail out if record is not resolved\n        if (!record) {\n            return;\n        }\n        // Now we have acquired a record, see what classes it requires on the\n        const\n            rCls          = record?.cls,\n            recordCls     = rCls ? (rCls.isDomClassList ? rCls : new DomClassList(rCls)) : null;\n        cls.assign({\n            // do not put updating class if we're exporting the row\n            'b-grid-row-updating' : updatingSingleRow && grid.transitionDuration && !isExport,\n            'b-selected'          : grid.isSelected(record?.id),\n            'b-readonly'          : record.readOnly,\n            'b-linked'            : record.isLinked,\n            'b-original'          : record.hasLinks\n        });\n        // These are DomClassLists, so they have to have their properties processed by add/remove\n        if (me.lastRecordCls) {\n            cls.remove(me.lastRecordCls);\n        }\n        // Assign our record's cls to the row, and cache the value so it can be removed next time round\n        if (recordCls) {\n            cls.add(recordCls);\n            me.lastRecordCls = Object.assign({}, recordCls);\n        }\n        else {\n            me.lastRecordCls = null;\n        }\n        // used by GroupSummary feature to clear row before\n        rowManager.trigger('beforeRenderRow', { row : me, record, recordIndex, oldId });\n        grid.beforeRenderRow({ row : me, record, recordIndex, oldId, cls });\n        // Flush any changes to our DomClassList to the Row's DOM\n        me.updateCls(cls);\n        if (updatingSingleRow && grid.transitionDuration && !isExport) {\n            grid.setTimeout(() => {\n                if (!me.isDestroyed) {\n                    cls.remove('b-grid-row-updating');\n                    me.updateCls(cls);\n                }\n            }, grid.transitionDuration + 50);\n        }\n        me.id = record.id;\n        me.dataIndex = recordIndex;\n        // Configured height, used as row height if renderers do not specify otherwise\n        const height = (!grid.fixedRowHeight && grid.getRowHeight(record)) || rowHeight;\n        // Max height returned by renderers\n        let maxRequestedHeight = me.maxRequestedHeight = null;\n        // Keep ARIA ownership up to date\n        if (isTree) {\n            for (const region in elements) {\n                const el = elements[region];\n                el.id = `${grid.id}-${region}-${me.id}`;\n                DomHelper.setAttributes(el, {\n                    'aria-level'    : record.childLevel + 1,\n                    'aria-setsize'  : record.parent.children.length,\n                    'aria-posinset' : record.parentIndex + 1\n                });\n                if (record.isExpanded(store)) {\n                    DomHelper.setAttributes(el, {\n                        'aria-expanded' : true,\n                        // A branch node may be configured expanded, but yet have no children.\n                        // They may be added dynamically.\n                        'aria-owns'     : record.children?.length ? record.children?.map(r => `${grid.id}-${region}-${r.id}`).join(' ') : null\n                    });\n                }\n                else {\n                    if (record.isLeaf) {\n                        el.removeAttribute('aria-expanded');\n                    }\n                    else {\n                        el.setAttribute('aria-expanded', false);\n                    }\n                    el.removeAttribute('aria-owns');\n                }\n            }\n        }\n        cellContext._record   = record;\n        cellContext._id       = record.id;\n        cellContext._rowIndex = recordIndex;\n        for (i = 0; i < grid.columns.visibleColumns.length; i++) {\n            const column = grid.columns.visibleColumns[i];\n            cellContext._columnId          = column.id;\n            cellContext._column            = column;\n            cellContext._columnIndex       = i;\n            cellContext._cell              = me.getCell(column.id, true);\n            cellContext.height             = height;\n            cellContext.maxRequestedHeight = maxRequestedHeight;\n            cellContext.updatingSingleRow  = updatingSingleRow;\n            size = me.renderCell(cellContext);\n            if (!rowManager.fixedRowHeight) {\n                // We want to make row in all regions as tall as the tallest cell\n                if (size.height != null) {\n                    maxRequestedHeight = Math.max(maxRequestedHeight, size.height);\n                    // Do not store a max height set by schedulers rendering, it has to base its layouts on the\n                    // original row height / that returned by other cells\n                    if (!size.transient) {\n                        me.maxRequestedHeight = maxRequestedHeight;\n                    }\n                }\n            }\n        }\n        const useHeight = maxRequestedHeight ?? height;\n        me.height = grid.processRowHeight(record, useHeight) ?? useHeight;\n        // Height gets set during render, reflect on elements\n        me.updateElementsHeight(isExport);\n        // Rerendering a row might change its height, which forces translation of all following rows\n        if (updatingSingleRow && !isExport) {\n            if (oldHeight !== me.height) {\n                rowManager.translateFromRow(me, batch);\n            }\n            rowManager.trigger('updateRow', { row : me, record, recordIndex, oldId });\n            rowManager.trigger('renderDone');\n        }\n        grid.afterRenderRow({ row : me, record, recordIndex, oldId, oldHeight, isExport });\n        rowManager.trigger('renderRow', { row : me, record, recordIndex, oldId, isExport });\n        if (oldHeight && me.height !== oldHeight) {\n            rowManager.trigger('rowRowHeight',  { row : me, record, height : me.height, oldHeight });\n        }\n        me.forceInnerHTML = false;\n    }\n    /**\n     * Renders a single cell, calling features to allow them to hook\n     * @param {Grid.util.Location|HTMLElement} cellContext A {@link Grid.util.Location} which contains rendering\n     * options, or a cell element which can be used to initialize a {@link Grid.util.Location}\n     * @param {Number} [cellContext.height] Configured row height\n     * @param {Number} [cellContext.maxRequestedHeight] Maximum proposed row height from renderers\n     * @param {Boolean} [cellContext.updatingSingleRow] Rendered as part of updating a single row\n     * @param {Boolean} [cellContext.isMeasuring] Rendered as part of a measuring operation\n     * @internal\n     */\n    renderCell(cellContext) {\n        if (!cellContext.isLocation) {\n            cellContext = new Location(cellContext);\n        }\n        let {\n            cell : cellElement,\n            record\n        } = cellContext;\n        const\n            me              = this,\n            {\n                grid,\n                column,\n                height,\n                maxRequestedHeight,\n                updatingSingleRow = true,\n                isMeasuring = false\n            }               = cellContext,\n            cellEdit        = grid.features?.cellEdit,\n            cellElementData = DomDataStore.get(cellElement),\n            rowElement      = cellElementData.rowElement,\n            rowElementData  = DomDataStore.get(rowElement);\n        if (!record) {\n            record = cellContext._record = grid.store.getById(rowElementData.id);\n            if (!record) {\n                return;\n            }\n        }\n        let cellContent  = column.getRawValue(record);\n        const\n            dataField    = record.fieldMap[column.field],\n            size         = { configuredHeight : height, height : null, maxRequestedHeight },\n            cellCls      = column.getCellClass(cellContext),\n            rendererData = {\n                cellElement,\n                dataField,\n                rowElement,\n                value : cellContent,\n                record,\n                column,\n                size,\n                grid,\n                row   : cellElementData.row,\n                updatingSingleRow,\n                isMeasuring\n            },\n            useRenderer  = column.renderer || column.defaultRenderer;\n        // Hook to allow processing cell before render, used by QuickFind & MergeCells\n        grid.beforeRenderCell(rendererData);\n        // Allow hook to redirect cell output\n        if (rendererData.cellElement !== cellElement) {\n            // Render to redirected target\n            cellElement = rendererData.cellElement;\n        }\n        DomHelper.syncClassList(cellElement, cellCls);\n        let shouldSetContent = true;\n        // By default, `cellContent` is raw value extracted from Record based on Column field.\n        // Call `renderer` if present, otherwise set innerHTML directly.\n        if (useRenderer) {\n            // `cellContent` could be anything here:\n            // - null\n            // - undefined when nothing is returned, used when column modifies cell content, for example Widget column\n            // - number as cell value, to be converted to string\n            // - string as cell value\n            // - string which contains custom DOM element which is handled by Angular after we render it as cell value\n            // - object with special $$typeof property equals to Symbol(react.element) handled by React when JSX is returned\n            // - object which has no special properties but understood by Vue because the column is marked as \"Vue\" column\n            // - object that should be passed to the `DomSync.sync` to update the cell content\n            cellContent = column.callback(useRenderer, column, [rendererData]);\n            if (cellContent === undefined) {\n                if (record.generatedParent && column.rendererReturningContent) {\n                    cellContent = '';\n                }\n                else if (column.alwaysClearCell === false) {\n                    shouldSetContent = false;\n                }\n            }\n        }\n        else if (dataField) {\n            cellContent = dataField.print(cellContent);\n        }\n        // Check if the cell content is going to be rendered by framework\n        const hasFrameworkRenderer = grid.hasFrameworkRenderer?.({ cellContent, column });\n        // This is exceptional case, using framework rendering while grouping is not supported.\n        // Need to reset the content in case of JSX is returned from the renderer.\n        // Normally, if a renderer returns some content, the Grouping feature will overwrite it with the grouped value.\n        // But useRenderer cannot be ignored completely, since a column might want to render additional content to the\n        // grouped row. For example, Action Column may render an action button the grouped row.\n        if (hasFrameworkRenderer && record.isSpecialRow) {\n            cellContent = '';\n        }\n        // If present, framework may decide if it wants our renderer to prerender the cell content or not.\n        // In case of normal cells in flat grids, React and Vue perform the full rendering into the root cell element.\n        // But in case of tree cell in tree grids, React and Vue require our renderer to prerender internals,\n        // and they perform rendering into inner \"b-tree-cell-value\" element. This way we can see our expand controls,\n        // bullets, etc.\n        const frameworkPerformsFullRendering = hasFrameworkRenderer && !column.data.tree && !record.isSpecialRow;\n        // `shouldSetContent` false means content is already set by the column (i.e. Widget column).\n        // `frameworkPerformsFullRendering` true means full cell content is set by framework renderer.\n        if (shouldSetContent && !frameworkPerformsFullRendering) {\n            let renderTarget = cellElement;\n            // If the cell is being edited, we render to a separate div and carefully\n            // insert the contents into a Range which excludes the editor.\n            if (cellEdit?.editorContext?.equals(cellContext) && !cellEdit.editor.isFinishing) {\n                renderTarget = me.moveContentFromCell(cellElement, cellEdit.editor.element);\n            }\n            const\n                hasObjectContent = cellContent != null && typeof cellContent === 'object',\n                hasStringContent = typeof cellContent === 'string',\n                text             = (hasObjectContent || cellContent == null) ? '' : String(cellContent);\n            // row might be flagged by GroupSummary to require full \"redraw\"\n            if (me.forceInnerHTML) {\n                // To allow minimal updates below, we must remove custom markup inserted by the GroupSummary feature\n                renderTarget.innerHTML = '';\n                // Delete cached content value\n                delete renderTarget._content;\n                cellElement.lastDomConfig = null;\n            }\n            // display cell contents as text or use actual html?\n            // (disableHtmlEncode set by features that decorate cell contents)\n            if (!hasObjectContent && column.htmlEncode && !column.disableHtmlEncode) {\n                // Set innerText if cell currently has html content.\n                if (cellElement._hasHtml) {\n                    renderTarget.innerText = text;\n                    cellElement._hasHtml = false;\n                }\n                else {\n                    DomHelper.setInnerText(renderTarget, text);\n                }\n            }\n            else {\n                if (column.autoSyncHtml && (!hasStringContent || DomHelper.getChildElementCount(renderTarget))) {\n                    // String content in html column is handled as a html template string\n                    if (hasStringContent) {\n                        // update cell with only changed attributes etc.\n                        DomHelper.sync(text, renderTarget.firstElementChild);\n                    }\n                    // Other content is considered to be a DomHelper config object\n                    else if (hasObjectContent) {\n                        DomSync.sync({\n                            domConfig     : cellContent,\n                            targetElement : renderTarget\n                        });\n                    }\n                }\n                // Consider all returned plain objects to be DomHelper configs for cell content\n                else if (hasObjectContent) {\n                    DomSync.sync({\n                        targetElement : renderTarget,\n                        domConfig     : {\n                            onlyChildren : true,\n                            children     : ArrayHelper.asArray(cellContent)\n                        }\n                    });\n                }\n                // Apply text as innerHTML only if it has changed\n                else if (renderTarget._content !== text) {\n                    renderTarget.innerHTML = renderTarget._content = text;\n                }\n            }\n            // If we had to render to a separate div to avoid the cell editor, insert the result now.\n            if (renderTarget !== cellElement) {\n                const { firstChild } = cellElement;\n                for (const node of renderTarget.childNodes) {\n                    cellElement.insertBefore(node, firstChild);\n                }\n            }\n        }\n        // If present, framework renders content into the cell element.\n        // Ignore special rows, like grouping.\n        if (!record.isSpecialRow) {\n            // processCellContent is implemented in the framework wrappers\n            grid.processCellContent?.({\n                cellElementData,\n                rendererData,\n                // In case of TreeColumn we should prerender inner cell content like expand controls, bullets, etc\n                // Then the framework renders the content into the nested \"b-tree-cell-value\" element.\n                // rendererHtml is set in TreeColumn.treeRenderer\n                rendererHtml : rendererData.rendererHtml || cellContent\n            });\n        }\n        if (column.autoHeight && size.height == null) {\n            cellElement.classList.add('b-measuring-auto-height');\n            // Shrinkwrap autoHeight must not allow a row's height to drop below the configured row height\n            size.height = Math.max(cellElement.offsetHeight, grid.rowHeight);\n            cellElement.classList.remove('b-measuring-auto-height');\n        }\n        if (!isMeasuring) {\n            // Allow others to affect rendering\n            me.rowManager.trigger('renderCell', rendererData);\n        }\n        return size;\n    }\n    //#region Hooks for salesforce\n    moveContentFromCell(cellElement, editorElement) {\n        cellContentRange.setStart(cellElement, 0);\n        cellContentRange.setEndBefore(editorElement);\n        const renderTarget = document.createElement('div');\n        renderTarget.appendChild(cellContentRange.extractContents());\n        return renderTarget;\n    }\n    //#endregion\n//endregion\n}\nRow.initClass();\nRow._$name = 'Row';", "import Widget from '../../Core/widget/Widget.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\n/**\n * @module Grid/view/Bar\n */\n/**\n * Base class used by Header and Footer. Holds an element for each column. Not intended to be used directly.\n *\n * @extends Core/widget/Widget\n * @internal\n * @abstract\n */\nexport default class Bar extends Widget {\n    static get $name() {\n        return 'Bar';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'gridbar';\n    }\n    static get defaultConfig() {\n        return {\n            htmlCls : '',\n            scrollable : {\n                overflowX : 'hidden-scroll'\n            }\n        };\n    }\n    //region Init\n    get columns() {\n        return this._columns || this.subGrid.columns;\n    }\n    // Only needed for tests which create standalone Headers with no owning SubGrid.\n    set columns(columns) {\n        this._columns = columns;\n    }\n    //endregion\n    /**\n     * Fix cell widths (flex or fixed width) after rendering.\n     * Not a part of template any longer because of CSP\n     * @private\n     */\n    fixCellWidths() {\n        const\n            me          = this,\n            { hasFlex } = me.columns;\n        let flexBasis;\n        // single header \"cell\"\n        me.columns.traverse(column => {\n            const\n                cellEl      = me.getBarCellElement(column.id),\n                domWidth    = DomHelper.setLength(column.width),\n                domMinWidth = DomHelper.setLength(column.minWidth),\n                domMaxWidth = DomHelper.setLength(column.maxWidth);\n            if (cellEl) {\n                flexBasis = domWidth;\n                cellEl.style.maxWidth = domMaxWidth;\n                // Parent column without any specified width and flex should have flex calculated if any child has flex\n                if (column.isParent && column.width == null && column.flex == null) {\n                    const flex = column.children.reduce((result, child) => (result += !child.hidden && child.flex || 0), 0);\n                    // Do not want to store this flex value on the column since it is always calculated\n                    cellEl.style.flex = flex > 0 ? `${flex} 0 auto` : '';\n                    // minWidth might leak from other column when reordering, reset it\n                    cellEl.style.minWidth = null;\n                    if (flex > 0) {\n                        column.traverse(col => col.data.minWidth = null);\n                    }\n                }\n                // Normal case, set flex, width etc.\n                else {\n                    if (parseInt(column.minWidth) >= 0) {\n                        cellEl.style.minWidth = domMinWidth;\n                    }\n                    // Clear all the things we might have to set to correct cell widths\n                    cellEl.style.flex = cellEl.style.flexBasis = cellEl.style.width = '';\n                    if (column.flex) {\n                        // If column has children we need to give it\n                        // flex-shrink: 0, flex-basis: auto so that it always\n                        // shrinkwraps its children without shrinking\n                        if (!isNaN(parseInt(column.flex)) && column.children) {\n                            cellEl.style.flex = `${column.flex} 0 auto`;\n                        }\n                        else {\n                            cellEl.style.flex = column.flex;\n                        }\n                    }\n                    else if (parseInt(column.width) >= 0) {\n                        const parent = column.parent;\n                        // Only grid header bar has a notion of group headers\n                        // Column is a child of an unwidthed group. We have to use width\n                        // to stretch it.\n                        if (me.isHeader && !parent.isRoot && !parent.width) {\n                            cellEl.style.width = domWidth;\n                        }\n                        else {\n                            // https://app.assembla.com/spaces/bryntum/tickets/8041\n                            // Column header widths must be set using flex-basis.\n                            // Using width means that wide widths cause a flexed SubGrid\n                            // to bust the flex rules.\n                            // Note that grid in Grid#onColumnsResized and SubGrid#fixCellWidths,\n                            // cells MUST still be sized using width since rows\n                            // are absolutely positioned and will not cause the busting out\n                            // problem, and rows will not stretch to shrinkwrap the cells\n                            // unless they are widthed with width.\n                            cellEl.style.flexBasis = flexBasis;\n                        }\n                    }\n                }\n                if (column.height >= 0) {\n                    cellEl.style.height = DomHelper.setLength(column.height);\n                }\n            }\n        });\n        me.scrollable.element.classList.toggle('b-has-flex', hasFlex);\n    }\n    getLrPadding(cellEl) {\n        if (!this.cellLrPadding) {\n            const s = cellEl.ownerDocument.defaultView.getComputedStyle(cellEl);\n            this.cellLrPadding = parseInt(s.getPropertyValue('padding-left')) + parseInt(s.getPropertyValue('padding-right')) +\n                parseInt(s.getPropertyValue('border-left-width')) + parseInt(s.getPropertyValue('border-right-width'));\n        }\n        return this.cellLrPadding;\n    }\n    /**\n     * Get the header or footer cell element for the specified column.\n     * @param {String} columnId Column id\n     * @returns {HTMLElement} Header or footer element, depending on which subclass is in use.\n     * @private\n     */\n    getBarCellElement(columnId) {\n        return this.element.querySelector(`[data-column-id=\"${columnId}\"]`);\n    }\n}\n// Register this widget type with its Factory\nBar.initClass();\nBar._$name = 'Bar';", "import TemplateHelper from '../../Core/helper/TemplateHelper.js';\nimport Bar from './Bar.js';\n//import styles from '../../../resources/sass/grid/view/footer.scss';\n/**\n * @module Grid/view/Footer\n */\n/**\n * Grid footer, used by Summary feature. You should not need to create instances manually.\n *\n * @extends Grid/view/Bar\n * @internal\n */\nexport default class Footer extends Bar {\n    static get $name() {\n        return 'Footer';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'gridfooter';\n    }\n    get subGrid() {\n        return this._subGrid;\n    }\n    set subGrid(subGrid) {\n        this._subGrid = this.owner = subGrid;\n    }\n    refreshContent() {\n        this.element.firstElementChild.innerHTML = this.contentTemplate();\n        this.fixFooterWidths();\n    }\n    onInternalPaint({ firstPaint }) {\n        if (firstPaint) {\n            this.refreshContent();\n        }\n    }\n    template() {\n        const region = this.subGrid.region;\n        return TemplateHelper.tpl`\n            <div class=\"b-grid-footer-scroller b-grid-footer-scroller-${region}\" role=\"presentation\">\n                <div data-reference=\"footersElement\" class=\"b-grid-footers b-grid-footers-${region}\" data-region=\"${region}\" role=\"presentation\"></div>\n            </div>\n        `;\n    }\n    get overflowElement() {\n        return this.footersElement;\n    }\n    //region Getters\n    /**\n     * Get the footer cell element for the specified column.\n     * @param {String} columnId Column id\n     * @returns {HTMLElement} Footer cell element\n     */\n    getFooter(columnId) {\n        return this.getBarCellElement(columnId);\n    }\n    //endregion\n    /**\n     * Footer template. Iterates leaf columns to create content.\n     * Style not included because of CSP. Widths are fixed up in\n     * {@link #function-fixFooterWidths}\n     * @private\n     */\n    contentTemplate() {\n        const me = this;\n        return me.columns.visibleColumns.map(column => {\n            return TemplateHelper.tpl`\n                <div\n                    class=\"b-grid-footer ${column.align ? `b-grid-footer-align-${column.align}` : ''} ${column.cls || ''}\"\n                    data-column=\"${column.field || ''}\" data-column-id=\"${column.id}\" data-all-index=\"${column.allIndex}\"\n                    role=\"presentation\">\n                    ${column.footerText || ''}\n                </div>`;\n        }).join('');\n    }\n    /**\n     * Fix footer widths (flex or fixed width) after rendering. Not a part of template any longer because of CSP\n     * @private\n     */\n    fixFooterWidths() {\n        this.fixCellWidths();\n    }\n}\n// Register this widget type with its Factory\nFooter.initClass();\nFooter._$name = 'Footer';", "import Rectangle from '../../Core/helper/util/Rectangle.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport Row from './Row.js';\nimport ArrayHelper from '../../Core/helper/ArrayHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\nimport Location from '../util/Location.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\n/**\n * @module Grid/row/RowManager\n */\nconst cloneRowEl = el => {\n    const\n        p      = el.parentElement,\n        result = el.cloneNode(true);\n    result.classList.add('b-removing');\n    p.insertBefore(result, el);\n    return result;\n};\n/**\n * Virtual representation of the grid, using {@link Grid.row.Row} to represent rows. Plugs into {@link Grid.view.Grid}\n * and exposes the following functions on grid itself:\n * * {@link #function-getRecordCoords()}\n * * {@link #function-getRowById()}\n * * {@link #function-getRow()}\n * * {@link #function-getRowFor()}\n * * {@link #function-getRowFromElement()}\n *\n * ```javascript\n * let row = grid.getRowById(1);\n * ```\n *\n * @plugin\n * @private\n */\nexport default class RowManager extends InstancePlugin {\n    //region Config\n    // Plugin configuration.\n    static get pluginConfig() {\n        return {\n            chain : [\n                'destroy'\n            ],\n            assign : [\n                'topRow', 'bottomRow', 'firstVisibleRow', 'lastVisibleRow', 'firstFullyVisibleRow', 'lastFullyVisibleRow',\n                'getRowById', 'getRecordCoords', 'getRow', 'getRowFor', 'getRowFromElement'\n            ]\n        };\n    }\n    static get defaultConfig() {\n        return {\n            rowClass : Row,\n            /**\n             * Number of rows to render above current viewport\n             * @config {Number}\n             * @default\n             */\n            prependRowBuffer : 5,\n            /**\n             * Number of rows to render below current viewport\n             * @config {Number}\n             * @default\n             */\n            appendRowBuffer : 5,\n            /**\n             * Default row height, assigned from Grid at construction (either from config\n             * {@link Grid.view.Grid#config-rowHeight} or CSS). Can be set from renderers\n             * @config {Number}\n             * @default\n             */\n            rowHeight : null,\n            /**\n             * Set to `true` to get a small performance boost in applications that uses fixed row height\n             * @config {Boolean}\n             */\n            fixedRowHeight : null,\n            autoHeight : false\n        };\n    }\n    static get properties() {\n        return {\n            idMap                : {},\n            topIndex             : 0,\n            lastScrollTop        : 0,\n            _rows                : [],\n            // Record id -> row height mapping\n            heightMap            : new Map(),\n            // Sum of entries in heightMap\n            totalKnownHeight     : 0,\n            // Will be calculated in `estimateTotalHeight()`, as totalKnownHeight + an estimate for unknown rows\n            _totalHeight         : 0,\n            // Average of the known heights, kept up to date when entries in the heightMap are updated\n            averageRowHeight     : 0,\n            scrollTargetRecordId : null,\n            refreshDetails       : {\n                topRowIndex : 0,\n                topRowTop   : 0\n            }\n        };\n    }\n    //endregion\n    //region Init\n    construct(config) {\n        config.grid._rowManager = this;\n        super.construct(config.grid, config);\n    }\n    // Chained to grids doDestroy\n    doDestroy() {\n        // To remove timeouts\n        this._rows.forEach(row => row.destroy());\n        super.doDestroy();\n    }\n    /**\n     * Initializes the RowManager with Rows to fit specified height.\n     * @param {Number} height\n     * @param {Boolean} [isRendering]\n     * @private\n     * @category Init\n     */\n    initWithHeight(height, isRendering = false) {\n        const me = this;\n        // no valid height, make room for all rows\n        if (me.autoHeight) {\n            height = me.store.allCount * me.preciseRowOffsetHeight;\n        }\n        me.viewHeight = height;\n        me.calculateRowCount(isRendering);\n        return height;\n    }\n    /**\n     * Releases all elements (not from dom), calculates how many are needed, creates those and renders\n     */\n    reinitialize(returnToTop = false) {\n        const me = this;\n        // Calculate and correct the amount of rows needed (without triggering render)\n        // Rows which are found to be surplus are destroyed.\n        me.calculateRowCount(false, true, true);\n        // If our row range is outside the store's range, force a return to top\n        if (me.topIndex + me.rowCount - 1 > me.store.count) {\n            returnToTop = true;\n        }\n        if (returnToTop) {\n            me.topIndex = me.lastScrollTop = 0;\n        }\n        me.scrollTargetRecordId = null;\n        const { topRow } = me;\n        if (topRow) {\n            // Ensure rendering from the topRow starts at the correct position\n            topRow.dataIndex = me.topIndex;\n            topRow.setTop(me.calculateTop(me.topIndex), true);\n        }\n        // Need to estimate height in case we have Grid using autoHeight\n        me.estimateTotalHeight();\n        me.renderFromRow(topRow);\n    }\n    //endregion\n    //region Rows\n    /**\n     * Add or remove rows to fit row count\n     * @private\n     * @category Rows\n     */\n    matchRowCount(skipRender = false) {\n        const\n            me             = this,\n            { rows, grid, rowClass } = me,\n            numRows        = rows.length,\n            delta          = numRows - me.rowCount;\n        if (delta) {\n            if (delta < 0) {\n                const newRows = [];\n                // add rows\n                for (let index = numRows, dataIndex = numRows ? rows[numRows - 1].dataIndex + 1 : 0; index < me.rowCount; index++, dataIndex++) {\n                    newRows.push(rowClass.new({\n                        cls        : grid.rowCls,\n                        rowManager : me,\n                        grid,\n                        index,\n                        dataIndex\n                    }));\n                }\n                rows.push.apply(rows, newRows);\n                // and elements (by triggering event used by SubGrid to add elements)\n                me.trigger('addRows', { rows : newRows });\n                if (!skipRender) {\n                    // render\n                    me.renderFromRow(rows[Math.max(0, numRows - 1)]);\n                }\n            }\n            else {\n                // remove rows from bottom\n                const\n                    { focusedCell } = grid,\n                    rowActive       = focusedCell?.id != null && focusedCell?.cell?.contains(DomHelper.getActiveElement(grid)),\n                    removedRows     = rows.splice(numRows - delta, delta);\n                if (rowActive) {\n                    // All rows going: move focus up to header to avoid unwanted focusout events.\n                    if (delta === numRows) {\n                        grid.onFocusedRowDerender();\n                    }\n                    // Focus is in the zone that's being removed: move to new last row\n                    else if (me.getRowFor(focusedCell._record)?.index >= rows.length) {\n                        rows[rows.length - 1].cells[focusedCell.columnIndex].focus();\n                    }\n                }\n                // trigger event in case some feature needs to cleanup when removing (widget column might be interested)\n                me.trigger('removeRows', { rows : removedRows });\n                removedRows.forEach(row => row.destroy());\n                // no need to rerender or such when removing from bottom. all is good :)\n            }\n        }\n    }\n    /**\n     * Calculates how many rows fit in the available height (view height)\n     * @private\n     * @category Rows\n     */\n    calculateRowCount(skipMatchRowCount = false, allowRowCountShrink = true, skipRender = false) {\n        const\n            me                = this,\n            { store }         = me,\n            visibleRowCount   = Math.ceil(me.viewHeight / me.minRowOffsetHeight), // Want whole rows\n            maxRenderRowCount = visibleRowCount + me.prependRowBuffer + me.appendRowBuffer;\n        // If RowManager is reinitialized in a hidden state the view might not have a height\n        if (!me.grid.columns?.count || isNaN(visibleRowCount)) {\n            me.rowCount = 0;\n            return 0;\n        }\n        // when for example jumping we do not want to remove excess rows,\n        // since we know they are needed at other scroll locations\n        if (maxRenderRowCount < me.rowCount && !allowRowCountShrink) {\n            return me.rowCount;\n        }\n        me.visibleRowCount = visibleRowCount;\n        me.rowCount = Math.min(store.count, maxRenderRowCount); // No need for more rows than data\n        // If the row count doesn't match the calculated, ensure it matches,\n        if (!skipMatchRowCount) {\n            if (me.rows && me.rowCount !== me.rows.length) {\n                me.matchRowCount(skipRender);\n                // Rows might be pointing to data indices no longer available (when resetting to top topRow is already\n                // adjusted, we don't need to take action here)\n                if (me.bottomRow?.dataIndex >= store.count && me.topRow.dataIndex !== 0) {\n                    const indexDelta = me.bottomRow.dataIndex - store.count + 1;\n                    for (const row of me.rows) {\n                        row.dataIndex -= indexDelta;\n                    }\n                    me.topIndex -= indexDelta;\n                }\n            }\n            else if (!me.rowCount) {\n                me.trigger('changeTotalHeight', { totalHeight : me.totalHeight });\n            }\n            me.grid.toggleEmptyText();\n        }\n        return me.rowCount;\n    }\n    /**\n     * Animate adding or removing rows to/from the rows array.\n     * @internal\n     * @param {Number} index The index at which to insert or remove\n     * @param {Number} count The number of rows to add. May be negative to remove.\n     */\n    insert(index, count) {\n        const\n            me               = this,\n            {\n                rows,\n                rowCount,\n                rowClass,\n                grid,\n                rowHeight\n            }                = me,\n            {\n                rowCls\n            }                = grid,\n            newRowDataIndex  = rows[index - 1]?.dataIndex + 1 || 0,\n            removingLast     = index >= grid.store.count,\n            addedRows        = [],\n            durationMS       = DateHelper.as('ms', DomHelper.getStyleValue(grid.element, '--row-splice-duration')),\n            visibleRowsBelow = me.lastVisibleRow.index + 1 - index;\n        // Removing a block of rows\n        if (count < 0) {\n            count = Math.abs(count);\n            const\n                visualRemoveCount     = Math.min(count, visibleRowsBelow),\n                visuallyRemovedRows   = rows.slice(index, index + visualRemoveCount),\n                visuallyRemovedHeight = visualRemoveCount ? visuallyRemovedRows[visuallyRemovedRows.length - 1].bottom - visuallyRemovedRows[0].top : 0,\n                ougoingElements       = [];\n            // Leave clones of the outgoing rows in place so that the repurposed rows\n            // will move up into that space without it looking blank\n            for (let i = 0, { length } = visuallyRemovedRows; i < length; i++) {\n                ougoingElements.push(...visuallyRemovedRows[i]._elementsArray.map(cloneRowEl));\n            }\n            // Don't destroy the clones until the refresh is done\n            grid.setTimeout(() => {\n                ougoingElements.forEach(e => e.remove());\n            }, durationMS);\n            // We are actually changing the physical row count\n            if (removingLast) {\n                return me.calculateRowCount(false, true, true);\n            }\n            else {\n                // Adjust positions of rows after the remove block so that when refreshed\n                // they appear to move up from after the remove block\n                for (let i = index; i < rowCount; i++) {\n                    rows[i].setTop(rows[i].top + visuallyRemovedHeight);\n                }\n            }\n            // Ensure the translations done above have been flushed to the layout so that animations\n            // into place can now happen.\n            ougoingElements[0]?.getBoundingClientRect();\n            // Makes the row top positioning animate\n            DomHelper.addTemporaryClass(grid.element, 'b-splicing-rows', durationMS, grid);\n        }\n        // Adding a block of rows\n        else if (count > 0) {\n            count = me.grid.hasVerticalOverflow ? Math.min(count, me.lastVisibleRow.index + 1 - index) : count;\n            let newIndex  = index,\n                dataIndex = newRowDataIndex;\n            for (let i = 0; i < count; i++, newIndex++, dataIndex++) {\n                addedRows.push(rowClass.new({\n                    cls        : `${rowCls} b-adding`,\n                    rowManager : me,\n                    grid,\n                    index      : newIndex,\n                    dataIndex\n                }));\n            }\n            // Shift the rows which will become the rows following the new block down\n            for (let i = index; i < me.rowCount; i++, newIndex++, dataIndex++) {\n                rows[i].index = newIndex;\n                rows[i].dataIndex = dataIndex;\n            }\n            grid.setTimeout(() => {\n                addedRows.forEach(r => !r.isDestroyed && r.removeCls('b-adding'));\n            }, durationMS);\n            // Insert the new block.\n            rows.splice(index, 0, ...addedRows);\n            me.rowCount += count;\n            // Add elements (by triggering event used by SubGrid to add elements)\n            if (count) {\n                me.trigger('addRows', { rows : addedRows });\n            }\n            // Start with new rows poised one row above their final position.\n            // As they both fade into view and animate downwards simultaneously, this is the\n            // most visually pleasing effect we can get with infinite scroll/positioned rows.\n            for (let i = 0, top = (rows[index - 1]?.bottom || 0) - rowHeight; i < count; i++, top += rowHeight) {\n                addedRows[i].setTop(top);\n            }\n            // Makes the row top positioning animate\n            DomHelper.addTemporaryClass(grid.element, 'b-splicing-rows', durationMS, grid);\n        }\n        me.renderFromRow(rows[index]);\n        return addedRows;\n    }\n    removeAllRows() {\n        // remove rows from bottom\n        const\n            me         = this,\n            { topRow } = me,\n            result     = topRow ? (me.refreshDetails = {\n                topRowIndex : topRow.dataIndex,\n                topRowTop   : topRow.top\n            }) : me.refreshDetails,\n            removedRows = me.rows.slice();\n        // trigger event in case some feature needs to cleanup when removing (widget column might be interested)\n        me.trigger('removeRows', { rows : removedRows });\n        me.rows.forEach(row => row.destroy());\n        me.rows.length = 0;\n        me.idMap = {};\n        // We return a descriptor of the last rendered block before the remove.\n        // This is primarily for a full GridBase#renderContents to be able to perform a correct refresh.\n        return result;\n    }\n    setPosition(refreshDetails) {\n        // Sets up the rendering position for the next call to reinitialize\n        const\n            { topRow }                 = this,\n            { topRowIndex, topRowTop } = refreshDetails;\n        // Top row might be missing if trial has expired\n        if (topRow) {\n            topRow.setTop(topRowTop);\n            topRow.dataIndex = topRowIndex;\n        }\n    }\n    //endregion\n    //region Rows - Getters\n    get store() {\n        return this.client.store;\n    }\n    /**\n     * Get all Rows\n     * @property {Grid.row.Row[]}\n     * @readonly\n     * @category Rows\n     */\n    get rows() {\n        return this._rows;\n    }\n    /**\n     * Get the Row at a specified store index. Returns `undefined` if the row index is not rendered.\n     * @param {Number} index\n     * @returns {Grid.row.Row|undefined}\n     * @category Rows\n     */\n    getRow(index) {\n        if (this.rowCount) {\n            return this.rows[index - this.topIndex];\n        }\n    }\n    /**\n     * Get Row for specified record id\n     * @param {Core.data.Model|String|Number} recordOrId Record id (or a record)\n     * @returns {Grid.row.Row|null} Found Row or null if record not rendered\n     * @category Rows\n     */\n    getRowById(recordOrId) {\n        if (recordOrId && recordOrId.isModel) {\n            recordOrId = recordOrId.id;\n        }\n        return this.idMap[recordOrId];\n    }\n    /**\n     * Get a Row from an HTMLElement\n     * @param {HTMLElement} element\n     * @returns {Grid.row.Row|null} Found Row or null if record not rendered\n     * @category Rows\n     */\n    getRowFromElement(element) {\n        element = element.closest('.b-grid-row');\n        return element && this.getRow(element.dataset.index);\n    }\n    /**\n     * Get the row at the specified Y coordinate, which is by default viewport-based.\n     * @param {Number} y The `Y` coordinate to find the Row for.\n     * @param {Boolean} [local=false] Pass `true` if the `Y` coordinate is local to the SubGrid's element.\n     * @returns {Grid.row.Row} Found Row or null if no row is rendered at that point.\n     */\n    getRowAt(y, local = false) {\n        // Make it local.\n        if (!local) {\n            // Because this is used with event Y positions which are integers, we must\n            // round the Rectangle to the closest integer.\n            y -= Rectangle.from(this.grid.bodyContainer, null, true).roundPx(1).top;\n            // Adjust for scrolling\n            y += this.grid.scrollable.y;\n        }\n        y = DomHelper.roundPx(y);\n        return this.rows.find(r => y >= r.top && y < r.bottom);\n    }\n    /**\n     * Get a Row for either a record, a record id or an HTMLElement\n     * @param {HTMLElement|Core.data.Model|String|Number} recordOrId Record or record id or HTMLElement\n     * @returns {Grid.row.Row} Found Row or null if record not rendered\n     * @category Rows\n     */\n    getRowFor(recordOrId) {\n        if (recordOrId instanceof HTMLElement) {\n            return this.getRowFromElement(recordOrId);\n        }\n        return this.getRowById(recordOrId);\n    }\n    /**\n     * Gets the Row following the specified Row (by index or object). Wraps around the end.\n     * @param {Number|Grid.row.Row} indexOrRow index or Row\n     * @returns {Grid.row.Row}\n     * @category Rows\n     */\n    getNextRow(indexOrRow) {\n        const index = typeof indexOrRow === 'number' ? indexOrRow : indexOrRow.index;\n        return this.getRow((index + 1) % this.rowCount);\n    }\n    /**\n     * Get the Row that is currently displayed at top.\n     * @property {Grid.row.Row}\n     * @readonly\n     * @category Rows\n     */\n    get topRow() {\n        return this.rows[0];\n    }\n    /**\n     * Get the Row currently displayed furthest down.\n     * @property {Grid.row.Row}\n     * @readonly\n     * @category Rows\n     */\n    get bottomRow() {\n        const rowCount = Math.min(this.rowCount, this.store.count);\n        return this.rows[rowCount - 1];\n    }\n    /**\n     * Get the topmost visible Row\n     * @property {Grid.row.Row}\n     * @readonly\n     * @category Rows\n     */\n    get firstVisibleRow() {\n        // Ceil scroll position to make behavior consistent on a scaled display\n        return this.rows.find(r => r.bottom > Math.ceil(this.grid.scrollable.y));\n    }\n    get firstFullyVisibleRow() {\n        // Ceil scroll position to make behavior consistent on a scaled display\n        return this.rows.find(r => r.top >= Math.ceil(this.grid.scrollable.y));\n    }\n    /**\n     * Get the last visible Row\n     * @property {Grid.row.Row}\n     * @readonly\n     * @category Rows\n     */\n    get lastVisibleRow() {\n        const { grid } = this;\n        // We need the last row who's top is inside the scrolling viewport\n        return ArrayHelper.findLast(this.rows, r => r.top < grid.scrollable.y + grid.bodyHeight);\n    }\n    get lastFullyVisibleRow() {\n        const { grid } = this;\n        // We need the last row who's bottom is inside the scrolling viewport\n        return ArrayHelper.findLast(this.rows, r => r.bottom < grid.scrollable.y + grid.bodyHeight);\n    }\n    /**\n     * Calls offset() for each Row passing along offset parameter\n     * @param {Number} offset Pixels to translate Row elements.\n     * @private\n     * @category Rows\n     */\n    offsetRows(offset) {\n        if (offset !== 0) {\n            const\n                { rows }   = this,\n                { length } = rows;\n            for (let i = 0; i < length; i++) {\n                rows[i].offset(offset);\n            }\n        }\n        this.trigger('offsetRows', { offset });\n    }\n    //endregion\n    //region Row height\n    get prependBufferHeight() {\n        return this.prependRowBuffer * this.rowOffsetHeight;\n    }\n    get appendBufferHeight() {\n        return this.appendRowBuffer * this.rowOffsetHeight;\n    }\n    /**\n     * Set a fixed row height (can still be overridden by renderers) or get configured row height. Setting refreshes all rows\n     * @type {Number}\n     * @on-owner\n     * @category Rows\n     */\n    get rowHeight() {\n        return this._rowHeight;\n    }\n    set rowHeight(height) {\n        const\n            me                       = this,\n            { grid, fixedRowHeight } = me,\n            oldHeight                = me.rowHeight;\n        // Do not force redraw if row height has not actually changed. Covered by GridState.t\n        if (oldHeight === height) {\n            return;\n        }\n        ObjectHelper.assertNumber(height, 'rowHeight');\n        if (height < 10) {\n            height = 10;\n        }\n        me.trigger('beforeRowHeight', { height });\n        me.minRowHeight = me._rowHeight = height;\n        if (fixedRowHeight) {\n            me.averageRowHeight = height;\n        }\n        if (me.rows.length) {\n            const\n                oldY       = grid.scrollable.y,\n                topRow     = me.getRowAt(oldY, true),\n                // When changing rowHeight in a scrolled grid, there might no longer be a row at oldY\n                edgeOffset = topRow ? topRow.top - oldY : 0;\n            let average, oldAverage;\n            // When using fixedRowHeight there is no need to update an average\n            if (fixedRowHeight) {\n                average = height;\n                oldAverage = oldHeight;\n            }\n            else {\n                oldAverage = average = me.averageRowHeight;\n                me.clearKnownHeights();\n                // Scale the average height in proportion to the row height change\n                average *= height / oldHeight;\n            }\n            // Adjust number of rows, since it is only allowed to shrink in refresh()\n            me.calculateRowCount(false, true, true);\n            // Reposition the top row since it is used to position the rest\n            me.topRow.setTop(me.topRow.dataIndex * (average + grid._rowBorderHeight), true);\n            me.refresh();\n            const newY = oldY * (average / oldAverage);\n            // Scroll top row to the same position.\n            if (newY !== oldY) {\n                grid.scrollRowIntoView(topRow.id, {\n                    block : 'start',\n                    edgeOffset\n                });\n            }\n        }\n        // Note that `rowRowHeight` below is triggered in Row.js, but it needs to be documented here since it is\n        // triggered on the RowManager\n        /**\n         * Triggered when an individual rendered {@link Grid.row.Row} has its height changed.\n         * @event rowRowHeight\n         * @param {Grid.row.RowManager} source The firing RowManager instance.\n         * @param {Grid.row.Row} row The row which is changing.\n         * @param {Core.data.Model} record The row's record.\n         * @param {Number} height The row's new height.\n         * @param {Number} oldHeight The row's old height.\n         * @private\n         */\n        /**\n         * Triggered when the owning Grid's {@link Grid.view.Grid#property-rowHeight} is changed.\n         * @event rowHeight\n         * @param {Grid.row.RowManager} source The firing RowManager instance.\n         * @param {Number} height The RowManager's new default row height.\n         * @param {Number} oldHeight  The RowManager's old default row height.\n         * @private\n         */\n        me.trigger('rowHeight', { height, oldHeight });\n    }\n    /**\n     * Get actually used row height, which includes any border and might be an average if using variable row height.\n     * @property {Number}\n     */\n    get rowOffsetHeight() {\n        return Math.floor(this.preciseRowOffsetHeight);\n    }\n    get preciseRowOffsetHeight() {\n        return (this.averageRowHeight || this._rowHeight) + this.grid._rowBorderHeight;\n    }\n    get minRowOffsetHeight() {\n        return (this.minRowHeight || this._rowHeight) + this.grid._rowBorderHeight;\n    }\n    /*\n    * How store CRUD affects the height map:\n    *\n    * | Operation | Result                            |\n    * |-----------|-----------------------------------|\n    * | add       | No. Appears on render             |\n    * | insert    | No. Appears on render             |\n    * | remove    | Remove entry                      |\n    * | removeAll | Clear                             |\n    * | update    | No                                |\n    * | replace   | Height might differ, remove entry |\n    * | move      | No                                |\n    * | filter    | No                                |\n    * | sort      | No                                |\n    * | group     | No                                |\n    * | dataset   | Clear                             |\n    *\n    * The above is handled in GridBase\n    */\n    /**\n     * Returns `true` if all rows have a known height. They do if all rows are visited, or if RowManager is configured\n     * with `fixedRowHeight`. If so, all tops can be calculated exactly, no guessing needed\n     * @property {Boolean}\n     * @private\n     */\n    get allHeightsKnown() {\n        return this.fixedRowHeight || this.heightMap.size >= this.store.count;\n    }\n    /**\n     * Store supplied `height` using `id` as key in the height map. Called by `Row` when it gets its height.\n     * Keeps `averageRowHeight` and `totalKnownHeight` up to date. Ignored when configured with `fixedRowHeight`\n     * @param {String|Number} id\n     * @param {Number} height\n     * @internal\n     */\n    storeKnownHeight(id, height) {\n        const\n            me = this,\n            { heightMap } = me;\n        if (!me.fixedRowHeight) {\n            // Decrease know height with old value\n            if (heightMap.has(id)) {\n                me.totalKnownHeight -= heightMap.get(id);\n            }\n            // Height here is \"clientHeight\"\n            heightMap.set(id, height);\n            // And increase with new\n            me.totalKnownHeight += height;\n            if (height < me.minRowHeight) {\n                me.minRowHeight = height;\n            }\n            me.averageRowHeight = me.totalKnownHeight / heightMap.size;\n        }\n    }\n    /**\n     * Get the known or estimated offset height for the specified record id\n     * @param {Core.data.Model} record\n     * @returns {Number}\n     * @private\n     */\n    getOffsetHeight(record) {\n        const me = this;\n        // record may not be there if height gets from row with already removed from the store record\n        return ((record && me.heightMap.get(record.id)) || (record && me.grid.getRowHeight(record)) || me.averageRowHeight || me.rowHeight) + me.grid._rowBorderHeight;\n    }\n    /**\n     * Invalidate cached height for a record. Removing it from `totalKnownHeight` and factoring it out of\n     * `averageRowHeight`.\n     * @param {Core.data.Model|Core.data.Model[]} records\n     */\n    invalidateKnownHeight(records) {\n        const me = this;\n        if (!me.fixedRowHeight) {\n            const { heightMap } = me;\n            records = ArrayHelper.asArray(records);\n            records.forEach(record => {\n                if (record) {\n                    if (heightMap.has(record.id)) {\n                        // Known height decreases when invalidating\n                        me.totalKnownHeight -= heightMap.get(record.id);\n                        heightMap.delete(record.id);\n                    }\n                }\n            });\n            me.averageRowHeight = me.totalKnownHeight / heightMap.size;\n        }\n    }\n    /**\n     * Invalidates all cached height and resets `averageRowHeight` and `totalKnownHeight`\n     */\n    clearKnownHeights() {\n        this.heightMap.clear();\n        this.averageRowHeight = this.totalKnownHeight = 0;\n    }\n    /**\n     * Calculates a row top from its data index. Uses known values from the height map, unknown are substituted with\n     * the average row height. When configured with `fixedRowHeight`, it will always calculate a correct value\n     * @param {Number} index Index in store\n     * @private\n     */\n    calculateTop(index) {\n        // When using fixed row height, life is easy\n        if (this.fixedRowHeight) {\n            return index * this.rowOffsetHeight;\n        }\n        const { store } = this;\n        let top = 0;\n        // When not using fixed row height, we make an educated guess at the top. The more rows have been visited, the\n        // more correct the guess is (fully correct if all rows visited)\n        for (let i = 0; i < index; i++) {\n            const record = store.getAt(i);\n            top += this.getOffsetHeight(record);\n        }\n        return Math.floor(top);\n    }\n    //endregion\n    //region Calculations\n    /**\n     * Returns top and bottom for rendered row or estimated coordinates for unrendered.\n     * @param {Core.data.Model|String|Number} recordOrId Record or record id\n     * @param {Boolean} [local] Pass true to get relative record coordinates\n     * @param {Boolean} [roughly] Pass true to allow a less exact but cheaper estimate\n     * @returns {Core.helper.util.Rectangle} Record bounds with format { x, y, width, height, bottom, right }\n     * @category Calculations\n     */\n    getRecordCoords(recordOrId, local = false, roughly = false) {\n        const\n            me  = this,\n            row = me.getRowById(recordOrId);\n        let scrollingViewport = me.client._bodyRectangle;\n        // _bodyRectangle is not updated on page/containing element scroll etc. Need to make sure it is correct in case\n        // that has happend. This if-statement should be removed when fixing\n        // https://app.assembla.com/spaces/bryntum/tickets/6587-cached-_bodyrectangle-should-be-updated-on--quot-external-quot--scroll/details\n        if (!local) {\n            scrollingViewport = me.client.refreshBodyRectangle();\n        }\n        // Rendered? Then we know position for certain\n        if (row) {\n            return new Rectangle(\n                scrollingViewport.x,\n                local ? Math.round(row.top) : Math.round(row.top + scrollingViewport.y - me.client.scrollable.y),\n                scrollingViewport.width,\n                row.offsetHeight\n            );\n        }\n        return me.getRecordCoordsByIndex(me.store.indexOf(recordOrId), local, roughly);\n    }\n    /**\n     * Returns estimated top and bottom coordinates for specified row.\n     * @param {Number} recordIndex Record index\n     * @param {Boolean} [local]\n     * @returns {Core.helper.util.Rectangle} Estimated record bounds with format { x, y, width, height, bottom, right }\n     * @category Calculations\n     */\n    getRecordCoordsByIndex(recordIndex, local = false, roughly = false) {\n        const\n            me                    = this,\n            { topRow, bottomRow } = me,\n            scrollingViewport     = me.client._bodyRectangle,\n            { id }                = me.store.getAt(recordIndex),\n            // Not using rowOffsetHeight since it floors the value and that rounding might give big errors far down\n            height                = me.preciseRowOffsetHeight,\n            currentTopIndex       = topRow.dataIndex,\n            currentBottomIndex    = bottomRow.dataIndex,\n            // Instead of estimating top from the very top, use closest known coordinate. Makes sure a coordinate is not\n            // estimated on wrong side of rendered rows, needed to correctly draw dependencies where one event is located\n            // on a unrendered row\n            calculateFrom         =\n                // bottomRow is closest, calculate from it\n                recordIndex > currentBottomIndex\n                    ? { index : recordIndex - currentBottomIndex - 1, y : bottomRow.bottom, from : 'bottomRow' }\n                    //  closer to topRow than 0, use topRow\n                    : recordIndex > currentTopIndex / 2\n                        ? { index : recordIndex - currentTopIndex, y : topRow.top, from : 'topRow' }\n                        // closer to the very top, use it\n                        : { index : recordIndex, y : 0, from : 'top' },\n            top                   = me.allHeightsKnown && !roughly\n                // All heights are known (all rows visited or fixed row height), get actual top coord\n                ? me.calculateTop(recordIndex)\n                // Otherwise estimate\n                : Math.floor(calculateFrom.y + calculateFrom.index * height),\n            // Either known height or average\n            maybeKnownHeight      = Math.floor(me.heightMap.get(id) ?? height),\n            recordY               = local\n                ? calculateFrom.from === 'topRow'\n                    // here, when are moving from the top row above, we want to be calculating things from bottom to top,\n                    // so we first arrive at expected bottom (`top + height`), then deduct the row height from that -\n                    // either known or average\n                    // if row height is not known that is equivalent of just using `top`\n                    ? top + height - maybeKnownHeight\n                    : top\n                : top + scrollingViewport.y - me.client.scrollable.y,\n            result                = new Rectangle(scrollingViewport.x, recordY, scrollingViewport.width, maybeKnownHeight);\n        // Signal that it's not based on an element, so is only approximate.\n        // Grid.scrollRowIntoView will have to go round again using the block options below to ensure it's correct.\n        result.virtual = true;\n        // When the block becomes visible, scroll it to the logical position using the scrollIntoView's block\n        // option. If it's above, use block: 'start', if below, use block: 'end'.\n        result.block = result.bottom < scrollingViewport.y ? 'start' : (result.y > scrollingViewport.bottom ? 'end' : 'nearest');\n        return result;\n    }\n    /**\n     * Total estimated grid height (used for scroller)\n     * @property {Number}\n     * @readonly\n     * @category Calculations\n     */\n    get totalHeight() {\n        return this._totalHeight;\n    }\n    //endregion\n    //region Iteration etc.\n    /**\n     * Calls a function for each Row\n     * @param {Function} fn Function that will be called with Row as first parameter\n     * @category Iteration\n     */\n    forEach(fn) {\n        this.rows.forEach(fn);\n    }\n    /**\n     * Iterator that allows you to do for (let row of rowManager)\n     * @category Iteration\n     */\n    [Symbol.iterator]() {\n        return this.rows[Symbol.iterator]();\n    }\n    //endregion\n    //region Scrolling & rendering\n    /**\n     * Refresh a single cell.\n     * @param {Core.data.Model} record Record for row holding the cell that should be updated\n     * @param {String|Number} columnId Column id to identify the cell within the row\n     * @returns {Boolean} Returns `true` if cell was found and refreshed, `false` if not\n     */\n    refreshCell(record, columnId) {\n        const cellContext = new Location({ grid : this.grid, record, columnId });\n        return Boolean(cellContext.cell && cellContext.row.renderCell(cellContext));\n    }\n    /**\n     * Renders from the top of the grid, also resetting scroll to top. Used for example when collapsing all groups.\n     * @category Scrolling & rendering\n     */\n    returnToTop() {\n        const me = this;\n        me.topIndex = 0;\n        me.lastScrollTop = 0;\n        if (me.topRow) {\n            me.topRow.dataIndex = 0;\n            // Force the top row to the top of the scroll range\n            me.topRow.setTop(0, true);\n        }\n        me.refresh();\n        // Rows rendered from top, make sure grid is scrolled to top also\n        me.grid.scrollable.y = 0;\n    }\n    /**\n     * Renders from specified records row and down (used for example when collapsing a group, does not affect rows above).\n     * @param {Core.data.Model} record Record of first row to render\n     * @category Scrolling & rendering\n     */\n    renderFromRecord(record) {\n        const row = this.getRowById(record.id);\n        if (row) {\n            this.renderFromRow(row);\n        }\n    }\n    /**\n     * Renders from specified row and down (used for example when collapsing a group, does not affect rows above).\n     * @param {Grid.row.Row} fromRow First row to render\n     * @category Scrolling & rendering\n     */\n    renderFromRow(fromRow = null) {\n        const\n            me = this,\n            {\n                rows,\n                store,\n                topIndex,\n                topRow\n            }            = me,\n            storeCount   = store.count;\n        let fromRowIndex = fromRow ? rows.indexOf(fromRow) : 0;\n        // Calculate row count, adding rows if needed, but do not rerender - we are going to do that below.\n        // Bail out if no rows. Allow removing rows if we have more than store have rows\n        if (me.calculateRowCount(false, storeCount < rows.length, true) === 0) {\n            // Reestimate total height. Possible if all tasks deleted\n            me.estimateTotalHeight(true);\n            return;\n        }\n        // If the topIndex has decreased (rows above has been removed) we need to recalculate the top, and render from\n        // there\n        if (me.topIndex < topIndex) {\n            me.topRow.setTop(me.calculateTop(me.topIndex), true);\n            fromRowIndex = 0;\n            fromRow      = me.topRow;\n        }\n        // If the fromRow has been removed by calculateRowCount, use row at same index or top row\n        else if (fromRow && rows.indexOf(fromRow) < 0) {\n            fromRow = rows[fromRowIndex] || topRow;\n        }\n        // starting either from its specified dataIndex or from its index (happens on first render, no dataIndex yet)\n        let dataIndex = fromRow ? fromRow.dataIndex : rows[0].dataIndex;\n        const\n            // amount of records after this one in store\n            recordsAfter = storeCount - dataIndex - 1,\n            // render to this row, either the last row or the row which will hold the last record available\n            toRowIndex   = Math.min(rows.length - 1, fromRowIndex + recordsAfter);\n        let\n            // amount of rows which won't be rendered below last record (if we have fewer records than topRow + row count)\n            leftOverCount = rows.length - toRowIndex - 1,\n            // Start with top correctly just below the previous row's bottom\n            top           = fromRowIndex > 0 ? rows[fromRowIndex - 1].bottom : rows[fromRowIndex].top,\n            row;\n        // _rows array is ordered in display order, just iterate to the end\n        for (let i = fromRowIndex; i <= toRowIndex; i++) {\n            row = rows[i];\n            // Needed in scheduler when translating events, happens before render\n            row.dataIndex = dataIndex;\n            // Silent translation, render will update contents anyway\n            row.setTop(top, true);\n            row.render(dataIndex, store.getAt(dataIndex++), false);\n            top += row.offsetHeight;\n        }\n        // if number for records to display has decreased, for example by collapsing a node, we might get unused rows\n        // below bottom. move those to top to not have unused rows laying around\n        while (leftOverCount-- > 0) {\n            me.displayRecordAtTop();\n        }\n        // Renderers might yield a lower row height than the configured, leaving blank space at bottom\n        if (me.bottomRow.bottom < me.viewHeight) {\n            me.calculateRowCount();\n        }\n        // Reestimate total height\n        me.estimateTotalHeight(true);\n        me.trigger('renderDone');\n    }\n    /**\n     * Renders the passed array (or [Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set)) of {@link Grid.row.Row rows}\n     * @param {Grid.row.Row[]|Set} rows The rows to render\n     * @category Scrolling & rendering\n     */\n    renderRows(rows) {\n        let oldHeight,\n            heightChanged = false;\n        rows = Array.from(rows);\n        // Sort topmost row first\n        rows.sort((a, b) => a.dataIndex - b.dataIndex);\n        // Render the requested rows.\n        for (const row of rows) {\n            oldHeight = row.height;\n            // Pass updatingSingleRow as false, so that it does not shuffle following\n            // rows downwards on each render. We do that once here after the rows are all refreshed.\n            row.render(null, null, false);\n            heightChanged |= row.height !== oldHeight;\n        }\n        // If this caused a height change, shuffle following rows.\n        if (heightChanged) {\n            this.translateFromRow(rows[0]);\n        }\n        this.trigger('renderDone');\n    }\n    /**\n     * Translates all rows after the specified row. Used when a single rows height is changed and the others should\n     * rearrange. (Called from Row#render)\n     * @param {Grid.row.Row} fromRow\n     * @private\n     * @category Scrolling & rendering\n     */\n    translateFromRow(fromRow, batch = false) {\n        const me = this;\n        let top = fromRow.bottom,\n            row, index;\n        for (index = fromRow.dataIndex + 1, row = me.getRow(index); row; row = me.getRow(++index)) {\n            top = row.translate(top);\n        }\n        // Reestimate total height\n        if (!batch) {\n            me.estimateTotalHeight(true);\n        }\n    }\n    /**\n     * Rerender all rows\n     * @category Scrolling & rendering\n     * @privateparam {Boolean} force Force re-rendering even if there are no rows currently\n     */\n    refresh(force = false) {\n        const\n            me         = this,\n            { topRow } = me;\n        // too early\n        if ((!topRow && !force) || me.grid.refreshSuspended) {\n            return;\n        }\n        me.idMap = {};\n        me.renderFromRow(topRow);\n        me.trigger('refresh');\n    }\n    /**\n     * Makes sure that specified record is displayed in view\n     * @param newScrollTop Top of visible section\n     * @param [forceRecordIndex] Index of record to display at center\n     * @private\n     * @category Scrolling & rendering\n     */\n    jumpToPosition(newScrollTop, forceRecordIndex) {\n        // There are two very different requirements here.\n        // If there is a forceRecordIndex, that takes precedence to get it into the center of the\n        // viewport, and wherever we render the calculated row block, we may then *adjust the scrollTop*\n        // to get that row to the center.\n        //\n        // If there's no forceRecordIndex, then the scroll position is the primary objective and\n        // we must render what we calculate to be correct at that viewport position.\n        const\n            me                    = this,\n            { store, heightMap }  = me,\n            storeCount            = store.count;\n        if (me.allHeightsKnown && !me.fixedRowHeight) {\n            const\n                top    = newScrollTop - me.prependBufferHeight,\n                border = me.grid._rowBorderHeight;\n            let accumulated = 0,\n                targetIndex = 0;\n            while (accumulated < top) {\n                const record = store.getAt(targetIndex);\n                accumulated += heightMap.get(record.id) + border;\n                targetIndex++;\n            }\n            const startIndex = Math.max(Math.min(targetIndex, storeCount - me.rowCount), 0);\n            me.lastScrollTop = newScrollTop;\n            me.topRow.dataIndex = me.topIndex = startIndex;\n            me.topRow.setTop(me.calculateTop(startIndex), false);\n            // render entire buffer\n            me.refresh();\n        }\n        else {\n            const\n                rowHeight      = me.preciseRowOffsetHeight,\n                // Calculate index of the top of the rendered block.\n                // If we are targeting the scrollTop, this will be the top index at the scrollTop minus prepend count.\n                // If we are targeting a recordIndex, this will attempt to place that in the center of the rendered block.\n                targetIndex    = forceRecordIndex == null ? Math.floor(newScrollTop / rowHeight) - me.prependRowBuffer : forceRecordIndex - Math.floor(me.rowCount / 2),\n                startIndex     = Math.max(Math.min(targetIndex, storeCount - me.rowCount), 0),\n                viewportTop    = me.client.scrollable.y,\n                viewportBottom = Math.min(me.client._bodyRectangle.height + viewportTop + me.appendBufferHeight, me.totalHeight);\n            me.lastScrollTop = newScrollTop;\n            me.topRow.dataIndex = me.topIndex = startIndex;\n            me.topRow.setTop(Math.floor(startIndex * rowHeight), false);\n            // render entire buffer\n            me.refresh();\n            // Not filled all the way down?\n            if (me.bottomRow.bottom < viewportBottom) {\n                // Might have jumped into a section of low heights. Needs to be done after the refresh, since heights\n                // are not known before it\n                me.calculateRowCount(false, false, false);\n                // Fill with available rows (might be available above buffer because of var row height), stop if we run out of records :)\n                while (me.bottomRow.bottom < viewportBottom && me._rows[me.prependRowBuffer].top < viewportTop && me.bottomRow.dataIndex < storeCount - 1) {\n                    me.displayRecordAtBottom();\n                }\n            }\n            me.estimateTotalHeight();\n        }\n        // If the row index is our priority, then scroll it into the center\n        if (forceRecordIndex != null) {\n            const\n                { scrollable } = me.grid,\n                targetRow      = me.getRow(forceRecordIndex),\n                // When coming from a block of high rowHeights to one with much lower we might still miss the target...\n                rowCenter      = targetRow && Rectangle.from(targetRow._elementsArray[0]).center.y,\n                viewportCenter = scrollable.viewport.center.y;\n            // Scroll the targetRow into the center of the viewport\n            if (targetRow) {\n                scrollable.y = newScrollTop = Math.floor(scrollable.y + (rowCenter - viewportCenter));\n            }\n        }\n        return newScrollTop;\n    }\n    /**\n     * Jumps to a position if it is far enough from current position. Otherwise does nothing.\n     * @private\n     * @category Scrolling & rendering\n     */\n    warpIfNeeded(newScrollTop) {\n        const\n            me     = this,\n            result = { newScrollTop, deltaTop : newScrollTop - me.lastScrollTop };\n        // if gap to fill is large enough, better to jump there than to fill row by row\n        if (Math.abs(result.deltaTop) > (me.rowCount * me.rowOffsetHeight) * 3) {\n            // no specific record targeted\n            let index;\n            // Specific record specified as target of scroll?\n            if (me.scrollTargetRecordId) {\n                index = me.store.indexOf(me.scrollTargetRecordId);\n                // since scroll is happening async record might have been removed after requesting scroll,\n                // in that case we rely on calculated index (as when scrolling without target)\n            }\n            // We are jumping, so the focused row will derender\n            me.grid.onFocusedRowDerender();\n            // perform the jump and return results\n            result.newScrollTop = me.jumpToPosition(newScrollTop, index);\n            result.deltaTop = 0; // no extra filling needed\n        }\n        return result;\n    }\n    /**\n     * Handles virtual rendering (only visible rows + buffer are in dom) for rows\n     * @param {Number} newScrollTop The `Y` scroll position for which to render rows.\n     * @param {Boolean} [force=false] Pass `true` to update the rendered row block even if the scroll position has not changed.\n     * @returns {Number} Adjusted height required to fit rows\n     * @private\n     * @category Scrolling & rendering\n     */\n    updateRenderedRows(newScrollTop, force, ignoreError = false) {\n        const\n            me         = this,\n            clientRect = me.client._bodyRectangle;\n        // Might be triggered after removing all records, should not crash\n        if (me.rowCount === 0) {\n            return 0;\n        }\n        let result = me.totalHeight;\n        if (\n            force ||\n            // Only react if we have scrolled by one row or more\n            Math.abs(newScrollTop - me.lastScrollTop) >= me.rowOffsetHeight ||\n            // or if we have a gap at top/bottom (#9375)\n            me.topRow.top > newScrollTop ||\n            me.bottomRow.bottom < newScrollTop + clientRect.height\n        ) {\n            // If scrolled by a large amount, jump instead of rendering each row\n            const posInfo = me.warpIfNeeded(newScrollTop);\n            me.scrollTargetRecordId = null;\n            // Cache the last correct render scrollTop before fill.\n            // it can be adjusted to hide row position corrections.\n            me.lastScrollTop = posInfo.newScrollTop;\n            if (posInfo.deltaTop > 0) {\n                // Scrolling down\n                me.fillBelow(posInfo.newScrollTop);\n            }\n            else if (posInfo.deltaTop < 0) {\n                // Scrolling up\n                me.fillAbove(posInfo.newScrollTop);\n            }\n            if (!me.fixedRowHeight && !ignoreError) {\n                me.correctError(posInfo, clientRect, newScrollTop);\n            }\n            // Calculate the new height based on new content\n            result = me.estimateTotalHeight();\n        }\n        return result;\n    }\n    correctError(posInfo, clientRect, newScrollTop) {\n        const me = this;\n        let error = 0;\n        // When we transition from not knowing all heights to doing so, the old estimate will likely have positioned\n        // rows a bit off. Compensate for that here.\n        if (me.allHeightsKnown) {\n            error = me.topRow.top - me.calculateTop(me.topRow.dataIndex);\n        }\n        // If it's a temporary scroll, we can be told to ignore the drift.\n        // Apart from that, we must correct keep the rendered block position correct.\n        // Otherwise, when rolling upwards after a teleport, we may not be able to reach\n        // the top. Some rows may end up at -ve positions.\n        else {\n            // Only correct the rendered block position if we are in danger of running out of scroll space.\n            // That is if we are getting towards the top or bottom of the scroll range.\n            if (\n                // Scrolling up within top zone\n                (posInfo.deltaTop < 0 && newScrollTop < clientRect.height * 2) ||\n                // Scrolling down within bottom zone\n                (posInfo.deltaTop > 0 && newScrollTop > me.totalHeight - clientRect.height * 2 - 3)\n            ) {\n                error = me.topRow.top - me.calculateTop(me.topRow.dataIndex); //me.topIndex * me.rowOffsetHeight;\n            }\n        }\n        if (error) {\n            // Correct the rendered block position if it's not at the calculated position.\n            // Keep the visual position correct by adjusting the scrollTop by the same amount.\n            // When variable row heights are used, this will keep the rendered block top correct.\n            me.offsetRows(-error);\n            me.grid.scrollable.y = me.lastScrollTop = me.grid.scrollable.y - error;\n        }\n    }\n    /**\n     * Moves as many rows from the bottom to the top that are needed to fill to current scroll pos.\n     * @param newTop Scroll position\n     * @private\n     * @category Scrolling & rendering\n     */\n    fillAbove(newTop) {\n        const\n            me         = this,\n            fillHeight = newTop - me.topRow.top - me.prependBufferHeight;\n        let accumulatedHeight = 0;\n        while (accumulatedHeight > fillHeight && me.topIndex > 0) {\n            // We want to show prev record at top of rows\n            accumulatedHeight -= me.displayRecordAtTop();\n        }\n        me.trigger('renderDone');\n    }\n    /**\n     * Moves as many rows from the top to the bottom that are needed to fill to current scroll pos.\n     * @param newTop Scroll position\n     * @private\n     * @category Scrolling & rendering\n     */\n    fillBelow(newTop) {\n        const\n            me          = this,\n            fillHeight  = newTop - me.topRow.top - me.prependBufferHeight,\n            recordCount = me.store.count,\n            rowCount    = me.rowCount;\n        let accumulatedHeight = 0;\n        // Repeat until we have filled empty height\n        while (\n            accumulatedHeight < fillHeight &&         // fill empty height\n            me.topIndex + rowCount < recordCount &&   // as long as we have records left\n            me.topRow.top + me.topRow.offsetHeight < newTop // and do not move top row fully into view (can happen with var row height)\n        ) {\n            // We want to show next record at bottom of rows\n            accumulatedHeight += me.displayRecordAtBottom();\n        }\n        me.trigger('renderDone');\n    }\n    /**\n     * Estimates height needed to fit all rows, based on average row height. Also offsets rows if needed to not be above\n     * the reachable area of the view.\n     * @param {Boolean} [immediate] Specify true to pass the `immediate` flag on to any listeners (probably only Grid\n     * cares. Used to bypass buffered element resize)\n     * @returns {Number}\n     * @private\n     * @category Scrolling & rendering\n     */\n    estimateTotalHeight(immediate = false) {\n        const me = this;\n        if (me.grid.renderingRows) {\n            return;\n        }\n        const\n            recordCount   = me.store.count,\n            unknownCount  = recordCount - me.heightMap.size,\n            { bottomRow } = me;\n        let estimate;\n        // No need to estimate when using fixed row height\n        if (me.fixedRowHeight) {\n            estimate = recordCount * me.rowOffsetHeight;\n        }\n        else {\n            estimate =\n                // Known height, from entries in heightMap\n                me.totalKnownHeight +\n                // Those heights are \"clientHeights\", estimate needs to include borders\n                me.heightMap.size * me.grid._rowBorderHeight +\n                // Add estimate for rows with unknown height\n                unknownCount * me.preciseRowOffsetHeight;\n            // No bottomRow yet if estimating initial height in autoHeight grid\n            if (bottomRow && unknownCount) {\n                const bottom = bottomRow.bottom;\n                // Too low estimate or reached the end with scroll left, adjust to fit current bottom\n                if (bottom > estimate || (me.topIndex + me.rowCount >= recordCount && estimate > bottom && bottom > 0)) {\n                    estimate = bottom;\n                    // estimate all the way down\n                    if (bottomRow.dataIndex < recordCount - 1) {\n                        estimate += (recordCount - 1 - bottomRow.dataIndex) * me.preciseRowOffsetHeight;\n                    }\n                }\n            }\n            estimate = Math.floor(estimate);\n        }\n        if (estimate !== me.totalHeight) {\n            if (me.trigger('changeTotalHeight', { totalHeight : estimate, immediate }) !== false) {\n                me._totalHeight = estimate;\n            }\n        }\n        return estimate;\n    }\n    /**\n     * Moves a row from bottom to top and renders the corresponding record to it.\n     * @returns {Number} New row height\n     * @private\n     * @category Scrolling & rendering\n     */\n    displayRecordAtTop() {\n        const\n            me           = this,\n            { grid }     = me,\n            recordIndex  = me.topIndex - 1,\n            record       = me.store.getAt(recordIndex),\n            // Row currently rendered at the bottom, the row we want to move\n            bottomRow    = me.bottomRow,\n            bottomRowTop = bottomRow.top;\n        me.trigger('beforeTranslateRow', {\n            row       : bottomRow,\n            newRecord : record\n        });\n        // If focused cell is being scrolled off...\n        if (bottomRow.dataIndex === grid.focusedCell?.rowIndex) {\n            grid.onFocusedRowDerender();\n        }\n        // estimated top, for rendering that depends on having top\n        bottomRow._top = me.topRow.top - me.getOffsetHeight(record);\n        // if configured with fixed row height, it will be the correct value\n        bottomRow.estimatedTop = !me.fixedRowHeight;\n        // Render row\n        bottomRow.render(recordIndex, record, false);\n        // Move it to top. Restore top so that the setter won't reject non-change\n        // if the estimate happened to be correct.\n        bottomRow._top = bottomRowTop;\n        bottomRow.setBottom(me.topRow.top);\n        bottomRow.estimatedTop = false;\n        // Prev row is now at top\n        me.topIndex--;\n        // move to start of array (bottomRow becomes topRow)\n        me._rows.unshift(me._rows.pop());\n        me.fixIndices();\n        return bottomRow.offsetHeight;\n    }\n    /**\n     * Moves a row from top to bottom and renders the corresponding record to it.\n     * @returns {Number} New row height\n     * @private\n     * @category Scrolling & rendering\n     */\n    displayRecordAtBottom() {\n        const\n            me          = this,\n            { grid }    = me,\n            recordIndex = me.topIndex + me.rowCount,\n            record      = me.store.getAt(recordIndex),\n            // Row currently rendered on the top, the row we want to move\n            topRow      = me.topRow;\n        me.trigger('beforeTranslateRow', {\n            row       : topRow,\n            newRecord : record\n        });\n        // If focused cell is being scrolled off...\n        if (topRow.dataIndex === grid.focusedCell?.rowIndex) {\n            grid.onFocusedRowDerender();\n        }\n        topRow.dataIndex = recordIndex;\n        // Move it to bottom\n        topRow.setTop(me.bottomRow.bottom);\n        // Render row\n        topRow.render(recordIndex, record, false);\n        // Next row is now at top\n        me.topIndex++;\n        // move to end of array (topRow becomes bottomRow)\n        me._rows.push(me._rows.shift());\n        me.fixIndices();\n        return topRow.offsetHeight;\n    }\n    fixIndices() {\n        for (let i = 0, { rows } = this, { length } = rows; i < length; i++) {\n            rows[i].index = i;\n        }\n    }\n    //endregion\n}\nRowManager.featureClass = '';\nRowManager._$name = 'RowManager';", "import Bar from './Bar.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\n/**\n * @module Grid/view/Header\n */\n/**\n * The Grid header, which contains simple columns but also allows grouped columns. One instance is created and used per SubGrid\n * automatically, you should not need to instantiate this class manually. See {@link Grid.column.Column} for information about\n * column configuration.\n *\n * {@inlineexample Grid/view/Header.js}\n *\n * @extends Grid/view/Bar\n * @internal\n */\nexport default class Header extends Bar {\n    static $name = 'Header';\n    static type = 'gridheader';\n    get subGrid() {\n        return this._subGrid;\n    }\n    set subGrid(subGrid) {\n        this._subGrid = this.owner = subGrid;\n    }\n    get region() {\n        return this.subGrid?.region;\n    }\n    changeElement(element, was) {\n        const { region } = this;\n        // Columns must be examined for maxDepth\n        this.getConfig('columns');\n        return super.changeElement({\n            className : {\n                'b-grid-header-scroller'             : 1,\n                [`b-grid-header-scroller-${region}`] : region\n            },\n            children : [{\n                reference : 'headersElement',\n                className : {\n                    'b-grid-headers'             : 1,\n                    [`b-grid-headers-${region}`] : region\n                },\n                dataset : {\n                    region,\n                    reference : 'headersElement',\n                    maxDepth  : this.maxDepth\n                }\n            }]\n        }, was);\n    }\n    get overflowElement() {\n        return this.headersElement;\n    }\n    /**\n     * Recursive column header config creator.\n     * Style not included because of CSP. Widths are fixed up in\n     * {@link #function-fixHeaderWidths}\n     * @private\n     */\n    getColumnConfig(column) {\n        const\n            {\n                id,\n                align,\n                resizable,\n                isLeaf,\n                isParent,\n                isLastInSubGrid,\n                cls,\n                childLevel,\n                field,\n                tooltip,\n                children,\n                isFocusable,\n                grid\n            }           = column,\n            // Headers tested standalone - may be no grid\n            focusedCell = grid?.focusedCell,\n            isFocused   = focusedCell?.rowIndex === -1 && focusedCell?.column === column,\n            style = {};\n        if (column.isVisible) {\n            if (column.flex) {\n                style.flex = column.flex;\n            }\n            else if (column.width) {\n                style.width = DomHelper.setLength(column.width);\n            }\n            return {\n                style,\n                className : {\n                    'b-grid-header'                  : 1,\n                    'b-grid-header-parent'           : isParent,\n                    [`b-level-${childLevel}`]        : 1,\n                    [`b-depth-${column.meta.depth}`] : 1,\n                    [`b-grid-header-align-${align}`] : align,\n                    'b-grid-header-resizable'        : resizable && isLeaf,\n                    [cls]                            : cls,\n                    'b-collapsible'                  : column.collapsible,\n                    'b-last-parent'                  : isParent && isLastInSubGrid,\n                    'b-last-leaf'                    : isLeaf && isLastInSubGrid\n                },\n                role                            : isFocusable ? 'columnheader' : 'presentation',\n                'aria-sort'                     : 'none',\n                'aria-label'                    : column.ariaLabel,\n                [isFocusable ? 'tabIndex' : ''] : isFocused ? 0 : -1,\n                dataset                         : {\n                    ...Tooltip.encodeConfig(tooltip),\n                    columnId                : id,\n                    [field ? 'column' : ''] : field\n                },\n                children : [{\n                    className : 'b-grid-header-text',\n                    children  : [{\n                        [grid && isFocusable ? 'id' : ''] : `${grid?.id}-column-${column.id}`,\n                        className                         : 'b-grid-header-text-content'\n                    }]\n                }, children ? {\n                    className   : 'b-grid-header-children',\n                    children    : children.map(child => this.getColumnConfig(child)),\n                    syncOptions : {\n                        syncIdField : 'columnId'\n                    }\n                } : null,\n                {\n                    className : 'b-grid-header-resize-handle'\n                }]\n            };\n        }\n    }\n    // used by safari to fix flex when rows width shrink below this value\n    calculateMinWidthForSafari() {\n        let minWidth = 0;\n        this.columns.visibleColumns.forEach(column => {\n            minWidth += column.calculateMinWidth();\n        });\n        return minWidth;\n    }\n    /**\n     * Fix header widths (flex or fixed width) after rendering. Not a part of template any longer because of CSP\n     * @private\n     */\n    fixHeaderWidths() {\n        this.fixCellWidths();\n    }\n    refreshHeaders() {\n        const me = this;\n        // run renderers, not done from template to work more like cell rendering\n        me.columns.traverse(column => me.refreshColumn(column));\n        me.fixHeaderWidths();\n    }\n    refreshColumn(column) {\n        const\n            me            = this,\n            headerElement = me.getBarCellElement(column.id);\n        if (headerElement) {\n            let html = column.headerText;\n            if (column.headerRenderer) {\n                html = column.headerRenderer.call(column.thisObj || me, { column, headerElement });\n            }\n            if (column.headerWidgetMap) {\n                Object.values(column.headerWidgetMap).forEach(widget => {\n                    widget.render(column.textWrapper);\n                });\n            }\n            if (column.icon) {\n                html = `<i class=\"${StringHelper.encodeHtml(column.icon)}\"></i>` + (html || '');\n            }\n            const innerEl = headerElement.querySelector('.b-grid-header-text-content');\n            if (innerEl) {\n                innerEl.innerHTML = html || '';\n            }\n        }\n    }\n    get columns() {\n        const\n            me     = this,\n            result = super.columns;\n        if (!me.columnsDetacher) {\n            // columns is a chained store, it will be repopulated from master when columns change.\n            // That action always triggers change with action dataset.\n            me.columnsDetacher = result.ion({\n                change() {\n                    me.initDepths();\n                },\n                thisObj : me\n            });\n            me.initDepths();\n        }\n        return result;\n    }\n    set columns(columns) {\n        super.columns = columns;\n    }\n    /**\n     * Depths are used for styling of grouped headers. Sets them on meta.\n     * @private\n     */\n    initDepths(columns = this.columns.topColumns, parent = null) {\n        const me     = this;\n        let maxDepth = 0;\n        if (parent?.meta) {\n            parent.meta.depth++;\n        }\n        for (const column of columns) {\n            const { meta } = column;\n            meta.depth = 0;\n            if (column.children) {\n                me.initDepths(column.children.filter(me.columns.chainedFilterFn), column);\n                if (meta.depth && parent) {\n                    parent.meta.depth += meta.depth;\n                }\n            }\n            if (meta.depth > maxDepth) {\n                maxDepth = meta.depth;\n            }\n        }\n        if (!parent) {\n            me.maxDepth = maxDepth;\n        }\n        return maxDepth;\n    }\n    //endregion\n    //region Getters\n    /**\n     * Get the header cell element for the specified column.\n     * @param {String} columnId Column id\n     * @returns {HTMLElement} Header cell element\n     */\n    getHeader(columnId) {\n        return this.getBarCellElement(columnId);\n    }\n    //endregion\n    get contentElement() {\n        return this.element.firstElementChild;\n    }\n    refreshContent() {\n        const me = this;\n        DomSync.sync({\n            domConfig : {\n                children     : me.columns.topColumns.map(col => me.getColumnConfig(col)),\n                onlyChildren : true\n            },\n            targetElement    : me.contentElement,\n            strict           : true,\n            syncIdField      : 'columnId',\n            releaseThreshold : 0\n        });\n        me.refreshHeaders();\n    }\n    onInternalPaint({ firstPaint }) {\n        if (firstPaint) {\n            this.refreshContent();\n        }\n    }\n}\n// Register this widget type with its Factory\nHeader.initClass();\nHeader._$name = 'Header';", "import Base from '../../../Core/Base.js';\nimport DomDataStore from '../../../Core/data/DomDataStore.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport BrowserHelper from '../../../Core/helper/BrowserHelper.js';\nimport Location from '../../util/Location.js';\nconst gridBodyElementEventHandlers = {\n        touchstart  : 'onElementTouchStart',\n        touchmove   : 'onElementTouchMove',\n        touchend    : 'onElementTouchEnd',\n        pointerover : 'onElementMouseOver',\n        mouseout    : 'onElementMouseOut',\n        mousedown   : 'onElementMouseDown',\n        mousemove   : 'onElementMouseMove',\n        mouseup     : 'onElementMouseUp',\n        click       : 'onHandleElementClick',\n        dblclick    : 'onElementDblClick',\n        keyup       : 'onElementKeyUp',\n        keypress    : 'onElementKeyPress',\n        contextmenu : 'onElementContextMenu',\n        pointerdown : 'onElementPointerDown',\n        pointerup   : 'onElementPointerUp'\n    },\n    eventProps = [\n        'pageX',\n        'pageY',\n        'clientX',\n        'clientY',\n        'screenX',\n        'screenY'\n    ];\nfunction toggleHover(element, add = true) {\n    element?.classList.toggle('b-hover', add);\n}\nfunction setCellHover(columnId, row, add = true) {\n    row && columnId && toggleHover(row.getCell(columnId), add);\n}\n/**\n * @module Grid/view/mixin/GridElementEvents\n */\n/**\n * Mixin for Grid that handles dom events. Some listeners fire own events but all can be chained by features. None of\n * the functions in this class are indented to be called directly.\n *\n * See {@link Grid.view.Grid} for more information on grid keyboard interaction.\n *\n * @mixin\n */\nexport default Target => class GridElementEvents extends (Target || Base) {\n    static get $name() {\n        return 'GridElementEvents';\n    }\n    //region Config\n    static get configurable() {\n        return {\n            /**\n             * The currently hovered grid cell\n             * @member {HTMLElement}\n             * @readonly\n             * @category Misc\n             */\n            hoveredCell : null,\n            /**\n             * Time in ms until a longpress is triggered\n             * @prp {Number}\n             * @default\n             * @category Misc\n             */\n            longPressTime : 400,\n            /**\n             * Set to true to listen for CTRL-Z (CMD-Z on Mac OS) keyboard event and trigger undo (redo when SHIFT is\n             * pressed). Only applicable when using a {@link Core.data.stm.StateTrackingManager}.\n             * @prp {Boolean}\n             * @default\n             * @category Misc\n             */\n            enableUndoRedoKeys : true,\n            keyMap : {\n                'Ctrl+z'       : 'undoRedoKeyPress',\n                'Ctrl+Shift+z' : 'undoRedoKeyPress',\n                ' '            : { handler : 'clickCellByKey', weight : 1000 }\n            }\n        };\n    }\n    //endregion\n    //region Events\n    /**\n     * Fired when user clicks in a grid cell\n     * @event cellClick\n     * @param {Grid.view.Grid} grid The grid instance\n     * @param {Core.data.Model} record The record representing the row\n     * @param {Grid.column.Column} column The column to which the cell belongs\n     * @param {HTMLElement} cellElement The cell HTML element\n     * @param {HTMLElement} target The target element\n     * @param {MouseEvent} event The native DOM event\n     */\n    /**\n     * Fired when user double clicks a grid cell\n     * @event cellDblClick\n     * @param {Grid.view.Grid} grid The grid instance\n     * @param {Core.data.Model} record The record representing the row\n     * @param {Grid.column.Column} column The column to which the cell belongs\n     * @param {HTMLElement} cellElement The cell HTML element\n     * @param {HTMLElement} target The target element\n     * @param {MouseEvent} event The native DOM event\n     */\n    /**\n     * Fired when user activates contextmenu in a grid cell\n     * @event cellContextMenu\n     * @param {Grid.view.Grid} grid The grid instance\n     * @param {Core.data.Model} record The record representing the row\n     * @param {Grid.column.Column} column The column to which the cell belongs\n     * @param {HTMLElement} cellElement The cell HTML element\n     * @param {HTMLElement} target The target element\n     * @param {MouseEvent} event The native DOM event\n     */\n    /**\n     * Fired when user moves the mouse over a grid cell\n     * @event cellMouseOver\n     * @param {Grid.view.Grid} grid The grid instance\n     * @param {Core.data.Model} record The record representing the row\n     * @param {Grid.column.Column} column The column to which the cell belongs\n     * @param {HTMLElement} cellElement The cell HTML element\n     * @param {HTMLElement} target The target element\n     * @param {MouseEvent} event The native DOM event\n     */\n    /**\n     * Fired when a user moves the mouse out of a grid cell\n     * @event cellMouseOut\n     * @param {Grid.view.Grid} grid The grid instance\n     * @param {Core.data.Model} record The record representing the row\n     * @param {Grid.column.Column} column The column to which the cell belongs\n     * @param {HTMLElement} cellElement The cell HTML element\n     * @param {HTMLElement} target The target element\n     * @param {MouseEvent} event The native DOM event\n     */\n    //endregion\n    //region Event handling\n    /**\n     * Init listeners for a bunch of dom events. All events are handled by handleEvent().\n     * @private\n     * @category Events\n     */\n    initInternalEvents() {\n        const\n            handledEvents = Object.keys(gridBodyElementEventHandlers),\n            len           = handledEvents.length,\n            listeners     = {\n                element : this.bodyElement,\n                thisObj : this\n            };\n        // Route all events through handleEvent, so that we can capture this.event\n        // before we route to the handlers\n        for (let i = 0; i < len; i++) {\n            const eventName = handledEvents[i];\n            listeners[eventName] = {\n                handler : 'handleEvent'\n            };\n            // Override default for touch events.\n            // Other event types already have correct default.\n            if (eventName.startsWith('touch')) {\n                listeners[eventName].passive = false;\n            }\n        }\n        EventHelper.on(listeners);\n        EventHelper.on({\n            focusin : 'onGridBodyFocusIn',\n            element : this.bodyElement,\n            thisObj : this,\n            capture : true\n        });\n    }\n    /**\n     * This method finds the cell location of the passed event. It returns an object describing the cell.\n     * @param {Event} event A Mouse, Pointer or Touch event targeted at part of the grid.\n     * @param {Boolean} [includeSingleAxisMatch] Set to `true` to return a cell from xy either above or below the Grid's\n     * body or to the left or right.\n     * @returns {Object} An object containing the following properties:\n     * - `cellElement` - The cell element clicked on.\n     * - `column` - The {@link Grid.column.Column column} clicked under.\n     * - `columnId` - The `id` of the {@link Grid.column.Column column} clicked under.\n     * - `record` - The {@link Core.data.Model record} clicked on.\n     * - `id` - The `id` of the {@link Core.data.Model record} clicked on.\n     * @internal\n     * @category Events\n     */\n    getCellDataFromEvent(event, includeSingleAxisMatch = false) {\n        const\n            me          = this,\n            { columns } = me,\n            { target }  = event,\n            targetIsRow = target.classList.contains('b-grid-row');\n        let cellElement = target.closest('.b-grid-cell');\n        // If event coords outside of cell, this will match a cell so long as either x or y is inside a cell.\n        if (!cellElement && includeSingleAxisMatch && !targetIsRow &&\n            !target.classList.contains('b-grid-subgrid')\n        ) {\n            const {\n                top,\n                left,\n                right,\n                bottom\n            }            = me.bodyContainer.getBoundingClientRect();\n            let match,\n                { x, y } = event;\n            // X axis correct\n            if (x >= left && x <= right) {\n                // y will match row either at the top or at the bottom, dependent on what the provided x is\n                y = match = Math.ceil(me[`${y < top ? 'first' : 'last'}FullyVisibleRow`].element.getBoundingClientRect().y);\n            }\n            // Y axis correct\n            else if (y >= top && y <= bottom) {\n                // x will match row either at to the left or to the right, dependent on what the provided y is\n                x = match = Math.ceil(columns.visibleColumns[x < left ? 0 : columns.visibleColumns.length - 1].element.getBoundingClientRect().x);\n            }\n            if (match !== undefined) {\n                cellElement = DomHelper.childFromPoint(event.target, event.offsetX, event.offsetY)?.closest('.b-grid-cell');\n            }\n        }\n        else if (targetIsRow) {\n            // Peek at vertical center of the row element\n            cellElement = DomHelper.childFromPoint(event.target, event.offsetX, event.offsetY - (target.offsetHeight / 2))?.closest('.b-grid-cell');\n        }\n        // There is a cell\n        if (cellElement) {\n            const\n                cellData         = DomDataStore.get(cellElement),\n                { id, columnId } = cellData,\n                record           = me.store.getById(id),\n                column           = columns.getById(columnId);\n            // Row might not have a record, since we transition record removal\n            // https://app.assembla.com/spaces/bryntum/tickets/6805\n            return record ? {\n                cellElement,\n                cellData,\n                columnId,\n                id,\n                record,\n                column,\n                cellSelector : { id, columnId }\n            } : null;\n        }\n    }\n    /**\n     * This method finds the header location of the passed event. It returns an object describing the header.\n     * @param {Event} event A Mouse, Pointer or Touch event targeted at part of the grid.\n     * @returns {Object} An object containing the following properties:\n     * - `headerElement` - The header element clicked on.\n     * - `column` - The {@link Grid.column.Column column} clicked under.\n     * - `columnId` - The `id` of the {@link Grid.column.Column column} clicked under.\n     * @internal\n     * @category Events\n     */\n    getHeaderDataFromEvent(event) {\n        const headerElement = event.target.closest('.b-grid-header');\n        // There is a header\n        if (headerElement) {\n            const\n                headerData   = ObjectHelper.assign({}, headerElement.dataset),\n                { columnId } = headerData,\n                column       = this.columns.getById(columnId);\n            return column ? {\n                headerElement,\n                headerData,\n                columnId,\n                column\n            } : null;\n        }\n    }\n    /**\n     * Handles all dom events, routing them to correct functions (touchstart -> onElementTouchStart)\n     * @param event\n     * @private\n     * @category Events\n     */\n    handleEvent(event) {\n        if (!this.disabled && gridBodyElementEventHandlers[event.type]) {\n            this[gridBodyElementEventHandlers[event.type]](event);\n        }\n    }\n    //endregion\n    //region Touch events\n    /**\n     * Touch start, chain this function in features to handle the event.\n     * @param event\n     * @category Touch events\n     * @internal\n     */\n    onElementTouchStart(event) {\n        const\n            me       = this,\n            cellData = me.getCellDataFromEvent(event);\n        DomHelper.isTouchEvent = true;\n        if (event.touches.length === 1) {\n            me.longPressTimeout = me.setTimeout(() => {\n                me.onElementLongPress(event);\n                event.preventDefault();\n                me.longPressPerformed = true;\n            }, me.longPressTime);\n        }\n        if (cellData && !event.defaultPrevented) {\n            me.onFocusGesture(event);\n        }\n    }\n    /**\n     * Touch move, chain this function in features to handle the event.\n     * @param event\n     * @category Touch events\n     * @internal\n     */\n    onElementTouchMove(event) {\n        const\n            me          = this,\n            {\n                lastTouchTarget\n            }           = me,\n            touch       = event.changedTouches[0],\n            {\n                pageX,\n                pageY\n            }           = touch,\n            touchTarget = document.elementFromPoint(pageX, pageY);\n        if (me.longPressTimeout) {\n            me.clearTimeout(me.longPressTimeout);\n            me.longPressTimeout = null;\n        }\n        // Keep grid informed about mouseover/outs during touch-based dragging\n        if (touchTarget !== lastTouchTarget) {\n            if (lastTouchTarget) {\n                const mouseoutEvent = new MouseEvent('mouseout', ObjectHelper.copyProperties({\n                    relatedTarget : touchTarget,\n                    pointerType   : 'touch',\n                    bubbles       : true\n                }, touch, eventProps));\n                mouseoutEvent.preventDefault = () => event.preventDefault();\n                lastTouchTarget?.dispatchEvent(mouseoutEvent);\n            }\n            if (touchTarget) {\n                const mouseoverEvent = new MouseEvent('mouseover', ObjectHelper.copyProperties({\n                    relatedTarget : lastTouchTarget,\n                    pointerType   : 'touch',\n                    bubbles       : true\n                }, touch, eventProps));\n                mouseoverEvent.preventDefault = () => event.preventDefault();\n                touchTarget?.dispatchEvent(mouseoverEvent);\n            }\n        }\n        me.lastTouchTarget = touchTarget;\n    }\n    /**\n     * Touch end, chain this function in features to handle the event.\n     * @param event\n     * @category Touch events\n     * @internal\n     */\n    onElementTouchEnd(event) {\n        const me = this;\n        if (me.longPressPerformed) {\n            if (event.cancelable) {\n                event.preventDefault();\n            }\n            me.longPressPerformed = false;\n        }\n        if (me.longPressTimeout) {\n            me.clearTimeout(me.longPressTimeout);\n            me.longPressTimeout = null;\n        }\n    }\n    onElementLongPress(event) {}\n    //endregion\n    //region Mouse events\n    // Trigger events in same style when clicking, dblclicking and for contextmenu\n    triggerCellMouseEvent(name, event, cellData = this.getCellDataFromEvent(event)) {\n        const me = this;\n        // There is a cell\n        if (cellData) {\n            const\n                column    = me.columns.getById(cellData.columnId),\n                eventData = {\n                    grid         : me,\n                    record       : cellData.record,\n                    column,\n                    cellSelector : cellData.cellSelector,\n                    cellElement  : cellData.cellElement,\n                    target       : event.target,\n                    event\n                };\n            me.trigger('cell' + StringHelper.capitalize(name), eventData);\n            if (name === 'click') {\n                column.onCellClick?.(eventData);\n            }\n        }\n    }\n    /**\n     * Mouse down, chain this function in features to handle the event.\n     * @param event\n     * @category Mouse events\n     * @internal\n     */\n    onElementMouseDown(event) {\n        const\n            me       = this,\n            cellData = me.getCellDataFromEvent(event);\n        me.skipFocusSelection = true;\n        // If click was on a scrollbar or splitter, preventDefault to not steal focus\n        if (me.isScrollbarOrRowBorderOrSplitterClick(event)) {\n            event.preventDefault();\n        }\n        else {\n            me.triggerCellMouseEvent('mousedown', event, cellData);\n            // Browser event unification fires a mousedown on touch tap prior to focus.\n            if (cellData && !event.defaultPrevented) {\n                me.onFocusGesture(event);\n            }\n        }\n    }\n    isScrollbarOrRowBorderOrSplitterClick({ target, x, y }) {\n        // Normally cells catch the click, directly on row = user clicked border, which we ignore.\n        // Also ignore clicks on the virtual width element used to stretch fake scrollbar\n        if (target.closest('.b-grid-splitter') || target.matches('.b-grid-row, .b-virtual-width')) {\n            return true;\n        }\n        if (target.matches('.b-vertical-overflow')) {\n            const rect = target.getBoundingClientRect();\n            return x > rect.right - DomHelper.scrollBarWidth;\n        }\n        else if (target.matches('.b-horizontal-overflow')) {\n            const rect = target.getBoundingClientRect();\n            return y > rect.bottom - DomHelper.scrollBarWidth - 1; // -1 for height of virtualScrollerWidth element\n        }\n    }\n    /**\n     * Mouse move, chain this function in features to handle the event.\n     * @param event\n     * @category Mouse events\n     * @internal\n     */\n    onElementMouseMove(event) {\n        // Keep track of the last mouse position in case, due to OSX sloppy focusing,\n        // focus is moved into the browser before a mousedown is delivered.\n        // The cached mousemove event will provide the correct target in\n        // GridNavigation#onGridElementFocus.\n        this.mouseMoveEvent = event;\n    }\n    /**\n     * Mouse up, chain this function in features to handle the event.\n     * @param event\n     * @category Mouse events\n     * @internal\n     */\n    onElementMouseUp(event) {}\n    onElementPointerDown(event) {}\n    /**\n     * Pointer up, chain this function in features to handle the event.\n     * @param event\n     * @category Mouse events\n     * @internal\n     */\n    onElementPointerUp(event) {}\n    /**\n     * Called before {@link #function-onElementClick}.\n     * Fires 'beforeElementClick' event which can return false to cancel further onElementClick actions.\n     * @param event\n     * @fires beforeElementClick\n     * @category Mouse events\n     * @internal\n     */\n    onHandleElementClick(event) {\n        if (this.trigger('beforeElementClick', { event }) !== false) {\n            this.onElementClick(event);\n        }\n    }\n    /**\n     * Click, select cell on click and also fire 'cellClick' event.\n     * Chain this function in features to handle the dom event.\n     * @param event\n     * @fires cellClick\n     * @category Mouse events\n     * @internal\n     */\n    onElementClick(event) {\n        const\n            me       = this,\n            cellData = me.getCellDataFromEvent(event);\n        // There is a cell\n        if (cellData) {\n            me.triggerCellMouseEvent('click', event, cellData);\n        }\n    }\n    onFocusGesture(event) {\n        const\n            me                    = this,\n            { navigationEvent }   = me,\n            { target }            = event,\n            isContextMenu         = event.button === 2,\n            // Interaction with tree expand/collapse icons doesn't focus\n            isTreeExpander        = !isContextMenu && target.matches('.b-icon-tree-expand, .b-icon-tree-collapse'),\n            // Mac OS specific behaviour: when you right click a non-active window, the window does not receive focus, but the context menu is shown.\n            // So for Mac OS we treat the right click as a non-focusable action, if window is not active\n            isUnfocusedRightClick = !document.hasFocus() && BrowserHelper.isMac && isContextMenu;\n        // Tree expander clicks and contextmenus on unfocused windows don't focus\n        if (isTreeExpander || isUnfocusedRightClick) {\n            event.preventDefault();\n        }\n        else {\n            // Used by the GridNavigation mixin to detect what interaction event if any caused\n            // the focus to be moved. If it's a programmatic focus, there won't be one.\n            // Grid doesn't use a Navigator which maintains this property, so we need to set it.\n            me.navigationEvent = event;\n            const location = new Location(target);\n            // Context menu doesn't focus by default, so that needs to explicitly focus.\n            // If they're re-clicking the current focus, GridNavigation#focusCell\n            // still needs to know. It's a no-op, but it informs the GridSelection of the event.\n            if (isContextMenu || me.focusedCell?.equals(location)) {\n                let focusOptions;\n                // If current event is a MouseEvent and previous event is a TouchEvent on same target, this event is\n                // most likely a MouseEvent triggered by a TouchEvent, which should not trigger selection\n                if (globalThis.TouchEvent && event instanceof MouseEvent && navigationEvent instanceof TouchEvent &&\n                    target === navigationEvent.target\n                ) {\n                    focusOptions = { doSelect : false };\n                }\n                me.focusCell(location, focusOptions);\n            }\n        }\n    }\n    /**\n     * Double click, fires 'cellDblClick' event.\n     * Chain this function in features to handle the dom event.\n     * @param {Event} event\n     * @fires cellDblClick\n     * @category Mouse events\n     * @internal\n     */\n    onElementDblClick(event) {\n        const { target } = event;\n        this.triggerCellMouseEvent('dblClick', event);\n        if (target.classList.contains('b-grid-header-resize-handle')) {\n            const\n                header = target.closest('.b-grid-header'),\n                column = this.columns.getById(header.dataset.columnId);\n            column.resizeToFitContent();\n        }\n    }\n    /**\n     * Mouse over, adds 'hover' class to elements.\n     * @param event\n     * @fires mouseOver\n     * @category Mouse events\n     * @internal\n     */\n    onElementMouseOver(event) {\n        // bail out early if scrolling\n        if (!this.scrolling) {\n            const\n                me              = this,\n                { hoveredCell } = me,\n                // No hover effect needed if a mouse button is pressed (like when resizing window, region, or resizing something etc).\n                // NOTE: 'buttons' not supported in Safari\n                shouldHover     = (typeof event.buttons !== 'number' || event.buttons === 0) && event.pointerType !== 'touch';\n            let cellElement = event.target.closest('.b-grid-cell');\n            // If we are entering a grid row (which probably is a row border), we should hover\n            // cell/row above so not to get a blinking hovering, especially on column header\n            if (!cellElement && event.target.classList.contains('b-grid-row')) {\n                cellElement = DomHelper.childFromPoint(event.target, event.offsetX, event.offsetY - 2)?.closest('.b-grid-cell');\n            }\n            if (cellElement) {\n                if (shouldHover) {\n                    me.hoveredCell = cellElement;\n                }\n                if (hoveredCell !== me.hoveredCell) {\n                    me.triggerCellMouseEvent('mouseOver', event);\n                }\n            }\n            /**\n             * Mouse moved in over element in grid\n             * @event mouseOver\n             * @param {MouseEvent} event The native browser event\n             */\n            me.trigger('mouseOver', { event });\n        }\n    }\n    /**\n     * Mouse out, removes 'hover' class from elements.\n     * @param event\n     * @fires mouseOut\n     * @category Mouse events\n     * @internal\n     */\n    onElementMouseOut(event) {\n        const\n            me                        = this,\n            { target, relatedTarget } = event;\n        // If we have not moved onto a grid row\n        // (meaning over its border which is handled by getCellDataFromEvent)\n        // hover any new cell we are over.\n        if (relatedTarget && target.matches('.b-grid-cell') && !target.contains(relatedTarget)) {\n            if (!relatedTarget.matches('.b-grid-row')) {\n                me.hoveredCell = relatedTarget.closest('.b-grid-cell');\n            }\n        }\n        else if (!relatedTarget?.matches('.b-grid-row,.b-grid-cell') && !me.hoveredCell?.contains(relatedTarget)) {\n            me.hoveredCell = null;\n        }\n        // bail out early if scrolling\n        if (!me.scrolling) {\n            // Check that we are not within the same grid cell\n            if (relatedTarget?.closest('.b-grid-cell') !== target?.closest('.b-grid-cell')) {\n                if (target?.closest('.b-grid-cell')) {\n                    me.triggerCellMouseEvent('mouseOut', event);\n                }\n            }\n            /**\n             * Mouse moved out from element in grid\n             * @event mouseOut\n             * @param {MouseEvent} event The native browser event\n             */\n            me.trigger('mouseOut', { event });\n        }\n    }\n    // The may be chained in features\n    updateHoveredCell(cellElement, was) {\n        const\n            me                        = this,\n            { selectionMode }         = me,\n            rowNumberColumnId         = selectionMode.rowNumber && me.columns.find(c => c.type == 'rownumber')?.id,\n            checkboxSelectionColumnId = selectionMode.checkbox && me.checkboxSelectionColumn?.id;\n        // Clear last hovered cell\n        if (was) {\n            toggleHover(was, false);\n            // Also remove hovered class on checkcol, rownumbercol and column header\n            const\n                prevSelector      = DomDataStore.get(was),\n                { row : prevRow } = prevSelector;\n            if (prevRow && !prevRow.isDestroyed) {\n                setCellHover(rowNumberColumnId, prevRow, false);\n                setCellHover(checkboxSelectionColumnId, prevRow, false);\n            }\n            if (prevSelector?.columnId) {\n                toggleHover(me.columns.getById(prevSelector.columnId)?.element, false);\n            }\n        }\n        // Clears hovered row\n        // Only remove cls if row isn't destroyed\n        if (me._hoveredRow && !me._hoveredRow.isDestroyed) {\n            me._hoveredRow.removeCls('b-hover');\n        }\n        me._hoveredRow = null;\n        // Set hovered\n        if (cellElement && !me.scrolling) {\n            const\n                selector = DomDataStore.get(cellElement),\n                { row }  = selector;\n            if (row) {\n                // Set cell if cell selection mode is on\n                if (selectionMode.cell && selector.columnId !== rowNumberColumnId && selector.columnId !== checkboxSelectionColumnId) {\n                    const column = me.columns.getById(selector.columnId);\n                    toggleHover(cellElement);\n                    // In cell selection mode:\n                    // Also \"hover\" checkcolumn cell if such exists\n                    setCellHover(checkboxSelectionColumnId, row);\n                    // And also rownumbercolumn cell\n                    setCellHover(rowNumberColumnId, row);\n                    // And also column header\n                    if (column?.element && column.headerHoverable !== false) {\n                        toggleHover(column.element);\n                    }\n                }\n                // Else row\n                else {\n                    me._hoveredRow = row;\n                    row.addCls('b-hover');\n                }\n            }\n            else {\n                me.hoveredCell = null;\n            }\n        }\n    }\n    //endregion\n    //region Keyboard events\n    // Hooks on to keyMaps keydown-listener to be able to run before\n    keyMapOnKeyDown(event) {\n        if (this.element.contains(event.target)) {\n            this.onElementKeyDown(event);\n            super.keyMapOnKeyDown(event);\n        }\n    }\n    /**\n     * To catch all keydowns. For more specific keydown actions, use keyMap.\n     * @param event\n     * @category Keyboard events\n     * @internal\n     */\n    onElementKeyDown(event) {\n        // If some other function flagged the event as handled, we ignore it.\n        if (event.handled || !this.element.contains(event.target)) {\n            return;\n        }\n        const\n            me          = this,\n            // Read this to refresh cached reference in case this keystroke lead to the removal of current row\n            focusedCell = me.focusedCell;\n        if (focusedCell?.isCell && !focusedCell.isActionable) {\n            const\n                cellElement = focusedCell.cell;\n            // If a cell is focused and column is interested - call special callback\n            me.columns.getById(cellElement.dataset.columnId).onCellKeyDown?.({ event, cellElement });\n        }\n    }\n    undoRedoKeyPress(event) {\n        const { stm } = this.store;\n        if (stm && this.enableUndoRedoKeys && !this.features.cellEdit?.isEditing) {\n            stm.onUndoKeyPress(event);\n            return true;\n        }\n        return false;\n    }\n    // Trigger column.onCellClick when space bar is pressed\n    clickCellByKey(event) {\n        const\n            me          = this,\n            // Read this to refresh cached reference in case this keystroke lead to the removal of current row\n            focusedCell = me.focusedCell,\n            cellElement = focusedCell?.cell,\n            column      = me.columns.getById(cellElement.dataset.columnId);\n        if (focusedCell?.isCell && !focusedCell.isActionable) {\n            if (column.onCellClick) {\n                column.onCellClick({\n                    grid   : me,\n                    column,\n                    record : me.store.getById(focusedCell.id),\n                    cellElement,\n                    target : event.target,\n                    event\n                });\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Key press, chain this function in features to handle the dom event.\n     * @param event\n     * @category Keyboard events\n     * @internal\n     */\n    onElementKeyPress(event) {}\n    /**\n     * Key up, chain this function in features to handle the dom event.\n     * @param event\n     * @category Keyboard events\n     * @internal\n     */\n    onElementKeyUp(event) {}\n    //endregion\n    //region Other events\n    /**\n     * Context menu, chain this function in features to handle the dom event.\n     * In most cases, include ContextMenu feature instead.\n     * @param event\n     * @category Other events\n     * @internal\n     */\n    onElementContextMenu(event) {\n        const\n            me       = this,\n            cellData = me.getCellDataFromEvent(event);\n        // There is a cell\n        if (cellData) {\n            me.triggerCellMouseEvent('contextMenu', event, cellData);\n            // Focus on tap for touch events.\n            // Selection follows from focus.\n            if (DomHelper.isTouchEvent) {\n                me.onFocusGesture(event);\n            }\n        }\n    }\n    /**\n     * Overrides empty base function in View, called when view is resized.\n     * @fires resize\n     * @param element\n     * @param width\n     * @param height\n     * @param oldWidth\n     * @param oldHeight\n     * @category Other events\n     * @internal\n     */\n    onInternalResize(element, width, height, oldWidth, oldHeight) {\n        const me = this;\n        if (me._devicePixelRatio && me._devicePixelRatio !== globalThis.devicePixelRatio) {\n            // Pixel ratio changed, likely because of browser zoom. This affects the relative scrollbar width also\n            DomHelper.resetScrollBarWidth();\n        }\n        me._devicePixelRatio = globalThis.devicePixelRatio;\n        // cache to avoid recalculations in the middle of rendering code (RowManger#getRecordCoords())\n        me._bodyRectangle    = Rectangle.client(me.bodyContainer);\n        super.onInternalResize(...arguments);\n        if (height !== oldHeight) {\n            me._bodyHeight = me.bodyContainer.offsetHeight;\n            if (me.isPainted) {\n                // initial height will be set from render(),\n                // it reaches onInternalResize too early when rendering, headers/footers are not sized yet\n                me.rowManager.initWithHeight(me._bodyHeight);\n            }\n        }\n        me.refreshVirtualScrollbars();\n        if (width !== oldWidth) {\n            // Slightly delay to avoid resize loops.\n            me.setTimeout(() => {\n                if (!me.isDestroyed) {\n                    me.updateResponsive(width, oldWidth);\n                }\n            }, 0);\n        }\n    }\n    //endregion\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport GridFeatureManager from '../../feature/GridFeatureManager.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n/**\n * @module Grid/view/mixin/GridFeatures\n */\nconst validConfigTypes = {\n    string   : 1,\n    object   : 1,\n    function : 1 // used by CellTooltip\n};\n/**\n * Mixin for Grid that handles features. Features are plugins that add functionality to the grid. Feature classes should\n * register with Grid by calling {@link Grid.feature.GridFeatureManager#function-registerFeature-static registerFeature}. This\n * enables features to be specified and configured in grid\n * config.\n *\n * Define which features to use:\n *\n * ```javascript\n * // specify which features to use (note that some features are used by default)\n * const grid = new Grid({\n *   features: {\n *      sort: 'name',\n *      search: true\n *   }\n * });\n * ```\n *\n * Access a feature in use:\n *\n * ```javascript\n * grid.features.search.search('cat');\n * ```\n *\n * Basic example of implementing a feature:\n *\n * ```javascript\n * class MyFeature extends InstancePlugin {\n *\n * }\n *\n * GridFeatures.registerFeature(MyFeature);\n *\n * // using the feature\n * const grid = new Grid({\n *   features: {\n *     myFeature: true\n *   }\n * });\n * ```\n *\n * ## Enable and disable features at runtime\n *\n * Each feature is either \"enabled\" (included by default), or \"off\" (excluded completely). You can always check the docs\n * of a specific feature to find out how it is configured by default.\n *\n * Features which are \"off\" completely are not available and cannot be enabled at runtime.\n *\n * For a feature that is **off** by default that you want to enable later during runtime,\n * configure it with `disabled : true`:\n * ```javascript\n * const grid = new Grid({\n *      featureName : {\n *          disabled : true // on and disabled, can be enabled later\n *      }\n * });\n *\n * // enable the feature\n * grid.featureName.disabled = false;\n * ```\n *\n * If the feature is **disabled** by default, and you want to include and enable the feature, configure it as `true`:\n * ```javascript\n * const grid = new Grid({\n *      featureName : true // on and enabled, can be disabled later\n * });\n *\n * // disable the feature\n * grid.featureName.disabled = true;\n * ```\n *\n * If the feature is **on** by default, but you want to turn it **off**, configure it as `false`:\n * ```javascript\n * const grid = new Grid({\n *      featureName : false // turned off, not included at all\n * });\n * ```\n *\n * If the feature is **enabled** by default and you have no need of reconfiguring it,\n * you can omit the feature configuration.\n *\n * @mixin\n */\nexport default Target => class GridFeatures extends (Target || Base) {\n    static get $name() {\n        return 'GridFeatures';\n    }\n    //region Init\n    /**\n     * Specify which features to use on the grid. Most features accepts a boolean, some also accepts a config object.\n     * Please note that if you are not using the bundles you might need to import the features you want to use.\n     *\n     * ```javascript\n     * const grid = new Grid({\n     *     features : {\n     *         stripe : true,   // Enable stripe feature\n     *         sort   : 'name', // Configure sort feature\n     *         group  : false   // Disable group feature\n     *     }\n     * }\n     * ```\n     *\n     * @config {Object} features\n     * @category Common\n     */\n    /**\n     * Map of the features available on the grid. Use it to access them on your grid object\n     *\n     * ```javascript\n     * grid.features.group.expandAll();\n     * ```\n     *\n     * @readonly\n     * @member {Object} features\n     * @category Common\n     */\n    set features(features) {\n        const\n            me              = this,\n            defaultFeatures = GridFeatureManager.getInstanceDefaultFeatures(this);\n        features = me._features = ObjectHelper.assign({}, features);\n        // default features, enabled unless otherwise specified\n        if (defaultFeatures) {\n            Object.keys(defaultFeatures).forEach(feature => {\n                if (!(feature in features)) {\n                    features[feature] = true;\n                }\n            });\n        }\n        // We *prime* the features so that if any configuration code accesses a feature, it\n        // will self initialize, but if not, they will remain in a primed state until afterConfigure.\n        const registeredInstanceFeatures = GridFeatureManager.getInstanceFeatures(this);\n        for (const featureName of Object.keys(features)) {\n            const config = features[featureName];\n            // Create feature initialization property if config is truthy.\n            // Config must be a valid configuration value for the feature class.\n            if (config) {\n                const throwIfError = !globalThis.__bryntum_code_editor_changed;\n                // Feature configs name must start with lowercase letter to be valid\n                if (StringHelper.uncapitalize(featureName) !== featureName) {\n                    const errorMessage = `Invalid feature name '${featureName}', must start with a lowercase letter`;\n                    if (throwIfError) {\n                        throw new Error(errorMessage);\n                    }\n                    console.error(errorMessage);\n                    me._errorDuringConfiguration = errorMessage;\n                }\n                const featureClass = registeredInstanceFeatures[featureName];\n                if (!featureClass) {\n                    const errorMessage = `Feature '${featureName}' not available, make sure you have imported it`;\n                    if (throwIfError) {\n                        throw new Error(errorMessage);\n                    }\n                    console.error(errorMessage);\n                    me._errorDuringConfiguration = errorMessage;\n                    return;\n                }\n                // Create a self initializing property on the features object named by the feature name.\n                // when accessed, it will create and return the real feature.\n                // Now, if some Feature initialization code attempt to access a feature which has not yet been initialized\n                // it will be initialized just in time.\n                Reflect.defineProperty(features, featureName, me.createFeatureInitializer(features, featureName,\n                    featureClass, config));\n            }\n        }\n    }\n    get features() {\n        return this._features;\n    }\n    createFeatureInitializer(features, featureName, featureClass, config) {\n        const\n            constructorArgs = [this],\n            construct       = featureClass.prototype.construct;\n        // Config arg must be processed if feature is just requested with true\n        // so that default configurable values are processed.\n        if (config === true) {\n            config = {};\n        }\n        // Only pass config if there is one.\n        // The constructor(config = {}) only works for undefined config\n        if (validConfigTypes[typeof config]) {\n            constructorArgs[1] = config;\n        }\n        return {\n            configurable : true,\n            get() {\n                // Delete this defined property and replace it with the Feature instance.\n                delete features[featureName];\n                // Ensure the feature is injected into the features object before initialization\n                // so that it is available from call chains from its initialization.\n                featureClass.prototype.construct = function(...args) {\n                    features[featureName] = this;\n                    construct.apply(this, args);\n                    featureClass.prototype.construct = construct;\n                };\n                // Return the Feature instance\n                return new featureClass(...constructorArgs);\n            }\n        };\n    }\n    //endregion\n    //region Other stuff\n    /**\n     * Check if a feature is included\n     * @param {String} name Feature name, as registered with `GridFeatureManager.registerFeature()`\n     * @returns {Boolean}\n     * @category Misc\n     */\n    hasFeature(name) {\n        const { features } = this;\n        if (features) {\n            const featureProp = Object.getOwnPropertyDescriptor(this.features, name);\n            if (featureProp) {\n                // Do not actually force creation of the feature\n                return Boolean(featureProp.value || featureProp.get);\n            }\n        }\n        return false;\n    }\n    hasActiveFeature(name) {\n        return Boolean(this.features?.[name] && !this.features?.[name].disabled);\n    }\n    //endregion\n    //region Extract config\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    // It extracts the current configs for the features\n    getConfigValue(name, options) {\n        if (name === 'features') {\n            const result = {};\n            for (const feature in this.features) {\n                // Feature might be configured as `false`\n                const featureConfig = this.features[feature]?.getCurrentConfig?.(options);\n                if (featureConfig) {\n                    // Use `true` for empty feature configs `{ stripe : true }`\n                    if (ObjectHelper.isEmpty(featureConfig)) {\n                        // Exclude default features to not spam the config\n                        if (!GridFeatureManager.isDefaultFeatureForInstance(this.features[feature].constructor, this)) {\n                            result[feature] = true;\n                        }\n                    }\n                    else {\n                        result[feature] = featureConfig;\n                    }\n                }\n                else {\n                    result[feature] = false;\n                }\n            }\n            return result;\n        }\n        return super.getConfigValue(name, options);\n    }\n    //endregion\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n/**\n * @module Grid/view/mixin/GridResponsive\n */\n/**\n * Simplifies making grid responsive. Supply levels as {@link #config-responsiveLevels} config, default levels are:\n * <dl>\n * <dt>small <dd>< 400px,\n * <dt>medium <dd>< 600px\n * <dt>large <dd>> 600px\n * </dl>\n *\n * Columns can define configs per level to be resized etc:\n *\n * ```javascript\n * let grid = new Grid({\n *   responsiveLevels: {\n *     small: 300,\n *     medium: 400,\n *     large: '*' // everything above 400\n *   },\n *\n *   columns: [\n *     {\n *       field: 'name',\n *       text: 'Name',\n *       responsiveLevels: {\n *         small: { hidden: true },\n *         '*': { hidden: false } // all other levels\n *       }\n *     },\n *     { field: 'xx', ... }\n *   ]\n * });\n * ```\n *\n * It is also possible to give a [Grid state](#Grid/view/mixin/GridState) object instead of a level width, but in that\n * case the object must contain a `levelWidth` property:\n *\n * ```javascript\n * let grid = new Grid({\n *   responsiveLevels: {\n *     small: {\n *       // Width is required\n *       levelWidth : 400,\n *       // Other configs are optional, see GridState for available options\n *       rowHeight  : 30\n *     },\n *     medium : {\n *       levelWidth : 600,\n *       rowHeight  : 40\n *     },\n *     large: {\n *       levelWidth : '*', // everything above 300\n *       rowHeight  : 45\n *     }\n *   }\n * });\n * ```\n * {@inlineexample Grid/view/mixin/Responsive.js}\n *\n * @demo Grid/responsive\n *\n * @mixin\n */\nexport default Target => class GridResponsive extends (Target || Base) {\n    static get $name() {\n        return 'GridResponsive';\n    }\n    static get defaultConfig() {\n        return {\n            /**\n             * \"Break points\" for which responsive config to use for columns and css.\n             * @config {Object<String,Number|String>}\n             * @category Misc\n             * @default { small : 400, medium : 600, large : '*' }\n             */\n            responsiveLevels : Object.freeze({\n                small  : 400,\n                medium : 600,\n                large  : '*'\n            })\n        };\n    }\n    /**\n     * Find closes bigger level, aka level we want to use.\n     * @private\n     * @category Misc\n     */\n    getClosestBiggerLevel(width) {\n        const\n            me     = this,\n            levels = Object.keys(ObjectHelper.assign({}, me.responsiveLevels));\n        let useLevel     = null,\n            minDelta     = 99995,\n            biggestLevel = null;\n        levels.forEach(level => {\n            let levelSize = me.responsiveLevels[level];\n            // responsiveLevels can contains config objects, in which case we should use width from it\n            if (!['number', 'string'].includes(typeof levelSize)) {\n                levelSize = levelSize.levelWidth;\n            }\n            if (levelSize === '*') {\n                biggestLevel = level;\n            }\n            else if (width < levelSize) {\n                const delta = levelSize - width;\n                if (delta < minDelta) {\n                    minDelta = delta;\n                    useLevel = level;\n                }\n            }\n        });\n        return useLevel || biggestLevel;\n    }\n    /**\n     * Get currently used responsive level (as string)\n     * @property {String}\n     * @readonly\n     * @category Misc\n     */\n    get responsiveLevel() {\n        return this.getClosestBiggerLevel(this.width);\n    }\n    /**\n     * Check if resize lead to a new responsive level and take appropriate actions\n     * @private\n     * @fires responsive\n     * @param width\n     * @param oldWidth\n     * @category Misc\n     */\n    updateResponsive(width, oldWidth) {\n        const me       = this,\n            oldLevel = me.getClosestBiggerLevel(oldWidth),\n            level    = me.getClosestBiggerLevel(width);\n        // On first render oldWidth is 0, in such case we need to apply level anyway\n        if (oldWidth === 0 || oldLevel !== level) {\n            // Level might be a state object\n            const levelConfig = me.responsiveLevels[level];\n            if (!['number', 'string'].includes(typeof levelConfig)) {\n                me.applyState(levelConfig);\n            }\n            // check columns for responsive config\n            me.columns.forEach(column => {\n                const levels = column.responsiveLevels;\n                if (levels) {\n                    if (levels[level]) {\n                        // using state to apply responsive config, since it already does what we want...\n                        column.applyState(levels[level]);\n                    }\n                    else if (levels['*']) {\n                        column.applyState(levels['*']);\n                    }\n                }\n            });\n            me.element.classList.remove('b-responsive-' + oldLevel);\n            me.element.classList.add('b-responsive-' + level);\n            /**\n             * Grid resize lead to a new responsive level being applied\n             * @event responsive\n             * @param {Grid.view.Grid} grid Grid that was resized\n             * @param {String} level New responsive level (small, large, etc)\n             * @param {Number} width New width in px\n             * @param {String} oldLevel Old responsive level\n             * @param {Number} oldWidth Old width in px\n             */\n            me.trigger('responsive', { level, width, oldLevel, oldWidth });\n        }\n    }\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport GlobalEvents from '../../../Core/GlobalEvents.js';\nimport ArrayHelper from '../../../Core/helper/ArrayHelper.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport Collection from '../../../Core/util/Collection.js';\nimport ColumnStore from '../../data/ColumnStore.js';\nimport Location from '../../util/Location.js';\nimport '../../column/RowNumberColumn.js';\nconst\n    validIdTypes     = {\n        string : 1,\n        number : 1\n    },\n    isDataLoadAction = {\n        dataset : 1,\n        batch   : 1\n    };\n/**\n * @module Grid/view/mixin/GridSelection\n */\n/**\n * A mixin for Grid that handles row and cell selection. See {@link #config-selectionMode} for details on how to control\n * what should be selected (rows or cells)\n *\n * ```javascript\n * // select a row\n * grid.selectedRow = 7;\n *\n * // select a cell\n * grid.selectedCell = { id: 5, columnId: 'column1' }\n *\n * // select a record\n * grid.selectedRecord = grid.store.last;\n *\n * // select multiple records by ids\n * grid.selectedRecords = [1, 2, 4, 6]\n * ```\n *\n * @mixin\n */\nexport default Target => class GridSelection extends (Target || Base) {\n    static get $name() {\n        return 'GridSelection';\n    }\n    static configurable = {\n        /**\n         * The selection settings, where you can set these boolean flags to control what is selected. Options below:\n         * @config {Object} selectionMode\n         * @param {Boolean} selectionMode.cell Set to `true` to enable cell selection. This takes precedence over\n         * row selection, but rows can still be selected programmatically or with checkbox or RowNumber selection.\n         * Required for `column` selection\n         * @param {Boolean} selectionMode.multiSelect Allow multiple selection with ctrl and shift+click or with\n         * `checkbox` selection. Required for `dragSelect` and `column` selection\n         * @param {Boolean|CheckColumnConfig} selectionMode.checkbox Set to `true` to add a checkbox selection column to\n         * the grid, or pass a config object for the {@link Grid.column.CheckColumn}\n         * @param {Number|String} selectionMode.checkboxIndex Positions the checkbox column at the provided index or to\n         * the right of a provided column id. Defaults to 0 or to the right of an included `RowNumberColumn`\n         * @param {Boolean} selectionMode.checkboxOnly Select rows only when clicking in the checkbox column. Requires\n         * cell selection config to be `false` and checkbox to be set to `true`. This setting was previously named\n         * `rowCheckboxSelection`\n         * @param {Boolean} selectionMode.showCheckAll Set to `true` to add a checkbox to the selection column header to\n         * select/deselect all rows. Requires checkbox to also be set to `true`\n         * @param {Boolean} selectionMode.deselectFilteredOutRecords Set to `true` to deselect records when they are\n         * filtered out\n         * @param {Boolean|String} selectionMode.includeChildren Set to `true` to also select/deselect child nodes\n         * when a parent node is selected by toggling the checkbox. Set to `always` to always select/deselect child\n         * nodes.\n         * @param {Boolean|'all'|'some'} selectionMode.includeParents Set to `all` or `true` to auto select\n         * parent if all its children gets selected. If one gets deselected, the parent will also be deselected. Set to\n         * 'some' to select parent if one of its children gets selected. The parent will be deselected if all children\n         * gets deselected.\n         * @param {Boolean} selectionMode.preserveSelectionOnPageChange In `row` selection mode, this flag controls\n         * whether the Grid should preserve its selection when loading a new page of a paged data store. Defaults to\n         * `false`\n         * @param {Boolean} selectionMode.preserveSelectionOnDatasetChange In `row` selection mode, this flag\n         * controls whether the Grid should preserve its selection of cells / rows when loading a new dataset\n         * (assuming the selected records are included in the newly loaded dataset)\n         * @param {Boolean} selectionMode.deselectOnClick Toggles whether the Grid should deselect a selected row or\n         * cell when clicking it\n         * @param {Boolean} selectionMode.dragSelect Set to `true` to enable multiple selection by dragging.\n         * Requires `multiSelect` to also be set to `true`. Also requires the {@link Grid.feature.RowReorder} feature\n         * to be set to {@link Grid.feature.RowReorder#config-gripOnly}.\n         * @param {Boolean} selectionMode.selectOnKeyboardNavigation Set to `false` to disable auto-selection by keyboard\n         * navigation. This will activate the `select` keyboard shortcut.\n         * @param {Boolean} selectionMode.column Set to `true` to be able to select whole columns of cells by clicking the header.\n         * Requires cell to be set to `true`\n         * @param {Boolean|RowNumberColumnConfig} selectionMode.rowNumber Set to `true` or a config object to add a RowNumberColumn\n         * which, when clicked, selects the row.\n         * @param {Boolean} selectionMode.selectRecordOnCell Set to `false` not to include the record in the\n         * `selectedRecords` array when one of the record row's cells is selected.\n         * @default\n         * @category Selection\n         */\n        selectionMode : {\n            cell                             : false,\n            multiSelect                      : true,\n            checkboxOnly                     : false,\n            checkbox                         : false,\n            checkboxPosition                 : null,\n            showCheckAll                     : false,\n            deselectFilteredOutRecords       : false,\n            includeChildren                  : false,\n            includeParents                   : false,\n            preserveSelectionOnPageChange    : false,\n            preserveSelectionOnDatasetChange : true,\n            deselectOnClick                  : false,\n            dragSelect                       : false,\n            selectOnKeyboardNavigation       : true,\n            column                           : false,\n            rowNumber                        : false,\n            selectRecordOnCell               : true\n        },\n        keyMap : {\n            'Shift+ArrowUp'    : 'extendSelectionUp',\n            'Shift+ArrowDown'  : 'extendSelectionDown',\n            'Shift+ArrowLeft'  : 'extendSelectionLeft',\n            'Shift+ArrowRight' : 'extendSelectionRight',\n            ' '                : { handler : 'toggleSelection', weight : 10 }\n        },\n        selectedRecordCollection : {},\n        selectionDisabled : false\n    };\n    construct(config) {\n        this._selectedCells = [];\n        this._selectedRows  = [];\n        super.construct(config);\n        if (config?.selectedRecords) {\n            this.selectedRecords = config.selectedRecords;\n        }\n    }\n    //region Init\n    getDefaultGridSelection(clas) {\n        if (clas.$name === 'GridSelection') {\n            return clas.configurable.selectionMode;\n        }\n        else if (clas.superclass) {\n            return this.getDefaultGridSelection(clas.superclass);\n        }\n    }\n    changeSelectionMode(mode) {\n        const me = this;\n        // If changing the selectionMode config object after creation\n        if (me.selectionMode) {\n            ObjectHelper.assign(me.selectionMode, mode);\n            return me.selectionMode;\n        }\n        me.$defaultGridSelection = me.getDefaultGridSelection(me.constructor);\n        // Wraps changeSelectionMode object in a proxy to monitor property changes.\n        return new Proxy(mode, {\n            set(obj, prop, value) {\n                const old = ObjectHelper.assign({}, obj);\n                obj[prop] = value;\n                // Calls selectionMode's update method on property change\n                me.updateSelectionMode(obj, old);\n                return true;\n            }\n        });\n    }\n    /**\n     * The selectionMode configuration has been changed.\n     * @event selectionModeChange\n     * @param {Object} selectionMode The new {@link #config-selectionMode}\n     */\n    // Will be called if selectionMode config object changes or if one of its properties changes\n    updateSelectionMode(mode, oldMode = this.$defaultGridSelection) {\n        const\n            me             = this,\n            {\n                columns,\n                checkboxSelectionColumn\n            }              = me,\n            changed        = {},\n            { rowReorder } = me.features;\n        for (const property in mode) {\n            if (mode[property] != oldMode[property]) {\n                changed[property] = mode[property];\n            }\n        }\n        // Backwards compatibility. Remove on 7.X?\n        if (mode.rowCheckboxSelection && !mode.checkboxOnly) {\n            mode.checkboxOnly = true;\n            delete mode.rowCheckboxSelection;\n        }\n        // If column config has been activated, activate cell and multiSelect\n        if (changed.column) {\n            mode.cell        = true;\n            mode.multiSelect = true;\n        }\n        // If cell config has been activated, deactivate checkboxOnly\n        if (changed.cell) {\n            mode.checkboxOnly = false;\n        }\n        // If cell config has been deactivated, deactivate column\n        if (changed.cell === false) {\n            mode.column = false;\n        }\n        // If checkboxOnly config has been activated, activate checkbox and deactivate cell\n        if (changed.checkboxOnly) {\n            if (!mode.checkbox) {\n                // checkbox can be a CheckboxColumnConfig\n                mode.checkbox = true;\n            }\n            mode.cell = false;\n        }\n        // If checkbox config has been deactivated, deactivate checkboxOnly and showCheckAll\n        if (changed.checkbox === false) {\n            changed.checkboxOnly = false;\n            changed.showCheckAll = false;\n        }\n        // If showCheckAll has been activated, activate checkbox and multiselect\n        if (changed.showCheckAll) {\n            mode.checkbox    = mode.checkbox || true;\n            mode.multiSelect = true;\n        }\n        // If includeChildren config has been activated, activate multiselect\n        if (changed.includeChildren || changed.includeParents) {\n            mode.multiSelect = true;\n        }\n        // If multiSelect has been deactivated, deactivate column, showCheckAll, dragSelect and includeChildren\n        if (changed.multiSelect === false) {\n            mode.column = mode.showCheckAll = mode.dragSelect = mode.includeChildren = mode.includeParents = false;\n        }\n        if (changed.dragSelect) {\n            if (rowReorder?.enabled && rowReorder.gripOnly !== true) {\n                rowReorder.showGrip = rowReorder.gripOnly = true;\n            }\n            mode.multiSelect                = true;\n            me._selectionListenersDetachers = {};\n        }\n        if (changed.dragSelect === false && me._selectionListenersDetachers) {\n            me._selectionListenersDetachers.selectiondrag?.();\n            delete me._selectionListenersDetachers.selectiondrag;\n        }\n        // Deselect all when switching between row or cell selection mode\n        // Deselect all when switching from multiselect to singleselect\n        // Deselect all when changing deselectFilteredOutRecords\n        if (oldMode && (\n            changed.cell !== undefined ||\n            changed.deselectFilteredOutRecords !== undefined ||\n            changed.multiSelect !== undefined\n        )) {\n            me.deselectAll();\n        }\n        // Row number selection\n        if (changed.rowNumber) {\n            if (!columns.findRecord('type', 'rownumber')) {\n                columns.insert(0, {\n                    ...(typeof mode.rowNumber == 'object' ? mode.rowNumber : {}),\n                    type : 'rownumber'\n                });\n                me._selectionAddedRowNumberColumn = true;\n            }\n        }\n        else if (changed.rowNumber === false && me._selectionAddedRowNumberColumn) {\n            columns.remove(columns.findRecord('type', 'rownumber'));\n            delete me._selectionAddedRowNumberColumn;\n        }\n        // Add or remove checkbox column\n        if (mode.checkbox !== oldMode?.checkbox ||\n            (mode.checkbox && (mode.showCheckAll !== oldMode?.showCheckAll))\n        ) {\n            // See to it that were done configuring when initCheckboxSelection is called.\n            if (me.isConfiguring) {\n                me.shouldInitCheckboxSelection = true;\n            }\n            else {\n                if (oldMode) {\n                    me.deselectAll();\n                }\n                me.initCheckboxSelection();\n            }\n        }\n        // If only checkboxIndex has changed\n        if (oldMode && mode.checkbox && oldMode.checkbox &&\n            mode.checkboxIndex !== oldMode.checkboxIndex && checkboxSelectionColumn) {\n            checkboxSelectionColumn.parent.insertChild(checkboxSelectionColumn, columns.getAt(me.checkboxSelectionColumnInsertIndex));\n        }\n        me.trigger('selectionModeChange', ObjectHelper.clone(mode));\n        me.afterSelectionModeChange(mode);\n    }\n    afterConfigure() {\n        // See to it that were done configuring when initCheckboxSelection is called.\n        if (this.shouldInitCheckboxSelection) {\n            this.shouldInitCheckboxSelection = false;\n            this.initCheckboxSelection();\n        }\n        super.afterConfigure();\n    }\n    initCheckboxSelection() {\n        const\n            me           = this,\n            {\n                selectionMode,\n                columns,\n                checkboxSelectionColumn\n            }            = me,\n            { checkbox } = selectionMode;\n        // Always remove checkbox column when config changes\n        if (checkboxSelectionColumn) {\n            // Need to remove this handle because GridBase restores it if it exists.\n            me.checkboxSelectionColumn = null;\n            columns.remove(checkboxSelectionColumn);\n        }\n        // Inject our CheckColumn into the ColumnStore\n        if (checkbox) {\n            const\n                checkColumnClass = ColumnStore.getColumnClass('check'),\n                config           = checkbox === true ? null : checkbox;\n            if (!checkColumnClass) {\n                throw new Error('CheckColumn must be imported for checkbox selection mode to work');\n            }\n            const col = me.checkboxSelectionColumn = new checkColumnClass(ObjectHelper.assign({\n                id           : `${me.id}-selection-column`,\n                width        : '4em',\n                minWidth     : '4em', // Needed because 4em is below Column's default minWidth\n                field        : null,\n                sortable     : false,\n                filterable   : false,\n                hideable     : false,\n                cellCls      : 'b-checkbox-selection',\n                // Always put the checkcolumn in the first region\n                region       : me.items?.[0]?.region,\n                showCheckAll : selectionMode.showCheckAll,\n                draggable    : false,\n                resizable    : false,\n                widgets      : [{\n                    type          : 'checkbox',\n                    valueProperty : 'checked',\n                    ariaLabel     : 'L{Checkbox.toggleRowSelect}'\n                }]\n            }, config), columns, { isSelectionColumn : true });\n            col.meta.depth = 0;\n            // This is assigned in Column.js for normal columns\n            col._grid      = me;\n            // Override renderer to inject the rendered record's selected status into the value\n            const checkboxRenderer = col.renderer;\n            col.renderer = renderData => {\n                renderData.value = me.isSelected(renderData.record);\n                checkboxRenderer.call(col, renderData);\n            };\n            col.ion({\n                toggle    : 'onCheckChange',\n                toggleAll : 'onCheckAllChange',\n                thisObj   : me\n            });\n            columns.insert(me.checkboxSelectionColumnInsertIndex, col);\n        }\n    }\n    // Used internally to get the index where to insert checkboxselectioncolumn\n    // Default : Insert the checkbox after any rownumber column. If not there, -1 means in at 0.\n    // If provided, insert at provided index\n    get checkboxSelectionColumnInsertIndex() {\n        const\n            { columns }       = this;\n        let { checkboxIndex } = this.selectionMode;\n        if (!checkboxIndex) {\n            checkboxIndex = columns.indexOf(columns.findRecord('type', 'rownumber')) + 1;\n        }\n        else if (typeof checkboxIndex === 'string') {\n            checkboxIndex = columns.indexOf(columns.getById(checkboxIndex));\n        }\n        return checkboxIndex;\n    }\n    //endregion\n    // region Events docs & Hooks\n    /**\n     * The selection has been changed.\n     * @event selectionChange\n     * @param {'select'|'deselect'} action `'select'`/`'deselect'`\n     * @param {'row'|'cell'} mode `'row'`/`'cell'`\n     * @param {Grid.view.Grid} source\n     * @param {Core.data.Model[]} deselected The records deselected in this operation.\n     * @param {Core.data.Model[]} selected The records selected in this operation.\n     * @param {Core.data.Model[]} selection The records in the new selection.\n     * @param {Grid.util.Location[]} deselectedCells The cells deselected in this operation.\n     * @param {Grid.util.Location[]} selectedCells The cells selected in this operation.\n     * @param {Grid.util.Location[]} cellSelection The cells in the new selection.\n     */\n    /**\n     * Fires before the selection changes. Returning `false` from a listener prevents the change\n     * @event beforeSelectionChange\n     * @preventable\n     * @param {String} action `'select'`/`'deselect'`\n     * @param {'row'|'cell'} mode `'row'`/`'cell'`\n     * @param {Grid.view.Grid} source\n     * @param {Core.data.Model[]} deselected The records to be deselected in this operation.\n     * @param {Core.data.Model[]} selected The records to be selected in this operation.\n     * @param {Core.data.Model[]} selection The records in the current selection, before applying `selected` and\n     * `deselected`\n     * @param {Grid.util.Location[]} deselectedCells The cells to be deselected in this operation.\n     * @param {Grid.util.Location[]} selectedCells The cells to be selected in this operation.\n     * @param {Grid.util.Location[]} cellSelection  The cells in the current selection, before applying `selectedCells`\n     * and `deselectedCells`\n     */\n    afterSelectionChange() {}\n    afterSelectionModeChange() {}\n    // endregion\n    // region selectedRecordCollection\n    changeSelectedRecordCollection(collection) {\n        if (collection?.isCollection) {\n            if (!collection.owner) {\n                collection.owner = this;\n            }\n            return collection;\n        }\n        return Collection.new(collection, { owner : this });\n    }\n    updateSelectedRecordCollection(collection) {\n        collection.ion({\n            change  : 'onSelectedRecordCollectionChange',\n            thisObj : this\n        });\n    }\n    onSelectedRecordCollectionChange({ added = [], removed }) {\n        if (this.selectedRecordCollection._fromSelection !== this) {\n            // Filter out unselectable rows\n            added = added.filter(row => this.isSelectable(row));\n            this.performSelection({\n                selectedCells     : [],\n                deselectedCells   : [],\n                selectedRecords   : added,\n                deselectedRecords : removed\n            });\n        }\n    }\n    changeSelectedRecordCollectionSilent(fn) {\n        this.selectedRecordCollection._fromSelection = this;\n        const result                                 = fn(this.selectedRecordCollection);\n        delete this.selectedRecordCollection._fromSelection;\n        return result;\n    }\n    // endregion\n    // region Store\n    bindStore(store) {\n        this.detachListeners('selectionStoreFilter');\n        store.ion({\n            name    : 'selectionStoreFilter',\n            filter  : 'onStoreFilter',\n            thisObj : this\n        });\n        super.bindStore?.(store);\n    }\n    unbindStore(oldStore) {\n        this.detachListeners('selectionStoreFilter');\n        super.unbindStore(oldStore);\n    }\n    onStoreFilter({ source }) {\n        const\n            me       = this,\n            deselect = [];\n        // Look for selected records which is not in the store\n        for (const selectedRecord of me.selectedRows) {\n            if (!source.includes(selectedRecord)) {\n                // Should be deselected\n                deselect.push(selectedRecord);\n            }\n        }\n        // Deselects\n        const selectionChange = me.prepareSelection(me.selectionMode.deselectFilteredOutRecords ? deselect : []);\n        // If cell mode, always deselect cells\n        if (me.isCellSelectionMode) {\n            const { deselectedCells } = me.prepareSelection(me.getSelectedCellsForRecords(deselect));\n            if (deselectedCells?.length) {\n                selectionChange.deselectedCells = (selectionChange.deselectedCells || []).concat(deselectedCells);\n            }\n        }\n        if (selectionChange.deselectedCells.length || selectionChange.deselectedRecords.length) {\n            // Trigger deselect event\n            me.performSelection(selectionChange, false);\n            me.updateCheckboxHeader();\n        }\n    }\n    /**\n     * Triggered from Grid view when the id of a record has changed.\n     * Update the collection indices.\n     * @private\n     * @category Selection\n     */\n    onStoreRecordIdChange({ record, oldValue }) {\n        // If the next mixin up the inheritance chain has an implementation, call it\n        super.onStoreRecordIdChange?.(...arguments);\n        const item = this.selectedRecordCollection.get(oldValue);\n        // having the record registered by the oldValue means we need to rebuild indices\n        if (item === record) {\n            this.selectedRecordCollection.rebuildIndices();\n        }\n    }\n    /**\n     * Triggered from Grid view when records get removed from the store.\n     * Deselects all records which have been removed.\n     * @private\n     * @category Selection\n     */\n    onStoreRemove(event) {\n        // If the next mixin up the inheritance chain has an implementation, call it\n        super.onStoreRemove?.(event);\n        if (!event.isCollapse) {\n            const\n                me                = this,\n                deselectedRecords = event.records.filter(rec => this.isSelected(rec));\n            if (deselectedRecords.length) {\n                const selectionChange = me.prepareSelection(deselectedRecords);\n                // If cell selection mode, also deselect cells for removed records\n                // No need to update ui as grid will refresh\n                if (me.isCellSelectionMode) {\n                    const { deselectedCells } = me.prepareSelection(me.getSelectedCellsForRecords(deselectedRecords));\n                    if (deselectedCells?.length) {\n                        selectionChange.deselectedCells = (selectionChange.deselectedCells || []).concat(deselectedCells);\n                    }\n                }\n                me.performSelection(selectionChange);\n            }\n        }\n    }\n    /**\n     * Triggered from Grid view when the store changes. This might happen\n     * if store events are batched and then resumed.\n     * Deselects all records which have been removed.\n     * @private\n     * @category Selection\n     */\n    onStoreDataChange({ action, source : store }) {\n        const\n            me                = this,\n            { selectionMode } = me;\n        let selectionChange;\n        // If the next mixin up the inheritance chain has an implementation, call it\n        super.onStoreDataChange?.(...arguments);\n        if (action === 'pageLoad') {\n            // on page load, clear selection if not `preserverSelectionOnPageChange` is true\n            if (!selectionMode.preserveSelectionOnPageChange) {\n                selectionChange = me.prepareSelection(null, null, true);\n            }\n            // For paged grid scenario, we need to update the check-all checkbox in the checkbox column header\n            // as we move between store pages\n            me.updateCheckboxHeader();\n        }\n        else if (isDataLoadAction[action]) {\n            const deselect = [];\n            if (selectionMode.preserveSelectionOnDatasetChange === false) {\n                selectionChange = me.prepareSelection(null, null, true);\n            }\n            else {\n                // Update selected records\n                deselect.push(...me.changeSelectedRecordCollectionSilent(c => c.match(store.storage)));\n                for (const selectedCell of me._selectedCells) {\n                    if (!store.getById(selectedCell.id)) {\n                        deselect.push(selectedCell);\n                    }\n                }\n                selectionChange = me.prepareSelection(deselect);\n            }\n        }\n        if (selectionChange && (selectionChange.deselectAll || selectionChange.deselectedCells.length || selectionChange.deselectedRecords.length || selectionChange.selectedCells.length || selectionChange.selectedRecords.length)) {\n            me.performSelection(selectionChange, false);\n            me.updateCheckboxHeader();\n        }\n    }\n    /**\n     * Triggered from Grid view when all records get removed from the store.\n     * Deselects all records.\n     * @private\n     * @category Selection\n     */\n    onStoreRemoveAll() {\n        // If the next mixin up the inheritance chain has an implementation, call it\n        super.onStoreRemoveAll?.();\n        this.performSelection(this.prepareSelection(null, null, true), false);\n    }\n    //endregion\n    // region Checkbox selection\n    onCheckChange({ checked, record, checkbox }) {\n        const\n            me              = this,\n            { multiSelect } = me.selectionMode,\n            deselectAll     = !multiSelect && checked,\n            deselect        = !deselectAll && !checked ? [record] : null,\n            select          = checked ? [record] : null;\n        me._isCheckboxSelecting = true;\n        // Saves previously non-shift checked checkbox\n        if (checked && !GlobalEvents.shiftKeyDown) {\n            me._lastSelectionChecked = record;\n        }\n        // Shift range select\n        if (checked && multiSelect && me._lastSelectionChecked && GlobalEvents.shiftKeyDown) {\n            me.performSelection(me.internalSelectRange(me._lastSelectionChecked, record, true));\n        }\n        // Regular selection, updates UI and triggers events\n        else if (me.performSelection(me.prepareSelection(deselect, select, deselectAll, true)) === false) {\n            // Need to manually reset checkbox in case outside world returns false from beforeSelectionChange\n            checkbox.checked = !checkbox.checked;\n        }\n        me._isCheckboxSelecting = false;\n    }\n    // Update header checkbox\n    updateCheckboxHeader() {\n        const { selectionMode, checkboxSelectionColumn, store } = this;\n        if (!this._isCheckAllSelecting && selectionMode.checkbox && selectionMode.showCheckAll && checkboxSelectionColumn?.headerCheckbox) {\n            const allSelected = store.count && !store.some(record => this.isSelectable(record) && !this.isSelected(record));\n            if (checkboxSelectionColumn.headerCheckbox.checked !== allSelected) {\n                checkboxSelectionColumn.suspendEvents();\n                checkboxSelectionColumn.headerCheckbox.checked = allSelected;\n                checkboxSelectionColumn.resumeEvents();\n            }\n        }\n    }\n    onCheckAllChange({ checked }) {\n        const me = this;\n        me._isCheckboxSelecting = me._isCheckAllSelecting = true;\n        me[checked ? 'selectAll' : 'deselectAll'](me.store.isPaged && me.selectionMode.preserveSelectionOnPageChange);\n        me._isCheckboxSelecting = me._isCheckAllSelecting = false;\n    }\n    //endregion\n    // region Selection drag\n    // Hook for SalesForce-code to overwrite\n    get selectionDragMouseEventListenerElement() {\n        return globalThis;\n    }\n    // Creates new selection range on mouseover. Listener is initiated on mousedown\n    onSelectionDrag(event) {\n        const\n            me                      = this,\n            { _selectionStartCell } = me;\n        // If we're here but there's no mouse button down for some reason, cancel\n        if (!GlobalEvents.isMouseDown()) {\n            me.onSelectionEnd();\n        }\n        // No start cell, ignore\n        if (!_selectionStartCell) {\n            return;\n        }\n        const\n            { items, _lastSelectionDragRegion } = me,\n            cellData                            = me.getCellDataFromEvent(event, true),\n            region                              = cellData?.column.region,\n            cellSelector                        = cellData?.cellSelector && me.normalizeCellContext(cellData.cellSelector);\n        // If mouse enters new cell\n        if (cellSelector && !cellSelector.equals(me._lastSelectionDragCell, true)) {\n            if (!me._isSelectionDragging) {\n                // When starting selection, start monitoring for near edge scrolling\n                me.enableScrollingCloseToEdges(items);\n            }\n            // If we start a new selection drag on already selected cell, the default (de)selection is delayed until\n            // mouseup. If we detect that a drag range is indeed what the user intends, deselect immediately\n            if (me._clearSelectionOnSelectionDrag && !_selectionStartCell.equals(cellSelector, true)) {\n                me.deselectAll();\n                delete me._clearSelectionOnSelectionDrag;\n            }\n            // A grid with multiple regions need to handle selection and scrolling moving between regions\n            if (_lastSelectionDragRegion && region !== _lastSelectionDragRegion) {\n                const\n                    leavingSubGrid     = me.subGrids[_lastSelectionDragRegion],\n                    enteringSubGrid    = me.subGrids[region],\n                    leavingScrollable  = leavingSubGrid.scrollable,\n                    enteringScrollable = enteringSubGrid.scrollable,\n                    goingForward       = items.indexOf(leavingSubGrid) - items.indexOf(enteringSubGrid) < 0;\n                // Immediately scrolls an entering subgrid to either start or end depending on direction\n                enteringScrollable.x = goingForward ? 0 : enteringScrollable.maxX;\n                // Waiting for grid to scroll to start/end (handled by scrollmanager)\n                if (goingForward ? leavingScrollable.x < leavingScrollable.maxX - 1 : leavingScrollable.x > 1) {\n                    return;\n                }\n                // Forces the previous subgrid to stop reserving horizontal scroll\n                const activeHorizontalScroll = me.scrollManager._activeScroll?.horizontal;\n                if (activeHorizontalScroll && activeHorizontalScroll.element !== enteringScrollable.element) {\n                    activeHorizontalScroll.stopScroll(true);\n                }\n            }\n            me._lastSelectionDragRegion = region;\n            me._lastSelectionDragCell   = cellSelector;\n            me._isSelectionDragging     = true;\n            const selectionChange = me._lastSelectionDragChange = me.internalSelectRange(_selectionStartCell,\n                cellSelector, me.isRowNumberSelecting(cellSelector) || me.isRowNumberSelecting(_selectionStartCell));\n            // As selection at this point is UI only, we don't want to affect already selected records\n            selectionChange.deselectedCells   = selectionChange.deselectedCells.filter(cell => !me.isCellSelected(cell));\n            selectionChange.deselectedRecords = selectionChange.deselectedRecords.filter(record => !me.isSelected(record));\n            // selectionChange event fires onSelectionEnd\n            me.refreshGridSelectionUI(selectionChange);\n            /**\n             * Fires while drag selecting. UI will update with current range, but the cells will not be selected until\n             * mouse up. This event can be listened for to perform actions while drag selecting.\n             * @event dragSelecting\n             * @param {Grid.view.Grid} source\n             * @param {Core.data.Model[]|Object} selectedCells The cells that is currently being dragged over\n             */\n            me.trigger('dragSelecting', selectionChange);\n        }\n    }\n    // Tells onSelectionDrag that it's not dragging any longer\n    onSelectionEnd() {\n        const\n            me         = this,\n            lastChange = me._lastSelectionDragChange;\n        if (me._isSelectionDragging && !me._selectionStartCell.equals(me._lastSelectionDragCell, true) && lastChange) {\n            me.performSelection(lastChange, false);\n        }\n        me.disableScrollingCloseToEdges(me.items);\n        me._isSelectionDragging     = false;\n        me._lastSelectionDragChange = me._lastSelectionDragCell = me._lastSelectionDragRegion = null;\n        // Remove listeners\n        me._selectionListenersDetachers.selectiondrag?.();\n        delete me._selectionListenersDetachers.selectiondrag;\n    }\n    // endregion\n    // region Column selection\n    onHandleElementClick(event) {\n        const me = this;\n        // If rownumber column is clicked, toggle selectAll\n        if (me.selectionMode.rowNumber && event.target.closest('.b-rownumber-header')) {\n            event.handled = true;\n            if (me.store.count && me.store.some(record => !me.isSelected(record))) {\n                me.selectAll();\n            }\n            else {\n                me.deselectAll();\n            }\n        }\n        // In column selection mode, and we clicked a header, the column should be selected\n        else if (me.selectionMode.column && event.target.closest('.b-grid-header')) {\n            event.handled = true;\n            me.selectColumn(event, event.ctrlKey);\n        }\n        super.onHandleElementClick(event);\n    }\n    selectColumn(event, addToSelection = false) {\n        const\n            me           = this,\n            { store }    = me,\n            { columnId } = me.getHeaderDataFromEvent(event);\n        // internalSelectRange uses this to remember last range, we have no need for that here\n        me._shiftSelectRange = null;\n        if (!event.shiftKey) {\n            me._shiftSelectColumn = columnId;\n        }\n        const\n            fromColumnId    = (event.shiftKey && me._shiftSelectColumn) || columnId,\n            selectionChange = me.internalSelectRange(\n                me.normalizeCellContext({ id : store.first.id, columnId : fromColumnId }),\n                me.normalizeCellContext({ id : store.last.id, columnId })\n            );\n        // If we are selecting a column that is already selected, deselect it\n        if (addToSelection && !selectionChange.selectedCells.some(sc => !me.isCellSelected(sc))) {\n            selectionChange.deselectedCells = selectionChange.selectedCells;\n            selectionChange.selectedCells   = [];\n        }\n        if (!addToSelection) {\n            selectionChange.deselectedCells = me._selectedCells;\n        }\n        me.cleanSelectionChange(selectionChange);\n        me.performSelection(selectionChange);\n    }\n    // endregion\n    // region Public row/record selection\n    /**\n     * Checks whether a row is selected. Will not check if any of a row's cells are selected.\n     * @param {LocationConfig|String|Number|Core.data.Model} cellSelectorOrId Cell selector { id: x, column: xx } or row\n     * id, or record\n     * @returns {Boolean} true if row is selected, otherwise false\n     * @category Selection\n     */\n    isSelected(cellSelectorOrId) {\n        // Not a selected cell, check recoWds\n        if (cellSelectorOrId?.id) {\n            cellSelectorOrId = cellSelectorOrId.id;\n        }\n        if (validIdTypes[typeof cellSelectorOrId]) {\n            return this.selectedRows.some(rec => rec.id === cellSelectorOrId);\n        }\n        return false;\n    }\n    /**\n     * Checks whether a cell is selected.\n     * @param {LocationConfig|Location} cellSelector Cell selector { id: x, column: xx }\n     * @param {Boolean} includeRow to also check if row is selected\n     * @returns {Boolean} true if cell is selected, otherwise false\n     * @category Selection\n     */\n    isCellSelected(cellSelector, includeRow) {\n        cellSelector = this.normalizeCellContext(cellSelector);\n        return (this.isCellSelectionMode && this._selectedCells.some(cell => cellSelector.equals(cell, true))) ||\n            (includeRow && this.isSelected(cellSelector));\n    }\n    /**\n     * Checks whether a cell or row can be selected.\n     * @param {Core.data.Model|LocationConfig|String|Number} recordCellOrId Record or cell or record id\n     * @returns {Boolean} true if cell or row can be selected, otherwise false\n     * @category Selection\n     */\n    isSelectable(recordCellOrId) {\n        return this.normalizeCellContext({ id : recordCellOrId.id || recordCellOrId }).isSelectable;\n    }\n    /**\n     * The last selected record. Set to select a row or use Grid#selectRow. Set to null to\n     * deselect all\n     * @property {Core.data.Model}\n     * @category Selection\n     */\n    get selectedRecord() {\n        return this.selectedRecords[this.selectedRecords.length - 1] || null;\n    }\n    set selectedRecord(record) {\n        this.selectRow({ record });\n    }\n    /**\n     * Selected records.\n     *\n     * If {@link #config-selectionMode deselectFilteredOutRecords} is `false` (default) this will include selected\n     * records which has been filtered out.\n     *\n     * If {@link #config-selectionMode preserveSelectionOnPageChange} is `true` (defaults to `false`) this will include\n     * selected records on all pages.\n     *\n     * If {@link #config-selectionMode selectRecordOnCell} is `true` (default) this will include any record which has at\n     * least one cell selected.\n     *\n     * Can be set as array of ids:\n     *\n     * ```javascript\n     * grid.selectedRecords = [1, 2, 4, 6]\n     * ```\n     *\n     * @property {Core.data.Model[]}\n     * @accepts {Core.data.Model[]|Number[]}\n     * @category Selection\n     */\n    get selectedRecords() {\n        return this.selectedRecordCollection.values;\n    }\n    set selectedRecords(selectedRecords) {\n        this.selectRows(selectedRecords);\n    }\n    /**\n     * Selected records. Records selected via cell selection is excluded.\n     *\n     * If {@link #config-selectionMode deselectFilteredOutRecords} is `false` (default) this will include selected\n     * records which has been filtered out.\n     *\n     * If {@link #config-selectionMode preserveSelectionOnPageChange} is `true` (defaults to `false`) this will include\n     * selected records on all pages.\n     *\n     * if {@link #config-selectionMode selectRecordOnCell} is `false` this will return same records as\n     * {@link #property-selectedRecords}.\n     *\n     * Can be set as array of ids:\n     *\n     * ```javascript\n     * grid.selectedRecords = [1, 2, 4, 6]\n     * ```\n     *\n     * @property {Core.data.Model[]}\n     * @accepts {Core.data.Model[]|Number[]}\n     * @category Selection\n     */\n    get selectedRows() {\n        return [...this._selectedRows];\n    }\n    set selectedRows(selectedRows) {\n        this.selectRows(selectedRows);\n    }\n    /**\n     * Removes and adds records to/from the selection at the same time. Analogous\n     * to the `Array` `splice` method.\n     *\n     * Note that if items that are specified for removal are also in the `toAdd` array,\n     * then those items are *not* removed then appended. They remain in the same position\n     * relative to all remaining items.\n     *\n     * @param {Number} index Index at which to remove a block of items. Only valid if the\n     * second, `toRemove` argument is a number.\n     * @param {Object[]|Number} toRemove Either the number of items to remove starting\n     * at the passed `index`, or an array of items to remove (If an array is passed, the `index` is ignored).\n     * @param  {Object[]|Object} toAdd An item, or an array of items to add.\n     * @category Selection\n     */\n    spliceSelectedRecords(index, toRemove, toAdd) {\n        const me = this;\n        if (typeof toRemove == 'number') {\n            const select = [...me.selectedRecords];\n            select.splice(index, toRemove, ...ArrayHelper.asArray(toAdd));\n            me.performSelection(me.prepareSelection(null, select, true, true));\n        }\n        else {\n            // Just add and remove\n            me.performSelection(me.prepareSelection(toRemove, toAdd, false, true));\n        }\n    }\n    /**\n     * Select one row\n     * @param {Object|Core.data.Model|String|Number} options A record or id to select or a config object describing the\n     * selection\n     * @param {Core.data.Model|String|Number} options.record Record or record id, specifying null will deselect all\n     * @param {Grid.column.Column} [options.column] The column to scroll into view if `scrollIntoView` is not specified as\n     * `false`. Defaults to the grid's first column.\n     * @param {Boolean} [options.scrollIntoView] Specify `false` to prevent row from being scrolled into view\n     * @param {Boolean} [options.addToSelection] Specify `true` to add to selection, defaults to `false` which replaces\n     * @fires selectionChange\n     * @category Selection\n     */\n    selectRow(options) {\n        // Make sure we have an object\n        if (typeof options === 'number' || options.isModel || !('record' in options)) {\n            options = {\n                records : [options]\n            };\n        }\n        // scrollIntoView is default here\n        ObjectHelper.assignIf(options, {\n            scrollIntoView : true\n        });\n        this.selectRows(options);\n    }\n    /**\n     * Select one or more rows\n     * @param {Object|Core.data.Model[]|String[]|Number[]} options An array of records or ids for a record or a\n     * config object describing the selection\n     * @param {Core.data.Model[]|String[]|Number[]} options.records An array of records or ids for a record\n     * @param {Grid.column.Column} options.column The column to scroll into view if `scrollIntoView` is not specified as\n     * `false`. Defaults to the grid's first column.\n     * @param {Boolean} [options.scrollIntoView] Specify `false` to prevent row from being scrolled into view\n     * @param {Boolean} [options.addToSelection] Specify `true` to add to selection, defaults to `false` which replaces\n     * @category Selection\n     */\n    selectRows(options) {\n        // Got a single or an array of records/ids, convert it to an object\n        if (!options || Array.isArray(options) || options.isModel || typeof options === 'number' ||\n            (!('records' in options) && !('record' in options))\n        ) {\n            options = {\n                records : ArrayHelper.asArray(options) || []\n            };\n        }\n        const\n            me        = this,\n            { store } = me,\n            toSelect  = [],\n            {\n                records        = options.record ? [options.record] : [], // Got a record instead of records\n                column         = me.columns.visibleColumns[0], // Default\n                scrollIntoView,\n                addToSelection = arguments[1] // Backwards compatibility\n            }         = options;\n        for (let record of records) {\n            record = store.getById(record);\n            if (record) {\n                toSelect.push(record);\n            }\n        }\n        if (!addToSelection) {\n            me._shiftSelectRange = null;\n        }\n        me.performSelection(me.prepareSelection(null, toSelect, !addToSelection, true));\n        if (toSelect.length && scrollIntoView) {\n            me.scrollRowIntoView(toSelect[0].id, {\n                column\n            });\n        }\n    }\n    /**\n     * This selects all rows. If store is filtered, this will merge the selection of all visible rows with any selection\n     * made prior to filtering.\n     * @privateparam {Boolean} [silent] Pass `true` not to fire any event upon selection change\n     * @category Selection\n     */\n    selectAll(silent = false) {\n        const\n            { store } = this,\n            records   = (store.isGrouped ? store.allRecords : store.records).filter(r => !r.isSpecialRow);\n        // If store is grouped, store.records excludes collapsed records and allRecords excludes filtered out records\n        // Else, store records holds what we're after\n        this.performSelection(this.prepareSelection(null, records, false, true), true, silent);\n    }\n    /**\n     * Deselects all selected rows and cells. If store is filtered, this will unselect all visible rows only. Any\n     * selections made prior to filtering remains.\n     * @param {Boolean} [removeCurrentRecordsOnly] Pass `false` to clear all selected records, and `true` to only\n     * clear selected records in the current set of records\n     * @param {Boolean} [silent] Pass `true` not to fire any event upon selection change\n     * @category Selection\n     */\n    deselectAll(removeCurrentRecordsOnly = false, silent = false) {\n        const\n            { store } = this,\n            records   = removeCurrentRecordsOnly\n                ? (store.isGrouped ? store.allRecords : store.records).filter(r => !r.isSpecialRow) : null;\n        this.performSelection(this.prepareSelection(records, null, !removeCurrentRecordsOnly), true, silent);\n    }\n    /**\n     * Deselect one row\n     * @param {Core.data.Model|String|Number} recordOrId Record or an id for a record\n     * @category Selection\n     */\n    deselectRow(record) {\n        this.deselectRows(record);\n    }\n    /**\n     * Deselect one or more rows\n     * @param {Core.data.Model|String|Number|Core.data.Model[]|String[]|Number[]} recordOrIds An array of records or ids\n     * for a record\n     * @category Selection\n     */\n    deselectRows(recordsOrIds) {\n        // Ignore any non-existing row records passed\n        const\n            { store } = this,\n            records   = ArrayHelper.asArray(recordsOrIds).map(recordOrId => store.getById(recordOrId)).filter(rec => rec);\n        this.performSelection(this.prepareSelection(records));\n    }\n    /**\n     * Selects rows corresponding to a range of records (from fromId to toId)\n     * @param {String|Number} fromId\n     * @param {String|Number} toId\n     * @category Selection\n     */\n    selectRange(fromId, toId, addToSelection = false) {\n        const\n            me        = this,\n            { store } = me,\n            selection = me.internalSelectRange(store.getById(fromId), store.getById(toId), true);\n        me._shiftSelectRange = null; // For below function to not replace last range with new one\n        me.performSelection(selection);\n    }\n    // endregion\n    // region Public cell selection\n    /**\n     * In cell selection mode, this will get the cell selector for the (last) selected cell. Set to an available cell\n     * selector to select only that cell. Or use {@link #function-selectCell()} instead.\n     * @property {Grid.util.Location}\n     * @category Selection\n     */\n    get selectedCell() {\n        return this._selectedCells[this._selectedCells.length - 1];\n    }\n    set selectedCell(cellSelector) {\n        this.selectCells([cellSelector]);\n    }\n    /**\n     * In cell selection mode, this will get the cell selectors for all selected cells. Set to an array of available\n     * cell selectors. Or use {@link #function-selectCells()} instead.\n     * @property {Grid.util.Location[]}\n     * @category Selection\n     */\n    get selectedCells() {\n        return [...this._selectedCells];\n    }\n    set selectedCells(cellSelectors) {\n        this.selectCells(cellSelectors);\n    }\n    /**\n     * CSS selector for the currently selected cell. Format is \"[data-index=index] [data-column-id=column]\".\n     * @type {String}\n     * @category Selection\n     * @readonly\n     */\n    get selectedCellCSSSelector() {\n        const\n            cell = this.selectedCell,\n            row  = cell && this.getRowById(cell.id);\n        if (!cell || !row) return '';\n        return `[data-index=${row.dataIndex}] [data-column-id=${cell.columnId}]`;\n    }\n    /**\n     * If in cell selection mode, this selects one cell. If not, this selects the cell's record.\n     * @param {LocationConfig|Object} options A cell selector ({ id: rowId, columnId: 'columnId' }) or a config object\n     * @param {LocationConfig} options.cell  A cell selector ({ id: rowId, columnId: 'columnId' })\n     * @param {Boolean} [options.scrollIntoView] Specify `false` to prevent row from being scrolled into view\n     * @param {Boolean} [options.addToSelection] Specify `true` to add to selection, defaults to `false` which replaces\n     * @param {Boolean} [options.silent] Specify `true` to not trigger any events when selecting the cell\n     * @returns {Grid.util.Location} Cell selector\n     * @fires selectionChange\n     * @category Selection\n     */\n    selectCell(options) {\n        // Got a cell selector as first argument\n        if ('id' in options) {\n            options = {\n                cell : options\n            };\n            // Arguments backward's compability\n            options = Object.assign({\n                scrollIntoView : arguments[1],\n                addToSelection : arguments[2],\n                silent         : arguments[3]\n            }, options);\n        }\n        return this.selectCells(options)?.[0];\n    }\n    /**\n     * If in cell selection mode, this selects a number of cells. If not, this selects corresponding records.\n     * @param {Object|LocationConfig[]} options An array of cell selectors ({ id: rowId, columnId: 'columnId' }) or a config\n     * object\n     * @param {LocationConfig[]} options.cells An array of cell selectors { id: rowId, columnId: 'columnId' }\n     * @param {Boolean} [options.scrollIntoView] Specify `false` to prevent row from being scrolled into view\n     * @param {Boolean} [options.addToSelection] Specify `true` to add to selection, defaults to `false` which replaces\n     * @param {Boolean} [options.silent] Specify `true` to not trigger any events when selecting the cell\n     * @returns {Grid.util.Location[]} Cell selectors\n     * @returns {Grid.util.Location[]} Cell selectors\n     * @fires selectionChange\n     * @category Selection\n     */\n    selectCells(options) {\n        // Got a cell selector array as first argument\n        if (Array.isArray(options)) {\n            options = {\n                cells : options\n            };\n        }\n        const\n            me              = this,\n            {\n                cells          = options.cell ? [options.cell] : [], // Got a cell instead of cells\n                scrollIntoView = true,\n                addToSelection = false,\n                silent         = false\n            }               = options,\n            selectionChange = me.prepareSelection(null, cells, !addToSelection);\n        if (!addToSelection) {\n            me._shiftSelectRange = null;\n        }\n        me.performSelection(selectionChange, true, silent);\n        if (scrollIntoView) {\n            me.scrollRowIntoView(cells[0].id, {\n                column : cells[0].columnId\n            });\n        }\n        return me.isCellSelectionMode ? selectionChange.selectedCells : selectionChange.selectedRecords;\n    }\n    /**\n     * If in cell selection mode, this deselects one cell. If not, this deselects the cell's record.\n     * @param {LocationConfig} cellSelector\n     * @returns {Grid.util.Location} Normalized cell selector\n     * @category Selection\n     */\n    deselectCell(cellSelector) {\n        return this.deselectCells([cellSelector])?.[0];\n    }\n    /**\n     * If in cell selection mode, this deselects a number of cells. If not, this deselects corresponding records.\n     * @param {LocationConfig[]} cellSelectors\n     * @returns {Grid.util.Location[]} Normalized cell selectors\n     * @category Selection\n     */\n    deselectCells(cellSelectors) {\n        const selectionChange = this.prepareSelection(cellSelectors);\n        this.performSelection(selectionChange);\n        return this.isCellSelectionMode ? selectionChange.deselectedCells : selectionChange.deselectedRecords;\n    }\n    // Used by keymap to toggle selection of currently focused cell.\n    toggleSelection(keyEvent) {\n        const\n            me          = this,\n            {\n                _focusedCell,\n                selectionMode\n            }           = me,\n            isRowNumber = me.isRowNumberSelecting(_focusedCell),\n            isSelected  = me.isCellSelected(_focusedCell, true);\n        // Only if keyboardNavigation selection is deactivated and were not focusing an actionable cell\n        if (selectionMode.selectOnKeyboardNavigation === true || _focusedCell.isActionable) {\n            // Return false to ley keyMap know we didn't handle this event\n            return false;\n        }\n        me.performSelection(\n            me.prepareSelection(\n                isSelected ? _focusedCell : null,\n                isSelected ? null : _focusedCell,\n                !selectionMode.multiSelect,\n                isRowNumber\n            ));\n        // Space key has preventDefault = false somewhere\n        keyEvent.preventDefault();\n    }\n    /**\n     * Selects a range of cells, from a cell selector (Location) to another\n     * @param {Grid.util.Location|LocationConfig} from\n     * @param {Grid.util.Location|LocationConfig} to\n     * @category Selection\n     */\n    selectCellRange(from, to) {\n        this.performSelection(this.internalSelectRange(from, to));\n    }\n    // endregion\n    // region Private convenience functions & properties\n    getSelection() {\n        if (this.isRowSelectionMode) {\n            return this.selectedRecords;\n        }\n        else {\n            return this.selectedCells;\n        }\n    }\n    // Makes sure the same record or cell isn't deselected and selected at the same time. Selection will take precedence\n    cleanSelectionChange(selectionChange) {\n        const\n            {\n                deselectedRecords,\n                deselectedCells,\n                selectedCells,\n                deselectedCellRecords\n            }                     = selectionChange,\n            selectedRecordIds     = selectionChange.selectedRecords?.map(r => r.id),\n            selectedCellRecordIds = selectionChange.selectedCellRecords?.map(r => r.id);\n        // Filter out records which is both selected and deselected\n        if (deselectedRecords?.length && selectedRecordIds?.length) {\n            selectionChange.deselectedRecords = deselectedRecords.filter(dr => !selectedRecordIds.includes(dr.id));\n        }\n        // Filter out cells which is both selected and deselected\n        if (deselectedCells?.length && selectedCells?.length) {\n            selectionChange.deselectedCells = deselectedCells.filter(dc => !selectedCells.some(sc => dc.equals(sc, true)));\n        }\n        // Filter out cell-selected records that is being selected\n        if (deselectedCellRecords.length && (selectedCellRecordIds.length || selectedRecordIds?.length)) {\n            selectionChange.deselectedCellRecords = deselectedCellRecords.filter(dcr => {\n                return !selectedCellRecordIds.includes(dcr.id) && !selectedRecordIds.includes(dcr.id);\n            });\n        }\n        return selectionChange;\n    }\n    getSelectedCellsForRecords(records) {\n        return this._selectedCells.filter(cell => cell.id && records.some(record => record.id === cell.id));\n    }\n    delayUntilMouseUp(fn) {\n        const detacher = EventHelper.on({\n            element : globalThis,\n            blur    : ev => fn(ev, detacher),\n            mouseup : ev => fn(ev, detacher),\n            thisObj : this,\n            once    : true\n        });\n    }\n    get isRowSelectionMode() {\n        return !this.isCellSelectionMode;\n    }\n    get isCellSelectionMode() {\n        return this.selectionMode.cell === true;\n    }\n    // Checks if rowNumber is activated and that all arguments (cellselectors) is of type rownumber\n    isRowNumberSelecting(...selectors) {\n        return this.selectionMode.rowNumber && !selectors.some(cs => cs.column.type !== 'rownumber');\n    }\n    selectionShouldIncludeChildren(record) {\n        const { includeChildren, multiSelect } = this.selectionMode;\n        return (includeChildren === 'always' || (includeChildren === true && this._isCheckboxSelecting)) &&\n            multiSelect && !record.isLeaf && record.allChildren?.length;\n    }\n    // endregion\n    //region Navigation\n    // Used by keyMap to extend selection range\n    extendSelectionLeft() {\n        this.extendSelection('Left');\n    }\n    // Used by keyMap to extend selection range\n    extendSelectionRight() {\n        this.extendSelection('Right');\n    }\n    // Used by keyMap to extend selection range\n    extendSelectionUp() {\n        this.extendSelection('Up');\n    }\n    // Used by keyMap to extend selection range\n    extendSelectionDown() {\n        this.extendSelection('Down');\n    }\n    // Used by keyMap to extend selection range\n    extendSelection(dir) {\n        this._isKeyboardRangeSelecting = true;\n        this['navigate' + dir]();\n        this._isKeyboardRangeSelecting = false;\n    }\n    // Called from GridNavigation on mouse or keyboard events\n    // Single entry point for all default user selection actions\n    onCellNavigate(me, fromCellSelector, toCellSelector, doSelect) {\n        const\n            {\n                selectionMode,\n                _selectionListenersDetachers\n            }                                            = me,\n            { multiSelect, deselectOnClick, dragSelect } = selectionMode,\n            { ctrlKeyDown, shiftKeyDown }                = GlobalEvents,\n            isMouseLeft                                  = GlobalEvents.isMouseDown(),\n            isMouseRight                                 = GlobalEvents.isMouseDown(2),\n            currentEvent                                 = GlobalEvents.currentMouseDown || GlobalEvents.currentKeyDown;\n        // To be sure we got Locations\n        toCellSelector = me.normalizeCellContext(toCellSelector);\n        if (\n            me.selectionDisabled ||\n            !doSelect ||\n            // Do not affect selection if navigating into header row.\n            toCellSelector.rowIndex === -1 ||\n            toCellSelector.record?.isGroupHeader ||\n            // Don't allow keyboard selection if keyboardNavigation is deactivated\n            (currentEvent?.fromKeyMap && !selectionMode.selectOnKeyboardNavigation) ||\n            // CheckColumn events are handled by the CheckColumn itself.\n            me.columns.getById(toCellSelector.columnId) === me.checkboxSelectionColumn ||\n            selectionMode.checkboxOnly ||\n            // Don't select if event was handled elsewhere\n            currentEvent?.handled === true\n        ) {\n            return;\n        }\n        // Save adding state unless shift key\n        if (!shiftKeyDown) {\n            me._isAddingToSelection = ctrlKeyDown && multiSelect;\n            me._selectionStartCell  = toCellSelector; // To be able to begin a new range\n        }\n        // Flags that it's possible for onSelectDrag to apply its logic if the right conditions are met\n        // (preventDragSelect is set by RowReorder if mousedown on the grip with gripOnly configured. also set in\n        // DragCreateBase and EventDragSelect)\n        if (multiSelect && dragSelect && isMouseLeft && !_selectionListenersDetachers.selectiondrag && !me.preventDragSelect) {\n            _selectionListenersDetachers.selectiondrag = EventHelper.on({\n                name    : 'selectiondrag',\n                element : me.selectionDragMouseEventListenerElement,\n                blur    : 'onSelectionEnd',\n                mouseup : {\n                    handler : 'onSelectionEnd',\n                    element : globalThis\n                },\n                mousemove : 'onSelectionDrag',\n                thisObj   : me\n            });\n        }\n        me.preventDragSelect = false;\n        const\n            startCell = me._selectionStartCell,\n            adding    = me._isAddingToSelection;\n        // Select range on shiftKey\n        if (((shiftKeyDown && isMouseLeft) || me._isKeyboardRangeSelecting) && startCell && multiSelect) {\n            me.performSelection(\n                me.internalSelectRange(\n                    startCell,\n                    toCellSelector,\n                    me.isRowNumberSelecting(startCell, toCellSelector)\n                )\n            );\n        }\n        else {\n            let delay             = false,\n                continueSelecting = true,\n                deselect;\n            // If current is already selected\n            if (me.isCellSelected(toCellSelector, true)) {\n                // Do nothing if we right-clicked already selected row/cell\n                if (isMouseRight) {\n                    return;\n                }\n                // Deselect current if selected and multiselecting or deselect all if deselectOnClick is true\n                if ((adding || deselectOnClick)) {\n                    deselect          = deselectOnClick ? null : [toCellSelector];\n                    continueSelecting = false; // Only deselect at this code path\n                }\n                // If this is only row or cell that's selected\n                else if (me.selectedRecords.length + (me.isCellSelectionMode ? me._selectedCells.length : 0) <= 1) {\n                    // Should stay selected, do no more\n                    return;\n                }\n                // Delay if click a selected cell which will be deselected (for dragging)\n                delay = deselectOnClick || multiSelect;\n            }\n            // deselect all if not multiselecting\n            if (!deselect && !adding) {\n                deselect = null;\n                // Set flag so that dragselection functionality know to clear selection if needed\n                if (dragSelect && delay && _selectionListenersDetachers.selectiondrag) {\n                    me._clearSelectionOnSelectionDrag = true;\n                }\n            }\n            // Wrapping selection in a function to be called either directly or on mouse up\n            const finishSelection = (mouseUpEvent, detacher) => {\n                detacher?.();\n                if (mouseUpEvent?.target?.nodeType === Node.ELEMENT_NODE) {\n                    // If we are waiting for mouseUp and have moved to a different cell, abort selection change\n                    const mouseUpSelector = new Location(mouseUpEvent.target);\n                    if (mouseUpSelector?.grid && !mouseUpSelector.equals(toCellSelector, true)) {\n                        return;\n                    }\n                }\n                if (!shiftKeyDown) {\n                    me._shiftSelectRange = null; // Clear any previous range selected\n                }\n                me.performSelection(\n                    me.prepareSelection(\n                        deselect,\n                        continueSelecting && [toCellSelector],\n                        deselect === null,\n                        continueSelecting && me.isRowNumberSelecting(toCellSelector)\n                    )\n                );\n            };\n            if (me.features.rowReorder?.isDragging) {\n                return;\n            }\n            // Delay doing the selection until mouse up for allowing drag of row in certain cases\n            if (delay) {\n                me.delayUntilMouseUp(finishSelection);\n            }\n            else {\n                finishSelection();\n            }\n        }\n    }\n    // endregion\n    // region Internal selection & deselection functions\n    /**\n     * Used internally to prepare a number of cells or records for selection/deselection depending on if cell\n     * selectionMode is activated. This function will not select/deselect anything by itself\n     * (that's done in performSelection).\n     * @param {LocationConfig[]|Core.data.Model[]} cellSelectorsToDeselect Array of cell selectors or records.\n     * @param {LocationConfig[]|Core.data.Model[]} cellSelectorsToSelect Array of cell selectors or records.\n     * @param {Boolean} deselectAll Set to `true` to clear all selected records and cells.\n     * @param {Boolean} forceRecordSelection Set to `true` to force record selection even if cell selection is active.\n     * @returns {Object} selectionChange object to use for UI update\n     * @private\n     * @category Selection\n     */\n    prepareSelection(cellSelectorsToDeselect, cellSelectorsToSelect, deselectAll = false, forceRecordSelection = false) {\n        const\n            me                    = this,\n            isDragging            = me._isSelectionDragging,\n            {\n                includeParents,\n                selectRecordOnCell\n            }                     = me.selectionMode,\n            selectedCells         = [],\n            deselectedCells       = deselectAll ? me._selectedCells : [],\n            selectedRecords       = [],\n            deselectedRecords     = deselectAll ? me._selectedRows : [],\n            deselectedRecordIndex = ArrayHelper.keyBy(deselectedRecords, 'id', () => 1), // For performance\n            deselectedCellRecords = deselectAll ? me.selectedRecords.filter(r => !deselectedRecordIndex[r.id]) : [];\n        let selectedCellRecords   = [];\n        if (!deselectAll && cellSelectorsToDeselect) {\n            for (const selector of ArrayHelper.asArray(cellSelectorsToDeselect)) {\n                const\n                    cellSelector = me.normalizeCellContext(selector),\n                    record       = cellSelector?.record ||\n                        (selector.isModel ? selector : me.store.getById(cellSelector.id));\n                if (cellSelector.isSpecialRow) {\n                    continue;\n                }\n                deselectedCells.push(cellSelector);\n                if (record && !deselectedRecordIndex[record.id]) {\n                    // When dragging, this path is taken but nothing is actually selected until mouseup\n                    // So should check if selected for dragselection (until mouseup)\n                    if (isDragging || me.isSelected(record)) {\n                        deselectedRecords.push(record);\n                        deselectedRecordIndex[record.id] = 1;\n                    }\n                    // If not directly selected, but selected by cell, deselect by cell\n                    else if (selectRecordOnCell && me.selectedRecordCollection.get(record.id) &&\n                        !deselectedCellRecords.some(dr => dr.id === record.id)\n                    ) {\n                        deselectedCellRecords.push(record);\n                    }\n                    // If configured, also deselect children\n                    if (me.selectionShouldIncludeChildren(record)) {\n                        for (const child of record.allChildren) {\n                            if (!deselectedRecordIndex[child.id] &&\n                                (isDragging || me.isSelected(child))\n                            ) {\n                                deselectedRecords.push(child);\n                                deselectedRecordIndex[record.id] = 1;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (cellSelectorsToSelect) {\n            const selectedRecordIndex = {}; // For performance\n            for (const selector of ArrayHelper.asArray(cellSelectorsToSelect)) {\n                const\n                    cellSelector = me.normalizeCellContext(selector),\n                    record       = cellSelector?.record ||\n                        (selector.isModel ? selector : me.store.getById(cellSelector.id));\n                if (!record || cellSelector.isSpecialRow) {\n                    continue;\n                }\n                // Only select cells if in cell selection mode and not forcing record selection\n                if (me.isCellSelectionMode && !forceRecordSelection) {\n                    selectedCells.push(cellSelector);\n                }\n                if ((me.isRowSelectionMode || forceRecordSelection) && !selectedRecordIndex[record.id]) {\n                    selectedRecords.push(record);\n                    selectedRecordIndex[record.id] = 1;\n                    // If configured, also select children\n                    if (me.selectionShouldIncludeChildren(record)) {\n                        for (const child of record.allChildren) {\n                            if (!selectedRecordIndex[child.id]) {\n                                selectedRecords.push(child);\n                                selectedRecordIndex[child.id] = 1;\n                            }\n                        }\n                    }\n                }\n            }\n            if (selectRecordOnCell && selectedCells.length) {\n                selectedCellRecords = ArrayHelper.unique(selectedCells.map(c => c.record))\n                    .filter(r => !selectedRecordIndex[r.id]);\n            }\n        }\n        // This setting could be either off, or true/'all' or 'some'\n        if (includeParents && (deselectedRecords.length || selectedRecords.length)) {\n            const\n                allChanges         = [...deselectedRecords, ...selectedRecords],\n                lowestLevelParents = ArrayHelper.unique(\n                    allChanges.filter(rec =>\n                        rec.parent && !rec.allChildren.some(child =>\n                            allChanges.includes(child))).map(rec => rec.parent));\n            lowestLevelParents.forEach(parent => me.toggleParentSelection(parent, selectedRecords, deselectedRecords));\n        }\n        return me.cleanSelectionChange({\n            selectedCells,\n            selectedRecords,\n            deselectedCells,\n            deselectedRecords,\n            deselectAll,\n            action : selectedRecords?.length || selectedCells?.length ? 'select' : 'deselect',\n            selectedCellRecords,\n            deselectedCellRecords\n        });\n    }\n    toggleParentSelection(parent, toSelect, toDeselect) {\n        if (!parent || parent.isRoot) {\n            return;\n        }\n        const\n            isSelected      = this.isSelected(parent),\n            inToSelect      = toSelect.includes(parent),\n            inToDeselect    = toDeselect.includes(parent),\n            childIsSelected = child => (this.isSelected(child) && !toDeselect.includes(child)) || toSelect.includes(child);\n        if (this.selectionMode.includeParents === 'some') {\n            // If any children are selected\n            if (parent.allChildren.some(childIsSelected)) {\n                // And parent is not being deselected => select\n                if ((!isSelected || inToDeselect) && !inToSelect) {\n                    toSelect.push(parent);\n                }\n            }\n            // No children are selected and parent is selected => deselect\n            else if (isSelected && !inToDeselect) {\n                toDeselect.push(parent);\n            }\n        }\n        else { // includeParents = true/'all'\n            if (isSelected) {\n                // If previously selected, and some child is to be deselected => deselect\n                if (!inToDeselect && !inToSelect && parent.allChildren.some(child => toDeselect.includes(child))) {\n                    toDeselect.push(parent);\n                }\n            }\n            else if (!inToSelect) {\n                // If not previously selected, select if all children are selected\n                if (parent.allChildren.every(childIsSelected)) {\n                    toSelect.push(parent);\n                }\n            }\n        }\n        // Go up one level if it exists\n        if (parent.parent) {\n            this.toggleParentSelection(parent.parent, toSelect, toDeselect);\n        }\n    }\n    /**\n     * Used internally to select a range of cells or records depending on selectionMode. Used in both shift-selection\n     * and for drag selection. Will remember current selection range and replace it with new one when it changes. But a\n     * range which is completed (drag select mouse up or a new shift range starting point has been set) will remain.\n     * This function will not update UI (that's done in refreshGridSelectionUI).\n     * @param {LocationConfig} fromSelector\n     * @param {LocationConfig} toSelector\n     * @returns {Object} selectionChange object to use for UI update\n     * @private\n     * @category Selection\n     */\n    internalSelectRange(fromSelector, toSelector, forceRecordSelection = false) {\n        const\n            me              = this,\n            selectRecords   = me.isRowSelectionMode || forceRecordSelection,\n            selectionChange = me.prepareSelection(me._shiftSelectRange,\n                me.getRange(fromSelector, toSelector, selectRecords), false, forceRecordSelection);\n        me._shiftSelectRange = selectionChange[`selected${selectRecords ? 'Records' : 'Cells'}`];\n        return selectionChange;\n    }\n    /**\n     * Used internally to get a range of cell selectors from a start selector to an end selector.\n     * @private\n     */\n    getRange(fromSelector, toSelector, selectRecords = false) {\n        const\n            me            = this,\n            { store }     = me,\n            fromCell      = me.normalizeCellContext(fromSelector),\n            toCell        = me.normalizeCellContext(toSelector),\n            startRowIndex = Math.min(fromCell.rowIndex, toCell.rowIndex),\n            endRowIndex   = Math.max(fromCell.rowIndex, toCell.rowIndex),\n            toSelect      = [],\n            startColIndex = Math.min(fromCell.columnIndex, toCell.columnIndex),\n            endColIndex   = Math.max(fromCell.columnIndex, toCell.columnIndex);\n        if (startRowIndex === -1 || endRowIndex === -1) {\n            throw new Error('Record not found in selectRange');\n        }\n        // Row selection\n        if (selectRecords) {\n            const range = store.getRange(startRowIndex, endRowIndex + 1, false);\n            // To make selectedRecords in correct order when range selecting upwards\n            if (toCell.rowIndex < fromCell.rowIndex) {\n                range.reverse();\n            }\n            toSelect.push(...range);\n        }\n        // Cell selection\n        else {\n            // Loops from start cell to end cell and creates selectors for all containing cells\n            for (let rIx = startRowIndex; rIx <= endRowIndex; rIx++) {\n                for (let cIx = startColIndex; cIx <= endColIndex; cIx++) {\n                    toSelect.push({ rowIndex : rIx, columnIndex : cIx });\n                }\n            }\n        }\n        return toSelect.map(s => me.normalizeCellContext(s));\n    }\n    // endregion\n    // region Update UI & trigger events\n    performSelection(selectionChange, updateUI = true, silent = false) {\n        const\n            me                   = this,\n            {\n                selectedRecords       = [],\n                selectedCells         = [],\n                selectedCellRecords   = [],\n                deselectedRecords     = [],\n                deselectedCells       = [],\n                deselectedCellRecords = [],\n                action\n            }                    = selectionChange,\n            allSelectedRecords   = [...selectedRecords, ...selectedCellRecords],\n            allDeselectedRecords = [...deselectedRecords, ...deselectedCellRecords],\n            rowMode              = me.isRowSelectionMode;\n        // Fire event to be able to prevent selection\n        if (me.trigger('beforeSelectionChange', {\n            mode          : rowMode ? 'row' : 'cell',\n            action,\n            selected      : allSelectedRecords,\n            deselected    : allDeselectedRecords,\n            selection     : me.selectedRecords,\n            selectedCells,\n            deselectedCells,\n            cellSelection : me.selectedCells\n        }) === false) {\n            return false;\n        }\n        // If deselecting all cells\n        if (me._selectedCells === deselectedCells) {\n            me._selectedCells = [];\n        }\n        // Not deselecting all cells\n        else {\n            const keepCells = [];\n            for (const selectedCell of me._selectedCells) {\n                if (!deselectedCells.some(cellSelector => selectedCell.equals(cellSelector, true))) {\n                    keepCells.push(selectedCell);\n                }\n            }\n            me._selectedCells = keepCells;\n        }\n        selectionChange.deselectedRecords = [...selectionChange.deselectedRecords];\n        // If deselecting all rows\n        if (deselectedRecords === me._selectedRows) {\n            me.changeSelectedRecordCollectionSilent(c => c.clear());\n            me._selectedRows.length = 0;\n        }\n        // Not deselecting all rows\n        else {\n            const\n                keepRecords               = [],\n                keepInCollection          = [],\n                allDeselectedRecordsIndex = ArrayHelper.keyBy(allDeselectedRecords, 'id', () => 1); // For performance\n            for (const selectedRecord of me.selectedRecords) {\n                if (!allDeselectedRecordsIndex[selectedRecord.id]) {\n                    if (me.isSelected(selectedRecord)) {\n                        keepRecords.push(selectedRecord);\n                    }\n                    else {\n                        keepInCollection.push(selectedRecord);\n                    }\n                }\n            }\n            me.changeSelectedRecordCollectionSilent(c => c.values = [...keepRecords, ...keepInCollection]);\n            me._selectedRows = keepRecords;\n        }\n        // New selection\n        if (selectedCells.length) {\n            for (const selectedCell of selectedCells) {\n                if (!me._selectedCells.some(cellSelector => cellSelector.equals(selectedCell, true))) {\n                    me._selectedCells.push(selectedCell);\n                }\n            }\n        }\n        if (selectedRecords.length) {\n            me.changeSelectedRecordCollectionSilent(c => c.add(...selectedRecords));\n            me._selectedRows.push(...selectedRecords.filter(r => !me._selectedRows.some(sr => sr.id === r.id)));\n        }\n        if (selectedCellRecords.length) {\n            me.changeSelectedRecordCollectionSilent(c => c.add(...selectedCellRecords));\n        }\n        if (updateUI) {\n            me.refreshGridSelectionUI(selectionChange);\n        }\n        me.afterSelectionChange(selectionChange);\n        if (!silent) {\n            me.triggerSelectionChangeEvent(selectionChange);\n        }\n    }\n    // Makes sure the DOM is up-to-date with current selection.\n    refreshGridSelectionUI({ selectedRecords, selectedCells, deselectedRecords, deselectedCells }) {\n        const\n            me                          = this,\n            { checkboxSelectionColumn } = me;\n        // Row selection\n        checkboxSelectionColumn?.suspendEvents();\n        me.updateGridSelectionRecords(selectedRecords, true);\n        me.updateGridSelectionRecords(deselectedRecords, false);\n        me.updateCheckboxHeader();\n        checkboxSelectionColumn?.resumeEvents();\n        // Cell selection\n        if (me.isCellSelectionMode) {\n            me.updateGridSelectionCells(selectedCells, true);\n            if (me.selectionMode.column) {\n                me.updateGridSelectionColumns(selectedCells);\n            }\n        }\n        me.updateGridSelectionCells(deselectedCells, false);\n    }\n    // Loops through records and updates Grid rows\n    updateGridSelectionRecords(records, selected) {\n        const { checkboxSelectionColumn } = this;\n        if (records?.length) {\n            for (let i = 0; i < records.length; i++) {\n                const row = this.getRowFor(records[i]);\n                if (row) {\n                    row.toggleCls('b-selected', selected);\n                    row.setAttribute('aria-selected', selected);\n                    if (checkboxSelectionColumn && !checkboxSelectionColumn.hidden && !records[i].isSpecialRow) {\n                        row.getCell(checkboxSelectionColumn.id).widget.checked = selected;\n                    }\n                }\n            }\n        }\n    }\n    // Loops through cell selectors and updates Grid cell's\n    updateGridSelectionCells(cells, selected) {\n        if (cells?.length) {\n            for (let i = 0; i < cells.length; i++) {\n                const cell = this.getCell(cells[i]);\n                if (cell) {\n                    cell.setAttribute('aria-selected', selected);\n                    cell.classList.toggle('b-selected', selected);\n                }\n            }\n        }\n    }\n    // Loops through columns to toggle their selected state\n    updateGridSelectionColumns(selectedCells) {\n        const { count } = this.store;\n        for (const column of this.columns.visibleColumns) {\n            column.element?.classList.toggle(\n                'b-selected',\n                selectedCells?.filter(s => s.columnId === column.id).length === count\n            );\n        }\n    }\n    triggerSelectionChangeEvent(selectionChange) {\n        const\n            {\n                selectedRecords       = [],\n                selectedCells         = [],\n                selectedCellRecords   = [],\n                deselectedRecords     = [],\n                deselectedCells       = [],\n                deselectedCellRecords = []\n            }                    = selectionChange,\n            allSelectedRecords   = [...selectedRecords, ...selectedCellRecords],\n            allDeselectedRecords = [...deselectedRecords, ...deselectedCellRecords],\n            rowMode              = this.isRowSelectionMode;\n        this.trigger('selectionChange', {\n            mode          : rowMode ? 'row' : 'cell',\n            action        : selectionChange.action,\n            selected      : allSelectedRecords,\n            deselected    : allDeselectedRecords,\n            selection     : this.selectedRecords,\n            selectedCells,\n            deselectedCells,\n            cellSelection : this.selectedCells\n        });\n    }\n    //endregion\n    doDestroy() {\n        this.selectedRecordCollection?.owner === this && this.selectedRecordCollection.destroy();\n        this._selectedCells.length = 0;\n        this._selectedRows.length  = 0;\n        for (const detacher in this._selectionListenersDetachers) {\n            this._selectionListenersDetachers[detacher]();\n        }\n        super.doDestroy();\n    }\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport WidgetHelper from '../../../Core/helper/WidgetHelper.js';\n/**\n * @module Grid/view/mixin/GridState\n */\nconst\n    suspendStoreEvents = subGrid => subGrid.columns.suspendEvents(),\n    resumeStoreEvents = subGrid => subGrid.columns.resumeEvents(),\n    fillSubGridColumns = subGrid => {\n        subGrid.columns.clearCaches();\n        subGrid.columns.fillFromMaster();\n    },\n    compareStateSortIndex = (a, b) => a.stateSortIndex - b.stateSortIndex;\n/**\n * Mixin for Grid that handles state. It serializes the following grid properties:\n *\n * * rowHeight\n * * selectedCell\n * * selectedRecords\n * * columns (order, widths, visibility)\n * * store (sorters, groupers, filters)\n * * scroll position\n *\n * See {@link Core.mixin.State} for more information on state.\n *\n * {@inlineexample Grid/view/mixin/GridState.js}\n *\n * @demo Grid/state\n *\n * @mixin\n */\nexport default Target => class GridState extends (Target || Base) {\n    static get $name() {\n        return 'GridState';\n    }\n    static get configurable() {\n        return {\n            statefulEvents : ['subGridCollapse', 'subGridExpand', 'horizontalScrollEnd', 'stateChange']\n        };\n    }\n    /**\n     * Gets or sets grid's state. Check out {@link Grid.view.mixin.GridState} mixin for details.\n     * @member {Object} state\n     * @property {Object[]} state.columns\n     * @property {Number} state.rowHeight\n     * @property {Object} state.scroll\n     * @property {Number} state.scroll.scrollLeft\n     * @property {Number} state.scroll.scrollTop\n     * @property {Array} state.selectedRecords\n     * @property {String} state.style\n     * @property {String} state.selectedCell\n     * @property {Object} state.store\n     * @property {Object} state.store.sorters\n     * @property {Object} state.store.groupers\n     * @property {Object} state.store.filters\n     * @property {Object} state.subGrids\n     * @category State\n     */\n    updateStore(store, was) {\n        super.updateStore?.(store, was);\n        this.detachListeners('stateStoreListeners');\n        store?.ion({\n            name    : 'stateStoreListeners',\n            filter  : 'triggerUpdate',\n            group   : 'triggerUpdate',\n            sort    : 'triggerUpdate',\n            thisObj : this\n        });\n    }\n    updateColumns(columns, was) {\n        super.updateColumns?.(columns, was);\n        this.detachListeners('stateColumnListeners');\n        columns.ion({\n            name    : 'stateColumnListeners',\n            change  : 'triggerUpdate',\n            thisObj : this\n        });\n    }\n    updateRowManager(manager, was) {\n        super.updateRowManager?.(manager, was);\n        this.detachListeners('stateRowManagerListeners');\n        manager.ion({\n            name      : 'stateRowManagerListeners',\n            rowHeight : 'triggerUpdate',\n            thisObj   : this\n        });\n    }\n    triggerUpdate() {\n        this.trigger('stateChange');\n    }\n    finalizeInit() {\n        super.finalizeInit();\n        this.ion({\n            selectionChange : 'triggerUpdate',\n            thisObj         : this\n        });\n    }\n    /**\n     * Get grid's current state for serialization. State includes rowHeight, headerHeight, selectedCell,\n     * selectedRecordId, column states and store state etc.\n     * @returns {Object} State object to be serialized\n     * @private\n     */\n    getState() {\n        const\n            me    = this,\n            style = me.element.style.cssText,\n            state = {\n                rowHeight : me.rowHeight\n            };\n        if (style) {\n            state.style = style;\n        }\n        if (me.selectedCell) {\n            const { id, columnId } = me.selectedCell;\n            state.selectedCell = { id, columnId };\n        }\n        state.selectedRecords = me.selectedRecords.map(entry => entry.id);\n        state.columns = me.columns.allRecords.map(column => column.getState());\n        state.store = me.store.state;\n        state.scroll = me.storeScroll();\n        state.subGrids = {};\n        me.eachSubGrid(subGrid => {\n            const config = state.subGrids[subGrid.region] = state.subGrids[subGrid.region] || {};\n            if (subGrid.isPainted) {\n                if (subGrid.flex == null) {\n                    config.width = subGrid.width;\n                }\n            }\n            else {\n                if (subGrid.config.width != null) {\n                    config.width = subGrid.config.width;\n                }\n                else {\n                    config.flex = subGrid.config.flex;\n                }\n            }\n            config.collapsed = subGrid.collapsed ?? false;\n            // Part of a collapsed SubGrid's state is the state to restore to when expanding again.\n            if (config.collapsed) {\n                config._beforeCollapseState = subGrid._beforeCollapseState;\n            }\n        });\n        return state;\n    }\n    /**\n     * Apply previously stored state.\n     * @param {Object} state\n     * @private\n     */\n    applyState(state) {\n        const me = this;\n        // Applying state will call row renderer at least 7 times. Suspending refresh helps to save some time.\n        // Roughly on default testing grid apply state takes 26ms without suspend and 16ms with it.\n        me.suspendRefresh();\n        // Do this first since it might perform full rendering of contents, recreating filterbar header fields\n        if ('columns' in state) {\n            let columnsChanged = false,\n                needSort = false;\n            // We're going to renderContents anyway, so stop the ColumnStores from updating the UI\n            me.columns.suspendEvents();\n            me.eachSubGrid(suspendStoreEvents);\n            // each column triggers rerender at least once...\n            state.columns.forEach((columnState, index) => {\n                const column = me.columns.getById(columnState.id);\n                if (column) {\n                    const columnGeneration = column.generation;\n                    // If column region is missing in the current config, clear it from the column state and\n                    // stick to the default configuration\n                    if ('region' in columnState && !(columnState.region in me.subGrids)) {\n                        delete columnState.region;\n                        delete columnState.locked;\n                    }\n                    column.applyState(columnState);\n                    columnsChanged = columnsChanged || (column.generation !== columnGeneration);\n                    // In case a sort is needed, stamp in the ordinal position.\n                    column.stateSortIndex = index;\n                    // If we find one out of order, only then do we need to sort\n                    if (column.allIndex !== index) {\n                        needSort = columnsChanged = true;\n                    }\n                }\n            });\n            if (columnsChanged) {\n                me.eachSubGrid(fillSubGridColumns);\n            }\n            if (needSort) {\n                me.eachSubGrid(subGrid => {\n                    subGrid.columns.records.sort(compareStateSortIndex);\n                    subGrid.columns.allRecords.sort(compareStateSortIndex);\n                });\n                me.columns.sort({\n                    fn        : compareStateSortIndex,\n                    // always sort ascending\n                    ascending : true\n                });\n            }\n            // If we have been painted, and column restoration changed the column layout, refresh contents\n            if (me.isPainted && columnsChanged) {\n                me.renderContents();\n            }\n            // Allow ColumnStores to update the UI again\n            me.columns.resumeEvents();\n            me.eachSubGrid(resumeStoreEvents);\n        }\n        if ('subGrids' in state) {\n            me.eachSubGrid(subGrid => {\n                if (subGrid.region in state.subGrids) {\n                    const subGridState = state.subGrids[subGrid.region];\n                    if ('width' in subGridState) {\n                        subGrid.width = subGridState.width;\n                    }\n                    else if ('flex' in subGridState) {\n                        subGrid.flex = subGridState.flex;\n                    }\n                    if ('collapsed' in subGridState) {\n                        subGrid.collapsed = subGridState.collapsed;\n                        subGrid._beforeCollapseState = subGridState._beforeCollapseState;\n                    }\n                }\n                subGrid.clearWidthCache();\n            });\n        }\n        if ('rowHeight' in state) {\n            me.rowHeight = state.rowHeight;\n        }\n        if ('style' in state) {\n            me.style = state.style;\n        }\n        if ('selectedCell' in state) {\n            me.selectedCell = state.selectedCell;\n        }\n        if ('store' in state) {\n            me.store.state = state.store;\n        }\n        if ('selectedRecords' in state) {\n            me.selectedRecords = state.selectedRecords;\n        }\n        me.resumeRefresh(true);\n        me.whenVisible(() => me.applyScrollState(state));\n    }\n    applyScrollState(state) {\n        const me = this;\n        // Update scroll state\n        me.eachSubGrid(s => s.refreshFakeScroll());\n        if ('scroll' in state) {\n            me.restoreScroll(state.scroll);\n            // We need to force resize handler on all observable elements, because vertical scroll triggered by the\n            // previous method will suspend the listener. So by the time ResizeObserver triggers mutation handler\n            // listener won't actually update widget size.\n            // Handler works here because we haven't _yet_ suspended it, it will happen one animation frame after\n            // scroll event is triggered\n            if (state.scroll.scrollTop) {\n                me.element.querySelectorAll('.b-resize-monitored').forEach(element => {\n                    const widget = WidgetHelper.fromElement(element);\n                    if (widget) {\n                        widget.onElementResize(element);\n                    }\n                });\n            }\n        }\n    }\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {\n    }\n};\n", "/**\n * @module Grid/util/SubGridScroller\n */\nimport Scroller from '../../Core/helper/util/Scroller.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nconst\n    immediatePromise     = Promise.resolve(),\n    defaultScrollOptions = {\n        block : 'nearest'\n    };\n/**\n * A Scroller subclass which handles scrolling in a SubGrid. Needs special treatment since the SubGrid itself only\n * allows horizontal scrolling, while the vertical scrolling is done by an outer element containing all subgrids.\n *\n * @internal\n */\nexport default class SubGridScroller extends Scroller {\n    // SubGrids do not drive the scrollWidth of their partners (Header and Footer)\n    // SubGrids scrollWidth is propagated from the Header by SubGrid.refreshFakeScroll.\n    static configurable = {\n        propagate : false,\n        overflowX : 'hidden-scroll',\n        yScroller : null\n    };\n    // The Grid's main Y scroller keeps a list of the X scrollers\n    updateYScroller(yScroller) {\n        yScroller?.addScroller(this);\n    }\n    scrollIntoView(element, options = defaultScrollOptions) {\n        const\n            me = this,\n            { xDelta, yDelta } = me.getDeltaTo(element, options);\n        let result = (xDelta || yDelta) ? me.scrollBy(xDelta, yDelta, options) : immediatePromise;\n        if (options.highlight || options.focus) {\n            const scrollPromise = result;\n            result = result.then(() => {\n                if (scrollPromise.cancelled) {\n                    return;\n                }\n                element = element instanceof Rectangle\n                    ? element\n                    : options.elementAfterScroll?.() ?? element;\n                if (options.highlight) {\n                    if (element instanceof Rectangle) {\n                        element.translate(-xDelta, -yDelta).highlight();\n                    }\n                    else {\n                        DomHelper.highlight(element);\n                    }\n                }\n                if (options.focus) {\n                    DomHelper.focusWithoutScrolling(element);\n                }\n            });\n            result.cancel = () => scrollPromise.cancel?.();\n        }\n        return result;\n    }\n    scrollBy(xDelta, yDelta, options) {\n        const\n            yPromise = yDelta && this.yScroller.scrollBy(0, yDelta, options),\n            xPromise = xDelta && super.scrollBy(xDelta, 0, options);\n        const result = Promise.all([xPromise, yPromise]);\n        // Set up cross canceling\n        result.cancel = () => {\n            xPromise?.cancel?.();\n            yPromise?.cancel?.();\n            result.cancelled = true;\n        };\n        if (xPromise?.cancel && yPromise?.cancel) {\n            // Make sure a side effect of scrolling in one direction does not disturb the other\n            options.force = true;\n        }\n        return result;\n    }\n    scrollTo(toX, toY, options) {\n        const\n            yPromise = (toY != null) && this.yScroller.scrollTo(null, toY, options),\n            xPromise = (toX != null) && super.scrollTo(toX, null, options);\n        // Keep partners in sync immediately unless we are going to animate our position.\n        // There are potentially three: The header, the footer and the docked fake horizontal scroller.\n        // It will be more efficient and maintain correct state doing it now.\n        if (!(options && options.animate)) {\n            this.syncPartners();\n        }\n        const result = Promise.all([xPromise, yPromise]);\n        // Set up cross canceling\n        result.cancel = () => {\n            xPromise?.cancel?.();\n            yPromise?.cancel?.();\n            result.cancelled = true;\n        };\n        if (xPromise?.cancel && yPromise?.cancel) {\n            // Make sure a side effect of scrolling in one direction does not disturb the other\n            options.force = true;\n        }\n        return result;\n    }\n    get viewport() {\n        const\n            elementBounds = Rectangle.from(this.element),\n            viewport      = elementBounds.intersect(Rectangle.from(this.yScroller.element));\n        // For 0 height subgrids, viewport will be `false` but we still expect a Rectangle to be returned\n        return viewport || new Rectangle(elementBounds.x, elementBounds.y, elementBounds.width, 0);\n    }\n    set y(y) {\n        if (this.yScroller) {\n            this.yScroller.y = y;\n        }\n    }\n    get y() {\n        return this.yScroller ? this.yScroller.y : 0;\n    }\n    get maxY() {\n        return this.yScroller ? this.yScroller.maxY : 0;\n    }\n    get scrollHeight() {\n        return this.yScroller ? this.yScroller.scrollHeight : 0;\n    }\n    get clientHeight() {\n        return this.yScroller ? this.yScroller.clientHeight : 0;\n    }\n    suspendEvents() {\n        super.suspendEvents();\n        this.yScroller?.suspendEvents();\n    }\n    resumeEvents() {\n        super.resumeEvents();\n        this.yScroller?.resumeEvents();\n    }\n}\nSubGridScroller._$name = 'SubGridScroller';", "import BrowserHelper from '../../Core/helper/BrowserHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\nimport Widget from '../../Core/widget/Widget.js';\nimport Column from '../column/Column.js';\nimport SubGridScroller from '../util/SubGridScroller.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport Scroller from '../../Core/helper/util/Scroller.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\n/**\n * @module Grid/view/SubGrid\n */\nconst sumWidths = (t, e) => t + e.getBoundingClientRect().width;\n/**\n * A SubGrid is a part of the grid (it has at least one and normally no more than two, called locked and normal). It\n * has its own header, which holds the columns to display rows for in the SubGrid. SubGrids are created by Grid, you\n * should not need to create instances directly.\n *\n * If not configured with a width or flex, the SubGrid will be sized to fit its columns. In this case, if all columns\n * have a fixed width (not using flex) then toggling columns will also affect the width of the SubGrid.\n *\n * @extends Core/widget/Widget\n */\nexport default class SubGrid extends Widget {\n    //region Config\n    static get $name() {\n        return 'SubGrid';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'subgrid';\n    }\n    /**\n     * Region (name) for this SubGrid\n     * @config {String} region\n     */\n    /**\n     * Column store, a store containing the columns for this SubGrid\n     * @config {Grid.data.ColumnStore} columns\n     */\n    static get defaultConfig() {\n        return {\n            insertRowsBefore : null,\n            appendTo         : null,\n            monitorResize    : true,\n            headerClass      : null,\n            footerClass      : null,\n            /**\n             * The subgrid \"weight\" determines its position among its SubGrid siblings.\n             * Higher weights go further right.\n             * @config {Number}\n             * @category Layout\n             */\n            weight : null,\n            /**\n             * Set `true` to start subgrid collapsed. To operate collapsed state on subgrid use\n             * {@link #function-collapse}/{@link #function-expand} methods.\n             * @config {Boolean}\n             * @default false\n             */\n            collapsed : null,\n            scrollable : {\n                // Each SubGrid only handles scrolling in the X axis.\n                // The owning Grid handles the Y axis.\n                overflowX : 'hidden-scroll'\n            },\n            scrollerClass : SubGridScroller,\n            // Will be set to true by GridSubGrids if it calculates the subgrids width based on its columns.\n            // Used to determine if hiding a column should affect subgrids width\n            hasCalculatedWidth : null,\n            /**\n             * Set `true` to disable moving columns into or out of this SubGrid.\n             * @config {Boolean}\n             * @default false\n             * @private\n             */\n            sealedColumns : null\n        };\n    }\n    static get configurable() {\n        return {\n            element                : true,\n            header                 : {},\n            footer                 : {},\n            virtualScrollerElement : true,\n            splitterElement        : true,\n            headerSplitter         : true,\n            scrollerSplitter       : true,\n            footerSplitter         : true,\n            /**\n             * Set to `false` to prevent this subgrid being resized with the {@link Grid.feature.RegionResize} feature\n             * @config {Boolean}\n             * @default true\n             */\n            resizable : null,\n            role : 'presentation'\n        };\n    }\n    static delayable = {\n        // This uses a shorter delay for tests, see construct()\n        hideOverlayScroller : 1000\n    };\n    //endregion\n    //region Init\n    /**\n     * SubGrid constructor\n     * @param config\n     * @private\n     */\n    construct(config) {\n        const me = this;\n        super.construct(config);\n        this.rowManager.ion({ addRows : 'onAddRow', thisObj : this });\n        if (BrowserHelper.isFirefox) {\n            const\n                { element }      = me,\n                verticalScroller = me.grid.scrollable;\n            // Firefox cannot scroll vertically smoothly when using touch pad. Even a microscopic horizontal touch will\n            // abort the vertical scrolling. To counter this we ignore pointer events on the subgrid element temporarily\n            // until scroll stops. No test coverage.\n            // https://github.com/bryntum/support/issues/3000\n            let lastScrollTop = 0;\n            element.addEventListener('wheel', ({ ctrlKey, deltaY, deltaX }) => {\n                const isVerticalScroll = Math.abs(deltaY) > Math.abs(deltaX);\n                // Ignore wheel event with Control key pressed - it doesn't scroll, it either zooms scheduler or zooms\n                // the page.\n                if (!ctrlKey && isVerticalScroll && !me.scrollEndDetacher && verticalScroller.y !== lastScrollTop) {\n                    element.style.pointerEvents = 'none';\n                    lastScrollTop               = verticalScroller.y;\n                    me.scrollEndDetacher = verticalScroller.ion({\n                        scrollEnd : async() => {\n                            lastScrollTop               = verticalScroller.y;\n                            element.style.pointerEvents = '';\n                            me.scrollEndDetacher = null;\n                        },\n                        once : true\n                    });\n                }\n            });\n        }\n        if (VersionHelper.isTestEnv) {\n            me.hideOverlayScroller.delay = 50;\n        }\n    }\n    doDestroy() {\n        const me = this;\n        me.header.destroy();\n        me.footer.destroy();\n        me.fakeScroller?.destroy();\n        me.virtualScrollerElement.remove();\n        me.splitterElements.forEach(element => element.remove());\n        super.doDestroy();\n    }\n    get barConfig() {\n        const\n            me              = this,\n            { width, flex } = me.element.style,\n            config          = {\n                subGrid  : me,\n                parent   : me,  // Contained widgets need to know their parents\n                maxWidth : me.maxWidth || undefined,\n                minWidth : me.minWidth || undefined\n            };\n        // If we have been configured with sizing, construct the Bar in sync.\n        if (flex) {\n            config.flex = flex;\n        }\n        else if (width) {\n            config.width = width;\n        }\n        return config;\n    }\n    changeHeader(header) {\n        return new this.headerClass(ObjectHelper.assign({\n            id : this.id + '-header'\n        }, this.barConfig, header));\n    }\n    changeFooter(footer) {\n        return new this.footerClass(ObjectHelper.assign({\n            id : this.id + '-footer'\n        }, this.barConfig, footer));\n    }\n    //endregion\n    //region Splitters\n    get splitterElements() {\n        return [this.splitterElement, this.headerSplitter, this.scrollerSplitter, this.footerSplitter];\n    }\n    /**\n     * Toggle (add/remove) class for splitters\n     * @param {String} cls class name\n     * @param {Boolean} [add] actions. Set to `true` to add class, `false` to remove\n     * @private\n     */\n    toggleSplitterCls(cls, add = true) {\n        this.splitterElements.forEach(el => el?.classList[add ? 'add' : 'remove'](cls));\n    }\n    hideSplitter() {\n        this.splitterElements.forEach(el => el.classList.add('b-hide-display'));\n        this.$showingSplitter = false;\n    }\n    showSplitter() {\n        this.splitterElements.forEach(el => el.classList.remove('b-hide-display'));\n        this.$showingSplitter = true;\n    }\n    //endregion\n    //region Template\n    changeElement(element, was) {\n        const { region } = this;\n        return super.changeElement({\n            'aria-label' : region,\n            className    : {\n                'b-grid-subgrid'             : 1,\n                [`b-grid-subgrid-${region}`] : region,\n                'b-grid-subgrid-collapsed'   : this.collapsed\n            },\n            dataset : {\n                region\n            }\n        }, was);\n    }\n    get rowElementConfig() {\n        const { grid } = this;\n        return {\n            role      : 'row',\n            className : grid.rowCls,\n            children  : this.columns.visibleColumns.map((column, columnIndex) => ({\n                role            : 'gridcell',\n                'aria-colindex' : columnIndex + 1,\n                tabIndex        : grid.cellTabIndex,\n                className       : 'b-grid-cell',\n                dataset         : {\n                    column   : column.field || '',\n                    columnId : column.id\n                }\n            }))\n        };\n    }\n    // Added to DOM in Grid `get bodyConfig`\n    changeVirtualScrollerElement() {\n        const references = DomHelper.createElement({\n            role      : 'presentation',\n            reference : 'virtualScrollerElement',\n            className : 'b-virtual-scroller',\n            tabIndex  : -1,\n            dataset   : {\n                region : this.region\n            },\n            children : [\n                {\n                    reference : 'virtualScrollerWidth',\n                    className : 'b-virtual-width'\n                }\n            ]\n        });\n        this.virtualScrollerWidth = references.virtualScrollerWidth;\n        return references.virtualScrollerElement;\n    }\n    changeSplitterElement() {\n        const references = DomHelper.createElement({\n            reference : 'splitterElement',\n            className : {\n                'b-grid-splitter'           : 1,\n                'b-grid-splitter-collapsed' : this.collapsed,\n                'b-hide-display'            : 1 // GridSubGrids determines visibility\n            },\n            dataset : {\n                region : this.region\n            },\n            children : [\n                BrowserHelper.isTouchDevice ? { className : 'b-splitter-touch-area' } : null,\n                {\n                    className : 'b-grid-splitter-inner b-grid-splitter-main',\n                    children  : [\n                        {\n                            className : 'b-grid-splitter-buttons',\n                            reference : 'splitterButtons',\n                            children  : [\n                                {\n                                    className : 'b-grid-splitter-button-collapse',\n                                    children  : [\n                                        BrowserHelper.isTouchDevice ? { className : 'b-splitter-button-touch-area' } : null,\n                                        {\n                                            tag       : 'svg',\n                                            ns        : 'http://www.w3.org/2000/svg',\n                                            version   : '1.1',\n                                            className : 'b-grid-splitter-button-icon b-gridregion-collapse-arrow',\n                                            viewBox   : '0 0 256 512',\n                                            children  : [\n                                                {\n                                                    tag : 'path',\n                                                    d   : 'M192 448c-8.188 0-16.38-3.125-22.62-9.375l-160-160c-12.5-1' +\n                                                        '2.5-12.5-32.75 0-45.25l160-160c12.5-12.5 32.75-12.5 45.25 0s' +\n                                                        '12.5 32.75 0 45.25L77.25 256l137.4 137.4c12.5 12.5 12.5 32.7' +\n                                                        '5 0 45.25C208.4 444.9 200.2 448 192 448z'\n                                                }\n                                            ]\n                                        }\n                                    ]\n                                },\n                                {\n                                    className : 'b-grid-splitter-button-expand',\n                                    children  : [\n                                        BrowserHelper.isTouchDevice ? { className : 'b-splitter-button-touch-area' } : null,\n                                        {\n                                            tag       : 'svg',\n                                            ns        : 'http://www.w3.org/2000/svg',\n                                            version   : '1.1',\n                                            className : 'b-grid-splitter-button-icon b-gridregion-expand-arrow',\n                                            viewBox   : '0 0 256 512',\n                                            children  : [\n                                                {\n                                                    tag : 'path',\n                                                    d   : 'M64 448c-8.188 0-16.38-3.125-22.62-9.375c-12.5-12.5-12.5-3' +\n                                                        '2.75 0-45.25L178.8 256L41.38 118.6c-12.5-12.5-12.5-32.75 0-4' +\n                                                        '5.25s32.75-12.5 45.25 0l160 160c12.5 12.5 12.5 32.75 0 45.25' +\n                                                        'l-160 160C80.38 444.9 72.19 448 64 448z'\n                                                }\n                                            ]\n                                        }\n                                    ]\n                                }\n                            ]\n                        }\n                    ]\n                }\n            ]\n        });\n        this.splitterButtons = references.splitterButtons;\n        return references.splitterElement;\n    }\n    get splitterConfig() {\n        return {\n            className : this.splitterElement.className.trim(),\n            children  : [\n                BrowserHelper.isTouchDevice ? { className : 'b-splitter-touch-area' } : null,\n                {\n                    className : 'b-grid-splitter-inner'\n                }\n            ],\n            dataset : {\n                region : this.region\n            }\n        };\n    }\n    changeHeaderSplitter() {\n        return DomHelper.createElement(this.splitterConfig);\n    }\n    changeScrollerSplitter() {\n        return DomHelper.createElement(this.splitterConfig);\n    }\n    changeFooterSplitter() {\n        return DomHelper.createElement(this.splitterConfig);\n    }\n    //endregion\n    //region Render\n    render(...args) {\n        const me = this;\n        super.render(...args);\n        // Unit tests create naked SubGrids so we have to do this.\n        if (me.grid) {\n            me.updateHasFlex();\n            me.element.parentNode.insertBefore(me.splitterElement, me.element.nextElementSibling);\n            // Cant use \"global\" listener with delegate for mouseenter, since mouseenter only fires on target\n            me.splitterElements.forEach(element =>\n                EventHelper.on({\n                    element,\n                    mouseenter : 'onSplitterMouseEnter',\n                    mouseleave : 'onSplitterMouseLeave',\n                    thisObj    : me\n                })\n            );\n            me._collapsed && me.collapse();\n        }\n    }\n    toggleHeaders(hide) {\n        const me = this;\n        if (hide) {\n            me.headerSplitter.remove();\n            me.header.element.remove();\n            me.scrollable.removePartner(me.header.scrollable, 'x');\n        }\n        else {\n            const { grid } = me;\n            // Header elements are always created in GridSubGrids.js\n            if (!me.isConfiguring) {\n                const index = grid.items.indexOf(me) * 2;\n                DomHelper.insertAt(grid.headerContainer, me.headerSplitter, index);\n                DomHelper.insertAt(grid.headerContainer, me.header.element, index);\n                me.refreshHeader();\n            }\n            me.scrollable.addPartner(me.header.scrollable, 'x');\n        }\n    }\n    refreshHeader() {\n        this.header.refreshContent();\n    }\n    refreshColumnHeader(column) {\n        this.header.refreshColumn(column);\n    }\n    refreshFooter() {\n        this.footer?.refreshContent();\n    }\n    // Override to iterate header and footer.\n    eachWidget(fn, deep = true) {\n        const\n            me      = this,\n            widgets = [me.header, me.footer];\n        for (let i = 0; i < widgets.length; i++) {\n            const widget = widgets[i];\n            if (fn(widget) === false) {\n                return;\n            }\n            if (deep && widget.eachWidget) {\n                widget.eachWidget(fn, deep);\n            }\n        }\n    }\n    //endregion\n    //region Size & resize\n    /**\n     * Sets cell widths. Cannot be done in template because of CSP\n     * @private\n     */\n    fixCellWidths(rowElement) {\n        const { visibleColumns } = this.columns;\n        // fix cell widths, no longer allowed in template because of CSP\n        let cell = rowElement.firstElementChild,\n            i    = 0;\n        while (cell) {\n            const\n                column      = visibleColumns[i],\n                { element } = column;\n            if (column.minWidth) {\n                cell.style.minWidth = DomHelper.setLength(column.minWidth);\n            }\n            if (column.maxWidth) {\n                cell.style.maxWidth = DomHelper.setLength(column.maxWidth);\n            }\n            // either flex or width, flex has precedence\n            if (column.flex) {\n                // Nested flex - we have to match the column's header width because it's flexing\n                // a different available space - the space in its owning column header.\n                if (column.childLevel && element) {\n                    cell.style.flex = `0 0 ${element.getBoundingClientRect().width}px`;\n                    cell.style.width = '';\n                }\n                else {\n                    cell.style.flex = column.flex;\n                    cell.style.width = '';\n                }\n            }\n            else if (column.width) {\n                // https://app.assembla.com/spaces/bryntum/tickets/8041\n                // Although header and footer elements must be sized using flex-basis to avoid the busting out problem,\n                // grid cells MUST be sized using width since rows are absolutely positioned and will not cause the\n                // busting out problem, and rows will not stretch to shrinkwrap the cells unless they are widthed with\n                // width.\n                cell.style.width = DomHelper.setLength(column.width);\n            }\n            else {\n                cell.style.flex = cell.style.width = cell.style.minWidth = '';\n            }\n            cell = cell.nextElementSibling;\n            i++;\n        }\n    }\n    get totalFixedWidth() {\n        return this.columns.totalFixedWidth;\n    }\n    get headerScrollWidth() {\n        return [...this.header.contentElement.children].reduce(sumWidths, 0) || this.columns.totalFixedWidth;\n    }\n    /**\n     * Sets header width and scroller width (if needed, depending on if using flex). Might also change the subgrids\n     * width, if it uses a width calculated from its columns.\n     * @private\n     */\n    fixWidths() {\n        const\n            me = this,\n            {\n                element,\n                header,\n                footer\n            }  = me;\n        if (!me.collapsed) {\n            if (me.flex) {\n                header.flex = me.flex;\n                if (footer) {\n                    footer.flex = me.flex;\n                }\n                element.style.flex = me.flex;\n            }\n            else {\n                // If width is calculated and no column is using flex, check if total width is less than width. If so,\n                // recalculate width and bail out of further processing (since setting width will trigger again)\n                if (\n                    me.hasCalculatedWidth &&\n                    !me.columns.some(col => !col.hidden && col.flex) &&\n                    me.totalFixedWidth !== me.width\n                ) {\n                    me.width = me.totalFixedWidth;\n                    // Setting width above clears the hasCalculatedWidth flag, but we want to keep it set to react\n                    // correctly next time\n                    me.hasCalculatedWidth = true;\n                    return;\n                }\n                let totalWidth = me.width;\n                // Calculate width from our total column width if we are supposed to have a calculated width\n                if (!totalWidth && me.hasCalculatedWidth) {\n                    totalWidth = 0;\n                    // summarize column widths, needed as container width when not using flex widths.\n                    for (const col of me.columns) {\n                        if (!col.flex && !col.hidden) totalWidth += col.width;\n                    }\n                }\n                // rows are absolutely positioned, meaning that their width won't affect container width\n                // hence we must set it, if not using flex\n                element.style.width = `${totalWidth}px`;\n                header.width = totalWidth;\n                if (footer) {\n                    footer.width = totalWidth;\n                }\n            }\n            me.handleHorizontalScroll(false);\n        }\n    }\n    // Safari does not shrink cells the same way as chrome & ff does without having a width set on the row\n    fixRowWidthsInSafariEdge() {\n        if (BrowserHelper.isSafari) {\n            const\n                me                 = this,\n                { region, header } = me,\n                minWidth           = header.calculateMinWidthForSafari();\n            // fix row widths for safari, it does not size flex cells correctly at small widths otherwise.\n            // there should be a css solution, but I have failed to find it\n            me.rowManager.forEach(row => {\n                // This function runs on resize and rendering a SubGrid triggers a resize. When adding a new SubGrid\n                // on the fly elements won't exists for it yet, so ignore...\n                const element = row.getElement(region);\n                // it is worth noting that setting a width does not prevent the row from growing beyond that with\n                // when making view wider, it is used in flex calculation more like a min-width\n                if (element) {\n                    element.style.width = `${minWidth}px`;\n                }\n            });\n            header.headersElement.style.width = `${minWidth}px`;\n        }\n    }\n    /**\n     * Get/set SubGrid width, which also sets header and footer width (if available).\n     * @property {Number}\n     */\n    set width(width) {\n        const me = this;\n        // Width explicitly set, remember that\n        me.hasCalculatedWidth = false;\n        super.width = width;\n        me.header.width = width;\n        me.footer.width = width;\n        // When we're live, we can't wait until the  throttled resize occurs - it looks bad.\n        if (me.isPainted) {\n            me.onElementResize();\n        }\n        // Sync width of same subgrid in other splits, but not during expand / resize since those are also synced\n        if (!me.isExpanding && !me.isCollapsing && !me.isConfiguring) {\n            me.grid.syncSplits?.(other => other.subGrids[me.region] && (other.subGrids[me.region].width = width));\n        }\n    }\n    get width() {\n        return super.width;\n    }\n    /**\n     * Get/set SubGrid flex, which also sets header and footer flex (if available).\n     * @property {Number|String}\n     */\n    set flex(flex) {\n        const me = this;\n        // Width explicitly set, remember that\n        me.hasCalculatedWidth = false;\n        me.header.flex = flex;\n        me.footer.flex = flex;\n        super.flex = flex;\n        // When we're live, we can't wait until the  throttled resize occurs - it looks bad.\n        if (me.isPainted) {\n            me.onElementResize();\n        }\n        // Sync width of same subgrid in other splits, but not during expand / resize since those are also synced\n        if (!me.isExpanding && !me.isCollapsing && !me.isConfiguring) {\n            me.grid.syncSplits?.(other => other.subGrids[me.region] && (other.subGrids[me.region].flex = flex));\n        }\n    }\n    get flex() {\n        return super.flex;\n    }\n    /**\n     * Called when grid changes size. SubGrid determines if it has changed size and triggers scroll (for virtual\n     * rendering in cells to work when resizing etc.)\n     * @private\n     */\n    onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight) {\n        const\n            me       = this,\n            { grid } = me;\n        // Widget caches dimensions\n        super.onInternalResize(...arguments);\n        // Unit tests create naked SubGrids so we have to do this.\n        if (grid?.isPainted) {\n            me.syncSplitterButtonPosition();\n            if (newWidth !== oldWidth) {\n                // Merged cells needs to react before we update scrollbars\n                me.trigger('beforeInternalResize', me);\n                // trigger scroll, in case anything is done on scroll it needs to be done now also\n                grid.trigger('horizontalScroll', {\n                    grid,\n                    subGrid    : me,\n                    scrollLeft : me.scrollable.scrollLeft,\n                    scrollX    : me.scrollable.x\n                });\n                // ditto for scrollEnd (state tests expect saving on resize, and that now happens on scrollEnd)\n                grid.trigger('horizontalScrollEnd', { subGrid : me });\n                // Update virtual scrollers, if they are ready\n                me.fakeScroller && me.refreshFakeScroll();\n                // Columns which are flexed, but as part of a grouped column cannot just have their flex\n                // value reflected in the flex value of its cells. They are flexing a different available space.\n                // These have to be set to the exact width and kept synced.\n                grid.syncFlexedSubCols();\n                me.fixRowWidthsInSafariEdge();\n            }\n            if (newHeight !== oldHeight) {\n                // Call this to update cached _bodyHeight\n                grid.onHeightChange();\n            }\n            me.trigger('afterInternalResize', me);\n        }\n    }\n    /**\n     * Keeps the parallel splitters in the header, footer and fake scroller synced in terms\n     * of being collapsed or not.\n     * @private\n     */\n    syncParallelSplitters(collapsed) {\n        const\n            me       = this,\n            { grid } = me;\n        if (me.splitterElement && me.$showingSplitter) {\n            me.toggleSplitterCls('b-grid-splitter-collapsed', collapsed);\n        }\n        else {\n            // If we're the last, we don't own a splitter, we use the previous region's splitter\n            const prevGrid = grid.getSubGrid(grid.getPreviousRegion(me.region));\n            // If there's a splitter before us, sync it with our state.\n            if (prevGrid && prevGrid.splitterElement) {\n                prevGrid.syncParallelSplitters(collapsed);\n            }\n        }\n    }\n    onSplitterMouseEnter() {\n        const\n            me              = this,\n            { nextSibling } = me;\n        // No hover effect when collapsed\n        if (!me.collapsed && (!nextSibling || !nextSibling.collapsed)) {\n            me.toggleSplitterCls('b-hover');\n        }\n        me.startSplitterButtonSyncing();\n    }\n    onSplitterMouseLeave() {\n        const\n            me              = this,\n            { nextSibling } = me;\n        me.toggleSplitterCls('b-hover', false);\n        if (!me.collapsed && (!nextSibling || !nextSibling.collapsed)) {\n            me.stopSplitterButtonSyncing();\n        }\n    }\n    startSplitterButtonSyncing() {\n        const me = this;\n        if (me.splitterElement) {\n            me.syncSplitterButtonPosition();\n            if (!me.splitterSyncScrollListener) {\n                me.splitterSyncScrollListener = me.grid.scrollable.ion({\n                    scroll  : 'syncSplitterButtonPosition',\n                    thisObj : me\n                });\n            }\n        }\n    }\n    stopSplitterButtonSyncing() {\n        if (this.splitterSyncScrollListener) {\n            this.splitterSyncScrollListener();\n            this.splitterSyncScrollListener = null;\n        }\n    }\n    syncSplitterButtonPosition() {\n        const { grid } = this;\n        this.splitterButtons.style.top = `${grid.scrollable.y + ((grid.bodyHeight - (this.headerSplitter ? grid.headerHeight : 0)) / 2)}px`;\n    }\n    /**\n     * Get the \"viewport\" for the SubGrid as a Rectangle\n     * @property {Core.helper.util.Rectangle}\n     * @readonly\n     */\n    get viewRectangle() {\n        const { scrollable } = this;\n        return new Rectangle(scrollable.x, scrollable.y, this.width || 0, this.rowManager.viewHeight);\n    }\n    /**\n     * Called when updating column widths to apply 'b-has-flex' which is used when fillLastColumn is configured.\n     * @internal\n     */\n    updateHasFlex() {\n        this.scrollable.element.classList.toggle('b-has-flex', this.columns.hasFlex);\n    }\n    updateResizable(resizable) {\n        this.splitterElements.forEach(splitter => DomHelper.toggleClasses(splitter, ['b-disabled'], !resizable));\n    }\n    /**\n     * Resize all columns in the SubGrid to fit their width, according to their configured\n     * {@link Grid.column.Column#config-fitMode}\n     */\n    resizeColumnsToFitContent() {\n        this.grid.beginGridMeasuring();\n        this.columns.visibleColumns.forEach(column => {\n            column.resizeToFitContent(null, null, true);\n        });\n        this.grid.endGridMeasuring();\n    }\n    //endregion\n    //region Scroll\n    get overflowingHorizontally() {\n        // We are not overflowing if collapsed.\n        // It is the columns which dictate the content width, so the header\n        // will know about overflow first.\n        return !this.collapsed && (this.hideHeaders ? this.scrollable.hasOverflow('x') : this.header.scrollable.hasOverflow('x'));\n    }\n    get overflowingVertically() {\n        // SubGrids never overflow vertically. They are full calculated content height.\n        // The owning Grid scrolls all SubGrids vertically in its own overflowElement.\n        return false;\n    }\n    /**\n     * Fixes widths of fake scrollers\n     * @private\n     */\n    refreshFakeScroll() {\n        const\n            me = this,\n            {\n                element,\n                virtualScrollerElement,\n                virtualScrollerWidth,\n                header,\n                footer,\n                scrollable\n            }  = me,\n            // Cannot use scrollWidth because its an integer and we need exact content size\n            totalFixedWidth = [...header.contentElement.children].reduce(sumWidths, 0);\n        // Use a fixed scroll width so that when grid is empty (e.g after filtering with no matches),\n        // it is able to it maintain its scroll-x position and magic mouse swiping\n        // in the grid area will produce horizontal scrolling.\n        // https://github.com/bryntum/support/issues/3247\n        scrollable.scrollWidth = totalFixedWidth;\n        // This style property ensures all rows expand to accommodate the visible columns\n        // And that headers, footers, and virtual scroller have scroll range.\n        element.style.setProperty('--total-column-width', `${me.headerScrollWidth}px`);\n        // Scroller lays out in the same way as subgrid.\n        // If we are flexed, the scroller is flexed etc.\n        virtualScrollerElement.style.width = element.style.width;\n        virtualScrollerElement.style.flex = element.style.flex;\n        virtualScrollerElement.style.minWidth = element.style.minWidth;\n        virtualScrollerElement.style.maxWidth = element.style.maxWidth;\n        header.scrollable.syncOverflowState();\n        footer.scrollable.syncOverflowState();\n        if (!me.collapsed) {\n            if (me.overflowingHorizontally) {\n                virtualScrollerWidth.style.width = `${scrollable.scrollWidth || 0}px`;\n                // If *any* SubGrids have horizontal overflow, the main grid\n                // has to show its virtual horizontal scrollbar.\n                me.grid.virtualScrollers.classList.remove('b-hide-display');\n            }\n            else {\n                virtualScrollerWidth.style.width = 0;\n            }\n        }\n    }\n    /**\n     * Init scroll syncing for header and footer (if available).\n     * @private\n     */\n    initScroll() {\n        const\n            me = this,\n            {\n                scrollable,\n                virtualScrollerElement,\n                grid\n            }  = me;\n        if (BrowserHelper.isFirefox) {\n            scrollable.element.addEventListener('wheel', event => {\n                if (event.deltaX) {\n                    scrollable.x += event.deltaX;\n                    event.preventDefault();\n                }\n            });\n        }\n        // Create a Scroller for the fake horizontal scrollbar so that it can partner\n        me.fakeScroller = new Scroller({\n            element   : virtualScrollerElement,\n            overflowX : true,\n            widget    : me // To avoid more expensive style lookup for RTL\n        });\n        // Sync scrolling partners (header, footer) when our xScroller reports a scroll.\n        // Also fires horizontalscroll\n        scrollable.ion({\n            scroll    : 'onSubGridScroll',\n            scrollend : 'onSubGridScrollEnd',\n            thisObj   : me\n        });\n        if (!grid.hideHorizontalScrollbar) {\n            scrollable.addPartner(me.fakeScroller, 'x');\n            // Update virtual scrollers (previously updated too early from onInternalResize)\n            me.refreshFakeScroll();\n        }\n        if (!grid.hideHeaders) {\n            scrollable.addPartner(me.header.scrollable, 'x');\n        }\n        if (!grid.hideFooters) {\n            scrollable.addPartner(me.footer.scrollable, 'x');\n        }\n    }\n    onSubGridScrollEnd(event) {\n        const\n            me       = this,\n            { grid } = me;\n        me.scrollingToCenter = event?.scrollingToCenter;\n        me.scrolling = false;\n        me.handleHorizontalScroll(false);\n        if (!DomHelper.scrollBarWidth) {\n            grid.virtualScrollers.classList.remove('b-scrolling');\n            // Remove interactivity a while after scrolling ended\n            me.hideOverlayScroller();\n        }\n        // Used by GridState\n        grid.trigger('horizontalScrollEnd', { subGrid : me });\n    }\n    onSubGridScroll(event) {\n        const me = this;\n        me.scrollingToCenter = event?.scrollingToCenter;\n        me.handleHorizontalScroll();\n    }\n    showOverlayScroller() {\n        this.hideOverlayScroller.cancel();\n        this.virtualScrollerElement.classList.add('b-show-virtual-scroller');\n    }\n    // Buffered 1500ms, hides virtual scrollers after scrolling has ended\n    hideOverlayScroller() {\n        this.virtualScrollerElement.classList.remove('b-show-virtual-scroller');\n    }\n    set scrolling(scrolling) {\n        this._scrolling = scrolling;\n    }\n    get scrolling() {\n        return this._scrolling;\n    }\n    /**\n     * Triggers the 'horizontalScroll' event + makes sure overlay scrollbar is reachable with pointer for a substantial\n     * amount of time after scrolling starts\n     * @internal\n     */\n    handleHorizontalScroll(addCls = true) {\n        const\n            subGrid  = this,\n            { grid } = subGrid;\n        if (!subGrid.scrolling && addCls) {\n            subGrid.scrolling = true;\n            // Allow interacting with overlaid scrollbar after scrolling starts\n            if (!DomHelper.scrollBarWidth) {\n                // Cls indicating that we are actively scrolling\n                grid.virtualScrollers.classList.add('b-scrolling');\n                // Cls sticking around longer to keep overlay scrollbar visible longer, allowing users to more easily\n                // grab it to drag more\n                subGrid.showOverlayScroller();\n            }\n        }\n        grid.trigger('horizontalScroll', {\n            subGrid,\n            grid,\n            scrollLeft        : subGrid.scrollable.scrollLeft,\n            scrollX           : subGrid.scrollable.x,\n            scrollingToCenter : subGrid?.scrollingToCenter\n        });\n    }\n    /**\n     * Scrolls a column into view (if it is not already). Called by Grid#scrollColumnIntoView, use it instead to not\n     * have to care about which SubGrid contains a column.\n     * @param {Grid.column.Column|String|Number} column Column name (data) or column index or actual column object.\n     * @param {BryntumScrollOptions} [options] How to scroll.\n     * @returns {Promise} If the column exists, a promise which is resolved when the column header element has been\n     * scrolled into view.\n     */\n    scrollColumnIntoView(column, options) {\n        const\n            { columns, header } = this,\n            scroller            = header.scrollable;\n        // Allow column,column id,or column index to be passed\n        column = (column instanceof Column) ? column : columns.get(column) || columns.getById(column) || columns.getAt(column);\n        if (column) {\n            // Get the current column header element.\n            const columnHeaderElement = header.getHeader(column.id);\n            if (columnHeaderElement) {\n                return scroller.scrollIntoView(Rectangle.from(columnHeaderElement, null, true), options);\n            }\n        }\n    }\n    //endregion\n    //region Rows\n    /**\n     * Creates elements for the new rows when RowManager has determined that more rows are needed\n     * @private\n     */\n    onAddRow({ source = this.grid.rowManager, rows, isExport }) {\n        const\n            me               = this,\n            { region }       = me,\n            config           = me.rowElementConfig,\n            frag             = document.createDocumentFragment(),\n            insertRowsBefore = source.rows[rows[rows.length - 1].index + 1]?.elements[region];\n        rows.forEach(row => {\n            const rowElement = DomHelper.createElement(config);\n            DomHelper.syncClassList(rowElement, row.cls);\n            frag.appendChild(rowElement);\n            row.addElement(region, rowElement);\n            me.fixCellWidths(rowElement);\n        });\n        // Do not insert elements to DOM if we're exporting them\n        if (!isExport) {\n            me.fixRowWidthsInSafariEdge();\n            // Put the row elements into the SubGrid en masse.\n            // If 2nd param is null, insertBefore appends.\n            me.element.insertBefore(frag, insertRowsBefore || me.insertRowsBefore);\n        }\n    }\n    /**\n     * Get all row elements for this SubGrid.\n     * @property {HTMLElement[]}\n     * @readonly\n     */\n    get rowElements() {\n        return this.fromCache('.b-grid-row', true);\n    }\n    /**\n     * Removes all row elements from the subgrids body and empties cache\n     * @private\n     */\n    clearRows() {\n        this.emptyCache();\n        const\n            all   = this.element.querySelectorAll('.b-grid-row'),\n            range = document.createRange();\n        if (all.length) {\n            range.setStartBefore(all[0]);\n            range.setEndAfter(all[all.length - 1]);\n            range.deleteContents();\n        }\n    }\n    // only called when RowManager.rowScrollMode = 'dom', which is not intended to be used\n    addNewRowElement() {\n        const rowElement = DomHelper.append(this.element, this.rowElementConfig);\n        this.fixCellWidths(rowElement);\n        return rowElement;\n    }\n    get store() {\n        return this.grid.store;\n    }\n    get rowManager() {\n        return this.grid?.rowManager;\n    }\n    //endregion\n    // region Expand/collapse\n    // All usages are commented, uncomment when this is resolved: https://app.assembla.com/spaces/bryntum/tickets/5472\n    toggleTransitionClasses(doRemove = false) {\n        const\n            me         = this,\n            grid       = me.grid,\n            nextRegion = grid.getSubGrid(grid.getNextRegion(me.region)),\n            splitter   = grid.resolveSplitter(nextRegion);\n        nextRegion.element.classList[doRemove ? 'remove' : 'add']('b-grid-subgrid-animate-collapse');\n        nextRegion.header.element.classList[doRemove ? 'remove' : 'add']('b-grid-subgrid-animate-collapse');\n        me.element.classList[doRemove ? 'remove' : 'add']('b-grid-subgrid-animate-collapse');\n        me.header.element.classList[doRemove ? 'remove' : 'add']('b-grid-subgrid-animate-collapse');\n        splitter.classList[doRemove ? 'remove' : 'add']('b-grid-splitter-animate');\n    }\n    /**\n     * Get/set collapsed state\n     * @property {Boolean}\n     */\n    get collapsed() {\n        return this._collapsed;\n    }\n    set collapsed(collapsed) {\n        if (this.isConfiguring) {\n            this._collapsed = collapsed;\n        }\n        else {\n            if (collapsed) {\n                this.collapse();\n            }\n            else {\n                this.expand();\n            }\n        }\n    }\n    /**\n     * Collapses subgrid. If collapsing subgrid is the only one expanded, next subgrid to the right (or previous) will\n     * be expanded.\n     *\n     * ```javascript\n     * let locked = grid.getSubGrid('locked');\n     * locked.collapse().then(() => {\n     *     console.log(locked.collapsed); // Logs 'True'\n     * });\n     *\n     * let normal = grid.getSubGrid('normal');\n     * normal.collapse().then(() => {\n     *     console.log(locked.collapsed); // Logs 'False'\n     *     console.log(normal.collapsed); // Logs 'True'\n     * });\n     * ```\n     *\n     * @returns {Promise} A Promise which resolves when this SubGrid is fully collapsed.\n     */\n    async collapse() {\n        const\n            me                       = this,\n            { grid, element }        = me,\n            nextRegion               = grid.getSubGrid(grid.getNextRegion(me.region)),\n            splitterOwner            = me.splitterElement ? me : me.previousSibling;\n        let { _beforeCollapseState } = me,\n            // Count all expanded regions. Grid must always have at least one expanded region\n            expandedRegions          = 0;\n        if (grid.rendered && me._collapsed === true) {\n            return;\n        }\n        me.isCollapsing = true;\n        grid.eachSubGrid(subGrid => {\n            subGrid !== me && !subGrid._collapsed && ++expandedRegions;\n        });\n        grid.syncSplits?.(other => other.subGrids[me.region]?.collapse());\n        // Current region is the only one expanded, expand next region\n        if (expandedRegions === 0) {\n            // When splitting, not all splits will have all regions\n            if (!nextRegion) {\n                return;\n            }\n            // expandPromise = nextRegion.expand();\n            await nextRegion.expand();\n        }\n        return new Promise((resolve) => {\n            if (!_beforeCollapseState) {\n                _beforeCollapseState = me._beforeCollapseState = {};\n                let widthChanged = false;\n                // If current width is zero, the resize event will not be fired. In such case we want to trigger callback immediately\n                if (me.width) {\n                    widthChanged = true;\n                    // Toggle transition classes here, we will actually change width below\n                    // me.toggleTransitionClasses();\n                    // afterinternalresize event is buffered, it will be fired only once after animation is finished\n                    // and element size is final\n                    me.ion({\n                        afterinternalresize : () => {\n                            // me.toggleTransitionClasses(true);\n                            resolve(me);\n                        },\n                        thisObj : me,\n                        once    : true\n                    });\n                }\n                // When trying to collapse region we need its partner to occupy free space. Considering multiple\n                // regions, several cases are possible:\n                // 1) Both left and right regions have fixed width\n                // 2) Left region has fixed width, right region is flexed\n                // 3) Left region is flexed, right region has fixed width\n                // 4) Both regions are flexed\n                //\n                // To collapse flexed region we need to remove flex style, remember it somehow and set fixed width.\n                // If another region is flexed, it will fill the space. If it has fixed width, we need to increase\n                // its width by collapsing region width. Same logic should be applied to headers.\n                //\n                // Save region width first\n                _beforeCollapseState.width = me.width;\n                _beforeCollapseState.elementWidth = element.style.width;\n                // Next region is not flexed, need to make it fill the space\n                if (nextRegion.element.style.flex === '') {\n                    _beforeCollapseState.nextRegionWidth = nextRegion.width;\n                    nextRegion.width = '';\n                    nextRegion.flex = '1';\n                }\n                // Current region is flexed, store style to restore on expand\n                if (element.style.flex !== '') {\n                    _beforeCollapseState.flex = element.style.flex;\n                    // remove flex state to reduce width later\n                    me.header.element.style.flex = element.style.flex = '';\n                }\n                // Sets the grid to its collapsed width as defined in SASS: zero\n                element.classList.add('b-grid-subgrid-collapsed');\n                // The parallel elements which must be in sync width-wise must know about collapsing\n                me.virtualScrollerElement.classList.add('b-collapsed');\n                me.header.element.classList.add('b-collapsed');\n                me.footer.element.classList.add('b-collapsed');\n                me._collapsed = true;\n                me.width = '';\n                if (!widthChanged) {\n                    // sync splitters in case subGrid was collapsed by state (https://github.com/bryntum/support/issues/1857)\n                    me.syncParallelSplitters(true);\n                    resolve(false);\n                }\n            }\n            else {\n                resolve();\n            }\n            grid.trigger('subGridCollapse', { subGrid : me });\n            grid.afterToggleSubGrid({ subGrid : me, collapsed : true });\n            me.isCollapsing = false;\n        }).then(value => {\n            if (!me.isDestroyed) {\n                if (value !== false) {\n                    grid.refreshVirtualScrollbars();\n                    me.syncParallelSplitters(true);\n                    // Our splitter is permanently visible when collapsed, so keep splitter button set\n                    // synced in the vertical centre of the view just in time for paint.\n                    // Uses translateY so will not cause a further layout.\n                    splitterOwner.startSplitterButtonSyncing?.();\n                }\n            }\n        });\n    }\n    /**\n     * Expands subgrid.\n     *\n     * ```javascript\n     * grid.getSubGrid('locked').expand().then(() => console.log('locked grid expanded'));\n     * ```\n     *\n     * @returns {Promise} A Promise which resolves when this SubGrid is fully expanded.\n     */\n    async expand() {\n        const\n            me            = this,\n            {\n                grid,\n                _beforeCollapseState\n            }             = me,\n            nextRegion    = grid.getSubGrid(grid.getNextRegion(me.region)),\n            splitterOwner = me.splitterElement ? me : me.previousSibling;\n        if (grid.rendered && me._collapsed !== true) {\n            return;\n        }\n        me.isExpanding = true;\n        grid.syncSplits?.(other => other.subGrids[me.region]?.expand());\n        return new Promise((resolve) => {\n            if (_beforeCollapseState != null) {\n                // If current width matches width expected after expand resize event will not be fired. In such case\n                // we want to trigger callback immediately\n                let widthChanged = false;\n                // See similar clause in collapse method above\n                if (me.width !== _beforeCollapseState.elementWidth) {\n                    widthChanged = true;\n                    // Toggle transition classes here, we will actually change width below\n                    // me.toggleTransitionClasses();\n                    me.ion({\n                        afterinternalresize() {\n                            // me.toggleTransitionClasses(true);\n                            // Delay the resolve to avoid \"ResizeObserver loop limit exceeded\" errors\n                            // collapsing the only expanded region and it has to expand its nextRegion\n                            // before it can collapse.\n                            me.setTimeout(() => resolve(me), 10);\n                        },\n                        thisObj : me,\n                        once    : true\n                    });\n                }\n                // previous region is not flexed, reduce its width as it was increased in collapse\n                if (_beforeCollapseState.nextRegionWidth) {\n                    nextRegion.width = _beforeCollapseState.nextRegionWidth;\n                    nextRegion.flex = null;\n                }\n                me.element.classList.remove('b-grid-subgrid-collapsed');\n                me._collapsed = false;\n                // The parallel elements which must be in sync width-wise must know about collapsing\n                me.virtualScrollerElement.classList.remove('b-collapsed');\n                me.header.element.classList.remove('b-collapsed');\n                me.footer.element.classList.remove('b-collapsed');\n                // This region used to be flex, let's restore it\n                if (_beforeCollapseState.flex) {\n                    // Always restore width, restoring flex won't trigger resize otherwise\n                    me.width = _beforeCollapseState.width;\n                    // Widget flex setting clears style width\n                    me.header.flex = me.flex = _beforeCollapseState.flex;\n                    me.footer.flex = _beforeCollapseState.flex;\n                    me._width = null;\n                }\n                else {\n                    me.width = _beforeCollapseState.elementWidth;\n                }\n                me.element.classList.remove('b-grid-subgrid-collapsed');\n                me._collapsed = false;\n                if (!widthChanged) {\n                    resolve(false);\n                }\n                else {\n                    // Our splitter buttons are hidden when expanded, so we no longer need to keep splitter button set\n                    // synced in the vertical centre of the view.\n                    splitterOwner.stopSplitterButtonSyncing();\n                    me.syncParallelSplitters(false);\n                }\n                delete me._beforeCollapseState;\n            }\n            else {\n                resolve();\n            }\n            grid.trigger('subGridExpand', { subGrid : me });\n            grid.afterToggleSubGrid({ subGrid : me, collapsed : false });\n            me.isExpanding = false;\n        });\n    }\n    hide() {\n        this.header?.hide();\n        this.footer?.hide();\n        this.hideSplitter();\n        return super.hide();\n    }\n    show() {\n        const me = this;\n        me.header?.show();\n        me.footer?.show();\n        // Show splitter if not last region\n        if (me.region !== me.grid.regions[me.grid.regions.length - 1]) {\n            me.showSplitter();\n        }\n        return super.show();\n    }\n    //endregion\n}\n// Register this widget type with its Factory\nSubGrid.initClass();\nSubGrid._$name = 'SubGrid';", "import Base from '../../../Core/Base.js';\nimport Column from '../../column/Column.js';\nimport SubGrid from '../SubGrid.js';\nimport ArrayHelper from '../../../Core/helper/ArrayHelper.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n/**\n * @module Grid/view/mixin/GridSubGrids\n */\n/**\n * Mixin for grid that handles SubGrids. Each SubGrid is scrollable horizontally separately from the other SubGrids.\n * Having two SubGrids allows you to achieve what is usually called locked or frozen columns.\n *\n * By default a Grid has two SubGrids, one named 'locked' and one 'normal'. The `locked` region has fixed width, while\n * the `normal` region grows to fill all available width (flex).\n *\n * Which SubGrid a column belongs to is determined using its {@link Grid.column.Column#config-region} config. For\n * example to put a column into the locked region, specify `{ region: 'locked' }`. For convenience, a column can be put\n * in the locked region using `{ locked: true }`.\n *\n * ```javascript\n * new Grid({\n *   columns : [\n *     // These two columns both end up in the \"locked\" region\n *     { field: 'name', text: 'Name', locked: true }\n *     { field: 'age', text: 'Age', region: 'locked' }\n *   ]\n * });\n * ```\n *\n * To customize the SubGrids, use {@link Grid.view.Grid#config-subGridConfigs}:\n *\n * ```javascript\n * // change the predefined subgrids\n * new Grid({\n *   subGridConfigs : {\n *       locked : { flex : 1 } ,\n *       normal : { flex : 3 }\n *   }\n * })\n *\n * // or define your own entirely\n * new Grid({\n *   subGridConfigs : {\n *       a : { width : 150 } ,\n *       b : { flex  : 1 },\n *       c : { width : 150 }\n *   },\n *\n *   columns : [\n *       { field : 'name', text : 'Name', region : 'a' },\n *       ...\n *   ]\n * })\n * ```\n *\n * @demo Grid/lockedcolumns\n * @mixin\n */\nexport default Target => class GridSubGrids extends (Target || Base) {\n    static get $name() {\n        return 'GridSubGrids';\n    }\n    static get properties() {\n        return {\n            /**\n             * An object containing the {@link Grid.view.SubGrid} region instances, indexed by subGrid id ('locked', normal'...)\n             * @member {Object<String,Grid.view.SubGrid>} subGrids\n             * @readonly\n             * @category Common\n             */\n            subGrids : {}\n        };\n    }\n    //region Init\n    changeSubGridConfigs(configs) {\n        const\n            me          = this,\n            usedRegions = new Set();\n        for (const column of me.columns) {\n            const { region } = column;\n            // Allow specifying regions for undefined subgrids\n            if (region) {\n                if (!configs[region]) {\n                    configs[region] = {};\n                }\n                usedRegions.add(region);\n            }\n        }\n        // Implementer has provided configs for other subGrids but not normal, put defaults in place\n        if (configs.normal && ObjectHelper.isEmpty(configs.normal)) {\n            configs.normal = { flex : 1 };\n        }\n        for (const region of usedRegions) {\n            me.createSubGrid(region, configs[region]);\n        }\n        // Add them to Grid\n        me.items = me.subGrids;\n        return configs;\n    }\n    createSubGrid(region, config = null) {\n        const\n            me             = this,\n            subGridColumns = me.columns.makeChained(column => column.region === region, ['region']),\n            subGridConfig  = ObjectHelper.assign({\n                type        : 'subgrid',\n                id          : `${me.id}-${region}Subgrid`,\n                parent      : me,\n                grid        : me,\n                region,\n                headerClass : me.headerClass,\n                footerClass : me.footerClass,\n                columns     : subGridColumns,\n                // Sort by region unless weight is explicitly defined\n                weight      : region,\n                // SubGridScrollers know about the main grid's scroller so that if asked to\n                // scroll vertically they know how to do it.\n                scrollable : {\n                    yScroller : me.scrollable\n                }\n            }, config || me.subGridConfigs[region]);\n        let hasCalculatedWidth = false;\n        if (!subGridConfig.flex && !subGridConfig.width) {\n            subGridConfig.width = subGridColumns.totalFixedWidth;\n            hasCalculatedWidth = true;\n        }\n        // Subclasses may inject a type property to create custom SubGrids\n        const subGrid = me.subGrids[region] = SubGrid.create(subGridConfig);\n        subGrid.element.style.setProperty('--total-column-width', subGridColumns.totalFixedWidth);\n        // Must be set after creation, otherwise reset in SubGrid#set width\n        subGrid.hasCalculatedWidth = hasCalculatedWidth;\n        if (region === me.regions[0]) {\n            // Have already done lookups for this in a couple of places, might as well store it...\n            subGrid.isFirstRegion = true;\n        }\n        return subGrid;\n    }\n    // A SubGrid is added to Grid, add its header etc. too\n    onChildAdd(subGrid) {\n        if (subGrid.isSubGrid) {\n            const\n                me    = this,\n                {\n                    items,\n                    headerContainer,\n                    virtualScrollers,\n                    footerContainer\n                }     = me,\n                // 2 elements per index, actual element + splitter\n                index = items.indexOf(subGrid) * 2;\n            // If some columns flex, they must be rendered since these widths as rendered\n            // will define the total column width which must be applied to the rows.\n            if (!me.hideHeaders || me.columns.some(c => c.flex)) {\n                DomHelper.insertAt(headerContainer, subGrid.headerSplitter, index);\n                DomHelper.insertAt(headerContainer, subGrid.header.element, index);\n            }\n            DomHelper.insertAt(virtualScrollers, subGrid.scrollerSplitter, index);\n            DomHelper.insertAt(virtualScrollers, subGrid.virtualScrollerElement, index);\n            DomHelper.insertAt(footerContainer, subGrid.footerSplitter, index);\n            DomHelper.insertAt(footerContainer, subGrid.footer.element, index);\n            // Show splitter for all except last (new might not sort last, depending on weight)\n            items.forEach((subGrid, i) => {\n                if (i < items.length - 1) {\n                    subGrid.showSplitter();\n                }\n            });\n            // Empty text should be displayed in the first subgrid\n            if (index === 0 && me.emptyTextEl) {\n                subGrid.element.appendChild(me.emptyTextEl);\n            }\n        }\n        return super.onChildAdd(subGrid);\n    }\n    // A SubGrid is remove from grid, remove its header etc. too\n    onChildRemove(subGrid) {\n        super.onChildRemove(subGrid);\n        if (subGrid.isSubGrid) {\n            const { items } = this;\n            delete this.subGrids[subGrid.region];\n            ArrayHelper.remove(this.regions, subGrid.region);\n            subGrid.destroy();\n            // Make sure the new last splitter is hidden\n            if (items.length) {\n                items[items.length - 1].hideSplitter();\n            }\n        }\n    }\n    doDestroy() {\n        this.eachSubGrid(subGrid => subGrid.destroy());\n        super.doDestroy();\n    }\n    //endregion\n    //region Iteration & calling\n    /**\n     * Iterate over all subGrids, calling the supplied function for each.\n     * @param {Function} fn Function to call for each instance\n     * @param {Object} thisObj `this` reference to call the function in, defaults to the subGrid itself\n     * @category SubGrid\n     * @internal\n     */\n    eachSubGrid(fn, thisObj = null) {\n        this.items.forEach((subGrid, i) => {\n            subGrid.isSubGrid && fn.call(thisObj || subGrid, subGrid, i++);\n        });\n    }\n    /**\n     * Call a function by name for all subGrids (that have the function).\n     * @param {String} fnName Name of function to call, uses the subGrid itself as `this` reference\n     * @param params Parameters to call the function with\n     * @returns {*} Return value from first SubGrid is returned\n     * @category SubGrid\n     * @internal\n     */\n    callEachSubGrid(fnName, ...params) {\n        let returnValue = null;\n        this.items.forEach((subGrid, i) => {\n            if (subGrid.isSubGrid && subGrid[fnName]) {\n                const partialReturnValue = subGrid[fnName](...params);\n                if (i === 0) returnValue = partialReturnValue;\n            }\n        });\n        return returnValue;\n    }\n    //endregion\n    //region Getters\n    get regions() {\n        return this.items.map(item => item.region);\n    }\n    /**\n     * This method should return names of the two last regions in the grid as they are visible in the UI. In case\n     * `regions` property cannot be trusted, use different approach. Used by SubGrid and RegionResize to figure out\n     * which region should collapse or expand.\n     * @returns {String[]}\n     * @private\n     * @category SubGrid\n     */\n    getLastRegions() {\n        const result = this.regions.slice(-2);\n        // ALWAYS return array of length 2 in order to avoid extra conditions. Normally should not be called with 1 region\n        return result.length === 2 ? result : [result[0], result[0]];\n    }\n    /**\n     * This method should return right neighbour for passed region, or left neighbour in case last visible region is passed.\n     * This method is used to decide which subgrid should take space of the collapsed one.\n     * @param {String} region\n     * @returns {String}\n     * @private\n     * @category SubGrid\n     */\n    getNextRegion(region) {\n        const regions = this.regions;\n        // return next region or next to last\n        return regions[regions.indexOf(region) + 1] || regions[regions.length - 2];\n    }\n    getPreviousRegion(region) {\n        return this.regions[this.regions.indexOf(region) - 1];\n    }\n    /**\n     * Returns the subGrid for the specified region.\n     * @param {String} region Region, eg. locked or normal (per default)\n     * @returns {Grid.view.SubGrid} A subGrid\n     * @category SubGrid\n     */\n    getSubGrid(region) {\n        return this.subGrids[region];\n    }\n    /**\n     * Get the SubGrid that contains specified column\n     * @param {String|Grid.column.Column} column Column \"name\" or column object\n     * @returns {Grid.view.SubGrid}\n     * @category SubGrid\n     */\n    getSubGridFromColumn(column) {\n        column = column instanceof Column ? column : this.columns.getById(column) || this.columns.get(column);\n        return this.getSubGrid(column.region);\n    }\n    //endregion\n    /**\n     * Returns splitter element for subgrid\n     * @param {Grid.view.SubGrid|String} subGrid\n     * @returns {HTMLElement}\n     * @private\n     * @category SubGrid\n     */\n    resolveSplitter(subGrid) {\n        const regions = this.getLastRegions();\n        let region = subGrid instanceof SubGrid ? subGrid.region : subGrid;\n        if (regions[1] === region) {\n            region = regions[0];\n        }\n        return this.subGrids[region].splitterElement;\n    }\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Scroller from '../../Core/helper/util/Scroller.js';\n/**\n * @module Grid/util/GridScroller\n */\nconst\n    xAxis = {\n        x : 1\n    },\n    subGridFilter = w => w.isSubGrid;\n/**\n * A Scroller subclass which handles scrolling in a grid.\n *\n * If the grid has no parallel scrolling grids (No locked columns), then this functions\n * transparently as a Scroller.\n *\n * If there are locked columns, then scrolling to an _element_ will invoke the scroller\n * of the subgrid which contains that element.\n * @internal\n */\nexport default class GridScroller extends Scroller {\n    addScroller(scroller) {\n        (this.xScrollers || (this.xScrollers = [])).push(scroller);\n    }\n    addPartner(otherScroller, axes = xAxis) {\n        if (typeof axes === 'string') {\n            axes = {\n                [axes] : 1\n            };\n        }\n        // Link up all our X scrollers\n        if (axes.x) {\n            // Ensure the other grid has set up its scrollers. This is done on first paint\n            // so may not have been executed yet.\n            otherScroller.owner.initScroll();\n            const\n                subGrids = this.widget.items.filter(subGridFilter),\n                otherSubGrids = otherScroller.widget.items.filter(subGridFilter);\n            // Loop through SubGrids to ensure that we partner their scrollers up correctly\n            for (let i = 0, { length } = subGrids; i < length; i++) {\n                subGrids[i].scrollable.addPartner(otherSubGrids[i].scrollable, 'x');\n            }\n        }\n        // We are the only Y scroller\n        if (axes.y) {\n            super.addPartner(otherScroller, 'y');\n        }\n    }\n    removePartner(otherScroller) {\n        this.xScrollers.forEach((scroller, i) => {\n            if (!scroller.isDestroyed) {\n                scroller.removePartner(otherScroller.xScrollers[i]);\n            }\n        });\n        super.removePartner(otherScroller);\n    }\n    updateOverflowX(overflowX) {\n        const hideScroll = overflowX === false;\n        this.xScrollers?.forEach(s => s.overflowX = hideScroll ? 'hidden' : 'hidden-scroll');\n        this.widget.virtualScrollers.classList.toggle('b-hide-display', hideScroll);\n    }\n    scrollIntoView(element, options) {\n        // If we are after an element, we have to ask the scroller of the SubGrid\n        // that the element is in. It will do the X scrolling and delegate the Y\n        // scrolling up to this GridScroller.\n        if (element.nodeType === Element.ELEMENT_NODE && this.element.contains(element)) {\n            for (const subGridScroller of this.xScrollers) {\n                if (subGridScroller.element.contains(element)) {\n                    return subGridScroller.scrollIntoView(element, options);\n                }\n            }\n        }\n        else {\n            return super.scrollIntoView(element, options);\n        }\n    }\n    hasOverflow(axis = 'y') {\n        return axis === 'y' ? this.scrollHeight > this.clientHeight : false;\n    }\n    set x(x) {\n        if (this.xScrollers) {\n            this.xScrollers[0].x = x;\n        }\n    }\n    get x() {\n        // when trying to scroll grid with no columns xScrollers do not exist\n        return this.xScrollers ? this.xScrollers[0].x : 0;\n    }\n}\nGridScroller._$name = 'GridScroller';", "import Base from '../../../Core/Base.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport Location from '../../util/Location.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport GlobalEvents from '../../../Core/GlobalEvents.js';\nimport VersionHelper from '../../../Core/helper/VersionHelper.js';\n/**\n * @module Grid/view/mixin/GridNavigation\n */\nconst\n    defaultFocusOptions = Object.freeze({}),\n    disableScrolling = Object.freeze({\n        x : false,\n        y : false\n    }),\n    containedFocusable = function(e) {\n        // When we step outside of the target cell, throw.\n        // The TreeWalker silences the exception and terminates the traverse.\n        if (!this.focusableFinderCell.contains(e)) {\n            return DomHelper.NodeFilter.FILTER_REJECT;\n        }\n        if (DomHelper.isFocusable(e) && !e.disabled) {\n            return DomHelper.NodeFilter.FILTER_ACCEPT;\n        }\n        return DomHelper.NodeFilter.FILTER_SKIP;\n    };\n/**\n * Mixin for Grid that handles cell to cell navigation.\n *\n * See {@link Grid.view.Grid} for more information on grid cell keyboard navigation.\n *\n * @mixin\n */\nexport default Target => class GridNavigation extends (Target || Base) {\n    static get $name() {\n        return 'GridNavigation';\n    }\n    static configurable =  {\n        focusable : false,\n        focusableSelector : '.b-grid-cell,.b-grid-header.b-depth-0',\n        // Set to true to revert focus on Esc or on ArrowUp/ArrowDown above/below first/last row\n        isNested : false,\n        // Documented on Grid\n        keyMap : {\n            ArrowUp    : { handler : 'navigateUp', weight : 10 },\n            ArrowRight : { handler : 'navigateRight', weight : 10 },\n            ArrowDown  : { handler : 'navigateDown', weight : 10 },\n            ArrowLeft  : { handler : 'navigateLeft', weight : 10 },\n            'Ctrl+Home' : 'navigateFirstCell',\n            Home        : 'navigateFirstColumn',\n            'Ctrl+End'  : 'navigateLastCell',\n            End         : 'navigateLastColumn',\n            PageUp      : 'navigatePrevPage',\n            PageDown    : 'navigateNextPage',\n            Enter       : 'activateHeader',\n            // Private\n            Escape      : { handler : 'onEscape', weight : 10 },\n            'Shift+Tab' : { handler : 'onShiftTab', preventDefault : false, weight : 200 },\n            Tab         : { handler : 'onTab', preventDefault : false, weight : 200 },\n            ' '         : { handler : 'onSpace', preventDefault : false }\n        }\n    };\n    onStoreRecordIdChange(event) {\n        super.onStoreRecordIdChange?.(event);\n        const\n            { focusedCell }     = this,\n            { oldValue, value } = event;\n        // https://github.com/bryntum/support/issues/4935\n        if (focusedCell && focusedCell.id === oldValue) {\n            focusedCell._id = value;\n        }\n    }\n    /**\n     * Called by the RowManager when the row which contains the focus location is derendered.\n     *\n     * This keeps focus in a consistent place.\n     * @protected\n     */\n    onFocusedRowDerender() {\n        const\n            me              = this,\n            { focusedCell } = me;\n        if (focusedCell?.id != null && focusedCell.cell) {\n            const isActive = focusedCell.cell.contains(DomHelper.getActiveElement(me));\n            if (me.hideHeaders) {\n                if (isActive) {\n                    me.revertFocus();\n                }\n            }\n            else {\n                const headerContext = me.normalizeCellContext({\n                    rowIndex    : -1,\n                    columnIndex : isActive ? focusedCell.columnIndex : 0\n                });\n                // The row contained focus, focus the corresponding header\n                if (isActive) {\n                    me.focusCell(headerContext);\n                }\n                else {\n                    headerContext.cell.tabIndex = 0;\n                }\n            }\n            focusedCell.cell.tabIndex = -1;\n        }\n    }\n    navigateFirstCell() {\n        this.focusCell(Location.FIRST_CELL);\n    }\n    navigateFirstColumn() {\n        this.focusCell(Location.FIRST_COLUMN);\n    }\n    navigateLastCell() {\n        this.focusCell(Location.LAST_CELL);\n    }\n    navigateLastColumn() {\n        this.focusCell(Location.LAST_COLUMN);\n    }\n    navigatePrevPage() {\n        this.focusCell(Location.PREV_PAGE);\n    }\n    navigateNextPage() {\n        this.focusCell(Location.NEXT_PAGE);\n    }\n    activateHeader(keyEvent) {\n        if (keyEvent.target.classList.contains('b-grid-header') && this.focusedCell.isColumnHeader) {\n            const { column } = this.focusedCell;\n            column.onKeyDown?.(keyEvent);\n            this.getHeaderElement(column.id).click();\n        }\n        return false;\n    }\n    onEscape(keyEvent) {\n        const\n            me              = this,\n            { focusedCell } = me;\n        if (!keyEvent.target.closest('.b-dragging') && focusedCell?.isActionable) {\n            // The escape must not be processed by handlers for the cell we are about to focus.\n            // We need to just push focus upwards to the cell, and stop there.\n            keyEvent.stopImmediatePropagation();\n            // To prevent the focusCell from being rejected as a no-op\n            me._focusedCell = null;\n            // Focus the cell with an explicit request to not jump in\n            me.focusCell({\n                rowIndex : focusedCell.rowIndex,\n                column   : focusedCell.column\n            }, {\n                disableActionable : true\n            });\n        }\n        // If configured as nested, revert focus to outer widget\n        // The owner can supply a function to catch the focus. Used in rowExpander.\n        else if (me.isNested && me.owner && !me.owner.catchFocus?.({ source : me })) {\n            me.revertFocus(true);\n        }\n    }\n    onTab(keyEvent) {\n        const\n            { target } = keyEvent,\n            {\n                focusedCell,\n                bodyElement\n            }          = this,\n            {\n                isActionable,\n                actionTargets\n            }          = focusedCell,\n            isEditable = isActionable && DomHelper.isEditable(target) && !target.readOnly;\n        // If we're on the last editable in a cell, TAB navigates right\n        if (isEditable && target === actionTargets[actionTargets.length - 1]) {\n            keyEvent.preventDefault();\n            this.navigateRight(keyEvent);\n        }\n        // If we're *on* a cell, or on last subtarget, TAB moves off the grid.\n        // Temporarily hide the grid body, and let TAB take effect from there\n        else if (!isActionable || target === actionTargets[actionTargets.length - 1]) {\n            bodyElement.style.display = 'none';\n            this.requestAnimationFrame(() => bodyElement.style.display = '');\n            // So that Navigator#onKeyDown does not continue to preventDefault;\n            return false;\n        }\n    }\n    onShiftTab(keyEvent) {\n        const\n            me = this,\n            { target } = keyEvent,\n            {\n                focusedCell,\n                bodyElement\n            }   = me,\n            {\n                cell,\n                isActionable,\n                actionTargets\n            } = focusedCell,\n            isEditable  = isActionable && DomHelper.isEditable(target) && !target.readOnly,\n            onFirstCell = focusedCell.columnIndex === 0 && focusedCell.rowIndex === (me.hideHeaders ? 0 : -1);\n        // If we're on the first editable in a cell that is not the first cell, SHIFT+TAB navigates left\n        if (!onFirstCell && isEditable && target === actionTargets[0]) {\n            keyEvent.preventDefault();\n            me.navigateLeft(keyEvent);\n        }\n        // If we're *on* a cell, or on first subtarget, SHIFT+TAB moves off the grid.\n        else if (!isActionable || target === actionTargets[0]) {\n            // Focus the first header cell and then let the key's default action take its course\n            const f = !onFirstCell && !me.hideHeaders && me.focusCell({\n                rowIndex : -1,\n                column   : 0\n            }, {\n                disableActionable : true\n            });\n            // If that was successful then reset the tabIndex\n            if (f) {\n                f.cell.tabIndex = -1;\n                cell.tabIndex = 0;\n                me._focusedCell = focusedCell;\n            }\n            // Otherwise, temporarily hide the grid body, and let TAB take effect from there\n            else {\n                bodyElement.style.display = 'none';\n                me.requestAnimationFrame(() => bodyElement.style.display = '');\n            }\n            // So that Navigator#onKeyDown does not continue to preventDefault;\n            return false;\n        }\n    }\n    onSpace(keyEvent) {\n        // SPACE scrolls, so disable that\n        if (!this.focusedCell.isActionable) {\n            keyEvent.preventDefault();\n        }\n        // Return false to tell keyMap that any other actions should be called\n        return false;\n    }\n    //region Cell\n    /**\n     * Triggered when a user navigates to a grid cell\n     * @event navigate\n     * @param {Grid.view.Grid} grid The grid instance\n     * @param {Grid.util.Location} last The previously focused location\n     * @param {Grid.util.Location} location The new focused location\n     * @param {Event} [event] The UI event which caused navigation.\n     */\n    /**\n     * Grid Location which encapsulates the currently focused cell.\n     * Set to focus a cell or use {@link #function-focusCell}.\n     * @property {Grid.util.Location}\n     */\n    get focusedCell() {\n        return this._focusedCell;\n    }\n    /**\n     * This property is `true` if an element _within_ a cell is focused.\n     * @property {Boolean}\n     * @readonly\n     */\n    get isActionableLocation() {\n        return this._focusedCell?.isActionable;\n    }\n    set focusedCell(cellSelector) {\n        this.focusCell(cellSelector);\n    }\n    get focusedRecord() {\n        return this._focusedCell?.record;\n    }\n    /**\n     * CSS selector for currently focused cell. Format is \"[data-index=index] [data-column-id=columnId]\".\n     * @property {String}\n     * @readonly\n     */\n    get cellCSSSelector() {\n        const cell = this._focusedCell;\n        return cell ? `[data-index=${cell.rowIndex}] [data-column-id=${cell.columnId}]` : '';\n    }\n    afterHide() {\n        super.afterHide(...arguments);\n        // Do not scroll back to the last focused cell/last moused over cell upon reshow\n        this.lastFocusedCell = null;\n    }\n    /**\n     * Checks whether a cell is focused.\n     * @param {LocationConfig|String|Number} cellSelector Cell selector { id: x, columnId: xx } or row id\n     * @returns {Boolean} true if cell or row is focused, otherwise false\n     */\n    isFocused(cellSelector) {\n        return Boolean(this._focusedCell?.equals(this.normalizeCellContext(cellSelector)));\n    }\n    get focusElement() {\n        if (!this.isDestroying) {\n            let focusCell;\n            // If the store is not empty, focusedCell can return the closest cell\n            if (this.store.count && this._focusedCell) {\n                focusCell = this._focusedCell.target;\n            }\n            // If the store is empty, or we have had no focusedCell set, focus a column header.\n            else {\n                focusCell = this.normalizeCellContext({\n                    rowIndex    : -1,\n                    columnIndex : this._focusedCell?.columnIndex || 0\n                }).target;\n            }\n            const superFocusEl = super.focusElement;\n            // If there's no cell, or the Container's focus element is before the cell\n            // use the Container's focus element.\n            // For example, we may have a top toolbar.\n            if (superFocusEl && (!focusCell || focusCell.compareDocumentPosition(superFocusEl) === Node.DOCUMENT_POSITION_PRECEDING)) {\n                return superFocusEl;\n            }\n            return focusCell;\n        }\n    }\n    onInternalPaint({ firstPaint }) {\n        const me = this;\n        super.onInternalPaint?.(...arguments);\n        // Make the grid initally tabbable into.\n        // The first cell has to have the initial roving tabIndex set into it.\n        const defaultFocus = this.normalizeCellContext({\n            rowIndex : me.hideHeaders ? 0 : -1,\n            column   : me.hideHeaders ? 0 : me.columns.find(col => !col.hidden && col.isFocusable)\n        });\n        if (defaultFocus.cell) {\n            defaultFocus._isDefaultFocus = true;\n            me._focusedCell = defaultFocus;\n            const { target } = defaultFocus;\n            // If cell doesn't contain a focusable target, it needs tabIndex 0.\n            if (target === defaultFocus.cell) {\n                defaultFocus.cell.tabIndex = 0;\n            }\n        }\n    }\n    /**\n     * This function handles focus moving into, or within the grid.\n     * @param {Event} focusEvent\n     * @private\n     */\n    onGridBodyFocusIn(focusEvent) {\n        const\n            me              = this,\n            { bodyElement } = me,\n            lastFocusedCell = me.focusedCell,\n            lastTarget      = lastFocusedCell?.initialTarget || lastFocusedCell?.target,\n            {\n                target,\n                relatedTarget\n            }               = focusEvent,\n            targetCell      = target.closest(me.focusableSelector);\n        // If focus moved into a valid cell...\n        // Only allows mouse left och right clicks (no other mouse buttons)\n        if (targetCell &&\n            (!GlobalEvents.currentMouseDown || GlobalEvents.isMouseDown(0) || GlobalEvents.isMouseDown(2))\n        ) {\n            const\n                cellSelector  = new Location(target),\n                { cell }      = cellSelector,\n                lastCell      = lastFocusedCell?.cell,\n                actionTargets = cellSelector.actionTargets = me.findFocusables(targetCell),\n                // Don't select on focus on a contained actionable location\n                doSelect      = (!me._fromFocusCell || me.selectOnFocus) && (target === cell || me._selectActionCell) && !target?._isRevertingFocus;\n            // https://github.com/bryntum/support/issues/4039\n            // Only try focusing cell is current target cell is getting removed\n            if (!me.store.getById(targetCell.parentNode.dataset.id) && cell !== targetCell) {\n                cell.focus({ preventScroll : true });\n                return;\n            }\n            if (target.matches(me.focusableSelector)) {\n                if (me.disableActionable) {\n                    cellSelector._target = cell;\n                }\n                // Focus first focusable target if we are configured to.\n                else if (actionTargets.length) {\n                    me._selectActionCell = GlobalEvents.currentMouseDown?.target === target;\n                    actionTargets[0].focus();\n                    delete me._selectActionCell;\n                    return;\n                }\n            }\n            else {\n                // If we have tabbed in and *NOT* mousedowned in, and hit a tabbable element which was not our\n                // last focused cell, go back to last focused cell.\n                if (lastFocusedCell?.target &&\n                    relatedTarget &&\n                    (!GlobalEvents.isMouseDown() || !bodyElement.contains(GlobalEvents.currentMouseDown?.target)) &&\n                    !bodyElement.contains(relatedTarget) &&\n                    !cellSelector.equals(lastFocusedCell)\n                ) {\n                    lastTarget.focus();\n                    return;\n                }\n                cellSelector._target = target;\n            }\n            if (lastCell) {\n                lastCell.classList.remove('b-focused');\n                lastCell.tabIndex = -1;\n            }\n            if (cell) {\n                cell.classList.add('b-focused');\n                // Column may update DOM on cell focus for A11Y purposes.\n                cellSelector.column.onCellFocus(cellSelector);\n                // Only switch the cell to be tabbable if focus was not directed to an inner focusable.\n                if (cell === target) {\n                    cell.tabIndex = 0;\n                }\n                // Moving back to a cell from a cell-contained Editor\n                if (cell.contains(focusEvent.relatedTarget)) {\n                    if (lastTarget === target) {\n                        return;\n                    }\n                }\n            }\n            //Remember\n            me._focusedCell = cellSelector;\n            me.onCellNavigate?.(me, lastFocusedCell, cellSelector, doSelect);\n            me.trigger('navigate', { lastFocusedCell, focusedCell : cellSelector, event : focusEvent });\n        }\n        // Focus not moved into a valid cell, refocus last cell's target\n        // if there was a previously focused cell.\n        // Allow text selection inside a row expander body\n        else if (!target.closest('.b-rowexpander-body')) {\n            lastTarget?.focus({ preventScroll : true });\n        }\n    }\n    findFocusables(cell) {\n        const\n            { focusableFinder } = this,\n            result              = [];\n        focusableFinder.currentNode = this.focusableFinderCell = cell;\n        for (let focusable = focusableFinder.nextNode(); focusable; focusable = focusableFinder.nextNode()) {\n            result.push(focusable);\n        }\n        return result;\n    }\n    get focusableFinder() {\n        const me = this;\n        if (!me._focusableFinder) {\n            me._focusableFinder = me.setupTreeWalker(me.bodyElement, DomHelper.NodeFilter.SHOW_ELEMENT, {\n                acceptNode : containedFocusable.bind(me)\n            });\n        }\n        return me._focusableFinder;\n    }\n    /**\n     * Sets the passed record as the current focused record for keyboard navigation and selection purposes.\n     * This API is used by Combo to activate items in its picker.\n     * @param {Core.data.Model|Number|String} activeItem The record, or record index, or record id to highlight as the active (\"focused\") item.\n     * @internal\n     */\n    restoreActiveItem(item = this._focusedCell) {\n        if (this.rowManager.count) {\n            // They sent a row number.\n            if (!isNaN(item)) {\n                item = this.store.getAt(item);\n            }\n            // Still not a record, treat it as a record ID.\n            else if (!item.isModel) {\n                item = this.store.getById(item);\n            }\n            return this.focusCell(item);\n        }\n    }\n    /**\n     * Navigates to a cell and/or its row (depending on selectionMode)\n     * @param {LocationConfig} cellSelector Cell location descriptor\n     * @param {Object} options Modifier options for how to deal with focusing the cell. These\n     * are used as the {@link Core.helper.util.Scroller#function-scrollTo} options.\n     * @param {BryntumScrollOptions|Boolean} [options.scroll=true] Pass `false` to not scroll the cell into view, or a\n     * scroll options object to affect the scroll.\n     * @returns {Grid.util.Location} A Location object representing the focused location.\n     * @fires navigate\n     */\n    focusCell(cellSelector, options = defaultFocusOptions) {\n        const\n            me               = this,\n            { _focusedCell } = me,\n            {\n                scroll,\n                disableActionable\n            }                = options,\n            isDown           = cellSelector === Location.DOWN,\n            isUp             = cellSelector === Location.UP;\n        // If we're being asked to go to a nonexistent header row, revert focus outwards\n        if (cellSelector?.rowIndex === -1 && me.hideHeaders) {\n            me.revertFocus();\n            return;\n        }\n        // Get a Grid Location.\n        // If the cellSelector is a number, it is taken to be a \"relative\" location as defined\n        // in the Location class eg Location.UP, and we move the current focus accordingly.\n        cellSelector = typeof cellSelector === 'number' && _focusedCell?.isLocation ? _focusedCell.move(cellSelector) : me.normalizeCellContext(cellSelector);\n        const doSelect = ('doSelect' in options) ? options.doSelect\n            : (!cellSelector.isActionable || cellSelector.initialTarget === cellSelector.cell);\n        if (cellSelector.equals(_focusedCell)) {\n            // If configured as nested, revert focus outside if navigating by keyboard below last row or above headers\n            if (me.isNested && (isDown || isUp)) {\n                // The owner can supply a function to catch the focus. Used in rowExpander.\n                if (!me.owner?.catchFocus?.({ source : me, navigationDirection : isDown ? 'down' : 'up' })) {\n                    me.revertFocus(true);\n                }\n            }\n            else {\n                // Request is a no-op, but it's still a navigate request which selection processing needs to know about\n                me.onCellNavigate?.(me, _focusedCell, cellSelector, doSelect);\n            }\n            return _focusedCell;\n        }\n        const\n            subGrid     = me.getSubGridFromColumn(cellSelector.columnId),\n            { cell }    = cellSelector,\n            testCell    = cell || me.getCell({\n                rowIndex : me.rowManager.topIndex,\n                columnId : cellSelector.columnId\n            }),\n            subGridRect = Rectangle.from(subGrid.element),\n            bodyRect    = Rectangle.from(me.bodyElement),\n            cellRect    = Rectangle.from(testCell).moveTo(null, subGridRect.y);\n        // No scrolling possible if we're moving to a column header\n        if (scroll === false || cellSelector.rowIndex === -1) {\n            options = Object.assign({}, options, disableScrolling);\n        }\n        else {\n            options = Object.assign({}, options, scroll);\n            // If the test cell is larger than the subGrid, in any dimension, disable scrolling\n            if (cellRect.width > subGridRect.width || cellRect.height > bodyRect.height) {\n                options.x = options.y = false;\n            }\n            // Else ask for the column to be scrolled into view\n            else {\n                options.column = cellSelector.columnId;\n            }\n            me.scrollRowIntoView(cellSelector.id, options);\n        }\n        // Clear hovering upon navigating so to not have hover style stick around when keyboard navigating away\n        if (me._hoveredRow || me.hoveredCell) {\n            me.hoveredCell = null;\n        }\n        // Disable auto stepping into the focused cell.\n        me.disableActionable = disableActionable;\n        // Go through select pathway upon focus\n        me.selectOnFocus = doSelect;\n        // To let onGridBodyFocusIn know where the focus originates\n        me._fromFocusCell = true;\n        // Focus the location's target, be it a cell, or an interior element.\n        // The onFocusIn element in this module responds to this.\n        cellSelector[disableActionable ? 'cell' : 'target']?.focus({ preventScroll : true });\n        me.disableActionable = me.selectOnFocus = false;\n        delete me._fromFocusCell;\n        return cellSelector;\n    }\n    blurCell(cellSelector) {\n        const me   = this,\n            cell = me.getCell(cellSelector);\n        if (cell) {\n            cell.classList.remove('b-focused');\n        }\n    }\n    clearFocus(fullClear) {\n        const me = this;\n        if (me._focusedCell) {\n            // set last to have focus return to previous cell when alt tabbing\n            me.lastFocusedCell = fullClear ? null : me._focusedCell;\n            me.blurCell(me._focusedCell);\n            me._focusedCell = null;\n        }\n    }\n    // For override-ability\n    catchFocus() {}\n    /**\n     * Selects the cell before or after currently focused cell.\n     * @private\n     * @param next Specify true to select the next cell, false to select the previous\n     * @returns {Object} Used cell selector\n     */\n    internalNextPrevCell(next = true) {\n        const\n            me           = this,\n            cellSelector = me._focusedCell;\n        if (cellSelector) {\n            return me.focusCell({\n                id       : cellSelector.id,\n                columnId : me.columns.getAdjacentVisibleLeafColumn(cellSelector.column, next, true).id\n            });\n        }\n        return null;\n    }\n    /**\n     * Select the cell after the currently focused one.\n     * @param {Event} [event] [DEPRECATED] unused param\n     * @returns {Grid.util.Location} Cell selector\n     */\n    navigateRight() {\n        if (arguments[0]?.fromKeyMap) {\n            return this.focusCell(this.rtl ? Location.PREV_CELL : Location.NEXT_CELL);\n        }\n        if (arguments[0]) {\n            VersionHelper.deprecate('Grid', '6.0.0', 'Event argument removed, unused param');\n        }\n        return this.internalNextPrevCell(!this.rtl);\n    }\n    /**\n     * Select the cell before the currently focused one.\n     * @param {Event} [event] [DEPRECATED] unused param\n     * @returns {Grid.util.Location} Cell selector\n     */\n    navigateLeft() {\n        if (arguments[0]?.fromKeyMap) {\n            return this.focusCell(this.rtl ? Location.NEXT_CELL : Location.PREV_CELL);\n        }\n        if (arguments[0]) {\n            VersionHelper.deprecate('Grid', '6.0.0', 'Event argument removed, unused param');\n        }\n        return this.internalNextPrevCell(Boolean(this.rtl));\n    }\n    //endregion\n    //region Row\n    /**\n     * Selects the next or previous record in relation to the current selection. Scrolls into view if outside.\n     * @private\n     * @param next Next record (true) or previous (false)\n     * @param {Boolean} [skipSpecialRows=true] True to not return specialRows like headers\n     * @param {Boolean} [moveToHeader=true] True to allow focus to move to a header\n     * @returns {Grid.util.Location|Boolean} Selection context for the focused row (& cell) or false if no selection was made\n     */\n    internalNextPrevRow(next, skipSpecialRows = true, moveToHeader = true) {\n        const\n            me   = this,\n            cell = me._focusedCell;\n        if (!cell) return false;\n        const record = me.store[`get${next ? 'Next' : 'Prev'}`](cell.id, false, skipSpecialRows);\n        if (record) {\n            return me.focusCell({\n                id       : record.id,\n                columnId : cell.columnId,\n                scroll   : {\n                    x : false\n                }\n            });\n        }\n        else if (!next && moveToHeader && !cell.isColumnHeader) {\n            this.clearFocus();\n            this.getHeaderElement(cell.columnId).focus();\n        }\n        return false;\n    }\n    /**\n     * Navigates to the cell below the currently focused cell\n     * @param {Event} [event] [DEPRECATED] unused param\n     * @returns {Grid.util.Location} Selector for focused row (& cell)\n     */\n    navigateDown() {\n        if (arguments[0]?.fromKeyMap) {\n            return this.focusCell(Location.DOWN);\n        }\n        if (arguments[0]) {\n            VersionHelper.deprecate('Grid', '6.0.0', 'Event argument removed, unused param');\n        }\n        return this.internalNextPrevRow(true, false);\n    }\n    /**\n     * Navigates to the cell above the currently focused cell\n     * @param {Event} [event] [DEPRECATED] unused param\n     * @returns {Grid.util.Location} Selector for focused row (& cell)\n     */\n    navigateUp() {\n        if (arguments[0]?.fromKeyMap) {\n            return this.focusCell(Location.UP);\n        }\n        if (arguments[0]) {\n            VersionHelper.deprecate('Grid', '6.0.0', 'Event argument removed, unused param');\n        }\n        return this.internalNextPrevRow(false, false);\n    }\n    //endregion\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import LocaleHelper from '../../Core/localization/LocaleHelper.js';\nimport '../../Core/localization/En.js';\nconst emptyString = new String();\nconst locale = {\n    localeName : 'En',\n    localeDesc : 'English (US)',\n    localeCode : 'en-US',\n    ColumnPicker : {\n        column          : 'Column',\n        columnsMenu     : 'Columns',\n        hideColumn      : 'Hide column',\n        hideColumnShort : 'Hide',\n        newColumns      : 'New columns'\n    },\n    Filter : {\n        applyFilter   : 'Apply filter',\n        filter        : 'Filter',\n        editFilter    : 'Edit filter',\n        on            : 'On',\n        before        : 'Before',\n        after         : 'After',\n        equals        : 'Equals',\n        lessThan      : 'Less than',\n        moreThan      : 'More than',\n        removeFilter  : 'Remove filter',\n        disableFilter : 'Disable filter'\n    },\n    FilterBar : {\n        enableFilterBar  : 'Show filter bar',\n        disableFilterBar : 'Hide filter bar'\n    },\n    Group : {\n        group                : 'Group',\n        groupAscending       : 'Group ascending',\n        groupDescending      : 'Group descending',\n        groupAscendingShort  : 'Ascending',\n        groupDescendingShort : 'Descending',\n        stopGrouping         : 'Stop grouping',\n        stopGroupingShort    : 'Stop'\n    },\n    HeaderMenu : {\n        moveBefore     : text => `Move before \"${text}\"`,\n        moveAfter      : text => `Move after \"${text}\"`,\n        collapseColumn : 'Collapse column',\n        expandColumn   : 'Expand column'\n    },\n    ColumnRename : {\n        rename : 'Rename'\n    },\n    MergeCells : {\n        mergeCells  : 'Merge cells',\n        menuTooltip : 'Merge cells with same value when sorted by this column'\n    },\n    Search : {\n        searchForValue : 'Search for value'\n    },\n    Sort : {\n        sort                   : 'Sort',\n        sortAscending          : 'Sort ascending',\n        sortDescending         : 'Sort descending',\n        multiSort              : 'Multi sort',\n        removeSorter           : 'Remove sorter',\n        addSortAscending       : 'Add ascending sorter',\n        addSortDescending      : 'Add descending sorter',\n        toggleSortAscending    : 'Change to ascending',\n        toggleSortDescending   : 'Change to descending',\n        sortAscendingShort     : 'Ascending',\n        sortDescendingShort    : 'Descending',\n        removeSorterShort      : 'Remove',\n        addSortAscendingShort  : '+ Ascending',\n        addSortDescendingShort : '+ Descending'\n    },\n    Split : {\n        split        : 'Split',\n        unsplit      : 'Unsplit',\n        horizontally : 'Horizontally',\n        vertically   : 'Vertically',\n        both         : 'Both'\n    },\n    Column : {\n        columnLabel : column => `${column.text ? `${column.text} column. ` : ''}SPACE for context menu${column.sortable ? ', ENTER to sort' : ''}`,\n        cellLabel   : emptyString\n    },\n    Checkbox : {\n        toggleRowSelect : 'Toggle row selection',\n        toggleSelection : 'Toggle selection of entire dataset'\n    },\n    RatingColumn : {\n        cellLabel : column => `${column.text ? column.text : ''} ${column.location?.record ? `rating : ${column.location.record.get(column.field) || 0}` : ''}`\n    },\n    GridBase : {\n        loadFailedMessage  : 'Data loading failed!',\n        syncFailedMessage  : 'Data synchronization failed!',\n        unspecifiedFailure : 'Unspecified failure',\n        networkFailure     : 'Network error',\n        parseFailure       : 'Failed to parse server response',\n        serverResponse     : 'Server response:',\n        noRows             : 'No records to display',\n        moveColumnLeft     : 'Move to left section',\n        moveColumnRight    : 'Move to right section',\n        moveColumnTo       : region => `Move column to ${region}`\n    },\n    CellMenu : {\n        removeRow : 'Delete'\n    },\n    RowCopyPaste : {\n        copyRecord  : 'Copy',\n        cutRecord   : 'Cut',\n        pasteRecord : 'Paste',\n        rows        : 'rows',\n        row         : 'row'\n    },\n    CellCopyPaste : {\n        copy  : 'Copy',\n        cut   : 'Cut',\n        paste : 'Paste'\n    },\n    PdfExport : {\n        'Waiting for response from server' : 'Waiting for response from server...',\n        'Export failed'                    : 'Export failed',\n        'Server error'                     : 'Server error',\n        'Generating pages'                 : 'Generating pages...',\n        'Click to abort'                   : 'Cancel'\n    },\n    ExportDialog : {\n        width          : '40em',\n        labelWidth     : '12em',\n        exportSettings : 'Export settings',\n        export         : 'Export',\n        printSettings  : 'Print settings',\n        print          : 'Print',\n        exporterType   : 'Control pagination',\n        cancel         : 'Cancel',\n        fileFormat     : 'File format',\n        rows           : 'Rows',\n        alignRows      : 'Align rows',\n        columns        : 'Columns',\n        paperFormat    : 'Paper format',\n        orientation    : 'Orientation',\n        repeatHeader   : 'Repeat header'\n    },\n    ExportRowsCombo : {\n        all     : 'All rows',\n        visible : 'Visible rows'\n    },\n    ExportOrientationCombo : {\n        portrait  : 'Portrait',\n        landscape : 'Landscape'\n    },\n    SinglePageExporter : {\n        singlepage : 'Single page'\n    },\n    MultiPageExporter : {\n        multipage     : 'Multiple pages',\n        exportingPage : ({ currentPage, totalPages }) => `Exporting page ${currentPage}/${totalPages}`\n    },\n    MultiPageVerticalExporter : {\n        multipagevertical : 'Multiple pages (vertical)',\n        exportingPage     : ({ currentPage, totalPages }) => `Exporting page ${currentPage}/${totalPages}`\n    },\n    RowExpander : {\n        loading  : 'Loading',\n        expand   : 'Expand',\n        collapse : 'Collapse'\n    },\n    TreeGroup : {\n        group                  : 'Group by',\n        stopGrouping           : 'Stop grouping',\n        stopGroupingThisColumn : 'Ungroup column'\n    }\n};\nexport default LocaleHelper.publishLocale(locale);\n", "//region Import\nimport Base from '../../Core/Base.js';\nimport AjaxStore from '../../Core/data/AjaxStore.js';\nimport DomDataStore from '../../Core/data/DomDataStore.js';\nimport Store from '../../Core/data/Store.js';\nimport ArrayHelper from '../../Core/helper/ArrayHelper.js';\nimport BrowserHelper from '../../Core/helper/BrowserHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\nimport ScrollManager from '../../Core/util/ScrollManager.js';\nimport Mask from '../../Core/widget/Mask.js';\nimport Panel from '../../Core/widget/Panel.js';\nimport GlobalEvents from '../../Core/GlobalEvents.js';\nimport LocaleManager from '../../Core/localization/LocaleManager.js';\nimport Pluggable from '../../Core/mixin/Pluggable.js';\nimport State from '../../Core/mixin/State.js';\nimport ColumnStore, { columnResizeEvent } from '../data/ColumnStore.js';\nimport GridRowModel from '../data/GridRowModel.js';\nimport RowManager from '../row/RowManager.js';\nimport GridScroller from '../util/GridScroller.js';\nimport Location from '../util/Location.js';\nimport Header from './Header.js';\nimport Footer from './Footer.js';\nimport GridElementEvents from './mixin/GridElementEvents.js';\nimport GridFeatures from './mixin/GridFeatures.js';\nimport GridNavigation from './mixin/GridNavigation.js';\nimport GridResponsive from './mixin/GridResponsive.js';\nimport GridSelection from './mixin/GridSelection.js';\nimport GridState from './mixin/GridState.js';\nimport GridSubGrids from './mixin/GridSubGrids.js';\nimport LoadMaskable from '../../Core/mixin/LoadMaskable.js';\nimport Column from '../column/Column.js';\n// Needed since Grid now has its own localization\nimport '../localization/En.js';\n//endregion\n/**\n * @module Grid/view/GridBase\n */\n/**\n * Additional options for the {@link Grid.view.GridBase#config-preserveScroll} configuration.\n *\n * @typedef {Object} PreserveScrollOptions\n * @property {Boolean} overscroll When there is not enough content remaining in the viewport to preserve the current\n * scroll position (for example, if rows below have been removed), allow the viewport to temporarily include empty\n * space beyond the available content, in order to avoid scrolling.\n */\nconst\n    resolvedPromise       = new Promise(resolve => resolve()),\n    storeListenerName     = 'GridBase:store',\n    defaultScrollOptions  = {\n        block  : 'nearest',\n        inline : 'nearest'\n    },\n    datasetReplaceActions = {\n        dataset  : 1,\n        pageLoad : 1,\n        filter   : 1\n    },\n    emptyArray            = Object.freeze([]),\n    ascending             = (l, r) => l - r;\n/**\n * A thin base class for {@link Grid.view.Grid}. Does not include any features by default, allowing smaller custom-built\n * bundles if used in place of {@link Grid.view.Grid}.\n *\n * **NOTE:** In most scenarios you probably want to use Grid instead of GridBase.\n * @extends Core/widget/Panel\n *\n * @mixes Core/mixin/Pluggable\n * @mixes Core/mixin/State\n * @mixes Grid/view/mixin/GridElementEvents\n * @mixes Grid/view/mixin/GridFeatures\n * @mixes Grid/view/mixin/GridResponsive\n * @mixes Grid/view/mixin/GridSelection\n * @mixes Grid/view/mixin/GridState\n * @mixes Grid/view/mixin/GridSubGrids\n * @mixes Core/mixin/LoadMaskable\n *\n * @features Grid/feature/CellCopyPaste\n * @features Grid/feature/CellEdit\n * @features Grid/feature/CellMenu\n * @features Grid/feature/CellTooltip\n * @features Grid/feature/ColumnAutoWidth\n * @features Grid/feature/ColumnDragToolbar\n * @features Grid/feature/ColumnPicker\n * @features Grid/feature/ColumnRename\n * @features Grid/feature/ColumnReorder\n * @features Grid/feature/ColumnResize\n * @features Grid/feature/FillHandle\n * @features Grid/feature/Filter\n * @features Grid/feature/FilterBar\n * @features Grid/feature/Group\n * @features Grid/feature/GroupSummary\n * @features Grid/feature/HeaderMenu\n * @features Grid/feature/MergeCells\n * @features Grid/feature/QuickFind\n * @features Grid/feature/RegionResize\n * @features Grid/feature/RowCopyPaste\n * @features Grid/feature/RowExpander\n * @features Grid/feature/RowReorder\n * @features Grid/feature/RowResize\n * @features Grid/feature/Search\n * @features Grid/feature/Sort\n * @features Grid/feature/Split\n * @features Grid/feature/StickyCells\n * @features Grid/feature/Stripe\n * @features Grid/feature/Summary\n * @features Grid/feature/Tree\n * @features Grid/feature/TreeGroup\n *\n * @features Grid/feature/experimental/ExcelExporter\n * @features Grid/feature/experimental/FileDrop\n *\n * @features Grid/feature/export/PdfExport\n * @features Grid/feature/export/Print\n *\n * @plugins Grid/row/RowManager\n * @widget\n */\nexport default class GridBase extends Panel.mixin(\n    Pluggable,\n    State,\n    GridElementEvents,\n    GridFeatures,\n    GridNavigation,\n    GridResponsive,\n    GridSelection,\n    GridState,\n    GridSubGrids,\n    LoadMaskable\n) {\n    //region Config\n    static get $name() {\n        return 'GridBase';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'gridbase';\n    }\n    static get delayable() {\n        return {\n            onGridVerticalScroll : {\n                type : 'raf'\n            },\n            // These use a shorter delay for tests, see finishConfigure()\n            bufferedAfterColumnsResized : 250,\n            bufferedElementResize       : 250\n        };\n    }\n    static get configurable() {\n        return {\n            //region Hidden configs\n            /**\n             * @hideconfigs autoUpdateRecord, defaults, hideWhenEmpty, itemCls, items, layout, layoutStyle, lazyItems, namedItems, record, textContent, defaultAction, html, htmlCls, tag, textAlign, trapFocus, content, defaultBindProperty, ripple, defaultFocus, align, anchor, centered, constrainTo, draggable, floating, hideAnimation, positioned, scrollAction, showAnimation, x, y, localeClass, localizableProperties, showTooltipWhenDisabled, tooltip, strictRecordMapping, maximizeOnMobile\n             */\n            /**\n             * @hideproperties html, isSettingValues, isValid, items, record, values, content, layoutStyle, firstItem, lastItem, anchorSize, x, y, layout, strictRecordMapping, visibleChildCount, maximizeOnMobile\n             */\n            /**\n             * @hidefunctions attachTooltip, add, getWidgetById, insert, processWidgetConfig, remove, removeAll, getAt, alignTo, setXY, showBy, showByPoint, toFront\n             */\n            //endregion\n            /**\n             * Set to `true` to make the grid read-only, by disabling any UIs for modifying data.\n             *\n             * __Note that checks MUST always also be applied at the server side.__\n             * @prp {Boolean} readOnly\n             * @default false\n             * @category Misc\n             */\n            /**\n             * Automatically set grids height to fit all rows (no scrolling in the grid). In general you should avoid\n             * using `autoHeight: true`, since it will bypass Grids virtual rendering and render all rows at once, which\n             * in a larger grid is really bad for performance.\n             * @config {Boolean}\n             * @default false\n             * @category Layout\n             */\n            autoHeight : null,\n            /**\n             * Configure this as `true` to allow elements within cells to be styled as `position: sticky`.\n             *\n             * Columns which contain sticky content will need to be configured with\n             *\n             * ```javascript\n             *    cellCls : 'b-sticky-cell',\n             * ```\n             *\n             * Or a custom renderer can add the class to the passed cell element.\n             *\n             * It is up to the application author how to style the cell content. It is recommended that\n             * a custom renderer create content with CSS class names which the application author\n             * will use to apply the `position`, and matching `margin-top` and `top` styles to keep the\n             * content stuck at the grid's top.\n             *\n             * Note that not all browsers support this CSS feature. A cross browser alternative\n             * is to use the {link Grid.feature.StickyCells StickyCells} Feature.\n             * @config {Boolean}\n             * @category Misc\n             */\n            enableSticky : null,\n            /**\n             * Set to true to allow text selection in the grid cells. Note, this cannot be used simultaneously with the\n             * `RowReorder` feature.\n             * @config {Boolean}\n             * @default false\n             * @category Selection\n             */\n            enableTextSelection : null,\n            /**\n             * Set to `true` to stretch the last column in a grid with all fixed width columns\n             * to fill extra available space if the grid's width is wider than the sum of all\n             * configured column widths.\n             * @config {Boolean}\n             * @default\n             * @category Layout\n             */\n            fillLastColumn : true,\n            /**\n             * See {@link Grid.view.Grid#keyboard-shortcuts Keyboard shortcuts} for details\n             * @config {Object<String,String>} keyMap\n             * @category Common\n             */\n            positionMode : 'translate', // translate, translate3d, position\n            /**\n             * Configure as `true` to have the grid show a red \"changed\" tag in cells who's\n             * field value has changed and not yet been committed.\n             *\n             * Set `showDirty.duringEdit` to `true` to show the red tag while editing a cell\n             * ```javascript\n             * showDirty : {\n             *     duringEdit : true\n             * }\n             * ```\n             *\n             * @config {Boolean|Object}\n             * @property {Boolean} showDirty.duringEdit Set to `true` to show the red tag while editing a cell\n             * @default false\n             * @category Misc\n             */\n            showDirty : null,\n            /**\n             * An object containing sub grid configuration objects keyed by a `region` property.\n             * By default, grid has a 'locked' region (if configured with locked columns) and a 'normal' region.\n             * The 'normal' region defaults to use `flex: 1`.\n             *\n             * This config can be used to reconfigure the \"built-in\" sub grids or to define your own.\n             *\n             * Redefining the default regions:\n             *\n             * {@frameworktabs}\n             * {@js}\n             * ```javascript\n             * new Grid({\n             *   subGridConfigs : {\n             *     locked : { flex : 1 },\n             *     normal : { width : 100 }\n             *   }\n             * });\n             * ```\n             * {@endjs}\n             * {@react}\n             * ```jsx\n             * const App = props => {\n             *     const subGridConfigs = {\n             *         locked : { flex : 1 },\n             *         normal : { width : 100 }\n             *     };\n             *\n             *     return <bryntum-grid subGridConfigs={subGridConfigs} />\n             * }\n             * ```\n             * {@endreact}\n             * {@vue}\n             * ```html\n             * <bryntum-grid :sub-grid-configs=\"subGridConfigs\" />\n             * ```\n             * ```javascript\n             * export default {\n             *     setup() {\n             *         return {\n             *             subGridConfigs : [\n             *                 locked : { flex : 1 },\n             *                 normal : { width : 100 }\n             *             ]\n             *         };\n             *     }\n             * }\n             * ```\n             * {@endvue}\n             * {@angular}\n             * ```html\n             * <bryntum-grid [subGridConfigs]=\"subGridConfigs\"></bryntum-grid>\n             * ```\n             * ```typescript\n             * export class AppComponent {\n             *      subGridConfigs = [\n             *          locked : { flex : 1 },\n             *          normal : { width : 100 }\n             *      ]\n             *  }\n             * ```\n             * {@endangular}\n             * {@endframeworktabs}\n             *\n             * Defining your own multi region grid:\n             *\n             * ```javascript\n             * new Grid({\n             *   subGridConfigs : {\n             *     left   : { width : 100 },\n             *     middle : { flex : 1 },\n             *     right  : { width  : 100 }\n             *   },\n             *\n             *   columns : [\n             *     { field : 'manufacturer', text: 'Manufacturer', region : 'left' },\n             *     { field : 'model', text: 'Model', region : 'middle' },\n             *     { field : 'year', text: 'Year', region : 'middle' },\n             *     { field : 'sales', text: 'Sales', region : 'right' }\n             *   ]\n             * });\n             * ```\n             * @config {Object<String,SubGridConfig>}\n             * @category Misc\n             */\n            subGridConfigs : {\n                normal : { flex : 1 }\n            },\n            /**\n             * Store that holds records to display in the grid, or a store config object. If the configuration contains\n             * a `readUrl`, an `AjaxStore` will be created.\n             *\n             * Note that a store will be created during initialization if none is specified.\n             *\n             * Supplying a store config object at initialization time:\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *     store : {\n             *         fields : ['name', 'powers'],\n             *         data   : [\n             *             { id : 1, name : 'Aquaman', powers : 'Decent swimmer' },\n             *             { id : 2, name : 'Flash', powers : 'Pretty fast' },\n             *         ]\n             *     }\n             * });\n             * ```\n             *\n             * Accessing the store at runtime:\n             *\n             * ```javascript\n             * grid.store.sort('powers');\n             * ```\n             *\n             * @prp {Core.data.Store}\n             * @accepts {Core.data.Store|StoreConfig}\n             * @typings {Core.data.Store|StoreConfig|Core.data.AjaxStore|AjaxStoreConfig}\n             * @category Common\n             */\n            store : {\n                value : {},\n                $config : 'nullify'\n            },\n            rowManager : {\n                value : {},\n                $config : ['nullify', 'lazy']\n            },\n            /**\n             * Configuration values for the {@link Core.util.ScrollManager} class on initialization. Returns the\n             * {@link Core.util.ScrollManager} at runtime.\n             *\n             * @prp {Core.util.ScrollManager}\n             * @accepts {ScrollManagerConfig|Core.util.ScrollManager}\n             * @readonly\n             * @category Scrolling\n             */\n            scrollManager : {\n                value : {},\n                $config : ['nullify', 'lazy']\n            },\n            /**\n             * Accepts column definitions for the grid during initialization. They will be used to create\n             * {@link Grid/column/Column} instances that are added to a {@link Grid/data/ColumnStore}.\n             *\n             * At runtime it is read-only and returns the {@link Grid/data/ColumnStore}.\n             *\n             * Initialization using column config objects:\n             *\n             * ```javascript\n             * new Grid({\n             *   columns : [\n             *     { text : 'Alias', field : 'alias' },\n             *     { text : 'Superpower', field : 'power' }\n             *   ]\n             * });\n             * ```\n             *\n             * Also accepts a store config object:\n             *\n             * ```javascript\n             * new Grid({\n             *   columns : {\n             *     data : [\n             *       { text : 'Alias', field : 'alias' },\n             *       { text : 'Superpower', field : 'power' }\n             *     ],\n             *     listeners : {\n             *       update() {\n             *         // Some update happened\n             *       }\n             *     }\n             *   }\n             * });\n             * ```\n             *\n             * Access the {@link Grid/data/ColumnStore} at runtime to manipulate columns:\n             *\n             * ```javascript\n             * grid.columns.add({ field : 'column', text : 'New column' });\n             * ```\n             * @prp {Grid.data.ColumnStore}\n             * @accepts {Grid.data.ColumnStore|GridColumnConfig[]|ColumnStoreConfig}\n             * @readonly\n             * @category Common\n             */\n            columns : {\n                value : [],\n                $config : 'nullify'\n            },\n            /**\n             * Grid's `min-height`. Defaults to `10em` to be sure that the Grid always has a height wherever it is\n             * inserted.\n             *\n             * Can be either a String or a Number (which will have 'px' appended).\n             *\n             * Note that _reading_ the value will return the numeric value in pixels.\n             *\n             * @config {String|Number}\n             * @category Layout\n             */\n            minHeight : '10em',\n            /**\n             * Set to `true` to hide the column header elements\n             * @prp {Boolean}\n             * @default false\n             * @category Misc\n             */\n            hideHeaders : null,\n            /**\n             * Set to `true` to hide the footer elements\n             * @prp {Boolean}\n             * @default\n             * @category Misc\n             */\n            hideFooters : true,\n            /**\n             * Set to `true` to hide the Grid's horizontal scrollbar(s)\n             * @config {Boolean}\n             * @default false\n             * @category Misc\n             */\n            hideHorizontalScrollbar : null,\n            contentElMutationObserver : false,\n            trapFocus                 : false,\n            ariaElement : 'bodyElement',\n            cellTabIndex : -1,\n            rowCls : {\n                value   : 'b-grid-row',\n                $config : {\n                    merge : this.mergeCls\n                }\n            },\n            cellCls : {\n                value   : 'b-grid-cell',\n                $config : {\n                    merge : this.mergeCls\n                }\n            },\n            /**\n             * Text or HTML to display when there is no data to display in the grid\n             * @prp {String}\n             * @default\n             * @category Common\n             */\n            emptyText        : 'L{noRows}',\n            sortFeatureStore : 'store',\n            /**\n             * Row height in pixels. This allows the default height for rows to be controlled. Note that it may be\n             * overriden by specifying a {@link Grid/data/GridRowModel#field-rowHeight} on a per record basis, or from\n             * a column {@link Grid/column/Column#config-renderer}.\n             *\n             * When initially configured as `null`, an empty row will be measured and its height will be used as default\n             * row height, enabling it to be controlled using CSS\n             *\n             * @prp {Number}\n             * @category Common\n             */\n            rowHeight : null,\n            /**\n             * Preserve the grid's vertical scroll position when changesets are applied, as in the case of remote\n             * changes, or when stores are configured with {@link Core.data.Store#config-syncDataOnLoad}.\n             *\n             * @prp {PreserveScrollOptions|Boolean}\n             * @default\n             * @category Common\n             */\n            preserveScroll : false,\n            /**\n             * When the {@link Grid.feature.Tree} feature is in use and the Store is a tree store, this\n             * config may be set to `true` to visually animate branch node expand and collapse operations.\n             * {@note}This is not supported in Scheduler and Gantt{/@note}\n             * @prp {Boolean}\n             * @default false\n             */\n            animateTreeNodeToggle : VersionHelper.checkVersion('core', '6.0', '>='),\n            /**\n             * Set to `false` to not show column lines. End result might be overruled by/differ between themes.\n             *\n             * @prp {Boolean}\n             * @default\n             * @category Misc\n             */\n            columnLines : true,\n            /**\n             * Set to `false` to not show row lines. End result might be overruled by/differ between themes.\n             *\n             * @prp {Boolean}\n             * @default\n             * @category Misc\n             */\n            rowLines : true\n        };\n    }\n    // Default settings, applied in grids constructor.\n    static get defaultConfig() {\n        return {\n            /**\n             * Use fixed row height. Setting this to `true` will configure the underlying RowManager to use fixed row\n             * height, which sacrifices the ability to use rows with variable height to gain a fraction better\n             * performance.\n             *\n             * Using this setting also ignores the {@link Grid.view.GridBase#config-getRowHeight} function, and thus any\n             * row height set in data. Only Grids configured {@link Grid.view.GridBase#config-rowHeight} is used.\n             *\n             * @config {Boolean}\n             * @category Layout\n             */\n            fixedRowHeight : null,\n            /**\n             * A function called for each row to determine its height. It is passed a {@link Core.data.Model record} and\n             * expected to return the desired height of that records row. If the function returns a falsy value, Grids\n             * configured {@link Grid.view.GridBase#config-rowHeight} is used.\n             *\n             * The default implementation of this function returns the row height from the records\n             * {@link Grid.data.GridRowModel#field-rowHeight rowHeight field}.\n             *\n             * Override this function to take control over how row heights are determined:\n             *\n             * ```javascript\n             * new Grid({\n             *    getRowHeight(record) {\n             *        if (record.low) {\n             *            return 20;\n             *        }\n             *        else if (record.high) {\n             *            return 60;\n             *        }\n             *\n             *        // Will use grids configured rowHeight\n             *        return null;\n             *    }\n             * });\n             * ```\n             *\n             * NOTE: Height set in a Column renderer takes precedence over the height returned by this function.\n             *\n             * @config {Function} getRowHeight\n             * @param {Core.data.Model} getRowHeight.record Record to determine row height for\n             * @returns {Number} Desired row height\n             * @category Layout\n             */\n            // used if no rowHeight specified and none found in CSS. not public since our themes have row height\n            // specified and this is more of an internal failsafe\n            defaultRowHeight : 45,\n            /**\n             * Refresh entire row when a record changes (`true`) or, if possible, only the cells affected (`false`).\n             *\n             * When this is set to `false`, then if a column uses a renderer, cells in that column will still\n             * be updated because it is impossible to know whether the cells value will be affected.\n             *\n             * If a standard, provided Column class is used with no custom renderer, its cells will only be updated\n             * if the column's {@link Grid.column.Column#config-field} is changed.\n             * @config {Boolean}\n             * @default\n             * @category Misc\n             */\n            fullRowRefresh : true,\n            /**\n             * Specify `true` to preserve vertical scroll position after store actions that trigger a `refresh` event,\n             * such as loading new data and filtering.\n             * @config {Boolean}\n             * @default false\n             * @category Misc\n             */\n            preserveScrollOnDatasetChange : null,\n            /**\n             * True to preserve focused cell after loading new data\n             * @config {Boolean}\n             * @default\n             * @category Misc\n             */\n            preserveFocusOnDatasetChange : true,\n            /**\n             * Convenient shortcut to set data in grids store both during initialization and at runtime. Can also be\n             * used to retrieve data at runtime, although we do recommend interacting with Grids store instead using\n             * the {@link #property-store} property.\n             *\n             * Setting initial data during initialization:\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *     data : [\n             *       { id : 1, name : 'Batman' },\n             *       { id : 2, name : 'Robin' },\n             *       ...\n             *     ]\n             * });\n             * ```\n             *\n             * Setting data at runtime:\n             *\n             * ```javascript\n             * grid.data = [\n             *     { id : 3, name : 'Joker' },\n             *     ...\n             * ];\n             * ```\n             *\n             * Getting data at runtime:\n             *\n             * ```javascript\n             * const records = store.data;\n             * ```\n             *\n             * Note that a Store will be created during initialization if none is specified.\n             *\n             * @prp {Core.data.Model[]}\n             * @accepts {Object[]|Core.data.Model[]}\n             * @category Common\n             */\n            data : null,\n            /**\n             * Region to which columns are added when they have none specified\n             * @config {String}\n             * @default\n             * @category Misc\n             */\n            defaultRegion : 'normal',\n            /**\n             * true to destroy the store when the grid is destroyed\n             * @config {Boolean}\n             * @default false\n             * @category Misc\n             */\n            destroyStore : null,\n            /**\n             * Grids change the `maskDefaults` to cover only their `body` element.\n             * @config {MaskConfig}\n             * @category Misc\n             */\n            maskDefaults : {\n                cover  : 'body',\n                target : 'element'\n            },\n            /**\n             * Set to `false` to only measure cell contents when double clicking the edge between column headers.\n             * @config {Boolean}\n             * @default\n             * @category Layout\n             */\n            resizeToFitIncludesHeader : true,\n            /**\n             * Set to `false` to prevent remove row animation and remove the delay related to that.\n             * @config {Boolean}\n             * @default\n             * @category Misc\n             */\n            animateRemovingRows : true,\n            /**\n             * Set to `true` to not get a warning when using another base class than GridRowModel for your grid data. If\n             * you do, and would like to use the full feature set of the grid then include the fields from GridRowModel\n             * in your model definition.\n             * @config {Boolean}\n             * @default false\n             * @category Misc\n             */\n            disableGridRowModelWarning : null,\n            headerClass : Header,\n            footerClass : Footer,\n            testPerformance : false,\n            rowScrollMode   : 'move', // move, dom, all\n            /**\n             * Grid monitors window resize by default.\n             * @config {Boolean}\n             * @default true\n             * @category Misc\n             */\n            monitorResize : true,\n            /**\n             * An object containing Feature configuration objects (or `true` if no configuration is required)\n             * keyed by the Feature class name in all lowercase.\n             * @config {Object}\n             * @category Common\n             */\n            features : true,\n            /**\n             * Configures whether the grid is scrollable in the `Y` axis. This is used to configure a {@link Grid.util.GridScroller}.\n             * See the {@link #config-scrollerClass} config option.\n             * @config {Boolean|ScrollerConfig|Core.helper.util.Scroller}\n             * @category Scrolling\n             */\n            scrollable : {\n                // Just Y for now until we implement a special grid.view.Scroller subclass\n                // Which handles the X scrolling of subgrids.\n                overflowY : true\n            },\n            /**\n             * The class to instantiate to use as the {@link #config-scrollable}. Defaults to {@link Grid.util.GridScroller}.\n             * @config {Core.helper.util.Scroller}\n             * @typings {typeof Scroller}\n             * @category Scrolling\n             */\n            scrollerClass : GridScroller,\n            refreshSuspended : 0,\n            /**\n             * Animation transition duration in milliseconds.\n             * @prp {Number}\n             * @default\n             * @category Misc\n             */\n            transitionDuration : 500,\n            /**\n             * Event which is used to show context menus.\n             * Available options are: 'contextmenu', 'click', 'dblclick'.\n             * @config {'contextmenu'|'click'|'dblclick'}\n             * @category Misc\n             * @default\n             */\n            contextMenuTriggerEvent : 'contextmenu',\n            localizableProperties : ['emptyText'],\n            asyncEventSuffix : '',\n            fixElementHeightsBuffer : 350,\n            testConfig : {\n                transitionDuration      : 50,\n                fixElementHeightsBuffer : 50\n            }\n        };\n    }\n    static get properties() {\n        return {\n            _selectedRecords      : [],\n            _verticalScrollHeight : 0,\n            virtualScrollHeight   : 0,\n            _scrollTop            : null\n        };\n    }\n    static bindStoreChangeset = true;\n    // Keep this commented out to have easy access to the syntax next time we need to use it\n    // static get deprecatedEvents() {\n    //     return {\n    //         cellContextMenuBeforeShow : {\n    //             product            : 'Grid',\n    //             invalidAsOfVersion : '5.0.0',\n    //             message            : '`cellContextMenuBeforeShow` event is deprecated, in favor of `cellMenuBeforeShow` event. Please see https://bryntum.com/products/grid/docs/guide/Grid/upgrades/4.0.0 for more information.'\n    //         }\n    //     };\n    // }\n    //endregion\n    //region Init-destroy\n    finishConfigure(config) {\n        const\n            me             = this,\n            { initScroll } = me;\n        // Make initScroll a one time only call\n        me.initScroll = () => !me.scrollInitialized && initScroll.call(me);\n        if (VersionHelper.isTestEnv) {\n            me.bufferedAfterColumnsResized.delay = 50;\n            me.bufferedElementResize.delay = 50;\n        }\n        super.finishConfigure(config);\n        // When locale is applied columns react and change, which triggers `change` event on columns store for each\n        // changed column, and every change normally triggers rendering view. This overhead becomes noticeable with\n        // larger amount of columns. So we set two listeners to locale events: prioritized listener to be executed first\n        // and suspend renderContents method and unprioritized one to resume method and call it immediately.\n        LocaleManager.ion({\n            locale  : 'onBeforeLocaleChange',\n            prio    : 1,\n            thisObj : me\n        });\n        LocaleManager.ion({\n            locale  : 'onLocaleChange',\n            prio    : -1,\n            thisObj : me\n        });\n        GlobalEvents.ion({\n            theme   : 'onThemeChange',\n            thisObj : me\n        });\n        me.ion({\n            subGridExpand : 'onSubGridExpand',\n            prio          : -1,\n            thisObj       : me\n        });\n        // Buffered for scrolling, to be called\n        me.bufferedFixElementHeights = me.buffer('fixElementHeights', me.fixElementHeightsBuffer, me);\n        // Add the extra grid classes to the element\n        me.setGridClassList(me.element.classList);\n        // We do not act as a regular Container.\n        me.verticalScroller.classList.remove('b-content-element', 'b-auto-container');\n        me.bodyWrapElement.classList.remove('b-auto-container-panel');\n    }\n    onSubGridExpand() {\n        // Need to rerender all rows, because if the rows were rerendered (by adding a new column to another region for example)\n        // while the region was collapsed, cells in the region will be empty.\n        this.renderContents();\n    }\n    onBeforeLocaleChange() {\n        this._suspendRenderContentsOnColumnsChanged = true;\n    }\n    onLocaleChange() {\n        this._suspendRenderContentsOnColumnsChanged = false;\n        if (this.isPainted) {\n            this.renderContents();\n        }\n    }\n    finalizeInit() {\n        super.finalizeInit();\n        if (this.store.isLoading) {\n            // Maybe show loadmask if store is already loading when grid is constructed\n            this.onStoreBeforeRequest();\n        }\n    }\n    changeScrollManager(scrollManager, oldScrollManager) {\n        oldScrollManager?.destroy();\n        if (scrollManager) {\n            return ScrollManager.new({\n                element : this.element,\n                owner   : this\n            }, scrollManager);\n        }\n        else {\n            return null;\n        }\n    }\n    /**\n     * Cleanup\n     * @private\n     */\n    doDestroy() {\n        const me = this;\n        me.detachListeners(storeListenerName);\n        me.scrollManager?.destroy();\n        for (const feature of Object.values(me.features)) {\n            feature.destroy?.();\n        }\n        me._focusedCell = null;\n        me.columns.destroy();\n        super.doDestroy();\n    }\n    /**\n     * Adds extra classes to the Grid element after it's been configured.\n     * Also iterates through features, thus ensuring they have been initialized.\n     * @private\n     */\n    setGridClassList(classList) {\n        const me = this;\n        Object.values(me.features).forEach(feature => {\n            if (feature.disabled || feature === false) {\n                return;\n            }\n            let featureClass;\n            if (Object.prototype.hasOwnProperty.call(feature.constructor, 'featureClass')) {\n                featureClass = feature.constructor.featureClass;\n            }\n            else {\n                featureClass = `b-${(feature instanceof Base ? feature.$$name : feature.constructor.name)}`;\n            }\n            if (featureClass) {\n                classList.add(featureClass.toLowerCase());\n            }\n        });\n    }\n    //endregion\n    // region Feature events\n    // For documentation & typings purposes\n    /**\n     * Fires after a sub grid is collapsed.\n     * @event subGridCollapse\n     * @param {Grid.view.Grid} source The firing Grid instance\n     * @param {Grid.view.SubGrid} subGrid The sub grid instance\n     */\n    /**\n     * Fires after a sub grid is expanded.\n     * @event subGridExpand\n     * @param {Grid.view.Grid} source The firing Grid instance\n     * @param {Grid.view.SubGrid} subGrid The sub grid instance\n     */\n    /**\n     * Fires before a row is rendered.\n     * @event beforeRenderRow\n     * @param {Grid.view.Grid} source The firing Grid instance.\n     * @param {Grid.row.Row} row The row about to be rendered.\n     * @param {Core.data.Model} record The record for the row.\n     * @param {Number} recordIndex The zero-based index of the record.\n     */\n    /**\n     * Fires after a row is rendered.\n     * @event renderRow\n     * @param {Grid.view.Grid} source The firing Grid instance.\n     * @param {Grid.row.Row} row The row that has been rendered.\n     * @param {Core.data.Model} record The record for the row.\n     * @param {Number} recordIndex The zero-based index of the record.\n     */\n    //endregion\n    //region Grid template & elements\n    compose() {\n        const { autoHeight, enableSticky, enableTextSelection, fillLastColumn, positionMode, showDirty } = this;\n        return {\n            class : {\n                [`b-grid-${positionMode}`] : 1,\n                'b-enable-sticky'          : enableSticky,\n                'b-grid-notextselection'   : !enableTextSelection,\n                'b-autoheight'             : autoHeight,\n                'b-fill-last-column'       : fillLastColumn,\n                'b-show-dirty'             : showDirty,\n                'b-show-dirty-during-edit' : showDirty?.duringEdit\n            }\n        };\n    }\n    get cellCls() {\n        const { _cellCls } = this;\n        // It may have been merged to create a DomClassList, but 90% of the time will be a simple string.\n        return _cellCls.value || _cellCls;\n    }\n    get bodyConfig() {\n        const { autoHeight, hideFooters, hideHeaders } = this;\n        return {\n            reference : 'bodyElement',\n            className : {\n                'b-autoheight'      : autoHeight,\n                'b-grid-panel-body' : 1\n            },\n            // Only include aria-labelled-by if we have a header\n            [this.hasHeader ? 'ariaLabelledBy' : ''] : `${this.id}-panel-title`,\n            children : {\n                headerContainer : {\n                    tag             : 'header',\n                    role            : 'row',\n                    'aria-rowindex' : 1,\n                    className       : {\n                        'b-grid-header-container' : 1,\n                        'b-hidden'                : hideHeaders\n                    }\n                },\n                bodyContainer : {\n                    className : 'b-grid-body-container',\n                    tabIndex  : -1,\n                    // Explicitly needs this because it's in theory focusable\n                    // and DomSync won't add a default role\n                    role     : 'presentation',\n                    children : {\n                        verticalScroller : {\n                            className : 'b-grid-vertical-scroller'\n                        }\n                    }\n                },\n                virtualScrollers : {\n                    className : 'b-virtual-scrollers b-hide-display',\n                    style     : BrowserHelper.isFirefox && DomHelper.scrollBarWidth ? {\n                        height : `${DomHelper.scrollBarWidth}px`\n                    } : undefined\n                },\n                footerContainer : {\n                    tag       : 'footer',\n                    className : {\n                        'b-grid-footer-container' : 1,\n                        'b-hidden'                : hideFooters\n                    }\n                }\n            }\n        };\n    }\n    get contentElement() {\n        return this.verticalScroller;\n    }\n    get overflowElement() {\n        return this.bodyContainer;\n    }\n    updateHideHeaders(hide) {\n        hide = Boolean(hide);\n        // Toggle scroll partnering when hidden\n        this.headerContainer?.classList.toggle('b-hidden', hide);\n        this.eachSubGrid(subGrid => subGrid.toggleHeaders(hide));\n    }\n    updateHideFooters(hide) {\n        hide = Boolean(hide);\n        this.footerContainer?.classList.toggle('b-hidden', hide);\n        this.eachSubGrid(subGrid => {\n            subGrid.scrollable[hide ? 'removePartner' : 'addPartner'](subGrid.footer.scrollable, 'x');\n        });\n    }\n    updateHideHorizontalScrollbar(hide) {\n        hide = Boolean(hide);\n        this.eachSubGrid(subGrid => {\n            subGrid.virtualScrollerElement.classList.toggle('b-hide-display', hide);\n            subGrid.scrollable[hide ? 'removePartner' : 'addPartner'](subGrid.fakeScroller, 'x');\n            if (!hide) {\n                subGrid.refreshFakeScroll();\n            }\n        });\n    }\n    //endregion\n    //region Columns\n    changeColumns(columns, currentStore) {\n        const me = this;\n        // Empty, clear or destroy store\n        if (!columns && currentStore) {\n            // Destroy when Grid is destroyed, if we created the ColumnStore\n            if (me.isDestroying) {\n                currentStore.owner === me && currentStore.destroy();\n            }\n            // Clear if set to falsy value at some other point\n            else {\n                currentStore.removeAll();\n            }\n            return currentStore;\n        }\n        // Keep store if configured with one\n        if (columns.isStore) {\n            currentStore?.owner === me && currentStore.destroy();\n            columns.grid = me;\n            return columns;\n        }\n        // Given an array of columns\n        if (Array.isArray(columns)) {\n            // If we have a store, plug them in\n            if (currentStore) {\n                const columnsBefore = currentStore.allRecords.slice();\n                currentStore.data = columns;\n                // Destroy any columns that were removed\n                for (const oldColumn of columnsBefore) {\n                    if (!currentStore.includes(oldColumn)) {\n                        oldColumn.destroy();\n                    }\n                }\n                return currentStore;\n            }\n            // No store, use as data for a new store below\n            columns = { data : columns };\n        }\n        if (currentStore) {\n            throw new Error('Replacing ColumnStore is not supported');\n        }\n        // Assuming a store config object\n        return ColumnStore.new({\n            grid  : me,\n            owner : me\n        }, columns);\n    }\n    updateColumns(columns, was) {\n        const me = this;\n        super.updateColumns?.(columns, was);\n        // changes might be triggered when applying state, before grid is rendered\n        columns.ion({\n            refresh : me.onColumnsChanged,\n            sort    : me.onColumnsChanged,\n            change  : me.onColumnsChanged,\n            move    : me.onColumnsChanged,\n            thisObj : me\n        });\n        columns.ion(columnResizeEvent(me.onColumnsResized, me));\n        // Add touch class for touch devices\n        if (BrowserHelper.isTouchDevice) {\n            me.touch = true;\n            // apply touchConfig for columns that defines it\n            columns.forEach(column => {\n                const { touchConfig } = column;\n                if (touchConfig) {\n                    column.applyState(touchConfig);\n                }\n            });\n        }\n        me.bodyElement?.setAttribute('aria-colcount', columns.visibleColumns.length);\n    }\n    onColumnsChanged({ type, action, changes, record : column, records : changedColumns, isMove }) {\n        const\n            me                  = this,\n            {\n                columns,\n                checkboxSelectionColumn\n            }                   = me,\n            isSingleFieldChange = changes && Object.keys(changes).length === 1;\n        isMove = isMove === true ? true : (isMove && Object.values(isMove).some(field => field));\n        if (\n            isMove || (type === 'refresh' && action !== 'batch' && action !== 'sort') ||\n            // Ignore the update of parentIndex following a column move (we redraw on the insert)\n            (action === 'update' && isSingleFieldChange && 'parentIndex' in changes)  ||\n            // Ignore sort caused by sync, will refresh on the batch instead\n            (action === 'sort' && columns.isSyncingDataOnLoad)) {\n            return;\n        }\n        const addingColumnToNonExistingSubGrid = action === 'add' && changedColumns.some(col => col.region && !me.subGrids[col.region]);\n        // this.onInternalPaint will handle changes caused by updateResponsive\n        if (me.isConfiguring || (!addingColumnToNonExistingSubGrid && (!me.isPainted || (isMove && action === 'remove')))) {\n            return;\n        }\n        // See if we have to create and add new SubGrids to accommodate new columns.\n        if (action === 'add') {\n            for (const column of changedColumns) {\n                const { region } = column;\n                // See if there's a home for this column, if not, add one\n                if (!me.subGrids[region]) {\n                    me.add(me.createSubGrid(region, me.subGridConfigs?.[region]));\n                }\n            }\n        }\n        if (action === 'update') {\n            // Just updating width is already handled in a minimal way.\n            if (('width' in changes || 'minWidth' in changes || 'maxWidth' in changes || 'flex' in changes) && !('region' in changes)) {\n                // Update any leaf columns that want to be repainted on size change\n                const { region } = column;\n                // We must not capture visibleColumns from the columns var\n                // at the top. It's a cached/recalculated value that we\n                // are invalidating in the body of this function.\n                columns.visibleColumns.forEach(col => {\n                    if (col.region === region && col.repaintOnResize) {\n                        me.refreshColumn(col);\n                    }\n                });\n                me.afterColumnsChange({ action, changes, column });\n                return;\n            }\n            // No repaint if only changing column text\n            if ('text' in changes && isSingleFieldChange) {\n                column.subGrid.refreshHeader();\n                return;\n            }\n            // Column toggled, need to recheck if any visible column has flex\n            if ('hidden' in changes) {\n                const subGrid = me.getSubGridFromColumn(column.id);\n                subGrid.header.fixHeaderWidths();\n                subGrid.footer.fixFooterWidths();\n                subGrid.updateHasFlex();\n            }\n        }\n        // Might have to add or remove subgrids when assigning a new set of columns or when changing region\n        if (action === 'dataset' || action === 'batch' || (action === 'update' && 'region' in changes)) {\n            const\n                regions             = columns.getDistinctValues('region', true),\n                { toRemove, toAdd } = ArrayHelper.delta(regions, me.regions, true);\n            me.remove(toRemove.map(region => me.getSubGrid(region)));\n            me.add(toAdd.map(region => me.createSubGrid(region, me.subGridConfigs[region])));\n        }\n        // Check if checkbox selection column was removed, if so insert it back as the first column\n        if (checkboxSelectionColumn && !columns.includes(checkboxSelectionColumn)) {\n            // Insert the checkbox after any rownumber column. If not there, -1 means in at 0.\n            const insertIndex = columns.indexOf(columns.findRecord('type', 'rownumber')) + 1;\n            columns.insert(insertIndex, checkboxSelectionColumn, true);\n        }\n        if (!me._suspendRenderContentsOnColumnsChanged) {\n            me.renderContents();\n        }\n        // Columns which are flexed, but as part of a grouped column cannot just have their flex\n        // value reflected in the flex value of its cells. They are flexing a different available space.\n        // These have to be set to the exact width and kept synced.\n        me.syncFlexedSubCols();\n        // We must not capture visibleColumns from the columns var\n        // at the top. It's a cached/recalculated value that we must\n        // are invalidating in the body of this function.\n        me.bodyElement.setAttribute('aria-colcount', columns.visibleColumns.length);\n        me.afterColumnsChange({ action, changes, column, columns : changedColumns });\n    }\n    onColumnsResized({ changes, record : column }) {\n        const me = this;\n        if (me.isConfiguring) {\n            return;\n        }\n        const\n            domWidth    = DomHelper.setLength(column.width),\n            domMinWidth = DomHelper.setLength(column.minWidth),\n            domMaxWidth = DomHelper.setLength(column.maxWidth),\n            subGrid     = me.getSubGridFromColumn(column.id);\n        // Let header and footer fix their own widths\n        subGrid.header.fixHeaderWidths();\n        subGrid.footer.fixFooterWidths();\n        subGrid.updateHasFlex();\n        // We can't apply flex from flexed subColums - they are flexing inside a different available width.\n        if (!(column.flex && column.childLevel)) {\n            if (!me.cellEls || column !== me.lastColumnResized) {\n                me.cellEls           = DomHelper.children(\n                    me.element,\n                    `.b-grid-cell[data-column-id=\"${column.id}\"]`\n                );\n                me.lastColumnResized = column;\n            }\n            for (const cell of me.cellEls) {\n                if ('width' in changes) {\n                    // https://app.assembla.com/spaces/bryntum/tickets/8041\n                    // Although header and footer elements must be sized using flex-basis to avoid the busting out problem,\n                    // grid cells MUST be sized using width since rows are absolutely positioned and will not cause the\n                    // busting out problem, and rows will not stretch to shrinkwrap the cells unless they are widthed with\n                    // width.\n                    cell.style.width = domWidth;\n                }\n                if ('minWidth' in changes) {\n                    cell.style.minWidth = domMinWidth;\n                }\n                if ('maxWidth' in changes) {\n                    cell.style.maxWidth = domMaxWidth;\n                }\n                if ('flex' in changes) {\n                    cell.style.flex = column.flex ?? null;\n                }\n            }\n        }\n        // If we're being driven by the ColumnResizer or other bulk column resizer (like\n        // ColumnAutoWidth), they will finish up with a call to afterColumnsResized.\n        if (!me.resizingColumns) {\n            me.afterColumnsResized(column);\n        }\n        // Columns which are flexed, but as part of a grouped column cannot just have their flex\n        // value reflected in the flex value of its cells. They are flexing a different available space.\n        // These have to be set to the exact width and kept synced.\n        me.syncFlexedSubCols();\n    }\n    afterColumnsResized(column) {\n        const me = this;\n        me.eachSubGrid(subGrid => {\n            // Only needed if the changed column is owned by the SubGrid\n            if (!subGrid.collapsed && (!column || column.region === subGrid.region)) {\n                subGrid.fixWidths();\n                subGrid.fixRowWidthsInSafariEdge();\n            }\n        });\n        me.lastColumnResized = me.cellEls = null;\n        // Buffer some expensive operations, like updating the fake scrollers\n        me.bufferedAfterColumnsResized(column);\n        // Must happen immediately, not inside the bufferedAfterColumnsResized\n        me.onHeightChange();\n    }\n    syncFlexedSubCols() {\n        const flexedSubCols = this.columns.query(c => c.flex && c.childLevel && c.element);\n        // Columns which are flexed, but as part of a grouped column cannot just have their flex\n        // value reflected in the flex value of its cells. They are flexing a different available space.\n        // These have to be set to the exact width and kept synced.\n        if (flexedSubCols) {\n            for (const column of flexedSubCols) {\n                const\n                    width   = column.element.getBoundingClientRect().width,\n                    cellEls = DomHelper.children(\n                        this.element,\n                        `.b-grid-cell[data-column-id=\"${column.id}\"]`\n                    );\n                for (const cell of cellEls) {\n                    cell.style.flex = `0 0 ${width}px`;\n                }\n            }\n        }\n    }\n    bufferedAfterColumnsResized(column) {\n        // Columns that allow their cell content to drive the row height requires a rerender after resize\n        if (this.columns.usesAutoHeight) {\n            this.refreshRows();\n        }\n        this.refreshVirtualScrollbars();\n        this.eachSubGrid(subGrid => {\n            // Only needed if the changed column is owned by the SubGrid\n            if (!subGrid.collapsed && (!column || column.region === subGrid.region)) {\n                subGrid.refreshFakeScroll();\n            }\n        });\n    }\n    bufferedElementResize() {\n        this.refreshRows();\n    }\n    onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight) {\n        // If a flexed subGrid would be flexed *down* by a width reduction, allow it\n        // to lay itself out before the refreshVirtualScrollbars called by GridElementEvents\n        // asks them whether they are overflowingHorizontally.\n        // This is to avoid an unnecessary extra layout with a horizontal\n        // scrollbar which may be hidden when the subgrid adjusts itself when its ResizeMonitor\n        // notification arrives - they are delivered outermost->innermost, we find out first here.\n        // When the actualResizeMonitor notification arrives, it will be a no-op.\n        if (DomHelper.scrollBarWidth && newWidth < oldWidth) {\n            this.eachSubGrid(subGrid => {\n                if (subGrid.flex) {\n                    subGrid.onElementResize(subGrid.element);\n                }\n            });\n        }\n        super.onInternalResize(...arguments);\n        // Columns that allow their cell content to drive the row height requires a rerender after element resize\n        if (this.isPainted && newWidth !== oldWidth && this.columns.usesFlexAutoHeight) {\n            this.bufferedElementResize();\n        }\n    }\n    //endregion\n    //region Rows\n    /**\n     * Get the topmost visible grid row\n     * @member {Grid.row.Row} firstVisibleRow\n     * @readonly\n     * @category Rows\n     */\n    /**\n     * Get the last visible grid row\n     * @member {Grid.row.Row} lastVisibleRow\n     * @readonly\n     * @category Rows\n     */\n    /**\n     * Get the Row that is currently displayed at top.\n     * @member {Grid.row.Row} topRow\n     * @readonly\n     * @category Rows\n     * @private\n     */\n    /**\n     * Get the Row currently displayed furthest down.\n     * @member {Grid.row.Row} bottomRow\n     * @readonly\n     * @category Rows\n     * @private\n     */\n    /**\n     * Get Row for specified record id.\n     * @function getRowById\n     * @param {Core.data.Model|String|Number} recordOrId Record id (or a record)\n     * @returns {Grid.row.Row} Found Row or null if record not rendered\n     * @category Rows\n     * @private\n     */\n    /**\n     * Returns top and bottom for rendered row or estimated coordinates for unrendered.\n     * @function getRecordCoords\n     * @param {Core.data.Model|String|Number} recordOrId Record or record id\n     * @returns {Object} Record bounds with format { top, height, bottom }\n     * @category Calculations\n     * @private\n     */\n    /**\n     * Get the Row at specified index. \"Wraps\" index if larger than available rows.\n     * @function getRow\n     * @param {Number} index\n     * @returns {Grid.row.Row}\n     * @category Rows\n     * @private\n     */\n    /**\n     * Get a Row for either a record, a record id or an HTMLElement\n     * @function getRowFor\n     * @param {HTMLElement|Core.data.Model|String|Number} recordOrId Record or record id or HTMLElement\n     * @returns {Grid.row.Row} Found Row or `null` if record not rendered\n     * @category Rows\n     */\n    /**\n     * Get a Row from an HTMLElement\n     * @function getRowFromElement\n     * @param {HTMLElement} element\n     * @returns {Grid.row.Row} Found Row or `null` if record not rendered\n     * @category Rows\n     * @private\n     */\n    changeRowManager(rowManager, oldRowManager) {\n        const me = this;\n        // Use row height from CSS if not specified in config. Did not want to turn this into a getter/setter for\n        // rowHeight since RowManager will plug its implementation into Grid when created below, and after initial\n        // configuration that is what should be used\n        if (!me._isRowMeasured) {\n            me.measureRowHeight();\n        }\n        oldRowManager?.destroy();\n        if (rowManager) {\n            // RowManager is a plugin, it is configured with its grid as its \"client\".\n            // It uses client.store as its record source.\n            const result = RowManager.new({\n                grid              : me,\n                rowHeight         : me.rowHeight,\n                rowScrollMode     : me.rowScrollMode || 'move',\n                autoHeight        : me.autoHeight,\n                fixedRowHeight    : me.fixedRowHeight,\n                internalListeners : {\n                    changeTotalHeight   : 'onRowManagerChangeTotalHeight',\n                    requestScrollChange : 'onRowManagerRequestScrollChange',\n                    thisObj             : me\n                }\n            }, rowManager);\n            // The grid announces row rendering to allow customization of rows.\n            me.relayEvents(result, ['beforeRenderRow', 'renderRow']);\n            // RowManager injects itself as a property into the grid so that the grid\n            // can reference it during RowManager's spin-up. We need to undo that now\n            // otherwise updaters will not run.\n            me._rowManager = null;\n            return result;\n        }\n    }\n    // Manual relay needed for Split feature to catch the config change\n    updateRowHeight(rowHeight) {\n        if (!this.isConfiguring && this.rowManager) {\n            this.rowManager.rowHeight = rowHeight;\n        }\n    }\n    get rowHeight() {\n        return this._rowManager?.rowHeight ?? this._rowHeight;\n    }\n    // Default implementation, documented in `defaultConfig`\n    getRowHeight(record) {\n        return record.rowHeight;\n    }\n    // Hook for features that need to alter the row height\n    processRowHeight(record, height) {}\n    //endregion\n    //region Store\n    getAsyncEventSuffixForStore(store) {\n        return this.asyncEventSuffix;\n    }\n    /**\n     * Hooks up data store listeners\n     * @private\n     * @category Store\n     */\n    bindStore(store) {\n        const\n            suffix = this.getAsyncEventSuffixForStore(store);\n        store.ion({\n            name : storeListenerName,\n            [`refresh${suffix}`]   : 'onStoreDataChange',\n            [`add${suffix}`]       : 'onStoreAdd',\n            [`remove${suffix}`]    : 'onStoreRemove',\n            [`replace${suffix}`]   : 'onStoreReplace',\n            [`removeAll${suffix}`] : 'onStoreRemoveAll',\n            [`move${suffix}`]      : store.tree ? null : 'onFlatStoreMove',\n            change                 : 'relayStoreDataChange',\n            idChange            : 'onStoreRecordIdChange',\n            update              : 'onStoreUpdateRecord',\n            beforeRequest       : 'onStoreBeforeRequest',\n            afterRequest        : 'onStoreAfterRequest',\n            exception           : 'onStoreException',\n            commit              : 'onStoreCommit',\n            startApplyChangeset : 'internalOnStoreStartApplyChangeset',\n            endApplyChangeset   : 'internalOnStoreEndApplyChangeset',\n            thisObj             : this\n        });\n        super.bindStore(store);\n    }\n    unbindStore(oldStore) {\n        this.detachListeners(storeListenerName);\n        if (this.destroyStore) {\n            oldStore.destroy();\n        }\n    }\n    changeStore(store) {\n        if (store == null) {\n            return null;\n        }\n        if (typeof store === 'string') {\n            store = Store.getStore(store);\n        }\n        if (!store.isStore) {\n            store = ObjectHelper.assign({\n                data : this.data,\n                tree : Boolean(this.initialConfig.features?.tree)\n            }, store);\n            if (!store.data) {\n                delete store.data;\n            }\n            if (!store.modelClass) {\n                store.modelClass = GridRowModel;\n            }\n            store = new (store.readUrl ? AjaxStore : Store)(store);\n        }\n        return store;\n    }\n    updateStore(store, was) {\n        const me = this;\n        super.updateStore?.(store, was);\n        if (was) {\n            me.unbindStore(was);\n        }\n        if (store) {\n            // Deselect all rows when replacing the store, otherwise selection retains old store\n            if (was) {\n                me.deselectAll();\n            }\n            me.bindStore(store);\n        }\n        me.trigger('bindStore', { store, oldStore : was });\n        // Changing store when painted -> refresh rows to reflect new data\n        if (!me.isDestroying && me.isPainted && !me.refreshSuspended) {\n            me._rowManager?.reinitialize();\n        }\n    }\n    /**\n     * Rerenders a cell if a record is updated in the store\n     * @private\n     * @category Store\n     */\n    onStoreUpdateRecord({ source : store, record, changes }) {\n        const me = this;\n        if (me.refreshSuspended) {\n            return;\n        }\n        if (me.forceFullRefresh) {\n            // flagged to need full refresh (probably from using GroupSummary)\n            me.rowManager.refresh();\n            me.forceFullRefresh = false;\n        }\n        else {\n            let row;\n            // Search for old row if id was changed\n            if (record.isFieldModified('id')) {\n                row = me.getRowFor(record.meta.modified.id);\n            }\n            row = row || me.getRowFor(record);\n            // not rendered, bail out\n            if (!row) {\n                return;\n            }\n            // We must refresh the full row if it's a special row which has signalled\n            // an update because it has no cells.\n            if (me.fullRowRefresh || record.isSpecialRow) {\n                const index = store.indexOf(record);\n                if (index !== -1) {\n                    row.render(index, record);\n                }\n            }\n            else {\n                me.columns.visibleColumns.forEach(column => {\n                    const\n                        field  = column.field,\n                        isSafe = column.constructor.simpleRenderer && !(Object.prototype.hasOwnProperty.call(column.data, 'renderer'));\n                    // If there's a  non-safe renderer, that is a renderer which draws values from elsewhere\n                    // than just its configured field, that column must be refreshed on every record update.\n                    // Obviously, if the column's configured field is changed that also means it's refreshed.\n                    if (!isSafe || changes[field]) {\n                        const cellElement = row.getCell(field);\n                        if (cellElement) {\n                            row.renderCell(cellElement);\n                        }\n                    }\n                });\n            }\n        }\n    }\n    refreshFromRowOnStoreAdd(row, context) {\n        const\n            me             = this,\n            { rowManager } = me;\n        rowManager.renderFromRow(row);\n        rowManager.trigger('changeTotalHeight', { totalHeight : rowManager.totalHeight });\n        // First record? Also update fake scrollers\n        if (me.store.count === 1) {\n            me.callEachSubGrid('refreshFakeScroll');\n        }\n    }\n    onMaskAutoClose(mask) {\n        super.onMaskAutoClose(mask);\n        this.toggleEmptyText();\n    }\n    /**\n     * Refreshes rows when data is added to the store\n     * @private\n     * @category Store\n     */\n    onStoreAdd({ source : store, records, index, oldIndex, isChild, oldParent, parent, isMove, isExpand, isExpandAll }) {\n        const\n            me             = this,\n            { rowManager } = me;\n        // Do not react if the content has not been rendered, or refresh is suspended,\n        // or we are part of a project that is having a changeset applied (a bit dirty to include that here, but\n        // avoids having to add an override in TimelineBase)\n        if (!me.isPainted || isExpandAll || me.refreshSuspended) {\n            return;\n        }\n        // If the add is an expand, the records will be visible because children collection is\n        // calculated in StoreTree.internalToggleTreeSubRecords WRT filtering.\n        // We can splice the incoming records into place with animation.\n        if (isExpand && me.animateTreeNodeToggle) {\n            return rowManager.insert(index, records.length);\n        }\n        // If we move records check if some of their old parents is expanded\n        const hasExpandedOldParent = isMove && records.some(record => {\n            if (isMove[record.id]) {\n                // When using TreeGroup there won't be an old parent\n                const oldParent = store.getById(record.meta.modified.parentId);\n                return oldParent?.isExpanded(store) && oldParent?.ancestorsExpanded(store);\n            }\n        });\n        // If it's the addition of a child to a collapsed zone (and old parents are also collapsed), the UI does not change.\n        if (isChild && !records[0].ancestorsExpanded(store) && !hasExpandedOldParent) {\n            // BUT it might change if parent had no children (expander made invisible) and it gets children added\n            if (!parent.isLeaf) {\n                const parentRow = rowManager.getRowById(parent);\n                if (parentRow) {\n                    rowManager.renderRows([parentRow]);\n                }\n            }\n            return;\n        }\n        rowManager.calculateRowCount(false, true, true);\n        // When store is filtered need to update the index value\n        if (store.isFiltered) {\n            index = store.indexOf(records[0]);\n        }\n        const\n            {\n                topIndex,\n                rows,\n                rowCount\n            }              = rowManager,\n            bottomIndex    = rowManager.topIndex + rowManager.rowCount - 1,\n            dataStart      = index,\n            dataEnd        = index + records.length - 1,\n            atEnd          = bottomIndex >= store.count - records.length - 1;\n        // When moving a node within a tree we might need the redraw to include its old parent and its children. Not\n        // worth the complexity of trying to do a partial render for this, rerender all rows to be safe. Cannot solely\n        // rely on presence of isMove, all keys might be false\n        // Moving records within a flat store is handled elsewhere, in onFlatStoreMove\n        if (oldParent || oldIndex > -1 || (isChild && isMove && Object.values(isMove).some(v => v))) {\n            rowManager.refresh();\n        }\n        // Added block starts in our visible block. Render from there downwards.\n        else if (dataStart >= topIndex && dataStart < topIndex + rowCount) {\n            me.refreshFromRowOnStoreAdd(rows[dataStart - topIndex], ...arguments);\n        }\n        // Added block ends in our visible block, render block\n        else if (dataEnd >= topIndex && dataEnd < topIndex + rowCount) {\n            rowManager.refresh();\n        }\n        // If added block is outside of the visible area, no visible change\n        // but potentially a change in total dataset height.\n        else {\n            // If we are against the end of the dataset, and have appended records\n            // ensure they are rendered below\n            if (atEnd && index > bottomIndex) {\n                rowManager.fillBelow(me._scrollTop || 0);\n            }\n            rowManager.estimateTotalHeight(true);\n        }\n    }\n    /**\n     * Responds to exceptions signalled by the store\n     * @private\n     * @category Store\n     */\n    onStoreException({ action, type, response, exceptionType, error }) {\n        const me = this;\n        let message;\n        switch (type) {\n            case 'server':\n                message = response.message || me.L('L{unspecifiedFailure}');\n                break;\n            case 'exception':\n                message = exceptionType === 'network' ? me.L('L{networkFailure}') : (error?.message || response?.parsedJson?.message || me.L('L{parseFailure}'));\n                break;\n        }\n        me.applyMaskError(\n            `<div class=\"b-grid-load-failure\">\n                <div class=\"b-grid-load-fail\">${me.L(action === 'read' ? 'L{loadFailedMessage}' : 'L{syncFailedMessage}')}</div>\n                ${response?.url ? `<div class=\"b-grid-load-fail\">${response.url}</div>` : ''}\n                <div class=\"b-grid-load-fail\">${me.L('L{serverResponse}')}</div>\n                <div class=\"b-grid-load-fail\">${message}</div>\n            </div>`);\n    }\n    /**\n     * Refreshes rows when data is changed in the store\n     * @private\n     * @category Store\n     */\n    onStoreDataChange({ action, changes, source : store, syncInfo }) {\n        // If the next mixin up the inheritance chain has an implementation, call it\n        super.onStoreDataChange?.(...arguments);\n        const me = this;\n        if (me.refreshSuspended || !me.rowManager) {\n            return;\n        }\n        // If it's new data, the old calculation is invalidated.\n        if (action === 'dataset') {\n            me.rowManager.clearKnownHeights();\n            // Initial filters on a tree store first triggers `dataset`, then `filter`.\n            // Ignore `dataset`, only redraw on `filter`\n            if (store.isTree && store.isFiltered) {\n                return;\n            }\n        }\n        const isGroupFieldChange = store.isGrouped && changes && store.groupers.some(grp => grp.field in changes);\n        // No need to rerender if it's a change of the value of the group field which\n        // will be responded to by StoreGroup\n        if (me.isPainted && !isGroupFieldChange) {\n            // Optionally scroll to top if setting new data or filtering based on preserveScrollOnDatasetChange setting\n            me.renderRows(Boolean(!(action in datasetReplaceActions) || me.preserveScrollOnDatasetChange));\n        }\n        me.toggleEmptyText();\n    }\n    /**\n     * The hook is called when the id of a record has changed.\n     * @private\n     * @category Store\n     */\n    onStoreRecordIdChange() {\n        // If the next mixin up the inheritance chain has an implementation, call it\n        super.onStoreRecordIdChange?.(...arguments);\n    }\n    /**\n     * Shows a load mask while the connected store is loading\n     * @private\n     * @category Store\n     */\n    onStoreBeforeRequest() {\n        this.applyLoadMask();\n    }\n    /**\n     * Hides load mask after a load request ends either in success or failure\n     * @private\n     * @category Store\n     */\n    onStoreAfterRequest(event) {\n        if (this.loadMask && !event.exception) {\n            this.masked = null;\n            this.toggleEmptyText();\n        }\n    }\n    needsFullRefreshOnStoreRemove({ isCollapse }) {\n        const { store } = this;\n        return (this.features?.group?.enabled && store.isGrouped) ||\n            // Need to redraw parents when children are removed since they might be converted to leaves\n            (store.tree && !isCollapse && store.modelClass.convertEmptyParentToLeaf);\n    }\n    /**\n     * Animates removal of record.\n     * @private\n     * @category Store\n     */\n    onStoreRemove({ source : store, records, isCollapse, isChild, isMove, isCollapseAll }) {\n        // Do not react if the content has not been rendered,\n        // or if it is a move, which will be handled by onStoreAdd\n        if (!this.isPainted || isMove || isCollapseAll) {\n            return;\n        }\n        // GridSelection mixin does its job on records removing\n        super.onStoreRemove?.(...arguments);\n        const\n            me             = this,\n            { rowManager } = me;\n        // Remove cached heights\n        rowManager.invalidateKnownHeight(records);\n        // Will be refresh once in onStoreLoadSync after sync data on load\n        if (me.refreshSuspended) {\n            return;\n        }\n        // Animated grid row remove.\n        // Slides outgoing row horizintally.\n        if (me.animateRemovingRows && !isCollapse && !isChild) {\n            // Gather all visible rows which need to be removed.\n            const rowsToRemove = records.reduce((result, record) => {\n                const row = rowManager.getRowById(record.id);\n                row && result.push(row);\n                return result;\n            }, []);\n            if (rowsToRemove.length) {\n                const topRow = rowsToRemove[0];\n                me.isAnimating = true;\n                // As soon as first row has disappeared, rerender the view\n                EventHelper.onTransitionEnd({\n                    element  : topRow._elementsArray[0],\n                    property : 'left',\n                    // Detach listener after timeout even if event wasn't fired\n                    duration : me.transitionDuration + 50,\n                    thisObj  : me,\n                    handler  : () => {\n                        me.isAnimating = false;\n                        rowsToRemove.forEach(row => !row.isDestroyed && row.removeCls('b-removing'));\n                        rowManager.refresh();\n                        // undocumented internal event for scheduler\n                        me.trigger('rowRemove');\n                        me.afterRemove(arguments[0]);\n                    }\n                });\n                rowsToRemove.forEach(row => row.addCls('b-removing'));\n            }\n        }\n        // Animated node collapse. Slides rows below upwards.\n        else if (isCollapse && me.animateTreeNodeToggle) {\n            // Gather all visible rows which need to be removed.\n            const\n                // We need to sort the indices being removed so we can detect whether it is a contiguous block\n                indicesToRemove = records.flatMap(record => {\n                    const row = rowManager.getRowFor(record);\n                    return row ? row.index : emptyArray;\n                }).sort(ascending),\n                { length } = indicesToRemove;\n            // If we are removing a contiguous block, the RowManager can do that, and the forthcoming refresh's\n            // set of row tops will animate any out of place rows into position\n            if (length && indicesToRemove[length - 1] === indicesToRemove[0] + length - 1) {\n                return rowManager.insert(indicesToRemove[0], -indicesToRemove.length);\n            }\n        }\n        // Cannot do an update from the affected row and down here. Since group headers might be affected by\n        // removing rows we need a full refresh\n        else if (me.needsFullRefreshOnStoreRemove(...arguments)) {\n            rowManager.refresh();\n            me.afterRemove(arguments[0]);\n        }\n        else {\n            const\n                { rows }    = rowManager,\n                topRowIndex = records.reduce((result, record) => {\n                    const row = rowManager.getRowById(record.id);\n                    if (row) {\n                        // Rows are repositioned in the array, it matches visual order. Need to find actual index in it\n                        result = Math.min(result, rows.indexOf(row));\n                    }\n                    return result;\n                }, rows.length);\n            // If there were rows below which have moved up into place\n            // then repurpose them with their new records\n            if (rows[topRowIndex]) {\n                !me.refreshSuspended && rowManager.renderFromRow(rows[topRowIndex]);\n            }\n            // If nothing to render below, just update dataset height\n            else {\n                rowManager.trigger('changeTotalHeight', { totalHeight : rowManager.totalHeight });\n            }\n            me.trigger('rowRemove', { isCollapse });\n            me.afterRemove(arguments[0]);\n        }\n    }\n    onFlatStoreMove({ from, to }) {\n        const\n            { rowManager, store } = this,\n            {\n                topIndex,\n                rowCount\n            }                     = rowManager,\n            // from and to are indices in the unfiltered collection, we need to convert them\n            // to indices in a visible collection\n            [dataStart, dataEnd]  = [from, to].sort((a, b) => a - b),\n            visibleStart          = store.indexOf(store.getAt(dataStart, true)),\n            visibleEnd            = store.indexOf(store.getAt(dataEnd, true));\n        // Changed block starts in our visible block. Render from there downwards.\n        if (visibleStart >= topIndex && visibleStart < topIndex + rowCount) {\n            rowManager.renderFromRow(rowManager.rows[visibleStart - topIndex]);\n        }\n        // Changed block ends in our visible block, render block\n        else if (visibleEnd >= topIndex && visibleEnd < topIndex + rowCount) {\n            rowManager.refresh();\n        }\n        // If the changed block is outside the visible area, this is a no-op\n    }\n    onStoreReplace({ records, all }) {\n        const { rowManager } = this;\n        if (all) {\n            rowManager.clearKnownHeights();\n            rowManager.refresh();\n        }\n        else {\n            const rows = records.reduce((rows, [, record]) => {\n                const row = this.getRowFor(record);\n                if (row) {\n                    rows.push(row);\n                }\n                return rows;\n            }, []);\n            // Heights will be stored on render, but some records might be out of view -> have to invalidate separately\n            rowManager.invalidateKnownHeight(records);\n            rowManager.renderRows(rows);\n        }\n    }\n    relayStoreDataChange(event) {\n        this.ariaElement?.setAttribute('aria-rowcount', this.store.count + 1);\n        /**\n         * Fired when data in the store changes.\n         *\n         * Basically a relayed version of the store's own change event, decorated with a `store` property.\n         * See the {@link Core.data.Store#event-change store change event} documentation for more information.\n         *\n         * @event dataChange\n         * @param {Grid.view.Grid} source Owning grid\n         * @param {Core.data.Store} store The originating store\n         * @param {'remove'|'removeAll'|'add'|'updatemultiple'|'clearchanges'|'filter'|'update'|'dataset'|'replace'} action\n         * Name of action which triggered the change. May be one of:\n         * * `'remove'`\n         * * `'removeAll'`\n         * * `'add'`\n         * * `'updatemultiple'`\n         * * `'clearchanges'`\n         * * `'filter'`\n         * * `'update'`\n         * * `'dataset'`\n         * * `'replace'`\n         * @param {Core.data.Model} record Changed record, for actions that affects exactly one record (`'update'`)\n         * @param {Core.data.Model[]} records Changed records, passed for all actions except `'removeAll'`\n         * @param {Object} changes Passed for the `'update'` action, info on which record fields changed\n         */\n        if (!this.project) {\n            return this.trigger('dataChange', { ...event, store : event.source, source : this });\n        }\n    }\n    /**\n     * Rerenders grid when all records have been removed\n     * @private\n     * @category Store\n     */\n    onStoreRemoveAll() {\n        // GridSelection mixin does its job on records removing\n        super.onStoreRemoveAll?.(...arguments);\n        if (this.isPainted) {\n            this.rowManager.clearKnownHeights();\n            this.renderRows(false);\n            this.toggleEmptyText();\n        }\n    }\n    // Refresh dirty cells on commit\n    onStoreCommit({ changes }) {\n        if (this.showDirty && changes.modified.length) {\n            const rows = [];\n            changes.modified.forEach(record => {\n                const row = this.rowManager.getRowFor(record);\n                row && rows.push(row);\n            });\n            this.rowManager.renderRows(rows);\n        }\n    }\n    internalOnStoreStartApplyChangeset() {\n        this.suspendRefresh();\n        if (this.constructor.bindStoreChangeset) {\n            this.captureScrollTargetRow();\n        }\n    }\n    internalOnStoreEndApplyChangeset() {\n        this.resumeRefresh(true);\n        if (this.constructor.bindStoreChangeset) {\n            this.restoreScrollTargetRow();\n        }\n    }\n    /**\n     * Remember scroll position when store is about to apply a changeset\n     * @private\n     */\n    captureScrollTargetRow() {\n        const me = this;\n        if (me.preserveScroll) {\n            const { firstFullyVisibleRow : firstRow, lastVisibleRow : lastRow } = me.rowManager;\n            if (firstRow) {\n                me.lastVisibleRowIds = [firstRow.id];\n                for (let index = firstRow.dataIndex + 1; index <= lastRow.dataIndex; index++) {\n                    me.lastVisibleRowIds.push(me.rowManager.getRow(index).id);\n                }\n                me.lastTopRowOffset = me.scrollable.getDeltaTo(firstRow.element,\n                    { block : 'start', x : false, constrainToScrollable : false });\n            }\n        }\n    }\n    /**\n     * Restore scroll position. Go to the topmost row formerly in the view that is still present in the dataset.\n     * @private\n     */\n    restoreScrollTargetRow() {\n        const me = this;\n        if (me.preserveScroll) {\n            if (me.lastVisibleRowIds) {\n                me.rowManager.refresh();\n                const targetId = me.lastVisibleRowIds.find(rowId => me.store.getById(rowId));\n                if (targetId != undefined && targetId !== me.rowManager.firstFullyVisibleRow.id) {\n                    if (me.preserveScroll.overscroll) {\n                        const scrollNeeded = me.scrollable.getDeltaTo(me.getRecordCoords(targetId),\n                            { block : 'start', x : false, constrainToScrollable : false, edgeOffset : me.lastTopRowOffset.yDelta }).yDelta;\n                        if (scrollNeeded > me.scrollable.maxY) {\n                            me.scrollable.scrollHeight += scrollNeeded;\n                        }\n                    }\n                    me.scrollRowIntoView(targetId, {\n                        block      : 'start',\n                        edgeOffset : me.lastTopRowOffset.yDelta,\n                        x          : false\n                    });\n                }\n            }\n            me.lastVisibleRowIds = undefined;\n            me.lastTopRowOffset = undefined;\n        }\n    }\n    // Documented with config\n    get data() {\n        if (this._store) {\n            return this._store.records;\n        }\n        else {\n            return this._data;\n        }\n    }\n    set data(data) {\n        if (this._store) {\n            this._store.data = data;\n        }\n        else {\n            this._data = data;\n        }\n    }\n    //endregion\n    //region Context menu items\n    /**\n     * Populates the header context menu. Chained in features to add menu items.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateHeaderMenu({ column, items }) {\n        const\n            me                    = this,\n            { subGrids, regions } = me,\n            { parent }            = column;\n        let first = true;\n        Object.entries(subGrids).forEach(([region, subGrid]) => {\n            // If SubGrid is configured with a sealed column set, do not allow moving into it\n            if (subGrid.sealedColumns) {\n                return;\n            }\n            if (\n                column.draggable &&\n                region !== column.region &&\n                (!parent && subGrids[column.region].columns.count > 1 || parent && parent.children.length > 1)\n            ) {\n                const\n                    preceding = subGrid.element.compareDocumentPosition(subGrids[column.region].element) === document.DOCUMENT_POSITION_PRECEDING,\n                    moveRight = me.rtl ? !preceding : preceding,\n                    // With 2 regions, use Move left, Move right. With multiple, include region name\n                    text      = regions.length > 2\n                        ? me.L('L{moveColumnTo}', me.optionalL(region))\n                        : me.L(moveRight ? 'L{moveColumnRight}' : 'L{moveColumnLeft}');\n                items[`${region}Region`] = {\n                    targetSubGrid : region,\n                    text,\n                    icon          : 'b-fw-icon b-icon-column-move-' + (moveRight ? 'right' : 'left'),\n                    separator     : first,\n                    disabled      : !column.allowDrag,\n                    onItem        : ({ item }) => {\n                        column.traverse(col => col.region = region);\n                        // Changing region will move the column to the correct SubGrid, but we want it to go last\n                        me.columns.insert(me.columns.indexOf(subGrids[item.targetSubGrid].columns.last) + 1, column);\n                        me.scrollColumnIntoView(column);\n                    }\n                };\n                first = false;\n            }\n        });\n    }\n    /**\n     * Populates the cell context menu. Chained in features to add menu items.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown\n     * @param {Core.data.Model} options.record Record for which the menu will be shown\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateCellMenu({ record, items }) {}\n    getColumnDragToolbarItems(column, items) {\n        return items;\n    }\n    //endregion\n    //region Getters\n    normalizeCellContext(cellContext) {\n        const\n            grid        = this,\n            { columns } = grid;\n        // Already have a Location\n        if (cellContext.isLocation) {\n            return cellContext;\n        }\n        // Create immutable Location object encapsulating the passed object.\n        if (cellContext.isModel) {\n            return new Location({\n                grid,\n                id       : cellContext.id,\n                columnId : columns.visibleColumns[0].id\n            });\n        }\n        return new Location(ObjectHelper.assign({ grid }, cellContext));\n    }\n    /**\n     * Returns a cell if rendered or null if not found.\n     * @param {LocationConfig} cellContext A cell location descriptor\n     * @returns {HTMLElement|null}\n     * @category Getters\n     */\n    getCell(cellContext) {\n        const\n            { store, columns } = this,\n            { visibleColumns } = this.columns,\n            rowIndex           = !isNaN(cellContext.row) ? cellContext.row : !isNaN(cellContext.rowIndex) ? cellContext.rowIndex : store.indexOf(cellContext.record || cellContext.id),\n            columnIndex        = !isNaN(cellContext.column) ? cellContext.column : !isNaN(cellContext.columnIndex) ? cellContext.columnIndex : visibleColumns.indexOf(cellContext.column || columns.getById(cellContext.columnId) || columns.get(cellContext.field) || visibleColumns[0]);\n        // Only return cell for valid address.\n        // This code is more strict than Location which attempts to find the closest existing cell.\n        // Here we MUST only return a cell if the passed context is fully valid.\n        return rowIndex > -1 && rowIndex < store.count && columnIndex > -1 && columnIndex < visibleColumns.length && this.normalizeCellContext(cellContext).cell || null;\n    }\n    /**\n     * Returns the header element for the column\n     * @param {String|Number|Grid.column.Column} columnId or Column instance\n     * @returns {HTMLElement} Header element\n     * @category Getters\n     */\n    getHeaderElement(columnId) {\n        if (columnId.isModel) {\n            columnId = columnId.id;\n        }\n        return this.fromCache(`.b-grid-header[data-column-id=\"${columnId}\"]`);\n    }\n    getHeaderElementByField(field) {\n        const column = this.columns.get(field);\n        return column ? this.getHeaderElement(column) : null;\n    }\n    /**\n     * Body height\n     * @member {Number}\n     * @readonly\n     * @category Layout\n     */\n    get bodyHeight() {\n        return this._bodyHeight;\n    }\n    /**\n     * Header height\n     * @member {Number}\n     * @readonly\n     * @category Layout\n     */\n    get headerHeight() {\n        const me = this;\n        // measure header if rendered and not stored\n        if (me.isPainted && !me._headerHeight) {\n            me._headerHeight = me.headerContainer.offsetHeight;\n        }\n        return me._headerHeight;\n    }\n    /**\n     * Footer height\n     * @member {Number}\n     * @readonly\n     * @category Layout\n     */\n    get footerHeight() {\n        const me = this;\n        // measure footer if rendered and not stored\n        if (me.isPainted && !me._footerHeight) {\n            me._footerHeight = me.footerContainer.offsetHeight;\n        }\n        return me._footerHeight;\n    }\n    get isTreeGrouped() {\n        return Boolean(this.features.treeGroup?.isGrouped);\n    }\n    /**\n     * Searches up from the specified element for a grid row and returns the record associated with that row.\n     * @param {HTMLElement} element Element somewhere within a row or the row container element\n     * @returns {Core.data.Model} Record for the row\n     * @category Getters\n     */\n    getRecordFromElement(element) {\n        const el = element.closest('.b-grid-row');\n        if (!el) return null;\n        return this.store.getAt(el.dataset.index);\n    }\n    /**\n     * Searches up from specified element for a grid cell or an header and returns the column which the cell belongs to\n     * @param {HTMLElement} element Element somewhere in a cell\n     * @returns {Grid.column.Column} Column to which the cell belongs\n     * @category Getters\n     */\n    getColumnFromElement(element) {\n        const cell = element.closest('.b-grid-cell, .b-grid-header');\n        if (!cell) return null;\n        if (cell.matches('.b-grid-header')) {\n            return this.columns.getById(cell.dataset.columnId);\n        }\n        const cellData = DomDataStore.get(cell);\n        return this.columns.getById(cellData.columnId);\n    }\n    // Only added for type checking, since it seems common to get it wrong in react/angular\n    updateAutoHeight(autoHeight) {\n        ObjectHelper.assertBoolean(autoHeight, 'autoHeight');\n    }\n    updateColumnLines(columnLines) {\n        ObjectHelper.assertBoolean(columnLines, 'columnLines');\n        DomHelper.toggleClasses(this.element, 'b-no-column-lines', !columnLines);\n    }\n    updateRowLines(rowLines) {\n        DomHelper.toggleClasses(this.element, 'b-no-row-lines', !rowLines);\n    }\n    get keyMapElement() {\n        return this.bodyElement;\n    }\n    //endregion\n    //region Fix width & height\n    /**\n     * Sets widths and heights for headers, rows and other parts of the grid as needed\n     * @private\n     * @category Width & height\n     */\n    fixSizes() {\n        // subGrid width\n        this.callEachSubGrid('fixWidths');\n        // Get leaf headers.\n        const colHeaders = this.headerContainer.querySelectorAll('.b-grid-header.b-depth-0');\n        // Update leaf headers' ariaColIndex\n        for (let i = 0, { length } = colHeaders; i < length; i++) {\n            colHeaders[i].setAttribute('aria-colindex', i + 1);\n        }\n    }\n    onRowManagerChangeTotalHeight({ totalHeight, immediate }) {\n        return this.refreshTotalHeight(totalHeight, immediate);\n    }\n    /**\n     * Makes height of vertical scroller match estimated total height of grid. Called when scrolling vertically and\n     * when showing/hiding rows.\n     * @param {Number} [height] Total height supplied by RowManager\n     * @param {Boolean} [immediate] Flag indicating if buffered element sizing should be bypassed\n     * @private\n     * @category Width & height\n     */\n    refreshTotalHeight(height = this.rowManager.totalHeight, immediate = false) {\n        const me = this;\n        // Veto change of estimated total height while rendering rows or if triggered while in a hidden state\n        if (me.renderingRows || !me.isVisible) {\n            return false;\n        }\n        const\n            scroller     = me.scrollable,\n            delta        = Math.abs(me.virtualScrollHeight - height),\n            clientHeight = me._bodyRectangle.height,\n            newMaxY      = height - clientHeight;\n        if (delta) {\n            const\n                // We must update immediately if we are nearing the end of the scroll range.\n                isCritical = (newMaxY - me._scrollTop < clientHeight * 2) ||\n                    // Or if we have scrolled pass visual height\n                    (me._verticalScrollHeight && (me._verticalScrollHeight - clientHeight < me._scrollTop));\n            // Update the true scroll range using the scroller. This will not cause a repaint.\n            scroller.scrollHeight = me.virtualScrollHeight = height;\n            // If we are scrolling, put this off because it causes\n            // a full document layout and paint.\n            // Do not buffer calls for not yet painted grid\n            if (me.isPainted && (me.scrolling && !isCritical || delta < 100) && !immediate) {\n                me.bufferedFixElementHeights();\n            }\n            else {\n                me.virtualScrollHeightDirty && me.virtualScrollHeightDirty();\n                me.bufferedFixElementHeights.cancel();\n                me.fixElementHeights();\n            }\n        }\n    }\n    fixElementHeights() {\n        const\n            me         = this,\n            height     = me.virtualScrollHeight,\n            heightInPx = `${height}px`;\n        me._verticalScrollHeight         = height;\n        me.verticalScroller.style.height = heightInPx;\n        me.virtualScrollHeightDirty      = false;\n        if (me.autoHeight) {\n            me.bodyContainer.style.height = heightInPx;\n            me._bodyHeight                = height;\n            me.refreshBodyRectangle();\n        }\n        me.refreshVirtualScrollbars();\n    }\n    refreshBodyRectangle() {\n        return this._bodyRectangle = Rectangle.client(this.bodyContainer);\n    }\n    //endregion\n    //region Scroll & virtual rendering\n    set scrolling(scrolling) {\n        this._scrolling = scrolling;\n    }\n    get scrolling() {\n        return this._scrolling;\n    }\n    /**\n     * Activates automatic scrolling of a subGrid when mouse is moved closed to the edges. Useful when dragging DOM\n     * nodes from outside this grid and dropping on the grid.\n     * @param {Grid.view.SubGrid|String|Grid.view.SubGrid[]|String[]} subGrid A subGrid instance or its region name or\n     * an array of either\n     * @category Scrolling\n     */\n    enableScrollingCloseToEdges(subGrids) {\n        this.scrollManager.startMonitoring({\n            scrollables : [\n                {\n                    element   : this.scrollable.element,\n                    direction : 'vertical'\n                },\n                ...ArrayHelper.asArray(subGrids || []).map(subGrid => (\n                    { element : (typeof subGrid === 'string' ? this.subGrids[subGrid] : subGrid).scrollable.element }\n                ))\n            ],\n            direction : 'horizontal'\n        });\n    }\n    /**\n     * Deactivates automatic scrolling of a subGrid when mouse is moved closed to the edges\n     * @param {Grid.view.SubGrid|String|Grid.view.SubGrid[]|String[]} subGrid A subGrid instance or its region name or\n     * an array of either\n     * @category Scrolling\n     */\n    disableScrollingCloseToEdges(subGrids) {\n        this.scrollManager.stopMonitoring([\n            this.scrollable.element,\n            ...ArrayHelper.asArray(subGrids || []).map(subGrid => (typeof subGrid === 'string' ? this.subGrids[subGrid] : subGrid).element)\n        ]);\n    }\n    /**\n     * Responds to request from RowManager to adjust scroll position. Happens when jumping to a scroll position with\n     * variable row height.\n     * @param {Number} bottomMostRowY\n     * @private\n     * @category Scrolling\n     */\n    onRowManagerRequestScrollChange({ bottom }) {\n        this.scrollable.y = bottom - this.bodyHeight;\n    }\n    /**\n     * Scroll syncing for normal headers & grid + triggers virtual rendering for vertical scroll\n     * @private\n     * @fires scroll\n     * @category Scrolling\n     */\n    initScroll() {\n        const\n            me             = this,\n            { scrollable } = me;\n        // This method may be called early, before render calls it, so ensure that it's\n        // only executed once.\n        if (!me.scrollInitialized) {\n            me.scrollInitialized = true;\n            // Allows FF to dynamically track scrollbar state change by reacting to content height changes.\n            // Remove when https://bugzilla.mozilla.org/show_bug.cgi?id=1733042 is fixed\n            scrollable.contentElement = me.contentElement;\n            scrollable.ion({\n                scroll    : 'onGridVerticalScroll',\n                scrollend : 'onGridVerticalScrollEnd',\n                thisObj   : me\n            });\n            me.callEachSubGrid('initScroll');\n            // Fixes scroll freezing bug on iPad by putting scroller in its own layer\n            if (BrowserHelper.isMobileSafari) {\n                scrollable.element.style.transform = 'translate3d(0, 0, 0)';\n            }\n        }\n    }\n    onGridVerticalScroll({ source : scrollable }) {\n        const\n            me                = this,\n            { y : scrollTop } = scrollable;\n        // Was getting scroll events in FF where scrollTop was unchanged, ignore those\n        if (scrollTop !== me._scrollTop) {\n            me._scrollTop = scrollTop;\n            if (!me.scrolling) {\n                me.scrolling = true;\n                // Vertical scroll may trigger resize if row height is variable\n                me.eachSubGrid(s => s.suspendResizeMonitor = true);\n            }\n            me.rowManager.updateRenderedRows(scrollTop);\n            // Hook for features that need to react to scroll\n            me.afterScroll({ scrollTop });\n            /**\n             * Grid has scrolled vertically\n             * @event scroll\n             * @param {Grid.view.Grid} source The firing Grid instance.\n             * @param {Number} scrollTop The vertical scroll position.\n             */\n            me.trigger('scroll', { scrollTop });\n        }\n    }\n    onGridVerticalScrollEnd() {\n        this.scrolling = false;\n        this.eachSubGrid(s => s.suspendResizeMonitor = false);\n    }\n    /**\n     * Scrolls a row into view. If row isn't rendered it tries to calculate position. Accepts the {@link BryntumScrollOptions}\n     * `column` property\n     * @param {Core.data.Model|String|Number} recordOrId Record or record id\n     * @param {BryntumScrollOptions} [options] How to scroll.\n     * @returns {Promise} A promise which resolves when the specified row has been scrolled into view.\n     * @category Scrolling\n     */\n    async scrollRowIntoView(recordOrId, options = defaultScrollOptions) {\n        const\n            me             = this,\n            blockPosition  = options.block || 'nearest',\n            { rowManager } = me,\n            record         = me.store.getById(recordOrId);\n        if (record) {\n            let scrollPromise;\n            // check that record is \"displayable\", not filtered out or hidden by collapse\n            if (me.store.indexOf(record) === -1) {\n                return resolvedPromise;\n            }\n            let scroller   = me.scrollable,\n                recordRect = me.getRecordCoords(record);\n            const scrollerRect = Rectangle.from(scroller.element);\n            // If it was calculated from the index, update the rendered rowScrollMode\n            // and scroll to the actual element. Note that this should only be necessary\n            // for variableRowHeight.\n            // But to \"make the tests green\", this is a workaround for a buffered rendering\n            // bug when teleporting scroll. It does not render the rows at their correct\n            // positions. Please do not try to \"fix\" this. I will do it. NGW\n            if (recordRect.virtual) {\n                const\n                    virtualBlock = recordRect.block,\n                    innerOptions = blockPosition !== 'nearest' ? options : {\n                        block : virtualBlock\n                    };\n                // Scroll the calculated position **synchronously** to the center of the scrollingViewport\n                // and then update the rendered block while asking the RowManager to\n                // display the required recordOrId.\n                scrollPromise = scroller.scrollIntoView(recordRect, {\n                    block : 'center'\n                });\n                rowManager.scrollTargetRecordId = record;\n                rowManager.updateRenderedRows(scroller.y, true);\n                recordRect               = me.getRecordCoords(record);\n                rowManager.lastScrollTop = scroller.y;\n                if (recordRect.virtual) {\n                    // bail out to not get caught in infinite loop, since code above is cut out of bundle\n                    return resolvedPromise;\n                }\n                // Scroll the target just less than append/prepend buffer height out of view so that the animation looks good\n                if (options.animate) {\n                    // Do not fire scroll events during this scroll sequence - it's a purely cosmetic operation.\n                    // We are scrolling the desired row out of view merely to *animate scroll* it to the requested position.\n                    scroller.suspendEvents();\n                    // Scroll to its final position\n                    if (blockPosition === 'end' || blockPosition === 'nearest' && virtualBlock === 'end') {\n                        scroller.y -= (scrollerRect.bottom - recordRect.bottom);\n                    }\n                    else if (blockPosition === 'start' || blockPosition === 'nearest' && virtualBlock === 'start') {\n                        scroller.y += (recordRect.y - scrollerRect.y);\n                    }\n                    // Ensure rendered block is correct at that position\n                    rowManager.updateRenderedRows(scroller.y, false, true);\n                    // Scroll away from final position to enable a cosmetic scroll to final position\n                    if (virtualBlock === 'end') {\n                        scroller.y -= (rowManager.appendRowBuffer * rowManager.rowHeight - 1);\n                    }\n                    else {\n                        scroller.y += (rowManager.prependRowBuffer * rowManager.rowHeight - 1);\n                    }\n                    // Now we're at the required position, resume events\n                    scroller.resumeEvents();\n                    // The row will still be rendered, so scroll it using the scroller directly\n                    await scroller.scrollIntoView(me.getRecordCoords(record), Object.assign({}, options, innerOptions));\n                }\n                else {\n                    if (!options.recursive) {\n                        await scrollPromise;\n                    }\n                    // May already be destroyed at this point, hence ?.\n                    await me.scrollRowIntoView?.(record, Object.assign({ recursive : true }, options, innerOptions));\n                }\n            }\n            else {\n                let { column } = options;\n                if (column) {\n                    if (!column.isModel) {\n                        column = me.columns.getById(column) || me.columns.get(column);\n                    }\n                    // If we are targeting a column, we must use the scroller of that column's SubGrid\n                    if (column) {\n                        scroller = me.getSubGridFromColumn(column).scrollable;\n                        const cellRect = Rectangle.from(rowManager.getRowFor(record).getCell(column.id));\n                        recordRect.x     = cellRect.x;\n                        recordRect.width = cellRect.width;\n                    }\n                }\n                // No column, then tell the scroller not to scroll in the X axis (without polluting the passed options)\n                else {\n                    options = ObjectHelper.assign({}, options, { x : false });\n                }\n                await scroller.scrollIntoView(recordRect, options);\n            }\n        }\n    }\n    /**\n     * Scrolls a column into view (if it is not already)\n     * @param {Grid.column.Column|String|Number} column Column name (data) or column index or actual column object.\n     * @param {BryntumScrollOptions} [options] How to scroll.\n     * @returns {Promise} If the column exists, a promise which is resolved when the column header element has been\n     * scrolled into view.\n     * @category Scrolling\n     */\n    scrollColumnIntoView(column, options) {\n        column = (column instanceof Column) ? column : this.columns.get(column) || this.columns.getById(column) || this.columns.getAt(column);\n        return this.getSubGridFromColumn(column).scrollColumnIntoView(column, options);\n    }\n    /**\n     * Scrolls a cell into view (if it is not already)\n     * @param {Object} cellContext Cell selector { id: recordId, column: 'columnName' }\n     * @category Scrolling\n     */\n    scrollCellIntoView(cellContext, options) {\n        return this.scrollRowIntoView(cellContext.id, Object.assign({\n            column : cellContext.columnId\n        }, typeof options === 'boolean' ? { animate : options } : options));\n    }\n    /**\n     * Scroll all the way down\n     * @returns {Promise} A promise which resolves when the bottom is reached.\n     * @category Scrolling\n     */\n    scrollToBottom(options) {\n        // triggers scroll to last record. not using current scroller height because we do not know if it is correct\n        return this.scrollRowIntoView(this.store.last, options);\n    }\n    /**\n     * Scroll all the way up\n     * @returns {Promise} A promise which resolves when the top is reached.\n     * @category Scrolling\n     */\n    scrollToTop(options) {\n        return this.scrollable.scrollBy(0, -this.scrollable.y, options);\n    }\n    /**\n     * Stores the scroll state. Returns an objects with a `scrollTop` number value for the entire grid and a `scrollLeft`\n     * object containing a left position scroll value per sub grid.\n     * @returns {Object}\n     * @category Scrolling\n     */\n    storeScroll() {\n        const\n            me    = this,\n            state = me.storedScrollState = {\n                scrollTop  : me.scrollable.y,\n                scrollLeft : {}\n            };\n        me.eachSubGrid(subGrid => {\n            state.scrollLeft[subGrid.region] = subGrid.scrollable.x;\n        });\n        return state;\n    }\n    /**\n     * Restore scroll state. If state is not specified, restores the last stored state.\n     * @param {Object} [state] Scroll state, optional\n     * @category Scrolling\n     */\n    restoreScroll(state = this.storedScrollState) {\n        const me = this;\n        me.eachSubGrid(subGrid => {\n            const x = state.scrollLeft[subGrid.region];\n            // Force scrollable to set its position to the underlying element in case it was removed and added back to\n            // the DOM prior to restoring state\n            if (x != null) {\n                subGrid.scrollable.updateX(x);\n                subGrid.header.scrollable.updateX(x);\n                subGrid.footer.scrollable.updateX(x);\n                subGrid.fakeScroller?.updateX(x);\n            }\n        });\n        me.scrollable.updateY(state.scrollTop);\n    }\n    //endregion\n    //region Theme & measuring\n    beginGridMeasuring() {\n        const me = this;\n        if (!me.$measureCellElements) {\n            me.$measureCellElements = DomHelper.createElement({\n                // For row height measuring, features are not yet there. Work around that for the stripe feature,\n                // which removes borders\n                className : 'b-grid-subgrid ' + (!me._isRowMeasured && me.hasFeature('stripe') ? 'b-stripe' : ''),\n                reference : 'subGridElement',\n                style     : {\n                    position   : 'absolute',\n                    top        : '-10000px',\n                    left       : '-100000px',\n                    visibility : 'hidden',\n                    contain    : 'strict'\n                },\n                children : [\n                    {\n                        className : 'b-grid-row',\n                        reference : 'rowElement',\n                        children  : [\n                            {\n                                className : 'b-grid-cell',\n                                reference : 'cellElement',\n                                style     : {\n                                    width   : 'auto',\n                                    contain : BrowserHelper.isFirefox ? 'layout paint' : 'layout style paint'\n                                }\n                            }\n                        ]\n                    }\n                ]\n            });\n        }\n        // Bring element into life if we get here early, to be able to access verticalScroller below\n        me.getConfig('element');\n        // Temporarily add to where subgrids live, to get have all CSS classes in play\n        me.verticalScroller.appendChild(me.$measureCellElements.subGridElement);\n        // Not yet on page, which prevents us from getting style values. Add it to the DOM temporarily\n        if (!me.rendered) {\n            const\n                targetEl    = me.appendTo || me.insertBefore || document.body,\n                rootElement = DomHelper.getRootElement(typeof targetEl === 'string' ? document.getElementById(targetEl) : targetEl) || document.body;\n            if (!me.adopt || !rootElement.contains(me.element)) {\n                rootElement.appendChild(me.element);\n                me.$removeAfterMeasuring = true;\n            }\n        }\n        return me.$measureCellElements;\n    }\n    endGridMeasuring() {\n        // Remove grid from DOM if it was added for measuring\n        if (this.$removeAfterMeasuring) {\n            this.element.remove();\n            this.$removeAfterMeasuring = false;\n        }\n        // Remove measuring elements from grid\n        this.$measureCellElements.subGridElement.remove();\n    }\n    /**\n     * Creates a fake subgrid with one row and measures its height. Result is used as rowHeight.\n     * @private\n     */\n    measureRowHeight() {\n        const\n            me             = this,\n            // Create a fake subgrid with one row, since styling for row is specified on .b-grid-subgrid .b-grid-row\n            { rowElement } = me.beginGridMeasuring(),\n            // Use style height or default height from config.\n            // Not using clientHeight since it will have some value even if no height specified in CSS\n            styles         = DomHelper.getStyleValue(rowElement, ['height', 'border-top-width', 'border-bottom-width']),\n            styleHeight    = parseInt(styles.height),\n            // FF reports border width adjusted to device pixel ration, e.g. on a 150% scaling it would tell 0.6667px width\n            // for a 1px border. Dividing by the integer part to take base devicePixelRatio into account\n            multiplier     = BrowserHelper.isFirefox ? globalThis.devicePixelRatio / Math.max(Math.trunc(globalThis.devicePixelRatio), 1) : 1,\n            borderTop      = styles['border-top-width'] ? Math.round(multiplier * parseFloat(styles['border-top-width'])) : 0,\n            borderBottom   = styles['border-bottom-width'] ? Math.round(multiplier * parseFloat(styles['border-bottom-width'])) : 0;\n        // Change rowHeight if specified in styling, also remember that value to replace later if theme changes and\n        // user has not explicitly set some other height\n        if (me.rowHeight == null || me.rowHeight === me._rowHeightFromStyle) {\n            me.rowHeight           = !isNaN(styleHeight) && styleHeight ? styleHeight : me.defaultRowHeight;\n            me._rowHeightFromStyle = me.rowHeight;\n        }\n        // this measurement will be added to rowHeight during rendering, to get correct cell height\n        me._rowBorderHeight = borderTop + borderBottom;\n        me._isRowMeasured = true;\n        me.endGridMeasuring();\n        // There is a ticket about measuring the actual first row instead:\n        // https://app.assembla.com/spaces/bryntum/tickets/5735-measure-first-real-rendered-row-for-rowheight/details\n    }\n    /**\n     * Handler for global theme change event (triggered by shared.js). Remeasures row height.\n     * @private\n     */\n    onThemeChange({ theme }) {\n        // Can only measure when we are visible, so do it next time we are.\n        this.whenVisible('measureRowHeight');\n        this.trigger('theme', { theme });\n    }\n    //endregion\n    //region Rendering of rows\n    /**\n     * Triggers a render of records to all row elements. Call after changing order, grouping etc. to reflect changes\n     * visually. Preserves scroll.\n     * @category Rendering\n     */\n    refreshRows(returnToTop = false) {\n        const { element, rowManager } = this;\n        element.classList.add('b-notransition');\n        if (returnToTop) {\n            rowManager.returnToTop();\n        }\n        else {\n            // Force refreshing even if we had no rows previously\n            rowManager.refresh(true);\n        }\n        element.classList.remove('b-notransition');\n    }\n    /**\n     * Triggers a render of all the cells in a column.\n     * @param {Grid.column.Column} column\n     * @category Rendering\n     */\n    refreshColumn(column) {\n        if (column.isVisible) {\n            if (column.isLeaf) {\n                this.rowManager.forEach(row => row.renderCell(row.getCell(column.id)));\n            }\n            else {\n                column.children.forEach(child => this.refreshColumn(child));\n            }\n        }\n    }\n    //endregion\n    //region Render the grid\n    /**\n     * Recalculates virtual scrollbars widths and scrollWidth\n     * @private\n     */\n    refreshVirtualScrollbars() {\n        // NOTE: This was at some point changed to only run on platforms with width-occupying scrollbars, but it needs\n        // to run with overlayed scrollbars also to make them show/hide as they should.\n        const\n            me                        = this,\n            {\n                headerContainer,\n                footerContainer,\n                virtualScrollers,\n                scrollable,\n                hasVerticalOverflow\n            }                         = me,\n            { classList }             = virtualScrollers,\n            hadHorizontalOverflow     = !classList.contains('b-hide-display'),\n            // We need to ask each subGrid if it has horizontal overflow.\n            // If any do, we show the virtual scroller, otherwise we hide it.\n            hasHorizontalOverflow     = Object.values(me.subGrids).some(subGrid => subGrid.overflowingHorizontally),\n            horizontalOverflowChanged = hasHorizontalOverflow !== hadHorizontalOverflow;\n        // If horizontal overflow state changed, the docked horizontal scrollbar's visibility\n        //  must be synced to match, and this may cause a height change;\n        if (horizontalOverflowChanged) {\n            virtualScrollers.classList.toggle('b-hide-display', !hasHorizontalOverflow);\n        }\n        // Auto-widthed padding element at end hides or shows to create matching margin.\n        if (DomHelper.scrollBarWidth) {\n            // Header will need its extra padding if we have overflow, *OR* if we are overflowY : scroll\n            const needsPadding = hasVerticalOverflow || scrollable.overflowY === 'scroll';\n            headerContainer.classList.toggle('b-show-yscroll-padding', needsPadding);\n            footerContainer.classList.toggle('b-show-yscroll-padding', needsPadding);\n            virtualScrollers.classList.toggle('b-show-yscroll-padding', needsPadding);\n            // Do any measuring necessitated by show/hide of the docked horizontal scrollbar\n            /// *after* mutating DOM classnames.\n            if (horizontalOverflowChanged) {\n                // If any subgrids reported they have horizontal overflow, then we have to ask them\n                // to sync the widths of the scroll elements inside the docked horizontal scrollbar\n                // so that it takes up the required scrollbar width at the bottom of our body element.\n                if (hasHorizontalOverflow) {\n                    me.callEachSubGrid('refreshFakeScroll');\n                }\n                me.onHeightChange();\n            }\n        }\n    }\n    get hasVerticalOverflow() {\n        return this.scrollable.hasOverflow('y');\n    }\n    /**\n     * Returns content height calculated from row manager\n     * @private\n     */\n    get contentHeight() {\n        const rowManager = this.rowManager;\n        return Math.max(rowManager.totalHeight, rowManager.bottomRow ? rowManager.bottomRow.bottom : 0);\n    }\n    onContentChange() {\n        const\n            me         = this,\n            rowManager = me.rowManager;\n        if (me.isVisible) {\n            rowManager.estimateTotalHeight();\n            me.paintListener = null;\n            me.refreshTotalHeight(me.contentHeight);\n            me.callEachSubGrid('refreshFakeScroll');\n            me.onHeightChange();\n        }\n        // If not visible, this operation MUST be done when we become visible.\n        // This is announced by the paint event which is triggered when a Widget\n        // really gains visibility, ie is shown or rendered, or it's not hidden,\n        // and a hidden/non-rendered ancestor is shown or rendered.\n        // See Widget#triggerPaint.\n        else if (!me.paintListener) {\n            me.paintListener = me.ion({\n                paint   : 'onContentChange',\n                once    : true,\n                thisObj : me\n            });\n        }\n    }\n    triggerPaint() {\n        if (!this.isPainted) {\n            this.refreshBodyRectangle();\n        }\n        super.triggerPaint();\n    }\n    onHeightChange() {\n        const me = this;\n        // cache to avoid recalculations in the middle of rendering code (RowManger#getRecordCoords())\n        me.refreshBodyRectangle();\n        me._bodyHeight = me.autoHeight ? me.contentHeight : me.bodyContainer.offsetHeight;\n    }\n    suspendRefresh() {\n        this.refreshSuspended++;\n    }\n    resumeRefresh(trigger) {\n        if (this.refreshSuspended && !--this.refreshSuspended) {\n            if (trigger) {\n                this.refreshRows();\n            }\n            this.trigger('resumeRefresh', { trigger });\n        }\n    }\n    /**\n     * Rerenders all grid rows, completely replacing all row elements with new ones\n     * @category Rendering\n     */\n    renderRows(keepScroll = true) {\n        const\n            me          = this,\n            scrollState = keepScroll && me.storeScroll();\n        if (me.refreshSuspended) {\n            return;\n        }\n        /**\n         * Grid rows are about to be rendered\n         * @event beforeRenderRows\n         * @param {Grid.view.Grid} source This grid.\n         */\n        me.trigger('beforeRenderRows');\n        me.renderingRows = true;\n        // This allows us to do things like disable animations on a refresh\n        me.element.classList.add('b-grid-refreshing');\n        if (!keepScroll) {\n            me.scrollable.y = me._scrollTop = 0;\n        }\n        me.rowManager.reinitialize(!keepScroll);\n        /**\n         * Grid rows have been rendered\n         * @event renderRows\n         * @param {Grid.view.Grid} source This grid.\n         */\n        me.trigger('renderRows');\n        me.renderingRows = false;\n        me.onContentChange();\n        if (keepScroll) {\n            me.restoreScroll(scrollState);\n        }\n        me.element.classList.remove('b-grid-refreshing');\n    }\n    /**\n     * Rerenders the grids rows, headers and footers, completely replacing all row elements with new ones\n     * @category Rendering\n     */\n    renderContents() {\n        const\n            me                                                        = this,\n            { element, headerContainer, footerContainer, rowManager } = me;\n        me.emptyCache();\n        // columns will be \"drawn\" on render anyway, bail out\n        if (me.isPainted) {\n            // reset measured header height, to make next call to get headerHeight measure it\n            me._headerHeight = null;\n            me.callEachSubGrid('refreshHeader');\n            me.callEachSubGrid('refreshFooter');\n            // Note that these are hook methods for features to plug in to. They do not do anything.\n            me.renderHeader(headerContainer, element);\n            me.renderFooter(footerContainer, element);\n            me.fixSizes();\n            // any elements currently used for rows should be released.\n            // actual removal of elements is done in SubGrid#clearRows\n            const refreshContext = rowManager.removeAllRows();\n            rowManager.calculateRowCount(false, true, true);\n            if (rowManager.rowCount) {\n                // Sets up the RowManager's position for when renderRows calls RowManager#reinitialize\n                // so that it renders the correct data block at the correct position.\n                rowManager.setPosition(refreshContext);\n                me.renderRows();\n            }\n        }\n    }\n    /**\n     * Rerenders all grid headers\n     * @category Rendering\n     */\n    refreshHeaders() {\n        this.callEachSubGrid('refreshHeader');\n    }\n    /**\n     * Rerender a single grid header\n     * @param {Grid.column.Column} column The column to refresh\n     * @category Rendering\n     */\n    refreshHeader(column) {\n        column.subGrid.refreshHeader();\n    }\n    onPaintOverride() {\n        // Internal procedure used for paint method overrides\n        // Not used in onInternalPaint() because it may be chained on instance and Override won't be applied\n    }\n    // Render rows etc. on first paint, to make sure Grids element has been laid out\n    onInternalPaint({ firstPaint }) {\n        const me = this;\n        me.ariaElement.setAttribute('aria-rowcount', me.store.count + 1);\n        super.onInternalPaint?.(...arguments);\n        if (me.onPaintOverride() || !firstPaint) {\n            return;\n        }\n        const\n            {\n                rowManager,\n                store,\n                element,\n                headerContainer,\n                bodyContainer,\n                footerContainer\n            }         = me,\n            scrollPad = DomHelper.scrollBarPadElement;\n        let columnsChanged,\n            maxDepth = 0;\n        // ARIA. Update our ariaElement that encapsulates all rows.\n        // The header is counted as a row, and column headers are cells.\n        me.role = store?.isTree ? 'treegrid' : 'grid';\n        // See if updateResponsive changed any columns.\n        me.columns.ion({\n            change : () => columnsChanged = true,\n            once   : true\n        });\n        // Apply any responsive configs before rendering rows.\n        me.updateResponsive(me.width, 0);\n        // If there were any column changes, apply them\n        if (columnsChanged) {\n            me.callEachSubGrid('refreshHeader', headerContainer);\n            me.callEachSubGrid('refreshFooter', footerContainer);\n        }\n        // Note that these are hook methods for features to plug in to. They do not do anything.\n        // SubGrids take care of their own rendering.\n        me.renderHeader(headerContainer, element);\n        me.renderFooter(footerContainer, element);\n        // These padding elements are only visible on scrollbar showing platforms.\n        // And then, only when the owning element as the b-show-yscroll-padding class added.\n        // See refreshVirtualScrollbars where this is synced on the header, footer and scroller elements.\n        DomHelper.append(headerContainer, scrollPad);\n        DomHelper.append(footerContainer, scrollPad);\n        DomHelper.append(me.virtualScrollers, scrollPad);\n        // Cached, updated on resize. Used by RowManager and by the subgrids upon their render.\n        // Measure after header and footer have been rendered and taken their height share.\n        me.refreshBodyRectangle();\n        const bodyOffsetHeight = me.bodyContainer.offsetHeight;\n        if (me.autoHeight) {\n            me._bodyHeight             = rowManager.initWithHeight(element.offsetHeight - headerContainer.offsetHeight - footerContainer.offsetHeight, true);\n            bodyContainer.style.height = me.bodyHeight + 'px';\n        }\n        else {\n            me._bodyHeight = bodyOffsetHeight;\n            rowManager.initWithHeight(me._bodyHeight, true);\n        }\n        me.eachSubGrid(subGrid => {\n            if (subGrid.header.maxDepth > maxDepth) {\n                maxDepth = subGrid.header.maxDepth;\n            }\n        });\n        headerContainer.dataset.maxDepth = maxDepth;\n        me.fixSizes();\n        if (store.count || !store.isLoading) {\n            me.renderRows();\n        }\n        // With autoHeight cells we need to refresh rows when fonts are loaded, to get correct measurements\n        if (me.columns.usesAutoHeight) {\n            const { fonts } = document;\n            if (fonts?.status !== 'loaded') {\n                fonts.ready.then(() => !me.isDestroyed && me.refreshRows());\n            }\n        }\n        me.initScroll();\n        me.initInternalEvents();\n    }\n    render() {\n        const me = this;\n        // When displayed inside one of our containers, require a size to be considered visible. Ensures it is painted\n        // on display when for example in a tab\n        me.requireSize = Boolean(me.owner);\n        // Render as a container. This renders the child SubGrids\n        super.render(...arguments);\n        me.setupFocusListeners();\n        if (!me.autoHeight) {\n            // Sanity check that main element has been given some sizing styles, unless autoHeight is used in which case\n            // it will be sized programmatically instead\n            if (me.headerContainer.offsetHeight && !me.bodyContainer.offsetHeight) {\n                console.warn('Grid element not sized correctly, please check your CSS styles and review how you size the widget');\n            }\n            // Warn if height equals the predefined minHeight, likely that is not what the dev intended\n            if (\n                !me.splitFrom && !me.features.split?.owner && // Don't warn for splits\n                !('minHeight' in me.initialConfig) &&\n                !('height' in me.initialConfig) &&\n                parseInt(globalThis.getComputedStyle(me.element).minHeight) === me.height\n            ) {\n                console.warn(\n                    `The ${me.$$name} is sized by its predefined minHeight, likely this is not intended. ` +\n                    `Please check your CSS and review how you size the widget, or assign a fixed height in the config. ` +\n                    `For more information, see the \"Basics/Sizing the component\" guide in docs.`\n                );\n            }\n        }\n    }\n    //endregion\n    //region Hooks\n    /**\n     * Called after headers have been rendered to the headerContainer.\n     * This does not do anything, it's just for Features to hook in to.\n     * @param {HTMLElement} headerContainer DOM element which contains the headers.\n     * @param {HTMLElement} element Grid element\n     * @private\n     * @category Rendering\n     */\n    renderHeader(headerContainer, element) {}\n    /**\n     * Called after footers have been rendered to the footerContainer.\n     * This does not do anything, it's just for Features to hook in to.\n     * @param {HTMLElement} footerContainer DOM element which contains the footers.\n     * @param {HTMLElement} element Grid element\n     * @private\n     * @category Rendering\n     */\n    renderFooter(footerContainer, element) {}\n    // Hook for features to affect cell rendering before renderers are run\n    beforeRenderCell() {}\n    // Hooks for features to react to a row being rendered\n    beforeRenderRow() {}\n    afterRenderRow() {}\n    // Hook for features to react to scroll\n    afterScroll() {}\n    // Hook that can be overridden to prepare custom editors, can be used by framework wrappers\n    processCellEditor(editorConfig) {}\n    // Hook for features to react to column changes\n    afterColumnsChange() {}\n    // Hook for features to react to record removal (which might be transitioned)\n    afterRemove(removeEvent) {}\n    // Hook for features to react to groups being collapsed/expanded\n    afterToggleGroup() {}\n    // Hook for features to react to subgrid being collapsed\n    afterToggleSubGrid() {}\n    // Hook into Base, to trigger another hook for features to hook into :)\n    // If features hook directly into this, it will be called both for Grid's changes + feature's changes,\n    // since they also extend Base.\n    onConfigChange(info) {\n        super.onConfigChange(info);\n        if (!this.isConfiguring) {\n            this.afterConfigChange(info);\n        }\n    }\n    afterConfigChange(info) {}\n    afterAddListener(eventName, listener) {}\n    afterRemoveListener(eventName, listener) {}\n    //endregion\n    //region Masking and Appearance\n    syncMaskCover(mask = this.masked) {\n        if (mask) {\n            const\n                bodyRect     = (mask.cover === 'body') && this.rectangleOf('bodyContainer'),\n                scrollerRect = bodyRect && this.rectangleOf('virtualScrollers'),\n                { style }    = mask.element;\n            // the width of the bodyCt covers the vscroll but the height does not cover the hscroll:\n            style.marginTop = bodyRect ? `${bodyRect.y}px` : '';\n            style.height    = bodyRect ? `${bodyRect.height + (scrollerRect?.height || 0)}px` : '';\n        }\n    }\n    /**\n     * Show a load mask with a spinner and the specified message. When using an AjaxStore masking and unmasking is\n     * handled automatically, but if you are loading data in other ways you can call this function manually when your\n     * load starts.\n     * ```\n     * myLoadFunction() {\n     *   // Show mask before initiating loading\n     *   grid.maskBody('Loading data');\n     *   // Your custom loading code\n     *   load.then(() => {\n     *      // Hide the mask when loading is finished\n     *      grid.unmaskBody();\n     *   });\n     * }\n     * ```\n     * @param {String|MaskConfig} loadMask The message to show in the load mask (next to the spinner) or a config object\n     * for a {@link Core.widget.Mask}.\n     * @returns {Core.widget.Mask}\n     * @category Misc\n     */\n    maskBody(loadMask) {\n        let ret;\n        if (this.bodyContainer) {\n            this.masked = Mask.mergeConfigs(this.loadMaskDefaults, loadMask);  // smart setter\n            ret         = this.masked;  // read back\n        }\n        return ret;\n    }\n    /**\n     * Hide the load mask.\n     * @category Misc\n     */\n    unmaskBody() {\n        this.masked = null;\n    }\n    updateEmptyText(emptyText) {\n        this.emptyTextEl?.remove();\n        // Grid might be created without subgrids, will add element to first when it is added\n        this.emptyTextEl = DomHelper.createElement({\n            parent                                       : this.firstItem?.element,\n            className                                    : 'b-empty-text',\n            [emptyText?.includes('<') ? 'html' : 'text'] : emptyText\n        });\n    }\n    toggleEmptyText() {\n        const { bodyContainer, store } = this;\n        bodyContainer?.classList.toggle('b-grid-empty', !(store.count > 0 || store.isLoading || store.isCommitting));\n    }\n    // Notify columns when our read-only state is toggled\n    updateReadOnly(readOnly, old) {\n        super.updateReadOnly(readOnly, old);\n        if (!this.isConfiguring) {\n            for (const column of this.columns.bottomColumns) {\n                column.updateReadOnly?.(readOnly);\n            }\n        }\n    }\n    //endregion\n    //region Extract config\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    // It extracts the current configs for the grid, with special handling for inline data\n    getCurrentConfig(options) {\n        const\n            result     = super.getCurrentConfig(options),\n            { store }  = this,\n            // Clean up inline data to not have group records in it\n            data       = store.getInlineData(options),\n            // Get stores current state, in case it has filters etc. added at runtime\n            storeState = store.getCurrentConfig(options) || result.store;\n        if (data.length) {\n            result.data = data;\n        }\n        // Don't include the default model class\n        if (storeState && store.originalModelClass === GridRowModel) {\n            delete storeState.modelClass;\n        }\n        if (!ObjectHelper.isEmpty(storeState)) {\n            result.store = storeState;\n        }\n        if (result.store) {\n            delete result.store.data;\n        }\n        return result;\n    }\n    //endregion\n}\n// Register this widget type with its Factory\nGridBase.initClass();\nVersionHelper.setVersion('grid', '5.6.2');\nGridBase._$name = 'GridBase';"],
  "mappings": "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",
  "names": ["Location", "_Location", "location", "grid", "Widget", "cell", "dataset", "config", "_a", "_b", "me", "store", "columns", "visibleColumns", "rowIndex", "columnIndex", "other", "shallow", "_id", "rowManager", "where", "record", "column", "result", "rowMin", "rowMax", "colMax", "atFirstRow", "atLastRow", "atFirstColumn", "atLastColumn", "id", "_cell", "row", "_target", "focusableFinder", "activeEl", "DomHelper", "validWidth", "value", "_Column", "Model", "Events_default", "Localizable_default", "data", "sorter", "filter", "Config", "collapsed", "headerAriaLabel", "cellAriaLabel", "_c", "widgets", "headerWidgetMap", "widget", "classes", "c", "columnAutoCls", "cellContext", "cellCls", "internalCellCls", "constructor", "align", "autoCls", "isEditing", "locked", "region", "sortable", "groupable", "editor", "ObjectHelper", "StringHelper", "owner", "subGrid", "prev", "next", "s", "silent", "hidingParent", "parent", "child", "forceVisible", "force", "childColumn", "firstChild", "collapsible", "headerWidgets", "pressed", "index", "w", "width", "minWidth", "flex", "minChildWidth", "widthMin", "widthMax", "batch", "element", "fitMode", "count", "rowElement", "cellElement", "maxWidth", "start", "end", "i", "length", "longest", "style", "headerText", "state", "focusedCell", "isEditable", "before", "col", "options", "__publicField", "Column", "columnDefinitions", "lockedColumnSorters", "ColumnStore", "_ColumnStore", "Store", "allColumns", "fn", "thisObj", "n", "childCol", "action", "changes", "event", "columnOrId", "wrap", "idx", "field", "dataField", "columnClass", "Objects", "fieldDefinition", "recordOrId", "rawData", "r", "simpleRenderer", "type", "defaults", "columnResizeEvent", "handler", "WidgetColumn", "readOnly", "renderData", "isExport", "widgetCfg", "widgetNextSibling", "WidgetHelper", "userAction", "valueProperty", "CheckColumn", "modelClass", "headerElement", "returnValue", "Checkbox", "checked", "source", "checkbox", "RowNumberColumn", "initial", "isMove", "cellPadding", "f", "CopyPasteBase", "InstancePlugin", "Clipboardable_default", "cells", "lastRowIndex", "lastColIndex", "stringData", "c1", "c2", "cellValue", "DateHelper", "clipboardData", "createNewRecords", "fields", "client", "_shiftSelectRange", "modifiedRecords", "rows", "selectedCell", "targetCells", "affectedCells", "cellRows", "curI", "curX", "targetCell", "rI", "targetRecord", "cI", "targetColumn", "targetField", "parsedDate", "locations", "rId", "string", "stringRows", "consumerToFeatureMap", "consumerToDefaultFeatureMap", "DEFAULT_FOR_TYPE", "remapToBase", "classNameFix", "GridFeatureManager", "featureClass", "onByDefault", "forType", "as", "consumerFeaturesMap", "consumerDefaultFeaturesMap", "features", "instance", "typeName", "typeChain", "len", "editingActions", "allActions", "CellEdit", "Delayable_default", "Editor", "gridListeners", "MessageDialog_default", "disable", "disabled", "columnId", "editorClass", "cellEditor", "leftOffset", "editorContext", "inputField", "GlobalEvents_default", "context", "relationName", "muteEvents", "cellInfo", "isForward", "rowId", "newRecordConfig", "addToCurrentParent", "triggeredByEvent", "cancelResult", "cellSelector", "target", "actionName", "selected", "previous", "nextCell", "finalizationResult", "key", "isDelete", "gridSelection", "isMultiDelete", "input", "toCell", "isEditableCellClick", "validateTapOut", "blurAction", "CellMenu", "ContextMenuBase", "eventParams", "cellData", "items", "ColumnDragToolbar", "buttons", "groups", "button", "group", "EventHelper", "info", "targetElement", "TemplateHelper", "btn", "BrowserHelper", "ColumnPicker", "columnStore", "createColumnsFromModel", "tags", "tag", "item", "itemEl", "allFields", "fieldName", "subItem", "currentRegion", "visibleInRegion", "itemConfig", "menu", "siblingItems", "hideItem", "lastVisibleItem", "menuItem", "siblingItem", "sibling", "parentItem", "ColumnReorder", "gridEl", "containers", "DragHelper", "ScrollManager", "columnEl", "isLast", "usingGroupBarWidget", "dragProxy", "headerContainerBox", "insertBeforeElement", "insertBefore", "targetHeader", "onHeader", "droppedInRegion", "isReorder", "vetoed", "newParent", "toRegion", "oldParent", "onColumn", "groupNode", "ColumnResize", "ResizeHelper", "liveResize", "resizer", "_GridFieldFilterPicker", "FieldFilterPicker", "newGrid", "allowedFieldNames", "outFields", "text", "filterType", "filterable", "fieldType", "isFilterableField", "isSupportedDurationField", "newFields", "localFields", "VersionHelper", "ArrayHelper", "mergedFields", "GridFieldFilterPicker", "GridFieldFilterPickerGroup", "FieldFilterPickerGroup", "fieldTypeMap", "defaultOperators", "allowedFilterTypes", "filterableFieldDataTypes", "menuItemsWithSeparators", "Filter", "clone", "reRenderRows", "iconElement", "Tooltip", "activeTarget", "columnFilters", "property", "internal", "isColumnFiltered", "headerEl", "textEl", "filterIconEl", "filterText", "bullet", "columnFilter", "_d", "_e", "isArray", "relation", "foreignKey", "relatedDisplayField", "getDisplayValue", "foreignId", "a", "b", "val", "filterConfig", "filterFn", "onlyForOperator", "initialValue", "changeCallback", "closeCallback", "filterField", "onClose", "onClear", "onKeydown", "onChange", "onEsc", "sourceField", "rec", "operator", "forceAddBlank", "legacyMode", "DomClassList", "menuItems", "dataType", "activeOperators", "allowedOperators", "argCount", "isArrayValued", "weight", "submenuItems", "maxArgCount", "isCellMenu", "canRemoveFilter", "rest", "filters", "CollectionFilter", "complexOperators", "FilterBar", "hidden", "prop", "applyFilter", "applyFilters", "externalCls", "hasFilterFieldStoreData", "configuredValue", "refreshData", "$filter", "Duration", "match", "isClearingFilter", "Group", "renderer", "g", "sorters", "groupRecord", "collapse", "skipRender", "domEvent", "oldRecord", "meta", "rowClasses", "persist", "groupRowFor", "groupSummary", "html", "applyDefault", "groupColumn", "isGroupHeaderColumn", "DomSync", "headerContainerElement", "groupInfo", "header", "grouped", "groupers", "curGroupHeaders", "records", "fromRow", "oldGroup", "columnGrouper", "DomDataStore", "HeaderMenu", "icon", "columnToMoveBefore", "columnToMoveAfter", "previousSibling", "nextSibling", "RegionResize", "splitterEl", "splitterElement", "clientX", "nextRegion", "nextSubGrid", "splitterSubGrid", "flip", "availableWidth", "sum", "dragContext", "regions", "lastSubGrid", "newClientX", "diffX", "newWidth", "splitter", "toggle", "touchedSplitter", "subGrids", "emptyArray", "Sort", "storeSorters", "sorterCount", "classList", "leafColumn", "leafHeader", "sortDirection", "sort", "sortBy", "Stripe", "even", "cellContentRange", "Row", "Base", "dataIndex", "idObj", "idMap", "Rectangle", "strict", "onlyRelease", "height", "add", "cls", "attribute", "top", "bottom", "_elementsArray", "offsetTop", "newTop", "recordIndex", "updatingSingleRow", "elements", "oldHeight", "oldId", "rowElData", "rowHeight", "isTree", "size", "rCls", "recordCls", "maxRequestedHeight", "el", "useHeight", "isMeasuring", "cellEdit", "cellElementData", "rowElementData", "cellContent", "rendererData", "useRenderer", "shouldSetContent", "hasFrameworkRenderer", "frameworkPerformsFullRendering", "renderTarget", "hasObjectContent", "hasStringContent", "node", "editorElement", "Bar", "hasFlex", "flexBasis", "cellEl", "domWidth", "domMinWidth", "domMaxWidth", "Footer", "firstPaint", "cloneRowEl", "p", "RowManager", "isRendering", "returnToTop", "topRow", "rowClass", "numRows", "delta", "newRows", "rowActive", "removedRows", "skipMatchRowCount", "allowRowCountShrink", "visibleRowCount", "maxRenderRowCount", "indexDelta", "rowCount", "rowCls", "newRowDataIndex", "removingLast", "addedRows", "durationMS", "visibleRowsBelow", "visualRemoveCount", "visuallyRemovedRows", "visuallyRemovedHeight", "ougoingElements", "e", "newIndex", "refreshDetails", "topRowIndex", "topRowTop", "y", "local", "indexOrRow", "offset", "fixedRowHeight", "oldY", "edgeOffset", "average", "oldAverage", "heightMap", "roughly", "scrollingViewport", "bottomRow", "currentTopIndex", "currentBottomIndex", "calculateFrom", "maybeKnownHeight", "recordY", "topIndex", "storeCount", "fromRowIndex", "recordsAfter", "toRowIndex", "leftOverCount", "heightChanged", "newScrollTop", "forceRecordIndex", "border", "accumulated", "targetIndex", "startIndex", "viewportTop", "viewportBottom", "scrollable", "targetRow", "rowCenter", "viewportCenter", "ignoreError", "clientRect", "posInfo", "error", "fillHeight", "accumulatedHeight", "recordCount", "immediate", "unknownCount", "estimate", "bottomRowTop", "Header", "was", "resizable", "isLeaf", "isParent", "isLastInSubGrid", "childLevel", "tooltip", "children", "isFocusable", "isFocused", "innerEl", "maxDepth", "gridBodyElementEventHandlers", "eventProps", "toggleHover", "setCellHover", "GridElementEvents_default", "Target", "handledEvents", "listeners", "eventName", "includeSingleAxisMatch", "targetIsRow", "left", "right", "x", "headerData", "lastTouchTarget", "touch", "pageX", "pageY", "touchTarget", "mouseoutEvent", "mouseoverEvent", "name", "eventData", "rect", "navigationEvent", "isContextMenu", "isTreeExpander", "isUnfocusedRightClick", "focusOptions", "hoveredCell", "shouldHover", "relatedTarget", "selectionMode", "rowNumberColumnId", "checkboxSelectionColumnId", "prevSelector", "prevRow", "selector", "stm", "oldWidth", "validConfigTypes", "GridFeatures_default", "defaultFeatures", "feature", "registeredInstanceFeatures", "featureName", "throwIfError", "errorMessage", "constructorArgs", "construct", "args", "featureProp", "featureConfig", "GridResponsive_default", "levels", "useLevel", "minDelta", "biggestLevel", "level", "levelSize", "oldLevel", "levelConfig", "validIdTypes", "isDataLoadAction", "GridSelection_default", "clas", "mode", "obj", "old", "oldMode", "checkboxSelectionColumn", "changed", "rowReorder", "checkColumnClass", "checkboxRenderer", "checkboxIndex", "collection", "Collection", "added", "removed", "oldStore", "deselect", "selectedRecord", "selectionChange", "deselectedCells", "oldValue", "deselectedRecords", "multiSelect", "deselectAll", "select", "allSelected", "_selectionStartCell", "_lastSelectionDragRegion", "leavingSubGrid", "enteringSubGrid", "leavingScrollable", "enteringScrollable", "goingForward", "activeHorizontalScroll", "lastChange", "addToSelection", "fromColumnId", "sc", "cellSelectorOrId", "includeRow", "recordCellOrId", "selectedRecords", "selectedRows", "toRemove", "toAdd", "toSelect", "scrollIntoView", "removeCurrentRecordsOnly", "recordsOrIds", "fromId", "toId", "selection", "cellSelectors", "keyEvent", "_focusedCell", "isRowNumber", "isSelected", "from", "to", "selectedCells", "deselectedCellRecords", "selectedRecordIds", "selectedCellRecordIds", "dr", "dc", "dcr", "detacher", "ev", "selectors", "cs", "includeChildren", "dir", "fromCellSelector", "toCellSelector", "doSelect", "_selectionListenersDetachers", "deselectOnClick", "dragSelect", "ctrlKeyDown", "shiftKeyDown", "isMouseLeft", "isMouseRight", "currentEvent", "startCell", "adding", "delay", "continueSelecting", "finishSelection", "mouseUpEvent", "mouseUpSelector", "cellSelectorsToDeselect", "cellSelectorsToSelect", "forceRecordSelection", "isDragging", "includeParents", "selectRecordOnCell", "deselectedRecordIndex", "selectedCellRecords", "selectedRecordIndex", "allChanges", "toDeselect", "inToSelect", "inToDeselect", "childIsSelected", "fromSelector", "toSelector", "selectRecords", "fromCell", "startRowIndex", "endRowIndex", "startColIndex", "endColIndex", "range", "rIx", "cIx", "updateUI", "allSelectedRecords", "allDeselectedRecords", "rowMode", "keepCells", "keepRecords", "keepInCollection", "allDeselectedRecordsIndex", "sr", "suspendStoreEvents", "resumeStoreEvents", "fillSubGridColumns", "compareStateSortIndex", "GridState_default", "manager", "entry", "columnsChanged", "needSort", "columnState", "columnGeneration", "subGridState", "immediatePromise", "defaultScrollOptions", "SubGridScroller", "Scroller", "yScroller", "xDelta", "yDelta", "scrollPromise", "yPromise", "xPromise", "toX", "toY", "elementBounds", "sumWidths", "t", "SubGrid", "verticalScroller", "lastScrollTop", "ctrlKey", "deltaY", "deltaX", "isVerticalScroll", "footer", "references", "hide", "deep", "totalWidth", "newHeight", "prevGrid", "virtualScrollerElement", "virtualScrollerWidth", "totalFixedWidth", "scrolling", "addCls", "scroller", "columnHeaderElement", "frag", "insertRowsBefore", "all", "doRemove", "splitterOwner", "_beforeCollapseState", "expandedRegions", "resolve", "widthChanged", "GridSubGrids_default", "configs", "usedRegions", "subGridColumns", "subGridConfig", "hasCalculatedWidth", "headerContainer", "virtualScrollers", "footerContainer", "fnName", "params", "partialReturnValue", "xAxis", "subGridFilter", "GridScroller", "otherScroller", "axes", "otherSubGrids", "overflowX", "hideScroll", "subGridScroller", "axis", "defaultFocusOptions", "disableScrolling", "containedFocusable", "GridNavigation_default", "isActive", "headerContext", "bodyElement", "isActionable", "actionTargets", "onFirstCell", "focusCell", "superFocusEl", "defaultFocus", "focusEvent", "lastFocusedCell", "lastTarget", "lastCell", "focusable", "scroll", "disableActionable", "isDown", "isUp", "testCell", "subGridRect", "bodyRect", "cellRect", "fullClear", "skipSpecialRows", "moveToHeader", "emptyString", "locale", "currentPage", "totalPages", "En_default", "LocaleHelper", "resolvedPromise", "storeListenerName", "datasetReplaceActions", "ascending", "l", "GridBase", "Panel", "Pluggable_default", "State_default", "LoadMaskable_default", "initScroll", "LocaleManager_default", "scrollManager", "oldScrollManager", "autoHeight", "enableSticky", "enableTextSelection", "fillLastColumn", "positionMode", "showDirty", "_cellCls", "hideFooters", "hideHeaders", "currentStore", "columnsBefore", "oldColumn", "touchConfig", "changedColumns", "isSingleFieldChange", "addingColumnToNonExistingSubGrid", "insertIndex", "flexedSubCols", "cellEls", "oldRowManager", "suffix", "GridRowModel", "AjaxStore", "mask", "oldIndex", "isChild", "isExpand", "isExpandAll", "hasExpandedOldParent", "parentRow", "bottomIndex", "dataStart", "dataEnd", "atEnd", "v", "response", "exceptionType", "message", "syncInfo", "isGroupFieldChange", "grp", "isCollapse", "isCollapseAll", "rowsToRemove", "indicesToRemove", "visibleStart", "visibleEnd", "firstRow", "lastRow", "targetId", "scrollNeeded", "first", "preceding", "moveRight", "columnLines", "rowLines", "colHeaders", "totalHeight", "clientHeight", "newMaxY", "isCritical", "heightInPx", "scrollTop", "blockPosition", "recordRect", "scrollerRect", "virtualBlock", "innerOptions", "targetEl", "rootElement", "styles", "styleHeight", "multiplier", "borderTop", "borderBottom", "theme", "hasVerticalOverflow", "hadHorizontalOverflow", "hasHorizontalOverflow", "horizontalOverflowChanged", "needsPadding", "trigger", "keepScroll", "scrollState", "refreshContext", "bodyContainer", "scrollPad", "bodyOffsetHeight", "fonts", "editorConfig", "removeEvent", "listener", "loadMask", "ret", "Mask", "emptyText", "storeState"]
}
